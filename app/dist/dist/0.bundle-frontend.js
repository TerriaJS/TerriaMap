webpackJsonp([0],{

/***/ 1192:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(70),
        __webpack_require__(0),
        __webpack_require__(3)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
        Uri,
        defined,
        DeveloperError) {
    'use strict';

    /**
     * Given a URI, returns the last segment of the URI, removing any path or query information.
     * @exports getFilenameFromUri
     *
     * @param {String} uri The Uri.
     * @returns {String} The last segment of the Uri.
     *
     * @example
     * //fileName will be"simple.czml";
     * var fileName = Cesium.getFilenameFromUri('/Gallery/simple.czml?value=true&example=false');
     */
    function getFilenameFromUri(uri) {
        //>>includeStart('debug', pragmas.debug);
        if (!defined(uri)) {
            throw new DeveloperError('uri is required.');
        }
        //>>includeEnd('debug');

        var uriObject = new Uri(uri);
        uriObject.normalize();
        var path = uriObject.path;
        var index = path.lastIndexOf('/');
        if (index !== -1) {
            path = path.substr(index + 1);
        }
        return path;
    }

    return getFilenameFromUri;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 1193:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(0),
        __webpack_require__(2),
        __webpack_require__(3),
        __webpack_require__(11),
        __webpack_require__(519),
        __webpack_require__(105),
        __webpack_require__(86)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
        defined,
        defineProperties,
        DeveloperError,
        Event,
        EventHelper,
        TimeIntervalCollection,
        Property) {
    'use strict';

    function subscribeAll(property, eventHelper, definitionChanged, intervals) {
        function callback() {
            definitionChanged.raiseEvent(property);
        }
        var items = [];
        eventHelper.removeAll();
        var length = intervals.length;
        for (var i = 0; i < length; i++) {
            var interval = intervals.get(i);
            if (defined(interval.data) && items.indexOf(interval.data) === -1) {
                eventHelper.add(interval.data.definitionChanged, callback);
            }
        }
    }

    /**
     * A {@link Property} which is defined by a {@link TimeIntervalCollection}, where the
     * data property of each {@link TimeInterval} is another Property instance which is
     * evaluated at the provided time.
     *
     * @alias CompositeProperty
     * @constructor
     *
     *
     * @example
     * var constantProperty = ...;
     * var sampledProperty = ...;
     *
     * //Create a composite property from two previously defined properties
     * //where the property is valid on August 1st, 2012 and uses a constant
     * //property for the first half of the day and a sampled property for the
     * //remaining half.
     * var composite = new Cesium.CompositeProperty();
     * composite.intervals.addInterval(Cesium.TimeInterval.fromIso8601({
     *     iso8601 : '2012-08-01T00:00:00.00Z/2012-08-01T12:00:00.00Z',
     *     data : constantProperty
     * }));
     * composite.intervals.addInterval(Cesium.TimeInterval.fromIso8601({
     *     iso8601 : '2012-08-01T12:00:00.00Z/2012-08-02T00:00:00.00Z',
     *     isStartIncluded : false,
     *     isStopIncluded : false,
     *     data : sampledProperty
     * }));
     *
     * @see CompositeMaterialProperty
     * @see CompositePositionProperty
     */
    function CompositeProperty() {
        this._eventHelper = new EventHelper();
        this._definitionChanged = new Event();
        this._intervals = new TimeIntervalCollection();
        this._intervals.changedEvent.addEventListener(CompositeProperty.prototype._intervalsChanged, this);
    }

    defineProperties(CompositeProperty.prototype, {
        /**
         * Gets a value indicating if this property is constant.  A property is considered
         * constant if getValue always returns the same result for the current definition.
         * @memberof CompositeProperty.prototype
         *
         * @type {Boolean}
         * @readonly
         */
        isConstant : {
            get : function() {
                return this._intervals.isEmpty;
            }
        },
        /**
         * Gets the event that is raised whenever the definition of this property changes.
         * The definition is changed whenever setValue is called with data different
         * than the current value.
         * @memberof CompositeProperty.prototype
         *
         * @type {Event}
         * @readonly
         */
        definitionChanged : {
            get : function() {
                return this._definitionChanged;
            }
        },
        /**
         * Gets the interval collection.
         * @memberof CompositeProperty.prototype
         *
         * @type {TimeIntervalCollection}
         */
        intervals : {
            get : function() {
                return this._intervals;
            }
        }
    });

    /**
     * Gets the value of the property at the provided time.
     *
     * @param {JulianDate} time The time for which to retrieve the value.
     * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
     * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.
     */
    CompositeProperty.prototype.getValue = function(time, result) {
        //>>includeStart('debug', pragmas.debug);
        if (!defined(time)) {
            throw new DeveloperError('time is required');
        }
        //>>includeEnd('debug');

        var innerProperty = this._intervals.findDataForIntervalContainingDate(time);
        if (defined(innerProperty)) {
            return innerProperty.getValue(time, result);
        }
        return undefined;
    };

    /**
     * Compares this property to the provided property and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     *
     * @param {Property} [other] The other property.
     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    CompositeProperty.prototype.equals = function(other) {
        return this === other || //
               (other instanceof CompositeProperty && //
                this._intervals.equals(other._intervals, Property.equals));
    };

    /**
     * @private
     */
    CompositeProperty.prototype._intervalsChanged = function() {
        subscribeAll(this, this._eventHelper, this._definitionChanged, this._intervals);
        this._definitionChanged.raiseEvent(this);
    };

    return CompositeProperty;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 1194:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(88),
        __webpack_require__(21),
        __webpack_require__(0),
        __webpack_require__(3),
        __webpack_require__(18),
        __webpack_require__(540)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
        buildModuleUrl,
        Color,
        defined,
        DeveloperError,
        Resource,
        writeTextToCanvas) {
    'use strict';

    /**
     * A utility class for generating custom map pins as canvas elements.
     * <br /><br />
     * <div align='center'>
     * <img src='Images/PinBuilder.png' width='500'/><br />
     * Example pins generated using both the maki icon set, which ships with Cesium, and single character text.
     * </div>
     *
     * @alias PinBuilder
     * @constructor
     *
     * @demo {@link https://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=Map%20Pins.html|Cesium Sandcastle PinBuilder Demo}
     */
    function PinBuilder() {
        this._cache = {};
    }

    /**
     * Creates an empty pin of the specified color and size.
     *
     * @param {Color} color The color of the pin.
     * @param {Number} size The size of the pin, in pixels.
     * @returns {Canvas} The canvas element that represents the generated pin.
     */
    PinBuilder.prototype.fromColor = function(color, size) {
        //>>includeStart('debug', pragmas.debug);
        if (!defined(color)) {
            throw new DeveloperError('color is required');
        }
        if (!defined(size)) {
            throw new DeveloperError('size is required');
        }
        //>>includeEnd('debug');
        return createPin(undefined, undefined, color, size, this._cache);
    };

    /**
     * Creates a pin with the specified icon, color, and size.
     *
     * @param {Resource|String} url The url of the image to be stamped onto the pin.
     * @param {Color} color The color of the pin.
     * @param {Number} size The size of the pin, in pixels.
     * @returns {Canvas|Promise.<Canvas>} The canvas element or a Promise to the canvas element that represents the generated pin.
     */
    PinBuilder.prototype.fromUrl = function(url, color, size) {
        //>>includeStart('debug', pragmas.debug);
        if (!defined(url)) {
            throw new DeveloperError('url is required');
        }
        if (!defined(color)) {
            throw new DeveloperError('color is required');
        }
        if (!defined(size)) {
            throw new DeveloperError('size is required');
        }
        //>>includeEnd('debug');
        return createPin(url, undefined, color, size, this._cache);
    };

    /**
     * Creates a pin with the specified {@link https://www.mapbox.com/maki/|maki} icon identifier, color, and size.
     *
     * @param {String} id The id of the maki icon to be stamped onto the pin.
     * @param {Color} color The color of the pin.
     * @param {Number} size The size of the pin, in pixels.
     * @returns {Canvas|Promise.<Canvas>} The canvas element or a Promise to the canvas element that represents the generated pin.
     */
    PinBuilder.prototype.fromMakiIconId = function(id, color, size) {
        //>>includeStart('debug', pragmas.debug);
        if (!defined(id)) {
            throw new DeveloperError('id is required');
        }
        if (!defined(color)) {
            throw new DeveloperError('color is required');
        }
        if (!defined(size)) {
            throw new DeveloperError('size is required');
        }
        //>>includeEnd('debug');
        return createPin(buildModuleUrl('Assets/Textures/maki/' + encodeURIComponent(id) + '.png'), undefined, color, size, this._cache);
    };

    /**
     * Creates a pin with the specified text, color, and size.  The text will be sized to be as large as possible
     * while still being contained completely within the pin.
     *
     * @param {String} text The text to be stamped onto the pin.
     * @param {Color} color The color of the pin.
     * @param {Number} size The size of the pin, in pixels.
     * @returns {Canvas} The canvas element that represents the generated pin.
     */
    PinBuilder.prototype.fromText = function(text, color, size) {
        //>>includeStart('debug', pragmas.debug);
        if (!defined(text)) {
            throw new DeveloperError('text is required');
        }
        if (!defined(color)) {
            throw new DeveloperError('color is required');
        }
        if (!defined(size)) {
            throw new DeveloperError('size is required');
        }
        //>>includeEnd('debug');

        return createPin(undefined, text, color, size, this._cache);
    };

    var colorScratch = new Color();

    //This function (except for the 3 commented lines) was auto-generated from an online tool,
    //http://www.professorcloud.com/svg-to-canvas/, using Assets/Textures/pin.svg as input.
    //The reason we simply can't load and draw the SVG directly to the canvas is because
    //it taints the canvas in Internet Explorer (and possibly some other browsers); making
    //it impossible to create a WebGL texture from the result.
    function drawPin(context2D, color, size) {
        context2D.save();
        context2D.scale(size / 24, size / 24); //Added to auto-generated code to scale up to desired size.
        context2D.fillStyle = color.toCssColorString(); //Modified from auto-generated code.
        context2D.strokeStyle = color.brighten(0.6, colorScratch).toCssColorString(); //Modified from auto-generated code.
        context2D.lineWidth = 0.846;
        context2D.beginPath();
        context2D.moveTo(6.72, 0.422);
        context2D.lineTo(17.28, 0.422);
        context2D.bezierCurveTo(18.553, 0.422, 19.577, 1.758, 19.577, 3.415);
        context2D.lineTo(19.577, 10.973);
        context2D.bezierCurveTo(19.577, 12.63, 18.553, 13.966, 17.282, 13.966);
        context2D.lineTo(14.386, 14.008);
        context2D.lineTo(11.826, 23.578);
        context2D.lineTo(9.614, 14.008);
        context2D.lineTo(6.719, 13.965);
        context2D.bezierCurveTo(5.446, 13.983, 4.422, 12.629, 4.422, 10.972);
        context2D.lineTo(4.422, 3.416);
        context2D.bezierCurveTo(4.423, 1.76, 5.447, 0.423, 6.718, 0.423);
        context2D.closePath();
        context2D.fill();
        context2D.stroke();
        context2D.restore();
    }

    //This function takes an image or canvas and uses it as a template
    //to "stamp" the pin with a white image outlined in black.  The color
    //values of the input image are ignored completely and only the alpha
    //values are used.
    function drawIcon(context2D, image, size) {
        //Size is the largest image that looks good inside of pin box.
        var imageSize = size / 2.5;
        var sizeX = imageSize;
        var sizeY = imageSize;

        if (image.width > image.height) {
            sizeY = imageSize * (image.height / image.width);
        } else if (image.width < image.height) {
            sizeX = imageSize * (image.width / image.height);
        }

        //x and y are the center of the pin box
        var x = Math.round((size - sizeX) / 2);
        var y = Math.round(((7 / 24) * size) - (sizeY / 2));

        context2D.globalCompositeOperation = 'destination-out';
        context2D.drawImage(image, x - 1, y, sizeX, sizeY);
        context2D.drawImage(image, x, y - 1, sizeX, sizeY);
        context2D.drawImage(image, x + 1, y, sizeX, sizeY);
        context2D.drawImage(image, x, y + 1, sizeX, sizeY);

        context2D.globalCompositeOperation = 'destination-over';
        context2D.fillStyle = Color.BLACK.toCssColorString();
        context2D.fillRect(x - 1, y - 1, sizeX + 2, sizeY + 2);

        context2D.globalCompositeOperation = 'destination-out';
        context2D.drawImage(image, x, y, sizeX, sizeY);

        context2D.globalCompositeOperation = 'destination-over';
        context2D.fillStyle = Color.WHITE.toCssColorString();
        context2D.fillRect(x - 1, y - 2, sizeX + 2, sizeY + 2);
    }

    var stringifyScratch = new Array(4);
    function createPin(url, label, color, size, cache) {
        //Use the parameters as a unique ID for caching.
        stringifyScratch[0] = url;
        stringifyScratch[1] = label;
        stringifyScratch[2] = color;
        stringifyScratch[3] = size;
        var id = JSON.stringify(stringifyScratch);

        var item = cache[id];
        if (defined(item)) {
            return item;
        }

        var canvas = document.createElement('canvas');
        canvas.width = size;
        canvas.height = size;

        var context2D = canvas.getContext('2d');
        drawPin(context2D, color, size);

        if (defined(url)) {
            var resource = Resource.createIfNeeded(url);

            //If we have an image url, load it and then stamp the pin.
            var promise = resource.fetchImage().then(function(image) {
                drawIcon(context2D, image, size);
                cache[id] = canvas;
                return canvas;
            });
            cache[id] = promise;
            return promise;
        } else if (defined(label)) {
            //If we have a label, write it to a canvas and then stamp the pin.
            var image = writeTextToCanvas(label, {
                font : 'bold ' + size + 'px sans-serif'
            });
            drawIcon(context2D, image, size);
        }

        cache[id] = canvas;
        return canvas;
    }

    return PinBuilder;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 1195:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(1),
        __webpack_require__(0),
        __webpack_require__(2),
        __webpack_require__(3),
        __webpack_require__(11),
        __webpack_require__(167),
        __webpack_require__(1193),
        __webpack_require__(86)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
        defaultValue,
        defined,
        defineProperties,
        DeveloperError,
        Event,
        ReferenceFrame,
        CompositeProperty,
        Property) {
    'use strict';

    /**
     * A {@link CompositeProperty} which is also a {@link PositionProperty}.
     *
     * @alias CompositePositionProperty
     * @constructor
     *
     * @param {ReferenceFrame} [referenceFrame=ReferenceFrame.FIXED] The reference frame in which the position is defined.
     */
    function CompositePositionProperty(referenceFrame) {
        this._referenceFrame = defaultValue(referenceFrame, ReferenceFrame.FIXED);
        this._definitionChanged = new Event();
        this._composite = new CompositeProperty();
        this._composite.definitionChanged.addEventListener(CompositePositionProperty.prototype._raiseDefinitionChanged, this);
    }

    defineProperties(CompositePositionProperty.prototype, {
        /**
         * Gets a value indicating if this property is constant.  A property is considered
         * constant if getValue always returns the same result for the current definition.
         * @memberof CompositePositionProperty.prototype
         *
         * @type {Boolean}
         * @readonly
         */
        isConstant : {
            get : function() {
                return this._composite.isConstant;
            }
        },
        /**
         * Gets the event that is raised whenever the definition of this property changes.
         * The definition is changed whenever setValue is called with data different
         * than the current value.
         * @memberof CompositePositionProperty.prototype
         *
         * @type {Event}
         * @readonly
         */
        definitionChanged : {
            get : function() {
                return this._definitionChanged;
            }
        },
        /**
         * Gets the interval collection.
         * @memberof CompositePositionProperty.prototype
         *
         * @type {TimeIntervalCollection}
         */
        intervals : {
            get : function() {
                return this._composite.intervals;
            }
        },
        /**
         * Gets or sets the reference frame which this position presents itself as.
         * Each PositionProperty making up this object has it's own reference frame,
         * so this property merely exposes a "preferred" reference frame for clients
         * to use.
         * @memberof CompositePositionProperty.prototype
         *
         * @type {ReferenceFrame}
         */
        referenceFrame : {
            get : function() {
                return this._referenceFrame;
            },
            set : function(value) {
                this._referenceFrame = value;
            }
        }
    });

    /**
     * Gets the value of the property at the provided time in the fixed frame.
     *
     * @param {JulianDate} time The time for which to retrieve the value.
     * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
     * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.
     */
    CompositePositionProperty.prototype.getValue = function(time, result) {
        return this.getValueInReferenceFrame(time, ReferenceFrame.FIXED, result);
    };

    /**
     * Gets the value of the property at the provided time and in the provided reference frame.
     *
     * @param {JulianDate} time The time for which to retrieve the value.
     * @param {ReferenceFrame} referenceFrame The desired referenceFrame of the result.
     * @param {Cartesian3} [result] The object to store the value into, if omitted, a new instance is created and returned.
     * @returns {Cartesian3} The modified result parameter or a new instance if the result parameter was not supplied.
     */
    CompositePositionProperty.prototype.getValueInReferenceFrame = function(time, referenceFrame, result) {
        //>>includeStart('debug', pragmas.debug);
        if (!defined(time)) {
            throw new DeveloperError('time is required.');
        }
        if (!defined(referenceFrame)) {
            throw new DeveloperError('referenceFrame is required.');
        }
        //>>includeEnd('debug');

        var innerProperty = this._composite._intervals.findDataForIntervalContainingDate(time);
        if (defined(innerProperty)) {
            return innerProperty.getValueInReferenceFrame(time, referenceFrame, result);
        }
        return undefined;
    };

    /**
     * Compares this property to the provided property and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     *
     * @param {Property} [other] The other property.
     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    CompositePositionProperty.prototype.equals = function(other) {
        return this === other || //
               (other instanceof CompositePositionProperty && //
                this._referenceFrame === other._referenceFrame && //
                this._composite.equals(other._composite, Property.equals));
    };

    /**
     * @private
     */
    CompositePositionProperty.prototype._raiseDefinitionChanged = function() {
        this._definitionChanged.raiseEvent(this);
    };

    return CompositePositionProperty;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 1196:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(1),
        __webpack_require__(0),
        __webpack_require__(2),
        __webpack_require__(3),
        __webpack_require__(11),
        __webpack_require__(519),
        __webpack_require__(167),
        __webpack_require__(86)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
        defaultValue,
        defined,
        defineProperties,
        DeveloperError,
        Event,
        EventHelper,
        ReferenceFrame,
        Property) {
    'use strict';

    /**
     * A {@link PositionProperty} whose value is an array whose items are the computed value
     * of other PositionProperty instances.
     *
     * @alias PositionPropertyArray
     * @constructor
     *
     * @param {Property[]} [value] An array of Property instances.
     * @param {ReferenceFrame} [referenceFrame=ReferenceFrame.FIXED] The reference frame in which the position is defined.
     */
    function PositionPropertyArray(value, referenceFrame) {
        this._value = undefined;
        this._definitionChanged = new Event();
        this._eventHelper = new EventHelper();
        this._referenceFrame = defaultValue(referenceFrame, ReferenceFrame.FIXED);
        this.setValue(value);
    }

    defineProperties(PositionPropertyArray.prototype, {
        /**
         * Gets a value indicating if this property is constant.  This property
         * is considered constant if all property items in the array are constant.
         * @memberof PositionPropertyArray.prototype
         *
         * @type {Boolean}
         * @readonly
         */
        isConstant : {
            get : function() {
                var value = this._value;
                if (!defined(value)) {
                    return true;
                }

                var length = value.length;
                for (var i = 0; i < length; i++) {
                    if (!Property.isConstant(value[i])) {
                        return false;
                    }
                }
                return true;
            }
        },
        /**
         * Gets the event that is raised whenever the definition of this property changes.
         * The definition is changed whenever setValue is called with data different
         * than the current value or one of the properties in the array also changes.
         * @memberof PositionPropertyArray.prototype
         *
         * @type {Event}
         * @readonly
         */
        definitionChanged : {
            get : function() {
                return this._definitionChanged;
            }
        },
        /**
         * Gets the reference frame in which the position is defined.
         * @memberof PositionPropertyArray.prototype
         * @type {ReferenceFrame}
         * @default ReferenceFrame.FIXED;
         */
        referenceFrame : {
            get : function() {
                return this._referenceFrame;
            }
        }
    });

    /**
     * Gets the value of the property.
     *
     * @param {JulianDate} [time] The time for which to retrieve the value.  This parameter is unused since the value does not change with respect to time.
     * @param {Cartesian3[]} [result] The object to store the value into, if omitted, a new instance is created and returned.
     * @returns {Cartesian3[]} The modified result parameter or a new instance if the result parameter was not supplied.
     */
    PositionPropertyArray.prototype.getValue = function(time, result) {
        return this.getValueInReferenceFrame(time, ReferenceFrame.FIXED, result);
    };

    /**
     * Gets the value of the property at the provided time and in the provided reference frame.
     *
     * @param {JulianDate} time The time for which to retrieve the value.
     * @param {ReferenceFrame} referenceFrame The desired referenceFrame of the result.
     * @param {Cartesian3} [result] The object to store the value into, if omitted, a new instance is created and returned.
     * @returns {Cartesian3} The modified result parameter or a new instance if the result parameter was not supplied.
     */
    PositionPropertyArray.prototype.getValueInReferenceFrame = function(time, referenceFrame, result) {
        //>>includeStart('debug', pragmas.debug);
        if (!defined(time)) {
            throw new DeveloperError('time is required.');
        }
        if (!defined(referenceFrame)) {
            throw new DeveloperError('referenceFrame is required.');
        }
        //>>includeEnd('debug');

        var value = this._value;
        if (!defined(value)) {
            return undefined;
        }

        var length = value.length;
        if (!defined(result)) {
            result = new Array(length);
        }
        var i = 0;
        var x = 0;
        while (i < length) {
            var property = value[i];
            var itemValue = property.getValueInReferenceFrame(time, referenceFrame, result[i]);
            if (defined(itemValue)) {
                result[x] = itemValue;
                x++;
            }
            i++;
        }
        result.length = x;
        return result;
    };

    /**
     * Sets the value of the property.
     *
     * @param {Property[]} value An array of Property instances.
     */
    PositionPropertyArray.prototype.setValue = function(value) {
        var eventHelper = this._eventHelper;
        eventHelper.removeAll();

        if (defined(value)) {
            this._value = value.slice();
            var length = value.length;
            for (var i = 0; i < length; i++) {
                var property = value[i];
                if (defined(property)) {
                    eventHelper.add(property.definitionChanged, PositionPropertyArray.prototype._raiseDefinitionChanged, this);
                }
            }
        } else {
            this._value = undefined;
        }
        this._definitionChanged.raiseEvent(this);
    };

    /**
     * Compares this property to the provided property and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     *
     * @param {Property} [other] The other property.
     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    PositionPropertyArray.prototype.equals = function(other) {
        return this === other || //
               (other instanceof PositionPropertyArray && //
                this._referenceFrame === other._referenceFrame && //
                Property.arrayEquals(this._value, other._value));
    };

    PositionPropertyArray.prototype._raiseDefinitionChanged = function() {
        this._definitionChanged.raiseEvent(this);
    };

    return PositionPropertyArray;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 1197:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(0),
        __webpack_require__(2),
        __webpack_require__(3),
        __webpack_require__(11),
        __webpack_require__(16),
        __webpack_require__(86)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
        defined,
        defineProperties,
        DeveloperError,
        Event,
        RuntimeError,
        Property) {
    'use strict';

    function resolveEntity(that) {
        var entityIsResolved = true;
        if (that._resolveEntity) {
            var targetEntity = that._targetCollection.getById(that._targetId);

            if (defined(targetEntity)) {
                targetEntity.definitionChanged.addEventListener(ReferenceProperty.prototype._onTargetEntityDefinitionChanged, that);
                that._targetEntity = targetEntity;
                that._resolveEntity = false;
            } else {
                //The property has become detached.  It has a valid value but is not currently resolved to an entity in the collection
                targetEntity = that._targetEntity;
                entityIsResolved = false;
            }

            if (!defined(targetEntity)) {
                throw new RuntimeError('target entity "' + that._targetId + '" could not be resolved.');
            }
        }
        return entityIsResolved;
    }

    function resolve(that) {
        var targetProperty = that._targetProperty;

        if (that._resolveProperty) {
            var entityIsResolved = resolveEntity(that);

            var names = that._targetPropertyNames;
            targetProperty = that._targetEntity;
            var length = names.length;
            for (var i = 0; i < length && defined(targetProperty); i++) {
                targetProperty = targetProperty[names[i]];
            }

            if (defined(targetProperty)) {
                that._targetProperty = targetProperty;
                that._resolveProperty = !entityIsResolved;
            } else if (!defined(that._targetProperty)) {
                throw new RuntimeError('targetProperty "' + that._targetId + '.' + names.join('.') + '" could not be resolved.');
            }
        }

        return targetProperty;
    }

    /**
     * A {@link Property} which transparently links to another property on a provided object.
     *
     * @alias ReferenceProperty
     * @constructor
     *
     * @param {EntityCollection} targetCollection The entity collection which will be used to resolve the reference.
     * @param {String} targetId The id of the entity which is being referenced.
     * @param {String[]} targetPropertyNames The names of the property on the target entity which we will use.
     *
     * @example
     * var collection = new Cesium.EntityCollection();
     *
     * //Create a new entity and assign a billboard scale.
     * var object1 = new Cesium.Entity({id:'object1'});
     * object1.billboard = new Cesium.BillboardGraphics();
     * object1.billboard.scale = new Cesium.ConstantProperty(2.0);
     * collection.add(object1);
     *
     * //Create a second entity and reference the scale from the first one.
     * var object2 = new Cesium.Entity({id:'object2'});
     * object2.model = new Cesium.ModelGraphics();
     * object2.model.scale = new Cesium.ReferenceProperty(collection, 'object1', ['billboard', 'scale']);
     * collection.add(object2);
     *
     * //Create a third object, but use the fromString helper function.
     * var object3 = new Cesium.Entity({id:'object3'});
     * object3.billboard = new Cesium.BillboardGraphics();
     * object3.billboard.scale = Cesium.ReferenceProperty.fromString(collection, 'object1#billboard.scale');
     * collection.add(object3);
     *
     * //You can refer to an entity with a # or . in id and property names by escaping them.
     * var object4 = new Cesium.Entity({id:'#object.4'});
     * object4.billboard = new Cesium.BillboardGraphics();
     * object4.billboard.scale = new Cesium.ConstantProperty(2.0);
     * collection.add(object4);
     *
     * var object5 = new Cesium.Entity({id:'object5'});
     * object5.billboard = new Cesium.BillboardGraphics();
     * object5.billboard.scale = Cesium.ReferenceProperty.fromString(collection, '\\#object\\.4#billboard.scale');
     * collection.add(object5);
     */
    function ReferenceProperty(targetCollection, targetId, targetPropertyNames) {
        //>>includeStart('debug', pragmas.debug);
        if (!defined(targetCollection)) {
            throw new DeveloperError('targetCollection is required.');
        }
        if (!defined(targetId) || targetId === '') {
            throw new DeveloperError('targetId is required.');
        }
        if (!defined(targetPropertyNames) || targetPropertyNames.length === 0) {
            throw new DeveloperError('targetPropertyNames is required.');
        }
        for (var i = 0; i < targetPropertyNames.length; i++) {
            var item = targetPropertyNames[i];
            if (!defined(item) || item === '') {
                throw new DeveloperError('reference contains invalid properties.');
            }
        }
        //>>includeEnd('debug');

        this._targetCollection = targetCollection;
        this._targetId = targetId;
        this._targetPropertyNames = targetPropertyNames;
        this._targetProperty = undefined;
        this._targetEntity = undefined;
        this._definitionChanged = new Event();
        this._resolveEntity = true;
        this._resolveProperty = true;

        targetCollection.collectionChanged.addEventListener(ReferenceProperty.prototype._onCollectionChanged, this);
    }

    defineProperties(ReferenceProperty.prototype, {
        /**
         * Gets a value indicating if this property is constant.
         * @memberof ReferenceProperty.prototype
         * @type {Boolean}
         * @readonly
         */
        isConstant : {
            get : function() {
                return Property.isConstant(resolve(this));
            }
        },
        /**
         * Gets the event that is raised whenever the definition of this property changes.
         * The definition is changed whenever the referenced property's definition is changed.
         * @memberof ReferenceProperty.prototype
         * @type {Event}
         * @readonly
         */
        definitionChanged : {
            get : function() {
                return this._definitionChanged;
            }
        },
        /**
         * Gets the reference frame that the position is defined in.
         * This property is only valid if the referenced property is a {@link PositionProperty}.
         * @memberof ReferenceProperty.prototype
         * @type {ReferenceFrame}
         * @readonly
         */
        referenceFrame : {
            get : function() {
                return resolve(this).referenceFrame;
            }
        },
        /**
         * Gets the id of the entity being referenced.
         * @memberof ReferenceProperty.prototype
         * @type {String}
         * @readonly
         */
        targetId : {
            get : function() {
                return this._targetId;
            }
        },
        /**
         * Gets the collection containing the entity being referenced.
         * @memberof ReferenceProperty.prototype
         * @type {EntityCollection}
         * @readonly
         */
        targetCollection : {
            get : function() {
                return this._targetCollection;
            }
        },
        /**
         * Gets the array of property names used to retrieve the referenced property.
         * @memberof ReferenceProperty.prototype
         * @type {String[]}
         * @readonly
         */
        targetPropertyNames : {
            get : function() {
                return this._targetPropertyNames;
            }
        },
        /**
         * Gets the resolved instance of the underlying referenced property.
         * @memberof ReferenceProperty.prototype
         * @type {Property}
         * @readonly
         */
        resolvedProperty : {
            get : function() {
                return resolve(this);
            }
        }
    });

    /**
     * Creates a new instance given the entity collection that will
     * be used to resolve it and a string indicating the target entity id and property.
     * The format of the string is "objectId#foo.bar", where # separates the id from
     * property path and . separates sub-properties.  If the reference identifier or
     * or any sub-properties contains a # . or \ they must be escaped.
     *
     * @param {EntityCollection} targetCollection
     * @param {String} referenceString
     * @returns {ReferenceProperty} A new instance of ReferenceProperty.
     *
     * @exception {DeveloperError} invalid referenceString.
     */
    ReferenceProperty.fromString = function(targetCollection, referenceString) {
        //>>includeStart('debug', pragmas.debug);
        if (!defined(targetCollection)) {
            throw new DeveloperError('targetCollection is required.');
        }
        if (!defined(referenceString)) {
            throw new DeveloperError('referenceString is required.');
        }
        //>>includeEnd('debug');

        var identifier;
        var values = [];

        var inIdentifier = true;
        var isEscaped = false;
        var token = '';
        for (var i = 0; i < referenceString.length; ++i) {
            var c = referenceString.charAt(i);

            if (isEscaped) {
                token += c;
                isEscaped = false;
            } else if (c === '\\') {
                isEscaped = true;
            } else if (inIdentifier && c === '#') {
                identifier = token;
                inIdentifier = false;
                token = '';
            } else if (!inIdentifier && c === '.') {
                values.push(token);
                token = '';
            } else {
                token += c;
            }
        }
        values.push(token);

        return new ReferenceProperty(targetCollection, identifier, values);
    };

    /**
     * Gets the value of the property at the provided time.
     *
     * @param {JulianDate} time The time for which to retrieve the value.
     * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
     * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.
     */
    ReferenceProperty.prototype.getValue = function(time, result) {
        return resolve(this).getValue(time, result);
    };

    /**
     * Gets the value of the property at the provided time and in the provided reference frame.
     * This method is only valid if the property being referenced is a {@link PositionProperty}.
     *
     * @param {JulianDate} time The time for which to retrieve the value.
     * @param {ReferenceFrame} referenceFrame The desired referenceFrame of the result.
     * @param {Cartesian3} [result] The object to store the value into, if omitted, a new instance is created and returned.
     * @returns {Cartesian3} The modified result parameter or a new instance if the result parameter was not supplied.
     */
    ReferenceProperty.prototype.getValueInReferenceFrame = function(time, referenceFrame, result) {
        return resolve(this).getValueInReferenceFrame(time, referenceFrame, result);
    };

    /**
     * Gets the {@link Material} type at the provided time.
     * This method is only valid if the property being referenced is a {@link MaterialProperty}.
     *
     * @param {JulianDate} time The time for which to retrieve the type.
     * @returns {String} The type of material.
     */
    ReferenceProperty.prototype.getType = function(time) {
        return resolve(this).getType(time);
    };

    /**
     * Compares this property to the provided property and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     *
     * @param {Property} [other] The other property.
     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    ReferenceProperty.prototype.equals = function(other) {
        if (this === other) {
            return true;
        }

        var names = this._targetPropertyNames;
        var otherNames = other._targetPropertyNames;

        if (this._targetCollection !== other._targetCollection || //
            this._targetId !== other._targetId || //
            names.length !== otherNames.length) {
            return false;
        }

        var length = this._targetPropertyNames.length;
        for (var i = 0; i < length; i++) {
            if (names[i] !== otherNames[i]) {
                return false;
            }
        }

        return true;
    };

    ReferenceProperty.prototype._onTargetEntityDefinitionChanged = function(targetEntity, name, value, oldValue) {
        if (this._targetPropertyNames[0] === name) {
            this._resolveProperty = true;
            this._definitionChanged.raiseEvent(this);
        }
    };

    ReferenceProperty.prototype._onCollectionChanged = function(collection, added, removed) {
        var targetEntity = this._targetEntity;
        if (defined(targetEntity)) {
            if (removed.indexOf(targetEntity) !== -1) {
                targetEntity.definitionChanged.removeEventListener(ReferenceProperty.prototype._onTargetEntityDefinitionChanged, this);
                this._resolveEntity = true;
                this._resolveProperty = true;
            } else if (this._resolveEntity) {
                //If targetEntity is defined but resolveEntity is true, then the entity is detached
                //and any change to the collection needs to incur an attempt to resolve in order to re-attach.
                //without this if block, a reference that becomes re-attached will not signal definitionChanged
                resolve(this);
                if (!this._resolveEntity) {
                    this._definitionChanged.raiseEvent(this);
                }
            }
        }
    };

    return ReferenceProperty;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 1198:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(4)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
        freezeObject) {
    'use strict';

    /**
     * Defined the orientation of stripes in {@link StripeMaterialProperty}.
     *
     * @exports StripeOrientation
     */
    var StripeOrientation = {
        /**
         * Horizontal orientation.
         * @type {Number}
         */
        HORIZONTAL : 0,

        /**
         * Vertical orientation.
         * @type {Number}
         */
        VERTICAL : 1
    };

    return freezeObject(StripeOrientation);
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 1199:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(6),
        __webpack_require__(1),
        __webpack_require__(0),
        __webpack_require__(2),
        __webpack_require__(3),
        __webpack_require__(11),
        __webpack_require__(29),
        __webpack_require__(86)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
        Cartesian3,
        defaultValue,
        defined,
        defineProperties,
        DeveloperError,
        Event,
        JulianDate,
        Property) {
    'use strict';

    /**
     * A {@link Property} which evaluates to a {@link Cartesian3} vector
     * based on the velocity of the provided {@link PositionProperty}.
     *
     * @alias VelocityVectorProperty
     * @constructor
     *
     * @param {Property} [position] The position property used to compute the velocity.
     * @param {Boolean} [normalize=true] Whether to normalize the computed velocity vector.
     *
     * @example
     * //Create an entity with a billboard rotated to match its velocity.
     * var position = new Cesium.SampledProperty();
     * position.addSamples(...);
     * var entity = viewer.entities.add({
     *   position : position,
     *   billboard : {
     *     image : 'image.png',
     *     alignedAxis : new Cesium.VelocityVectorProperty(position, true) // alignedAxis must be a unit vector
     *   }
     * }));
     */
    function VelocityVectorProperty(position, normalize) {
        this._position = undefined;
        this._subscription = undefined;
        this._definitionChanged = new Event();
        this._normalize = defaultValue(normalize, true);

        this.position = position;
    }

    defineProperties(VelocityVectorProperty.prototype, {
        /**
         * Gets a value indicating if this property is constant.
         * @memberof VelocityVectorProperty.prototype
         *
         * @type {Boolean}
         * @readonly
         */
        isConstant : {
            get : function() {
                return Property.isConstant(this._position);
            }
        },
        /**
         * Gets the event that is raised whenever the definition of this property changes.
         * @memberof VelocityVectorProperty.prototype
         *
         * @type {Event}
         * @readonly
         */
        definitionChanged : {
            get : function() {
                return this._definitionChanged;
            }
        },
        /**
         * Gets or sets the position property used to compute the velocity vector.
         * @memberof VelocityVectorProperty.prototype
         *
         * @type {Property}
         */
        position : {
            get : function() {
                return this._position;
            },
            set : function(value) {
                var oldValue = this._position;
                if (oldValue !== value) {
                    if (defined(oldValue)) {
                        this._subscription();
                    }

                    this._position = value;

                    if (defined(value)) {
                        this._subscription = value._definitionChanged.addEventListener(function() {
                            this._definitionChanged.raiseEvent(this);
                        }, this);
                    }

                    this._definitionChanged.raiseEvent(this);
                }
            }
        },
        /**
         * Gets or sets whether the vector produced by this property
         * will be normalized or not.
         * @memberof VelocityVectorProperty.prototype
         *
         * @type {Boolean}
         */
        normalize : {
            get : function() {
                return this._normalize;
            },
            set : function(value) {
                if (this._normalize === value) {
                    return;
                }

                this._normalize = value;
                this._definitionChanged.raiseEvent(this);
            }
        }
    });

    var position1Scratch = new Cartesian3();
    var position2Scratch = new Cartesian3();
    var timeScratch = new JulianDate();
    var step = 1.0 / 60.0;

    /**
     * Gets the value of the property at the provided time.
     *
     * @param {JulianDate} [time] The time for which to retrieve the value.
     * @param {Cartesian3} [result] The object to store the value into, if omitted, a new instance is created and returned.
     * @returns {Cartesian3} The modified result parameter or a new instance if the result parameter was not supplied.
     */
    VelocityVectorProperty.prototype.getValue = function(time, result) {
        return this._getValue(time, result);
    };

    /**
     * @private
     */
    VelocityVectorProperty.prototype._getValue = function(time, velocityResult, positionResult) {
        //>>includeStart('debug', pragmas.debug);
        if (!defined(time)) {
            throw new DeveloperError('time is required');
        }
        //>>includeEnd('debug');

        if (!defined(velocityResult)) {
            velocityResult = new Cartesian3();
        }

        var property = this._position;
        if (Property.isConstant(property)) {
            return this._normalize ? undefined : Cartesian3.clone(Cartesian3.ZERO, velocityResult);
        }

        var position1 = property.getValue(time, position1Scratch);
        var position2 = property.getValue(JulianDate.addSeconds(time, step, timeScratch), position2Scratch);

        //If we don't have a position for now, return undefined.
        if (!defined(position1)) {
            return undefined;
        }

        //If we don't have a position for now + step, see if we have a position for now - step.
        if (!defined(position2)) {
            position2 = position1;
            position1 = property.getValue(JulianDate.addSeconds(time, -step, timeScratch), position2Scratch);

            if (!defined(position1)) {
                return undefined;
            }
        }

        if (Cartesian3.equals(position1, position2)) {
            return this._normalize ? undefined : Cartesian3.clone(Cartesian3.ZERO, velocityResult);
        }

        if (defined(positionResult)) {
            position1.clone(positionResult);
        }

        var velocity = Cartesian3.subtract(position2, position1, velocityResult);
        if (this._normalize) {
            return Cartesian3.normalize(velocity, velocityResult);
        }

        return Cartesian3.divideByScalar(velocity, step, velocityResult);
    };

    /**
     * Compares this property to the provided property and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     *
     * @param {Property} [other] The other property.
     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    VelocityVectorProperty.prototype.equals = function(other) {
        return this === other ||//
               (other instanceof VelocityVectorProperty &&
                Property.equals(this._position, other._position));
    };

    return VelocityVectorProperty;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 1200:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(4)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
        freezeObject) {
    'use strict';

    /**
     * Style options for corners.
     *
     * @demo The {@link https://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=Corridor.html&label=Geometries|Corridor Demo}
     * demonstrates the three corner types, as used by {@link CorridorGraphics}.
     *
     * @exports CornerType
     */
    var CornerType = {
        /**
         * <img src="Images/CornerTypeRounded.png" style="vertical-align: middle;" width="186" height="189" />
         *
         * Corner has a smooth edge.
         * @type {Number}
         * @constant
         */
        ROUNDED : 0,

        /**
         * <img src="Images/CornerTypeMitered.png" style="vertical-align: middle;" width="186" height="189" />
         *
         * Corner point is the intersection of adjacent edges.
         * @type {Number}
         * @constant
         */
        MITERED : 1,

        /**
         * <img src="Images/CornerTypeBeveled.png" style="vertical-align: middle;" width="186" height="189" />
         *
         * Corner is clipped.
         * @type {Number}
         * @constant
         */
        BEVELED : 2
    };

    return freezeObject(CornerType);
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 1201:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(1),
        __webpack_require__(0),
        __webpack_require__(3),
        __webpack_require__(7)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
        defaultValue,
        defined,
        DeveloperError,
        CesiumMath) {
    'use strict';

    var factorial = CesiumMath.factorial;

    function calculateCoefficientTerm(x, zIndices, xTable, derivOrder, termOrder, reservedIndices) {
        var result = 0;
        var reserved;
        var i;
        var j;

        if (derivOrder > 0) {
            for (i = 0; i < termOrder; i++) {
                reserved = false;
                for (j = 0; j < reservedIndices.length && !reserved; j++) {
                    if (i === reservedIndices[j]) {
                        reserved = true;
                    }
                }

                if (!reserved) {
                    reservedIndices.push(i);
                    result += calculateCoefficientTerm(x, zIndices, xTable, derivOrder - 1, termOrder, reservedIndices);
                    reservedIndices.splice(reservedIndices.length - 1, 1);
                }
            }

            return result;
        }

        result = 1;
        for (i = 0; i < termOrder; i++) {
            reserved = false;
            for (j = 0; j < reservedIndices.length && !reserved; j++) {
                if (i === reservedIndices[j]) {
                    reserved = true;
                }
            }

            if (!reserved) {
                result *= x - xTable[zIndices[i]];
            }
        }

        return result;
    }

    /**
     * An {@link InterpolationAlgorithm} for performing Hermite interpolation.
     *
     * @exports HermitePolynomialApproximation
     */
    var HermitePolynomialApproximation = {
        type : 'Hermite'
    };

    /**
     * Given the desired degree, returns the number of data points required for interpolation.
     *
     * @param {Number} degree The desired degree of interpolation.
     * @param {Number} [inputOrder=0]  The order of the inputs (0 means just the data, 1 means the data and its derivative, etc).
     * @returns {Number} The number of required data points needed for the desired degree of interpolation.
     * @exception {DeveloperError} degree must be 0 or greater.
     * @exception {DeveloperError} inputOrder must be 0 or greater.
     */
    HermitePolynomialApproximation.getRequiredDataPoints = function(degree, inputOrder) {
        inputOrder = defaultValue(inputOrder, 0);

        //>>includeStart('debug', pragmas.debug);
        if (!defined(degree)) {
            throw new DeveloperError('degree is required.');
        }
        if (degree < 0) {
            throw new DeveloperError('degree must be 0 or greater.');
        }
        if (inputOrder < 0) {
            throw new DeveloperError('inputOrder must be 0 or greater.');
        }
        //>>includeEnd('debug');

        return Math.max(Math.floor((degree + 1) / (inputOrder + 1)), 2);
    };

    /**
     * Interpolates values using Hermite Polynomial Approximation.
     *
     * @param {Number} x The independent variable for which the dependent variables will be interpolated.
     * @param {Number[]} xTable The array of independent variables to use to interpolate.  The values
     * in this array must be in increasing order and the same value must not occur twice in the array.
     * @param {Number[]} yTable The array of dependent variables to use to interpolate.  For a set of three
     * dependent values (p,q,w) at time 1 and time 2 this should be as follows: {p1, q1, w1, p2, q2, w2}.
     * @param {Number} yStride The number of dependent variable values in yTable corresponding to
     * each independent variable value in xTable.
     * @param {Number[]} [result] An existing array into which to store the result.
     * @returns {Number[]} The array of interpolated values, or the result parameter if one was provided.
     */
    HermitePolynomialApproximation.interpolateOrderZero = function(x, xTable, yTable, yStride, result) {
        if (!defined(result)) {
            result = new Array(yStride);
        }

        var i;
        var j;
        var d;
        var s;
        var len;
        var index;
        var length = xTable.length;
        var coefficients = new Array(yStride);

        for (i = 0; i < yStride; i++) {
            result[i] = 0;

            var l = new Array(length);
            coefficients[i] = l;
            for (j = 0; j < length; j++) {
                l[j] = [];
            }
        }

        var zIndicesLength = length, zIndices = new Array(zIndicesLength);

        for (i = 0; i < zIndicesLength; i++) {
            zIndices[i] = i;
        }

        var highestNonZeroCoef = length - 1;
        for (s = 0; s < yStride; s++) {
            for (j = 0; j < zIndicesLength; j++) {
                index = zIndices[j] * yStride + s;
                coefficients[s][0].push(yTable[index]);
            }

            for (i = 1; i < zIndicesLength; i++) {
                var nonZeroCoefficients = false;
                for (j = 0; j < zIndicesLength - i; j++) {
                    var zj = xTable[zIndices[j]];
                    var zn = xTable[zIndices[j + i]];

                    var numerator;
                    if (zn - zj <= 0) {
                        index = zIndices[j] * yStride + yStride * i + s;
                        numerator = yTable[index];
                        coefficients[s][i].push(numerator / factorial(i));
                    } else {
                        numerator = (coefficients[s][i - 1][j + 1] - coefficients[s][i - 1][j]);
                        coefficients[s][i].push(numerator / (zn - zj));
                    }
                    nonZeroCoefficients = nonZeroCoefficients || (numerator !== 0);
                }

                if (!nonZeroCoefficients) {
                    highestNonZeroCoef = i - 1;
                }
            }
        }

        for (d = 0, len = 0; d <= len; d++) {
            for (i = d; i <= highestNonZeroCoef; i++) {
                var tempTerm = calculateCoefficientTerm(x, zIndices, xTable, d, i, []);
                for (s = 0; s < yStride; s++) {
                    var coeff = coefficients[s][i][0];
                    result[s + d * yStride] += coeff * tempTerm;
                }
            }
        }

        return result;
    };

    var arrayScratch = [];

    /**
     * Interpolates values using Hermite Polynomial Approximation.
     *
     * @param {Number} x The independent variable for which the dependent variables will be interpolated.
     * @param {Number[]} xTable The array of independent variables to use to interpolate.  The values
     * in this array must be in increasing order and the same value must not occur twice in the array.
     * @param {Number[]} yTable The array of dependent variables to use to interpolate.  For a set of three
     * dependent values (p,q,w) at time 1 and time 2 this should be as follows: {p1, q1, w1, p2, q2, w2}.
     * @param {Number} yStride The number of dependent variable values in yTable corresponding to
     * each independent variable value in xTable.
     * @param {Number} inputOrder The number of derivatives supplied for input.
     * @param {Number} outputOrder The number of derivatives desired for output.
     * @param {Number[]} [result] An existing array into which to store the result.
     *
     * @returns {Number[]} The array of interpolated values, or the result parameter if one was provided.
     */
    HermitePolynomialApproximation.interpolate = function(x, xTable, yTable, yStride, inputOrder, outputOrder, result) {
        var resultLength = yStride * (outputOrder + 1);
        if (!defined(result)) {
            result = new Array(resultLength);
        }
        for (var r = 0; r < resultLength; r++) {
            result[r] = 0;
        }

        var length = xTable.length;
        // The zIndices array holds copies of the addresses of the xTable values
        // in the range we're looking at. Even though this just holds information already
        // available in xTable this is a much more convenient format.
        var zIndices = new Array(length * (inputOrder + 1));
        var i;
        for (i = 0; i < length; i++) {
            for (var j = 0; j < (inputOrder + 1); j++) {
                zIndices[i * (inputOrder + 1) + j] = i;
            }
        }

        var zIndiceslength = zIndices.length;
        var coefficients = arrayScratch;
        var highestNonZeroCoef = fillCoefficientList(coefficients, zIndices, xTable, yTable, yStride, inputOrder);
        var reservedIndices = [];

        var tmp = zIndiceslength * (zIndiceslength + 1) / 2;
        var loopStop = Math.min(highestNonZeroCoef, outputOrder);
        for (var d = 0; d <= loopStop; d++) {
            for (i = d; i <= highestNonZeroCoef; i++) {
                reservedIndices.length = 0;
                var tempTerm = calculateCoefficientTerm(x, zIndices, xTable, d, i, reservedIndices);
                var dimTwo = Math.floor(i * (1 - i) / 2) + (zIndiceslength * i);

                for (var s = 0; s < yStride; s++) {
                    var dimOne = Math.floor(s * tmp);
                    var coef = coefficients[dimOne + dimTwo];
                    result[s + d * yStride] += coef * tempTerm;
                }
            }
        }

        return result;
    };

    function fillCoefficientList(coefficients, zIndices, xTable, yTable, yStride, inputOrder) {
        var j;
        var index;
        var highestNonZero = -1;
        var zIndiceslength = zIndices.length;
        var tmp = zIndiceslength * (zIndiceslength + 1) / 2;

        for (var s = 0; s < yStride; s++) {
            var dimOne = Math.floor(s * tmp);

            for (j = 0; j < zIndiceslength; j++) {
                index = zIndices[j] * yStride * (inputOrder + 1) + s;
                coefficients[dimOne + j] = yTable[index];
            }

            for (var i = 1; i < zIndiceslength; i++) {
                var coefIndex = 0;
                var dimTwo = Math.floor(i * (1 - i) / 2) + (zIndiceslength * i);
                var nonZeroCoefficients = false;

                for (j = 0; j < zIndiceslength - i; j++) {
                    var zj = xTable[zIndices[j]];
                    var zn = xTable[zIndices[j + i]];

                    var numerator;
                    var coefficient;
                    if (zn - zj <= 0) {
                        index = zIndices[j] * yStride * (inputOrder + 1) + yStride * i + s;
                        numerator = yTable[index];
                        coefficient = (numerator / CesiumMath.factorial(i));
                        coefficients[dimOne + dimTwo + coefIndex] = coefficient;
                        coefIndex++;
                    } else {
                        var dimTwoMinusOne = Math.floor((i - 1) * (2 - i) / 2) + (zIndiceslength * (i - 1));
                        numerator = coefficients[dimOne + dimTwoMinusOne + j + 1] - coefficients[dimOne + dimTwoMinusOne + j];
                        coefficient = (numerator / (zn - zj));
                        coefficients[dimOne + dimTwo + coefIndex] = coefficient;
                        coefIndex++;
                    }
                    nonZeroCoefficients = nonZeroCoefficients || (numerator !== 0.0);
                }

                if (nonZeroCoefficients) {
                    highestNonZero = Math.max(highestNonZero, i);
                }
            }
        }

        return highestNonZero;
    }

    return HermitePolynomialApproximation;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 1202:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(0)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
        defined) {
    'use strict';

    /**
     * An {@link InterpolationAlgorithm} for performing Lagrange interpolation.
     *
     * @exports LagrangePolynomialApproximation
     */
    var LagrangePolynomialApproximation = {
        type : 'Lagrange'
    };

    /**
     * Given the desired degree, returns the number of data points required for interpolation.
     *
     * @param {Number} degree The desired degree of interpolation.
     * @returns {Number} The number of required data points needed for the desired degree of interpolation.
     */
    LagrangePolynomialApproximation.getRequiredDataPoints = function(degree) {
        return Math.max(degree + 1.0, 2);
    };

    /**
     * Interpolates values using Lagrange Polynomial Approximation.
     *
     * @param {Number} x The independent variable for which the dependent variables will be interpolated.
     * @param {Number[]} xTable The array of independent variables to use to interpolate.  The values
     * in this array must be in increasing order and the same value must not occur twice in the array.
     * @param {Number[]} yTable The array of dependent variables to use to interpolate.  For a set of three
     * dependent values (p,q,w) at time 1 and time 2 this should be as follows: {p1, q1, w1, p2, q2, w2}.
     * @param {Number} yStride The number of dependent variable values in yTable corresponding to
     * each independent variable value in xTable.
     * @param {Number[]} [result] An existing array into which to store the result.
     * @returns {Number[]} The array of interpolated values, or the result parameter if one was provided.
     */
    LagrangePolynomialApproximation.interpolateOrderZero = function(x, xTable, yTable, yStride, result) {
        if (!defined(result)) {
            result = new Array(yStride);
        }

        var i;
        var j;
        var length = xTable.length;

        for (i = 0; i < yStride; i++) {
            result[i] = 0;
        }

        for (i = 0; i < length; i++) {
            var coefficient = 1;

            for (j = 0; j < length; j++) {
                if (j !== i) {
                    var diffX = xTable[i] - xTable[j];
                    coefficient *= (x - xTable[j]) / diffX;
                }
            }

            for (j = 0; j < yStride; j++) {
                result[j] += coefficient * yTable[i * yStride + j];
            }
        }

        return result;
    };

    return LagrangePolynomialApproximation;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 1203:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(8),
        __webpack_require__(1),
        __webpack_require__(0)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
        Check,
        defaultValue,
        defined) {
    'use strict';

    /**
     * A set of curvilinear 3-dimensional coordinates.
     *
     * @alias Spherical
     * @constructor
     *
     * @param {Number} [clock=0.0] The angular coordinate lying in the xy-plane measured from the positive x-axis and toward the positive y-axis.
     * @param {Number} [cone=0.0] The angular coordinate measured from the positive z-axis and toward the negative z-axis.
     * @param {Number} [magnitude=1.0] The linear coordinate measured from the origin.
     */
    function Spherical(clock, cone, magnitude) {
        this.clock = defaultValue(clock, 0.0);
        this.cone = defaultValue(cone, 0.0);
        this.magnitude = defaultValue(magnitude, 1.0);
    }

    /**
     * Converts the provided Cartesian3 into Spherical coordinates.
     *
     * @param {Cartesian3} cartesian3 The Cartesian3 to be converted to Spherical.
     * @param {Spherical} [result] The object in which the result will be stored, if undefined a new instance will be created.
     * @returns {Spherical} The modified result parameter, or a new instance if one was not provided.
     */
    Spherical.fromCartesian3 = function(cartesian3, result) {
        //>>includeStart('debug', pragmas.debug);
        Check.typeOf.object('cartesian3', cartesian3);
        //>>includeEnd('debug');

        var x = cartesian3.x;
        var y = cartesian3.y;
        var z = cartesian3.z;
        var radialSquared = x * x + y * y;

        if (!defined(result)) {
            result = new Spherical();
        }

        result.clock = Math.atan2(y, x);
        result.cone = Math.atan2(Math.sqrt(radialSquared), z);
        result.magnitude = Math.sqrt(radialSquared + z * z);
        return result;
    };

    /**
     * Creates a duplicate of a Spherical.
     *
     * @param {Spherical} spherical The spherical to clone.
     * @param {Spherical} [result] The object to store the result into, if undefined a new instance will be created.
     * @returns {Spherical} The modified result parameter or a new instance if result was undefined. (Returns undefined if spherical is undefined)
     */
    Spherical.clone = function(spherical, result) {
        if (!defined(spherical)) {
            return undefined;
        }

        if (!defined(result)) {
            return new Spherical(spherical.clock, spherical.cone, spherical.magnitude);
        }

        result.clock = spherical.clock;
        result.cone = spherical.cone;
        result.magnitude = spherical.magnitude;
        return result;
    };

    /**
     * Computes the normalized version of the provided spherical.
     *
     * @param {Spherical} spherical The spherical to be normalized.
     * @param {Spherical} [result] The object to store the result into, if undefined a new instance will be created.
     * @returns {Spherical} The modified result parameter or a new instance if result was undefined.
     */
    Spherical.normalize = function(spherical, result) {
      //>>includeStart('debug', pragmas.debug);
        Check.typeOf.object('spherical', spherical);
        //>>includeEnd('debug');

        if (!defined(result)) {
            return new Spherical(spherical.clock, spherical.cone, 1.0);
        }

        result.clock = spherical.clock;
        result.cone = spherical.cone;
        result.magnitude = 1.0;
        return result;
    };

    /**
     * Returns true if the first spherical is equal to the second spherical, false otherwise.
     *
     * @param {Spherical} left The first Spherical to be compared.
     * @param {Spherical} right The second Spherical to be compared.
     * @returns {Boolean} true if the first spherical is equal to the second spherical, false otherwise.
     */
    Spherical.equals = function(left, right) {
        return (left === right) ||
               ((defined(left)) &&
                (defined(right)) &&
                (left.clock === right.clock) &&
                (left.cone === right.cone) &&
                (left.magnitude === right.magnitude));
    };

    /**
     * Returns true if the first spherical is within the provided epsilon of the second spherical, false otherwise.
     *
     * @param {Spherical} left The first Spherical to be compared.
     * @param {Spherical} right The second Spherical to be compared.
     * @param {Number} [epsilon=0.0] The epsilon to compare against.
     * @returns {Boolean} true if the first spherical is within the provided epsilon of the second spherical, false otherwise.
     */
    Spherical.equalsEpsilon = function(left, right, epsilon) {
        epsilon = defaultValue(epsilon, 0.0);
        return (left === right) ||
               ((defined(left)) &&
                (defined(right)) &&
                (Math.abs(left.clock - right.clock) <= epsilon) &&
                (Math.abs(left.cone - right.cone) <= epsilon) &&
                (Math.abs(left.magnitude - right.magnitude) <= epsilon));
    };

    /**
     * Returns true if this spherical is equal to the provided spherical, false otherwise.
     *
     * @param {Spherical} other The Spherical to be compared.
     * @returns {Boolean} true if this spherical is equal to the provided spherical, false otherwise.
     */
    Spherical.prototype.equals = function(other) {
        return Spherical.equals(this, other);
    };

    /**
     * Creates a duplicate of this Spherical.
     *
     * @param {Spherical} [result] The object to store the result into, if undefined a new instance will be created.
     * @returns {Spherical} The modified result parameter or a new instance if result was undefined.
     */
    Spherical.prototype.clone = function(result) {
        return Spherical.clone(this, result);
    };

    /**
    * Returns true if this spherical is within the provided epsilon of the provided spherical, false otherwise.
    *
    * @param {Spherical} other The Spherical to be compared.
    * @param {Number} epsilon The epsilon to compare against.
    * @returns {Boolean} true if this spherical is within the provided epsilon of the provided spherical, false otherwise.
    */
    Spherical.prototype.equalsEpsilon = function(other, epsilon) {
        return Spherical.equalsEpsilon(this, other, epsilon);
    };

    /**
    * Returns a string representing this instance in the format (clock, cone, magnitude).
    *
    * @returns {String} A string representing this instance.
    */
    Spherical.prototype.toString = function() {
        return '(' + this.clock + ', ' + this.cone + ', ' + this.magnitude + ')';
    };

    return Spherical;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 1204:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(0),
        __webpack_require__(2),
        __webpack_require__(3),
        __webpack_require__(11),
        __webpack_require__(1193),
        __webpack_require__(86)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
        defined,
        defineProperties,
        DeveloperError,
        Event,
        CompositeProperty,
        Property) {
    'use strict';

    /**
     * A {@link CompositeProperty} which is also a {@link MaterialProperty}.
     *
     * @alias CompositeMaterialProperty
     * @constructor
     */
    function CompositeMaterialProperty() {
        this._definitionChanged = new Event();
        this._composite = new CompositeProperty();
        this._composite.definitionChanged.addEventListener(CompositeMaterialProperty.prototype._raiseDefinitionChanged, this);
    }

    defineProperties(CompositeMaterialProperty.prototype, {
        /**
         * Gets a value indicating if this property is constant.  A property is considered
         * constant if getValue always returns the same result for the current definition.
         * @memberof CompositeMaterialProperty.prototype
         *
         * @type {Boolean}
         * @readonly
         */
        isConstant : {
            get : function() {
                return this._composite.isConstant;
            }
        },
        /**
         * Gets the event that is raised whenever the definition of this property changes.
         * The definition is changed whenever setValue is called with data different
         * than the current value.
         * @memberof CompositeMaterialProperty.prototype
         *
         * @type {Event}
         * @readonly
         */
        definitionChanged : {
            get : function() {
                return this._definitionChanged;
            }
        },
        /**
         * Gets the interval collection.
         * @memberof CompositeMaterialProperty.prototype
         *
         * @type {TimeIntervalCollection}
         */
        intervals : {
            get : function() {
                return this._composite._intervals;
            }
        }
    });

    /**
     * Gets the {@link Material} type at the provided time.
     *
     * @param {JulianDate} time The time for which to retrieve the type.
     * @returns {String} The type of material.
     */
    CompositeMaterialProperty.prototype.getType = function(time) {
        //>>includeStart('debug', pragmas.debug);
        if (!defined(time)) {
            throw new DeveloperError('time is required');
        }
        //>>includeEnd('debug');

        var innerProperty = this._composite._intervals.findDataForIntervalContainingDate(time);
        if (defined(innerProperty)) {
            return innerProperty.getType(time);
        }
        return undefined;
    };

    /**
     * Gets the value of the property at the provided time.
     *
     * @param {JulianDate} time The time for which to retrieve the value.
     * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
     * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.
     */
    CompositeMaterialProperty.prototype.getValue = function(time, result) {
        //>>includeStart('debug', pragmas.debug);
        if (!defined(time)) {
            throw new DeveloperError('time is required');
        }
        //>>includeEnd('debug');

        var innerProperty = this._composite._intervals.findDataForIntervalContainingDate(time);
        if (defined(innerProperty)) {
            return innerProperty.getValue(time, result);
        }
        return undefined;
    };

    /**
     * Compares this property to the provided property and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     *
     * @param {Property} [other] The other property.
     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    CompositeMaterialProperty.prototype.equals = function(other) {
        return this === other || //
               (other instanceof CompositeMaterialProperty && //
                this._composite.equals(other._composite, Property.equals));
    };

    /**
     * @private
     */
    CompositeMaterialProperty.prototype._raiseDefinitionChanged = function() {
        this._definitionChanged.raiseEvent(this);
    };

    return CompositeMaterialProperty;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 1205:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(13),
        __webpack_require__(21),
        __webpack_require__(1),
        __webpack_require__(0),
        __webpack_require__(2),
        __webpack_require__(11),
        __webpack_require__(34),
        __webpack_require__(86)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
        Cartesian2,
        Color,
        defaultValue,
        defined,
        defineProperties,
        Event,
        createPropertyDescriptor,
        Property) {
    'use strict';

    var defaultColor = Color.WHITE;
    var defaultCellAlpha = 0.1;
    var defaultLineCount = new Cartesian2(8, 8);
    var defaultLineOffset = new Cartesian2(0, 0);
    var defaultLineThickness = new Cartesian2(1, 1);

    /**
     * A {@link MaterialProperty} that maps to grid {@link Material} uniforms.
     * @alias GridMaterialProperty
     *
     * @param {Object} [options] Object with the following properties:
     * @param {Property} [options.color=Color.WHITE] A Property specifying the grid {@link Color}.
     * @param {Property} [options.cellAlpha=0.1] A numeric Property specifying cell alpha values.
     * @param {Property} [options.lineCount=new Cartesian2(8, 8)] A {@link Cartesian2} Property specifying the number of grid lines along each axis.
     * @param {Property} [options.lineThickness=new Cartesian2(1.0, 1.0)] A {@link Cartesian2} Property specifying the thickness of grid lines along each axis.
     * @param {Property} [options.lineOffset=new Cartesian2(0.0, 0.0)] A {@link Cartesian2} Property specifying starting offset of grid lines along each axis.
     *
     * @constructor
     */
    function GridMaterialProperty(options) {
        options = defaultValue(options, defaultValue.EMPTY_OBJECT);

        this._definitionChanged = new Event();
        this._color = undefined;
        this._colorSubscription = undefined;
        this._cellAlpha = undefined;
        this._cellAlphaSubscription = undefined;
        this._lineCount = undefined;
        this._lineCountSubscription = undefined;
        this._lineThickness = undefined;
        this._lineThicknessSubscription = undefined;
        this._lineOffset = undefined;
        this._lineOffsetSubscription = undefined;

        this.color = options.color;
        this.cellAlpha = options.cellAlpha;
        this.lineCount = options.lineCount;
        this.lineThickness = options.lineThickness;
        this.lineOffset = options.lineOffset;
    }

    defineProperties(GridMaterialProperty.prototype, {
        /**
         * Gets a value indicating if this property is constant.  A property is considered
         * constant if getValue always returns the same result for the current definition.
         * @memberof GridMaterialProperty.prototype
         *
         * @type {Boolean}
         * @readonly
         */
        isConstant : {
            get : function() {
                return Property.isConstant(this._color) &&
                       Property.isConstant(this._cellAlpha) &&
                       Property.isConstant(this._lineCount) &&
                       Property.isConstant(this._lineThickness) &&
                       Property.isConstant(this._lineOffset);
            }
        },
        /**
         * Gets the event that is raised whenever the definition of this property changes.
         * The definition is considered to have changed if a call to getValue would return
         * a different result for the same time.
         * @memberof GridMaterialProperty.prototype
         *
         * @type {Event}
         * @readonly
         */
        definitionChanged : {
            get : function() {
                return this._definitionChanged;
            }
        },
        /**
         * Gets or sets the Property specifying the grid {@link Color}.
         * @memberof GridMaterialProperty.prototype
         * @type {Property}
         * @default Color.WHITE
         */
        color : createPropertyDescriptor('color'),
        /**
         * Gets or sets the numeric Property specifying cell alpha values.
         * @memberof GridMaterialProperty.prototype
         * @type {Property}
         * @default 0.1
         */
        cellAlpha : createPropertyDescriptor('cellAlpha'),
        /**
         * Gets or sets the {@link Cartesian2} Property specifying the number of grid lines along each axis.
         * @memberof GridMaterialProperty.prototype
         * @type {Property}
         * @default new Cartesian2(8.0, 8.0)
         */
        lineCount : createPropertyDescriptor('lineCount'),
        /**
         * Gets or sets the {@link Cartesian2} Property specifying the thickness of grid lines along each axis.
         * @memberof GridMaterialProperty.prototype
         * @type {Property}
         * @default new Cartesian2(1.0, 1.0)
         */
        lineThickness : createPropertyDescriptor('lineThickness'),
        /**
         * Gets or sets the {@link Cartesian2} Property specifying the starting offset of grid lines along each axis.
         * @memberof GridMaterialProperty.prototype
         * @type {Property}
         * @default new Cartesian2(0.0, 0.0)
         */
        lineOffset : createPropertyDescriptor('lineOffset')
    });

    /**
     * Gets the {@link Material} type at the provided time.
     *
     * @param {JulianDate} time The time for which to retrieve the type.
     * @returns {String} The type of material.
     */
    GridMaterialProperty.prototype.getType = function(time) {
        return 'Grid';
    };

    /**
     * Gets the value of the property at the provided time.
     *
     * @param {JulianDate} time The time for which to retrieve the value.
     * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
     * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.
     */
    GridMaterialProperty.prototype.getValue = function(time, result) {
        if (!defined(result)) {
            result = {};
        }
        result.color = Property.getValueOrClonedDefault(this._color, time, defaultColor, result.color);
        result.cellAlpha = Property.getValueOrDefault(this._cellAlpha, time, defaultCellAlpha);
        result.lineCount = Property.getValueOrClonedDefault(this._lineCount, time, defaultLineCount, result.lineCount);
        result.lineThickness = Property.getValueOrClonedDefault(this._lineThickness, time, defaultLineThickness, result.lineThickness);
        result.lineOffset = Property.getValueOrClonedDefault(this._lineOffset, time, defaultLineOffset, result.lineOffset);
        return result;
    };

    /**
     * Compares this property to the provided property and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     *
     * @param {Property} [other] The other property.
     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    GridMaterialProperty.prototype.equals = function(other) {
        return this === other || //
        (other instanceof GridMaterialProperty && //
        Property.equals(this._color, other._color) && //
        Property.equals(this._cellAlpha, other._cellAlpha) && //
        Property.equals(this._lineCount, other._lineCount) && //
        Property.equals(this._lineThickness, other._lineThickness) && //
        Property.equals(this._lineOffset, other._lineOffset));
    };

    return GridMaterialProperty;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 1206:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(21),
        __webpack_require__(0),
        __webpack_require__(2),
        __webpack_require__(11),
        __webpack_require__(34),
        __webpack_require__(86)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
        Color,
        defined,
        defineProperties,
        Event,
        createPropertyDescriptor,
        Property) {
    'use strict';

    /**
     * A {@link MaterialProperty} that maps to PolylineArrow {@link Material} uniforms.
     *
     * @param {Property} [color=Color.WHITE] The {@link Color} Property to be used.
     *
     * @alias PolylineArrowMaterialProperty
     * @constructor
     */
    function PolylineArrowMaterialProperty(color) {
        this._definitionChanged = new Event();
        this._color = undefined;
        this._colorSubscription = undefined;
        this.color = color;
    }

    defineProperties(PolylineArrowMaterialProperty.prototype, {
        /**
         * Gets a value indicating if this property is constant.  A property is considered
         * constant if getValue always returns the same result for the current definition.
         * @memberof PolylineArrowMaterialProperty.prototype
         *
         * @type {Boolean}
         * @readonly
         */
        isConstant : {
            get : function() {
                return Property.isConstant(this._color);
            }
        },
        /**
         * Gets the event that is raised whenever the definition of this property changes.
         * The definition is considered to have changed if a call to getValue would return
         * a different result for the same time.
         * @memberof PolylineArrowMaterialProperty.prototype
         *
         * @type {Event}
         * @readonly
         */
        definitionChanged : {
            get : function() {
                return this._definitionChanged;
            }
        },
        /**
         * Gets or sets the {@link Color} {@link Property}.
         * @memberof PolylineArrowMaterialProperty.prototype
         * @type {Property}
         * @default Color.WHITE
         */
        color : createPropertyDescriptor('color')
    });

    /**
     * Gets the {@link Material} type at the provided time.
     *
     * @param {JulianDate} time The time for which to retrieve the type.
     * @returns {String} The type of material.
     */
    PolylineArrowMaterialProperty.prototype.getType = function(time) {
        return 'PolylineArrow';
    };

    /**
     * Gets the value of the property at the provided time.
     *
     * @param {JulianDate} time The time for which to retrieve the value.
     * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
     * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.
     */
    PolylineArrowMaterialProperty.prototype.getValue = function(time, result) {
        if (!defined(result)) {
            result = {};
        }
        result.color = Property.getValueOrClonedDefault(this._color, time, Color.WHITE, result.color);
        return result;
    };

    /**
     * Compares this property to the provided property and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     *
     * @param {Property} [other] The other property.
     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    PolylineArrowMaterialProperty.prototype.equals = function(other) {
        return this === other || //
               (other instanceof PolylineArrowMaterialProperty && //
                Property.equals(this._color, other._color));
    };

    return PolylineArrowMaterialProperty;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 1207:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(21),
        __webpack_require__(1),
        __webpack_require__(0),
        __webpack_require__(2),
        __webpack_require__(11),
        __webpack_require__(34),
        __webpack_require__(86)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
        Color,
        defaultValue,
        defined,
        defineProperties,
        Event,
        createPropertyDescriptor,
        Property) {
    'use strict';

    var defaultColor = Color.WHITE;
    var defaultGapColor = Color.TRANSPARENT;
    var defaultDashLength = 16.0;
    var defaultDashPattern = 255.0;

    /**
     * A {@link MaterialProperty} that maps to polyline dash {@link Material} uniforms.
     * @alias PolylineDashMaterialProperty
     * @constructor
     *
     * @param {Object} [options] Object with the following properties:
     * @param {Property} [options.color=Color.WHITE] A Property specifying the {@link Color} of the line.
     * @param {Property} [options.gapColor=Color.TRANSPARENT] A Property specifying the {@link Color} of the gaps in the line.
     * @param {Property} [options.dashLength=16.0] A numeric Property specifying the length of the dash pattern in pixel.s
     * @param {Property} [options.dashPattern=255.0] A numeric Property specifying a 16 bit pattern for the dash
     */
    function PolylineDashMaterialProperty(options) {
        options = defaultValue(options, defaultValue.EMPTY_OBJECT);

        this._definitionChanged = new Event();
        this._color = undefined;
        this._colorSubscription = undefined;
        this._gapColor = undefined;
        this._gapColorSubscription = undefined;
        this._dashLength = undefined;
        this._dashLengthSubscription = undefined;
        this._dashPattern = undefined;
        this._dashPatternSubscription = undefined;

        this.color = options.color;
        this.gapColor = options.gapColor;
        this.dashLength = options.dashLength;
        this.dashPattern = options.dashPattern;
    }

    defineProperties(PolylineDashMaterialProperty.prototype, {
        /**
         * Gets a value indicating if this property is constant.  A property is considered
         * constant if getValue always returns the same result for the current definition.
         * @memberof PolylineDashMaterialProperty.prototype
         * @type {Boolean}
         * @readonly
         */
        isConstant : {
            get : function() {
                return (Property.isConstant(this._color) &&
                        Property.isConstant(this._gapColor) &&
                        Property.isConstant(this._dashLength) &&
                        Property.isConstant(this._dashPattern));
            }
        },
        /**
         * Gets the event that is raised whenever the definition of this property changes.
         * The definition is considered to have changed if a call to getValue would return
         * a different result for the same time.
         * @memberof PolylineDashMaterialProperty.prototype
         * @type {Event}
         * @readonly
         */
        definitionChanged : {
            get : function() {
                return this._definitionChanged;
            }
        },
        /**
         * Gets or sets the Property specifying the {@link Color} of the line.
         * @memberof PolylineDashMaterialProperty.prototype
         * @type {Property}
         */
        color : createPropertyDescriptor('color'),
        /**
         * Gets or sets the Property specifying the {@link Color} of the gaps in the line.
         * @memberof PolylineDashMaterialProperty.prototype
         * @type {Property}
         */
        gapColor : createPropertyDescriptor('gapColor'),
        /**
         * Gets or sets the numeric Property specifying the length of a dash cycle
         * @memberof PolylineDashMaterialProperty.prototype
         * @type {Property}
         */
        dashLength : createPropertyDescriptor('dashLength'),
        /**
         * Gets or sets the numeric Property specifying a dash pattern
         * @memberof PolylineDashMaterialProperty.prototype
         * @type {Property}
         */
        dashPattern : createPropertyDescriptor('dashPattern')
    });

    /**
     * Gets the {@link Material} type at the provided time.
     *
     * @param {JulianDate} time The time for which to retrieve the type.
     * @returns {String} The type of material.
     */
    PolylineDashMaterialProperty.prototype.getType = function(time) {
        return 'PolylineDash';
    };

    /**
     * Gets the value of the property at the provided time.
     *
     * @param {JulianDate} time The time for which to retrieve the value.
     * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
     * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.
     */
    PolylineDashMaterialProperty.prototype.getValue = function(time, result) {
        if (!defined(result)) {
            result = {};
        }
        result.color = Property.getValueOrClonedDefault(this._color, time, defaultColor, result.color);
        result.gapColor = Property.getValueOrClonedDefault(this._gapColor, time, defaultGapColor, result.gapColor);
        result.dashLength = Property.getValueOrDefault(this._dashLength, time, defaultDashLength, result.dashLength);
        result.dashPattern = Property.getValueOrDefault(this._dashPattern, time, defaultDashPattern, result.dashPattern);
        return result;
    };

    /**
     * Compares this property to the provided property and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     *
     * @param {Property} [other] The other property.
     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    PolylineDashMaterialProperty.prototype.equals = function(other) {
        return this === other || //
               (other instanceof PolylineDashMaterialProperty &&
                Property.equals(this._color, other._color) &&
                Property.equals(this._gapColor, other._gapColor) &&
                Property.equals(this._dashLength, other._dashLength) &&
                Property.equals(this._dashPattern, other._dashPattern)
                );
    };

    return PolylineDashMaterialProperty;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 1208:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(21),
        __webpack_require__(1),
        __webpack_require__(0),
        __webpack_require__(2),
        __webpack_require__(11),
        __webpack_require__(34),
        __webpack_require__(86)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
        Color,
        defaultValue,
        defined,
        defineProperties,
        Event,
        createPropertyDescriptor,
        Property) {
    'use strict';

    var defaultColor = Color.WHITE;
    var defaultGlowPower = 0.25;

    /**
     * A {@link MaterialProperty} that maps to polyline glow {@link Material} uniforms.
     * @alias PolylineGlowMaterialProperty
     * @constructor
     *
     * @param {Object} [options] Object with the following properties:
     * @param {Property} [options.color=Color.WHITE] A Property specifying the {@link Color} of the line.
     * @param {Property} [options.glowPower=0.25] A numeric Property specifying the strength of the glow, as a percentage of the total line width.
     */
    function PolylineGlowMaterialProperty(options) {
        options = defaultValue(options, defaultValue.EMPTY_OBJECT);

        this._definitionChanged = new Event();
        this._color = undefined;
        this._colorSubscription = undefined;
        this._glowPower = undefined;
        this._glowPowerSubscription = undefined;

        this.color = options.color;
        this.glowPower = options.glowPower;
    }

    defineProperties(PolylineGlowMaterialProperty.prototype, {
        /**
         * Gets a value indicating if this property is constant.  A property is considered
         * constant if getValue always returns the same result for the current definition.
         * @memberof PolylineGlowMaterialProperty.prototype
         * @type {Boolean}
         * @readonly
         */
        isConstant : {
            get : function() {
                return Property.isConstant(this._color) && Property.isConstant(this._glow);
            }
        },
        /**
         * Gets the event that is raised whenever the definition of this property changes.
         * The definition is considered to have changed if a call to getValue would return
         * a different result for the same time.
         * @memberof PolylineGlowMaterialProperty.prototype
         * @type {Event}
         * @readonly
         */
        definitionChanged : {
            get : function() {
                return this._definitionChanged;
            }
        },
        /**
         * Gets or sets the Property specifying the {@link Color} of the line.
         * @memberof PolylineGlowMaterialProperty.prototype
         * @type {Property}
         */
        color : createPropertyDescriptor('color'),
        /**
         * Gets or sets the numeric Property specifying the strength of the glow, as a percentage of the total line width (less than 1.0).
         * @memberof PolylineGlowMaterialProperty.prototype
         * @type {Property}
         */
        glowPower : createPropertyDescriptor('glowPower')
    });

    /**
     * Gets the {@link Material} type at the provided time.
     *
     * @param {JulianDate} time The time for which to retrieve the type.
     * @returns {String} The type of material.
     */
    PolylineGlowMaterialProperty.prototype.getType = function(time) {
        return 'PolylineGlow';
    };

    /**
     * Gets the value of the property at the provided time.
     *
     * @param {JulianDate} time The time for which to retrieve the value.
     * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
     * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.
     */
    PolylineGlowMaterialProperty.prototype.getValue = function(time, result) {
        if (!defined(result)) {
            result = {};
        }
        result.color = Property.getValueOrClonedDefault(this._color, time, defaultColor, result.color);
        result.glowPower = Property.getValueOrDefault(this._glowPower, time, defaultGlowPower, result.glowPower);
        return result;
    };

    /**
     * Compares this property to the provided property and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     *
     * @param {Property} [other] The other property.
     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    PolylineGlowMaterialProperty.prototype.equals = function(other) {
        return this === other || //
               (other instanceof PolylineGlowMaterialProperty && //
                Property.equals(this._color, other._color) &&
                Property.equals(this._glowPower, other._glowPower));
    };

    return PolylineGlowMaterialProperty;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 1209:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(21),
        __webpack_require__(1),
        __webpack_require__(0),
        __webpack_require__(2),
        __webpack_require__(11),
        __webpack_require__(34),
        __webpack_require__(86)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
        Color,
        defaultValue,
        defined,
        defineProperties,
        Event,
        createPropertyDescriptor,
        Property) {
    'use strict';

    var defaultColor = Color.WHITE;
    var defaultOutlineColor = Color.BLACK;
    var defaultOutlineWidth = 1.0;

    /**
     * A {@link MaterialProperty} that maps to polyline outline {@link Material} uniforms.
     * @alias PolylineOutlineMaterialProperty
     * @constructor
     *
     * @param {Object} [options] Object with the following properties:
     * @param {Property} [options.color=Color.WHITE] A Property specifying the {@link Color} of the line.
     * @param {Property} [options.outlineColor=Color.BLACK] A Property specifying the {@link Color} of the outline.
     * @param {Property} [options.outlineWidth=1.0] A numeric Property specifying the width of the outline, in pixels.
     */
    function PolylineOutlineMaterialProperty(options) {
        options = defaultValue(options, defaultValue.EMPTY_OBJECT);

        this._definitionChanged = new Event();
        this._color = undefined;
        this._colorSubscription = undefined;
        this._outlineColor = undefined;
        this._outlineColorSubscription = undefined;
        this._outlineWidth = undefined;
        this._outlineWidthSubscription = undefined;

        this.color = options.color;
        this.outlineColor = options.outlineColor;
        this.outlineWidth = options.outlineWidth;
    }

    defineProperties(PolylineOutlineMaterialProperty.prototype, {
        /**
         * Gets a value indicating if this property is constant.  A property is considered
         * constant if getValue always returns the same result for the current definition.
         * @memberof PolylineOutlineMaterialProperty.prototype
         *
         * @type {Boolean}
         * @readonly
         */
        isConstant : {
            get : function() {
                return Property.isConstant(this._color) && Property.isConstant(this._outlineColor) && Property.isConstant(this._outlineWidth);
            }
        },
        /**
         * Gets the event that is raised whenever the definition of this property changes.
         * The definition is considered to have changed if a call to getValue would return
         * a different result for the same time.
         * @memberof PolylineOutlineMaterialProperty.prototype
         *
         * @type {Event}
         * @readonly
         */
        definitionChanged : {
            get : function() {
                return this._definitionChanged;
            }
        },
        /**
         * Gets or sets the Property specifying the {@link Color} of the line.
         * @memberof PolylineOutlineMaterialProperty.prototype
         * @type {Property}
         * @default Color.WHITE
         */
        color : createPropertyDescriptor('color'),
        /**
         * Gets or sets the Property specifying the {@link Color} of the outline.
         * @memberof PolylineOutlineMaterialProperty.prototype
         * @type {Property}
         * @default Color.BLACK
         */
        outlineColor : createPropertyDescriptor('outlineColor'),
        /**
         * Gets or sets the numeric Property specifying the width of the outline.
         * @memberof PolylineOutlineMaterialProperty.prototype
         * @type {Property}
         * @default 1.0
         */
        outlineWidth : createPropertyDescriptor('outlineWidth')
    });

    /**
     * Gets the {@link Material} type at the provided time.
     *
     * @param {JulianDate} time The time for which to retrieve the type.
     * @returns {String} The type of material.
     */
    PolylineOutlineMaterialProperty.prototype.getType = function(time) {
        return 'PolylineOutline';
    };

    /**
     * Gets the value of the property at the provided time.
     *
     * @param {JulianDate} time The time for which to retrieve the value.
     * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
     * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.
     */
    PolylineOutlineMaterialProperty.prototype.getValue = function(time, result) {
        if (!defined(result)) {
            result = {};
        }
        result.color = Property.getValueOrClonedDefault(this._color, time, defaultColor, result.color);
        result.outlineColor = Property.getValueOrClonedDefault(this._outlineColor, time, defaultOutlineColor, result.outlineColor);
        result.outlineWidth = Property.getValueOrDefault(this._outlineWidth, time, defaultOutlineWidth);
        return result;
    };

    /**
     * Compares this property to the provided property and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     *
     * @param {Property} [other] The other property.
     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    PolylineOutlineMaterialProperty.prototype.equals = function(other) {
        return this === other || //
               (other instanceof PolylineOutlineMaterialProperty && //
                Property.equals(this._color, other._color) && //
                Property.equals(this._outlineColor, other._outlineColor) && //
                Property.equals(this._outlineWidth, other._outlineWidth));
    };

    return PolylineOutlineMaterialProperty;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 1210:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(0),
        __webpack_require__(2),
        __webpack_require__(3),
        __webpack_require__(11),
        __webpack_require__(519),
        __webpack_require__(86)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
        defined,
        defineProperties,
        DeveloperError,
        Event,
        EventHelper,
        Property) {
    'use strict';

    /**
     * A {@link Property} whose value is an array whose items are the computed value
     * of other property instances.
     *
     * @alias PropertyArray
     * @constructor
     *
     * @param {Property[]} [value] An array of Property instances.
     */
    function PropertyArray(value) {
        this._value = undefined;
        this._definitionChanged = new Event();
        this._eventHelper = new EventHelper();
        this.setValue(value);
    }

    defineProperties(PropertyArray.prototype, {
        /**
         * Gets a value indicating if this property is constant.  This property
         * is considered constant if all property items in the array are constant.
         * @memberof PropertyArray.prototype
         *
         * @type {Boolean}
         * @readonly
         */
        isConstant : {
            get : function() {
                var value = this._value;
                if (!defined(value)) {
                    return true;
                }
                var length = value.length;
                for (var i = 0; i < length; i++) {
                    if (!Property.isConstant(value[i])) {
                        return false;
                    }
                }
                return true;
            }
        },
        /**
         * Gets the event that is raised whenever the definition of this property changes.
         * The definition is changed whenever setValue is called with data different
         * than the current value or one of the properties in the array also changes.
         * @memberof PropertyArray.prototype
         *
         * @type {Event}
         * @readonly
         */
        definitionChanged : {
            get : function() {
                return this._definitionChanged;
            }
        }
    });

    /**
     * Gets the value of the property.
     *
     * @param {JulianDate} time The time for which to retrieve the value.
     * @param {Object[]} [result] The object to store the value into, if omitted, a new instance is created and returned.
     * @returns {Object[]} The modified result parameter, which is an array of values produced by evaluating each of the contained properties at the given time or a new instance if the result parameter was not supplied.
     */
    PropertyArray.prototype.getValue = function(time, result) {
        //>>includeStart('debug', pragmas.debug);
        if (!defined(time)) {
            throw new DeveloperError('time is required.');
        }
        //>>includeEnd('debug');

        var value = this._value;
        if (!defined(value)) {
            return undefined;
        }

        var length = value.length;
        if (!defined(result)) {
            result = new Array(length);
        }
        var i = 0;
        var x = 0;
        while (i < length) {
            var property = this._value[i];
            var itemValue = property.getValue(time, result[i]);
            if (defined(itemValue)) {
                result[x] = itemValue;
                x++;
            }
            i++;
        }
        result.length = x;
        return result;
    };

    /**
     * Sets the value of the property.
     *
     * @param {Property[]} value An array of Property instances.
     */
    PropertyArray.prototype.setValue = function(value) {
        var eventHelper = this._eventHelper;
        eventHelper.removeAll();

        if (defined(value)) {
            this._value = value.slice();
            var length = value.length;
            for (var i = 0; i < length; i++) {
                var property = value[i];
                if (defined(property)) {
                    eventHelper.add(property.definitionChanged, PropertyArray.prototype._raiseDefinitionChanged, this);
                }
            }
        } else {
            this._value = undefined;
        }
        this._definitionChanged.raiseEvent(this);
    };

    /**
     * Compares this property to the provided property and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     *
     * @param {Property} [other] The other property.
     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    PropertyArray.prototype.equals = function(other) {
        return this === other || //
               (other instanceof PropertyArray && //
                Property.arrayEquals(this._value, other._value));
    };

    PropertyArray.prototype._raiseDefinitionChanged = function() {
        this._definitionChanged.raiseEvent(this);
    };

    return PropertyArray;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 1211:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(1),
        __webpack_require__(0),
        __webpack_require__(3),
        __webpack_require__(7)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
        defaultValue,
        defined,
        DeveloperError,
        CesiumMath) {
    'use strict';

    /**
     * Represents a {@link Packable} number that always interpolates values
     * towards the shortest angle of rotation. This object is never used directly
     * but is instead passed to the constructor of {@link SampledProperty}
     * in order to represent a two-dimensional angle of rotation.
     *
     * @exports Rotation
     *
     *
     * @example
     * var time1 = Cesium.JulianDate.fromIso8601('2010-05-07T00:00:00');
     * var time2 = Cesium.JulianDate.fromIso8601('2010-05-07T00:01:00');
     * var time3 = Cesium.JulianDate.fromIso8601('2010-05-07T00:02:00');
     *
     * var property = new Cesium.SampledProperty(Cesium.Rotation);
     * property.addSample(time1, 0);
     * property.addSample(time3, Cesium.Math.toRadians(350));
     *
     * //Getting the value at time2 will equal 355 degrees instead
     * //of 175 degrees (which is what you get if you construct
     * //a SampledProperty(Number) instead.  Note, the actual
     * //return value is in radians, not degrees.
     * property.getValue(time2);
     *
     * @see PackableForInterpolation
     */
    var Rotation = {
        /**
         * The number of elements used to pack the object into an array.
         * @type {Number}
         */
        packedLength : 1,

        /**
         * Stores the provided instance into the provided array.
         *
         * @param {Rotation} value The value to pack.
         * @param {Number[]} array The array to pack into.
         * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
         *
         * @returns {Number[]} The array that was packed into
         */
        pack : function(value, array, startingIndex) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(value)) {
                throw new DeveloperError('value is required');
            }

            if (!defined(array)) {
                throw new DeveloperError('array is required');
            }
            //>>includeEnd('debug');

            startingIndex = defaultValue(startingIndex, 0);
            array[startingIndex] = value;

            return array;
        },

        /**
         * Retrieves an instance from a packed array.
         *
         * @param {Number[]} array The packed array.
         * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
         * @param {Rotation} [result] The object into which to store the result.
         * @returns {Rotation} The modified result parameter or a new Rotation instance if one was not provided.
         */
        unpack : function(array, startingIndex, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(array)) {
                throw new DeveloperError('array is required');
            }
            //>>includeEnd('debug');

            startingIndex = defaultValue(startingIndex, 0);
            return array[startingIndex];
        },

        /**
         * Converts a packed array into a form suitable for interpolation.
         *
         * @param {Number[]} packedArray The packed array.
         * @param {Number} [startingIndex=0] The index of the first element to be converted.
         * @param {Number} [lastIndex=packedArray.length] The index of the last element to be converted.
         * @param {Number[]} result The object into which to store the result.
         */
        convertPackedArrayForInterpolation : function(packedArray, startingIndex, lastIndex, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(packedArray)) {
                throw new DeveloperError('packedArray is required');
            }
            //>>includeEnd('debug');

            startingIndex = defaultValue(startingIndex, 0);
            lastIndex = defaultValue(lastIndex, packedArray.length);

            var previousValue;
            for (var i = 0, len = lastIndex - startingIndex + 1; i < len; i++) {
                var value = packedArray[startingIndex + i];
                if (i === 0 || Math.abs(previousValue - value) < Math.PI) {
                    result[i] = value;
                } else {
                    result[i] = value - CesiumMath.TWO_PI;
                }
                previousValue = value;
            }
        },

        /**
         * Retrieves an instance from a packed array converted with {@link Rotation.convertPackedArrayForInterpolation}.
         *
         * @param {Number[]} array The array previously packed for interpolation.
         * @param {Number[]} sourceArray The original packed array.
         * @param {Number} [firstIndex=0] The firstIndex used to convert the array.
         * @param {Number} [lastIndex=packedArray.length] The lastIndex used to convert the array.
         * @param {Rotation} [result] The object into which to store the result.
         * @returns {Rotation} The modified result parameter or a new Rotation instance if one was not provided.
         */
        unpackInterpolationResult : function(array, sourceArray, firstIndex, lastIndex, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(array)) {
                throw new DeveloperError('array is required');
            }
            if (!defined(sourceArray)) {
                throw new DeveloperError('sourceArray is required');
            }
            //>>includeEnd('debug');

            result = array[0];
            if (result < 0) {
                return result + CesiumMath.TWO_PI;
            }
            return result;
        }
    };

    return Rotation;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 1212:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(21),
        __webpack_require__(1),
        __webpack_require__(0),
        __webpack_require__(2),
        __webpack_require__(11),
        __webpack_require__(34),
        __webpack_require__(86),
        __webpack_require__(1198)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
        Color,
        defaultValue,
        defined,
        defineProperties,
        Event,
        createPropertyDescriptor,
        Property,
        StripeOrientation) {
    'use strict';

    var defaultOrientation = StripeOrientation.HORIZONTAL;
    var defaultEvenColor = Color.WHITE;
    var defaultOddColor = Color.BLACK;
    var defaultOffset = 0;
    var defaultRepeat = 1;

    /**
     * A {@link MaterialProperty} that maps to stripe {@link Material} uniforms.
     * @alias StripeMaterialProperty
     * @constructor
     *
     * @param {Object} [options] Object with the following properties:
     * @param {Property} [options.evenColor=Color.WHITE] A Property specifying the first {@link Color}.
     * @param {Property} [options.oddColor=Color.BLACK] A Property specifying the second {@link Color}.
     * @param {Property} [options.repeat=1] A numeric Property specifying how many times the stripes repeat.
     * @param {Property} [options.offset=0] A numeric Property specifying how far into the pattern to start the material.
     * @param {Property} [options.orientation=StripeOrientation.HORIZONTAL] A Property specifying the {@link StripeOrientation}.
     */
    function StripeMaterialProperty(options) {
        options = defaultValue(options, defaultValue.EMPTY_OBJECT);

        this._definitionChanged = new Event();

        this._orientation = undefined;
        this._orientationSubscription = undefined;

        this._evenColor = undefined;
        this._evenColorSubscription = undefined;

        this._oddColor = undefined;
        this._oddColorSubscription = undefined;

        this._offset = undefined;
        this._offsetSubscription = undefined;

        this._repeat = undefined;
        this._repeatSubscription = undefined;

        this.orientation = options.orientation;
        this.evenColor = options.evenColor;
        this.oddColor = options.oddColor;
        this.offset = options.offset;
        this.repeat = options.repeat;
    }

    defineProperties(StripeMaterialProperty.prototype, {
        /**
         * Gets a value indicating if this property is constant.  A property is considered
         * constant if getValue always returns the same result for the current definition.
         * @memberof StripeMaterialProperty.prototype
         *
         * @type {Boolean}
         * @readonly
         */
        isConstant : {
            get : function() {
                return Property.isConstant(this._orientation) && //
                       Property.isConstant(this._evenColor) && //
                       Property.isConstant(this._oddColor) && //
                       Property.isConstant(this._offset) && //
                       Property.isConstant(this._repeat);
            }
        },
        /**
         * Gets the event that is raised whenever the definition of this property changes.
         * The definition is considered to have changed if a call to getValue would return
         * a different result for the same time.
         * @memberof StripeMaterialProperty.prototype
         *
         * @type {Event}
         * @readonly
         */
        definitionChanged : {
            get : function() {
                return this._definitionChanged;
            }
        },
        /**
         * Gets or sets the Property specifying the {@link StripeOrientation}/
         * @memberof StripeMaterialProperty.prototype
         * @type {Property}
         * @default StripeOrientation.HORIZONTAL
         */
        orientation : createPropertyDescriptor('orientation'),
        /**
         * Gets or sets the Property specifying the first {@link Color}.
         * @memberof StripeMaterialProperty.prototype
         * @type {Property}
         * @default Color.WHITE
         */
        evenColor : createPropertyDescriptor('evenColor'),
        /**
         * Gets or sets the Property specifying the second {@link Color}.
         * @memberof StripeMaterialProperty.prototype
         * @type {Property}
         * @default Color.BLACK
         */
        oddColor : createPropertyDescriptor('oddColor'),
        /**
         * Gets or sets the numeric Property specifying the point into the pattern
         * to begin drawing; with 0.0 being the beginning of the even color, 1.0 the beginning
         * of the odd color, 2.0 being the even color again, and any multiple or fractional values
         * being in between.
         * @memberof StripeMaterialProperty.prototype
         * @type {Property}
         * @default 0.0
         */
        offset : createPropertyDescriptor('offset'),
        /**
         * Gets or sets the numeric Property specifying how many times the stripes repeat.
         * @memberof StripeMaterialProperty.prototype
         * @type {Property}
         * @default 1.0
         */
        repeat : createPropertyDescriptor('repeat')
    });

    /**
     * Gets the {@link Material} type at the provided time.
     *
     * @param {JulianDate} time The time for which to retrieve the type.
     * @returns {String} The type of material.
     */
    StripeMaterialProperty.prototype.getType = function(time) {
        return 'Stripe';
    };

    /**
     * Gets the value of the property at the provided time.
     *
     * @param {JulianDate} time The time for which to retrieve the value.
     * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
     * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.
     */
    StripeMaterialProperty.prototype.getValue = function(time, result) {
        if (!defined(result)) {
            result = {};
        }
        result.horizontal = Property.getValueOrDefault(this._orientation, time, defaultOrientation) === StripeOrientation.HORIZONTAL;
        result.evenColor = Property.getValueOrClonedDefault(this._evenColor, time, defaultEvenColor, result.evenColor);
        result.oddColor = Property.getValueOrClonedDefault(this._oddColor, time, defaultOddColor, result.oddColor);
        result.offset = Property.getValueOrDefault(this._offset, time, defaultOffset);
        result.repeat = Property.getValueOrDefault(this._repeat, time, defaultRepeat);
        return result;
    };

    /**
     * Compares this property to the provided property and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     *
     * @param {Property} [other] The other property.
     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    StripeMaterialProperty.prototype.equals = function(other) {
        return this === other || //
               (other instanceof StripeMaterialProperty && //
                       Property.equals(this._orientation, other._orientation) && //
                       Property.equals(this._evenColor, other._evenColor) && //
                       Property.equals(this._oddColor, other._oddColor) && //
                       Property.equals(this._offset, other._offset) && //
                       Property.equals(this._repeat, other._repeat));
    };

    return StripeMaterialProperty;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 1213:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(6),
        __webpack_require__(1),
        __webpack_require__(0),
        __webpack_require__(2),
        __webpack_require__(22),
        __webpack_require__(11),
        __webpack_require__(35),
        __webpack_require__(52),
        __webpack_require__(42),
        __webpack_require__(86),
        __webpack_require__(1199)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
        Cartesian3,
        defaultValue,
        defined,
        defineProperties,
        Ellipsoid,
        Event,
        Matrix3,
        Quaternion,
        Transforms,
        Property,
        VelocityVectorProperty) {
    'use strict';

    /**
     * A {@link Property} which evaluates to a {@link Quaternion} rotation
     * based on the velocity of the provided {@link PositionProperty}.
     *
     * @alias VelocityOrientationProperty
     * @constructor
     *
     * @param {Property} [position] The position property used to compute the orientation.
     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid used to determine which way is up.
     *
     * @example
     * //Create an entity with position and orientation.
     * var position = new Cesium.SampledProperty();
     * position.addSamples(...);
     * var entity = viewer.entities.add({
     *   position : position,
     *   orientation : new Cesium.VelocityOrientationProperty(position)
     * }));
     */
    function VelocityOrientationProperty(position, ellipsoid) {
        this._velocityVectorProperty = new VelocityVectorProperty(position, true);
        this._subscription = undefined;
        this._ellipsoid = undefined;
        this._definitionChanged = new Event();

        this.ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);

        var that = this;
        this._velocityVectorProperty.definitionChanged.addEventListener(function() {
            that._definitionChanged.raiseEvent(that);
        });
    }

    defineProperties(VelocityOrientationProperty.prototype, {
        /**
         * Gets a value indicating if this property is constant.
         * @memberof VelocityOrientationProperty.prototype
         *
         * @type {Boolean}
         * @readonly
         */
        isConstant : {
            get : function() {
                return Property.isConstant(this._velocityVectorProperty);
            }
        },
        /**
         * Gets the event that is raised whenever the definition of this property changes.
         * @memberof VelocityOrientationProperty.prototype
         *
         * @type {Event}
         * @readonly
         */
        definitionChanged : {
            get : function() {
                return this._definitionChanged;
            }
        },
        /**
         * Gets or sets the position property used to compute orientation.
         * @memberof VelocityOrientationProperty.prototype
         *
         * @type {Property}
         */
        position : {
            get : function() {
                return this._velocityVectorProperty.position;
            },
            set : function(value) {
                this._velocityVectorProperty.position = value;
            }
        },
        /**
         * Gets or sets the ellipsoid used to determine which way is up.
         * @memberof VelocityOrientationProperty.prototype
         *
         * @type {Property}
         */
        ellipsoid : {
            get : function() {
                return this._ellipsoid;
            },
            set : function(value) {
                var oldValue = this._ellipsoid;
                if (oldValue !== value) {
                    this._ellipsoid = value;
                    this._definitionChanged.raiseEvent(this);
                }
            }
        }
    });

    var positionScratch = new Cartesian3();
    var velocityScratch = new Cartesian3();
    var rotationScratch = new Matrix3();

    /**
     * Gets the value of the property at the provided time.
     *
     * @param {JulianDate} [time] The time for which to retrieve the value.
     * @param {Quaternion} [result] The object to store the value into, if omitted, a new instance is created and returned.
     * @returns {Quaternion} The modified result parameter or a new instance if the result parameter was not supplied.
     */
    VelocityOrientationProperty.prototype.getValue = function(time, result) {
        var velocity = this._velocityVectorProperty._getValue(time, velocityScratch, positionScratch);

        if (!defined(velocity)) {
            return undefined;
        }

        Transforms.rotationMatrixFromPositionVelocity(positionScratch, velocity, this._ellipsoid, rotationScratch);
        return Quaternion.fromRotationMatrix(rotationScratch, result);
    };

    /**
     * Compares this property to the provided property and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     *
     * @param {Property} [other] The other property.
     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    VelocityOrientationProperty.prototype.equals = function(other) {
        return this === other ||//
               (other instanceof VelocityOrientationProperty &&
                Property.equals(this._velocityVectorProperty, other._velocityVectorProperty) &&
                (this._ellipsoid === other._ellipsoid ||
                 this._ellipsoid.equals(other._ellipsoid)));
    };

    return VelocityOrientationProperty;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 1214:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {
  if (true) {
    // AMD. Register as an anonymous module unless amdModuleId is set
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
      return (root['Autolinker'] = factory());
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof exports === 'object') {
    // Node. Does not work with strict CommonJS, but
    // only CommonJS-like environments that support module.exports,
    // like Node.
    module.exports = factory();
  } else {
    root['Autolinker'] = factory();
  }
}(this, function () {

/*!
 * Autolinker.js
 * 0.17.1
 *
 * Copyright(c) 2015 Gregory Jacobs <greg@greg-jacobs.com>
 * MIT Licensed. http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/gregjacobs/Autolinker.js
 */
/**
 * @class Autolinker
 * @extends Object
 *
 * Utility class used to process a given string of text, and wrap the matches in
 * the appropriate anchor (&lt;a&gt;) tags to turn them into links.
 *
 * Any of the configuration options may be provided in an Object (map) provided
 * to the Autolinker constructor, which will configure how the {@link #link link()}
 * method will process the links.
 *
 * For example:
 *
 *     var autolinker = new Autolinker( {
 *         newWindow : false,
 *         truncate  : 30
 *     } );
 *
 *     var html = autolinker.link( "Joe went to www.yahoo.com" );
 *     // produces: 'Joe went to <a href="http://www.yahoo.com">yahoo.com</a>'
 *
 *
 * The {@link #static-link static link()} method may also be used to inline options into a single call, which may
 * be more convenient for one-off uses. For example:
 *
 *     var html = Autolinker.link( "Joe went to www.yahoo.com", {
 *         newWindow : false,
 *         truncate  : 30
 *     } );
 *     // produces: 'Joe went to <a href="http://www.yahoo.com">yahoo.com</a>'
 *
 *
 * ## Custom Replacements of Links
 *
 * If the configuration options do not provide enough flexibility, a {@link #replaceFn}
 * may be provided to fully customize the output of Autolinker. This function is
 * called once for each URL/Email/Phone#/Twitter Handle/Hashtag match that is
 * encountered.
 *
 * For example:
 *
 *     var input = "...";  // string with URLs, Email Addresses, Phone #s, Twitter Handles, and Hashtags
 *
 *     var linkedText = Autolinker.link( input, {
 *         replaceFn : function( autolinker, match ) {
 *             console.log( "href = ", match.getAnchorHref() );
 *             console.log( "text = ", match.getAnchorText() );
 *
 *             switch( match.getType() ) {
 *                 case 'url' :
 *                     console.log( "url: ", match.getUrl() );
 *
 *                     if( match.getUrl().indexOf( 'mysite.com' ) === -1 ) {
 *                         var tag = autolinker.getTagBuilder().build( match );  // returns an `Autolinker.HtmlTag` instance, which provides mutator methods for easy changes
 *                         tag.setAttr( 'rel', 'nofollow' );
 *                         tag.addClass( 'external-link' );
 *
 *                         return tag;
 *
 *                     } else {
 *                         return true;  // let Autolinker perform its normal anchor tag replacement
 *                     }
 *
 *                 case 'email' :
 *                     var email = match.getEmail();
 *                     console.log( "email: ", email );
 *
 *                     if( email === "my@own.address" ) {
 *                         return false;  // don't auto-link this particular email address; leave as-is
 *                     } else {
 *                         return;  // no return value will have Autolinker perform its normal anchor tag replacement (same as returning `true`)
 *                     }
 *
 *                 case 'phone' :
 *                     var phoneNumber = match.getPhoneNumber();
 *                     console.log( phoneNumber );
 *
 *                     return '<a href="http://newplace.to.link.phone.numbers.to/">' + phoneNumber + '</a>';
 *
 *                 case 'twitter' :
 *                     var twitterHandle = match.getTwitterHandle();
 *                     console.log( twitterHandle );
 *
 *                     return '<a href="http://newplace.to.link.twitter.handles.to/">' + twitterHandle + '</a>';
 *
 *                 case 'hashtag' :
 *                     var hashtag = match.getHashtag();
 *                     console.log( hashtag );
 *
 *                     return '<a href="http://newplace.to.link.hashtag.handles.to/">' + hashtag + '</a>';
 *             }
 *         }
 *     } );
 *
 *
 * The function may return the following values:
 *
 * - `true` (Boolean): Allow Autolinker to replace the match as it normally would.
 * - `false` (Boolean): Do not replace the current match at all - leave as-is.
 * - Any String: If a string is returned from the function, the string will be used directly as the replacement HTML for
 *   the match.
 * - An {@link Autolinker.HtmlTag} instance, which can be used to build/modify an HTML tag before writing out its HTML text.
 *
 * @constructor
 * @param {Object} [config] The configuration options for the Autolinker instance, specified in an Object (map).
 */
var Autolinker = function( cfg ) {
	Autolinker.Util.assign( this, cfg );  // assign the properties of `cfg` onto the Autolinker instance. Prototype properties will be used for missing configs.

	// Validate the value of the `hashtag` cfg.
	var hashtag = this.hashtag;
	if( hashtag !== false && hashtag !== 'twitter' && hashtag !== 'facebook' ) {
		throw new Error( "invalid `hashtag` cfg - see docs" );
	}
};

Autolinker.prototype = {
	constructor : Autolinker,  // fix constructor property

	/**
	 * @cfg {Boolean} urls
	 *
	 * `true` if miscellaneous URLs should be automatically linked, `false` if they should not be.
	 */
	urls : true,

	/**
	 * @cfg {Boolean} email
	 *
	 * `true` if email addresses should be automatically linked, `false` if they should not be.
	 */
	email : true,

	/**
	 * @cfg {Boolean} twitter
	 *
	 * `true` if Twitter handles ("@example") should be automatically linked, `false` if they should not be.
	 */
	twitter : true,

	/**
	 * @cfg {Boolean} phone
	 *
	 * `true` if Phone numbers ("(555)555-5555") should be automatically linked, `false` if they should not be.
	 */
	phone: true,

	/**
	 * @cfg {Boolean/String} hashtag
	 *
	 * A string for the service name to have hashtags (ex: "#myHashtag")
	 * auto-linked to. The currently-supported values are:
	 *
	 * - 'twitter'
	 * - 'facebook'
	 *
	 * Pass `false` to skip auto-linking of hashtags.
	 */
	hashtag : false,

	/**
	 * @cfg {Boolean} newWindow
	 *
	 * `true` if the links should open in a new window, `false` otherwise.
	 */
	newWindow : true,

	/**
	 * @cfg {Boolean} stripPrefix
	 *
	 * `true` if 'http://' or 'https://' and/or the 'www.' should be stripped
	 * from the beginning of URL links' text, `false` otherwise.
	 */
	stripPrefix : true,

	/**
	 * @cfg {Number} truncate
	 *
	 * A number for how many characters long matched text should be truncated to inside the text of
	 * a link. If the matched text is over this number of characters, it will be truncated to this length by
	 * adding a two period ellipsis ('..') to the end of the string.
	 *
	 * For example: A url like 'http://www.yahoo.com/some/long/path/to/a/file' truncated to 25 characters might look
	 * something like this: 'yahoo.com/some/long/pat..'
	 */
	truncate : undefined,

	/**
	 * @cfg {String} className
	 *
	 * A CSS class name to add to the generated links. This class will be added to all links, as well as this class
	 * plus match suffixes for styling url/email/phone/twitter/hashtag links differently.
	 *
	 * For example, if this config is provided as "myLink", then:
	 *
	 * - URL links will have the CSS classes: "myLink myLink-url"
	 * - Email links will have the CSS classes: "myLink myLink-email", and
	 * - Twitter links will have the CSS classes: "myLink myLink-twitter"
	 * - Phone links will have the CSS classes: "myLink myLink-phone"
	 * - Hashtag links will have the CSS classes: "myLink myLink-hashtag"
	 */
	className : "",

	/**
	 * @cfg {Function} replaceFn
	 *
	 * A function to individually process each match found in the input string.
	 *
	 * See the class's description for usage.
	 *
	 * This function is called with the following parameters:
	 *
	 * @cfg {Autolinker} replaceFn.autolinker The Autolinker instance, which may be used to retrieve child objects from (such
	 *   as the instance's {@link #getTagBuilder tag builder}).
	 * @cfg {Autolinker.match.Match} replaceFn.match The Match instance which can be used to retrieve information about the
	 *   match that the `replaceFn` is currently processing. See {@link Autolinker.match.Match} subclasses for details.
	 */


	/**
	 * @private
	 * @property {Autolinker.htmlParser.HtmlParser} htmlParser
	 *
	 * The HtmlParser instance used to skip over HTML tags, while finding text nodes to process. This is lazily instantiated
	 * in the {@link #getHtmlParser} method.
	 */
	htmlParser : undefined,

	/**
	 * @private
	 * @property {Autolinker.matchParser.MatchParser} matchParser
	 *
	 * The MatchParser instance used to find matches in the text nodes of an input string passed to
	 * {@link #link}. This is lazily instantiated in the {@link #getMatchParser} method.
	 */
	matchParser : undefined,

	/**
	 * @private
	 * @property {Autolinker.AnchorTagBuilder} tagBuilder
	 *
	 * The AnchorTagBuilder instance used to build match replacement anchor tags. Note: this is lazily instantiated
	 * in the {@link #getTagBuilder} method.
	 */
	tagBuilder : undefined,

	/**
	 * Automatically links URLs, Email addresses, Phone numbers, Twitter
	 * handles, and Hashtags found in the given chunk of HTML. Does not link
	 * URLs found within HTML tags.
	 *
	 * For instance, if given the text: `You should go to http://www.yahoo.com`,
	 * then the result will be `You should go to
	 * &lt;a href="http://www.yahoo.com"&gt;http://www.yahoo.com&lt;/a&gt;`
	 *
	 * This method finds the text around any HTML elements in the input
	 * `textOrHtml`, which will be the text that is processed. Any original HTML
	 * elements will be left as-is, as well as the text that is already wrapped
	 * in anchor (&lt;a&gt;) tags.
	 *
	 * @param {String} textOrHtml The HTML or text to autolink matches within
	 *   (depending on if the {@link #urls}, {@link #email}, {@link #phone},
	 *   {@link #twitter}, and {@link #hashtag} options are enabled).
	 * @return {String} The HTML, with matches automatically linked.
	 */
	link : function( textOrHtml ) {
		var htmlParser = this.getHtmlParser(),
		    htmlNodes = htmlParser.parse( textOrHtml ),
		    anchorTagStackCount = 0,  // used to only process text around anchor tags, and any inner text/html they may have
		    resultHtml = [];

		for( var i = 0, len = htmlNodes.length; i < len; i++ ) {
			var node = htmlNodes[ i ],
			    nodeType = node.getType(),
			    nodeText = node.getText();

			if( nodeType === 'element' ) {
				// Process HTML nodes in the input `textOrHtml`
				if( node.getTagName() === 'a' ) {
					if( !node.isClosing() ) {  // it's the start <a> tag
						anchorTagStackCount++;
					} else {   // it's the end </a> tag
						anchorTagStackCount = Math.max( anchorTagStackCount - 1, 0 );  // attempt to handle extraneous </a> tags by making sure the stack count never goes below 0
					}
				}
				resultHtml.push( nodeText );  // now add the text of the tag itself verbatim

			} else if( nodeType === 'entity' || nodeType === 'comment' ) {
				resultHtml.push( nodeText );  // append HTML entity nodes (such as '&nbsp;') or HTML comments (such as '<!-- Comment -->') verbatim

			} else {
				// Process text nodes in the input `textOrHtml`
				if( anchorTagStackCount === 0 ) {
					// If we're not within an <a> tag, process the text node to linkify
					var linkifiedStr = this.linkifyStr( nodeText );
					resultHtml.push( linkifiedStr );

				} else {
					// `text` is within an <a> tag, simply append the text - we do not want to autolink anything
					// already within an <a>...</a> tag
					resultHtml.push( nodeText );
				}
			}
		}

		return resultHtml.join( "" );
	},

	/**
	 * Process the text that lies in between HTML tags, performing the anchor
	 * tag replacements for the matches, and returns the string with the
	 * replacements made.
	 *
	 * This method does the actual wrapping of matches with anchor tags.
	 *
	 * @private
	 * @param {String} str The string of text to auto-link.
	 * @return {String} The text with anchor tags auto-filled.
	 */
	linkifyStr : function( str ) {
		return this.getMatchParser().replace( str, this.createMatchReturnVal, this );
	},


	/**
	 * Creates the return string value for a given match in the input string,
	 * for the {@link #linkifyStr} method.
	 *
	 * This method handles the {@link #replaceFn}, if one was provided.
	 *
	 * @private
	 * @param {Autolinker.match.Match} match The Match object that represents the match.
	 * @return {String} The string that the `match` should be replaced with. This is usually the anchor tag string, but
	 *   may be the `matchStr` itself if the match is not to be replaced.
	 */
	createMatchReturnVal : function( match ) {
		// Handle a custom `replaceFn` being provided
		var replaceFnResult;
		if( this.replaceFn ) {
			replaceFnResult = this.replaceFn.call( this, this, match );  // Autolinker instance is the context, and the first arg
		}

		if( typeof replaceFnResult === 'string' ) {
			return replaceFnResult;  // `replaceFn` returned a string, use that

		} else if( replaceFnResult === false ) {
			return match.getMatchedText();  // no replacement for the match

		} else if( replaceFnResult instanceof Autolinker.HtmlTag ) {
			return replaceFnResult.toAnchorString();

		} else {  // replaceFnResult === true, or no/unknown return value from function
			// Perform Autolinker's default anchor tag generation
			var tagBuilder = this.getTagBuilder(),
			    anchorTag = tagBuilder.build( match );  // returns an Autolinker.HtmlTag instance

			return anchorTag.toAnchorString();
		}
	},


	/**
	 * Lazily instantiates and returns the {@link #htmlParser} instance for this Autolinker instance.
	 *
	 * @protected
	 * @return {Autolinker.htmlParser.HtmlParser}
	 */
	getHtmlParser : function() {
		var htmlParser = this.htmlParser;

		if( !htmlParser ) {
			htmlParser = this.htmlParser = new Autolinker.htmlParser.HtmlParser();
		}

		return htmlParser;
	},


	/**
	 * Lazily instantiates and returns the {@link #matchParser} instance for this Autolinker instance.
	 *
	 * @protected
	 * @return {Autolinker.matchParser.MatchParser}
	 */
	getMatchParser : function() {
		var matchParser = this.matchParser;

		if( !matchParser ) {
			matchParser = this.matchParser = new Autolinker.matchParser.MatchParser( {
				urls        : this.urls,
				email       : this.email,
				twitter     : this.twitter,
				phone       : this.phone,
				hashtag     : this.hashtag,
				stripPrefix : this.stripPrefix
			} );
		}

		return matchParser;
	},


	/**
	 * Returns the {@link #tagBuilder} instance for this Autolinker instance, lazily instantiating it
	 * if it does not yet exist.
	 *
	 * This method may be used in a {@link #replaceFn} to generate the {@link Autolinker.HtmlTag HtmlTag} instance that
	 * Autolinker would normally generate, and then allow for modifications before returning it. For example:
	 *
	 *     var html = Autolinker.link( "Test google.com", {
	 *         replaceFn : function( autolinker, match ) {
	 *             var tag = autolinker.getTagBuilder().build( match );  // returns an {@link Autolinker.HtmlTag} instance
	 *             tag.setAttr( 'rel', 'nofollow' );
	 *
	 *             return tag;
	 *         }
	 *     } );
	 *
	 *     // generated html:
	 *     //   Test <a href="http://google.com" target="_blank" rel="nofollow">google.com</a>
	 *
	 * @return {Autolinker.AnchorTagBuilder}
	 */
	getTagBuilder : function() {
		var tagBuilder = this.tagBuilder;

		if( !tagBuilder ) {
			tagBuilder = this.tagBuilder = new Autolinker.AnchorTagBuilder( {
				newWindow   : this.newWindow,
				truncate    : this.truncate,
				className   : this.className
			} );
		}

		return tagBuilder;
	}

};


/**
 * Automatically links URLs, Email addresses, Phone Numbers, Twitter handles,
 * and Hashtags found in the given chunk of HTML. Does not link URLs found
 * within HTML tags.
 *
 * For instance, if given the text: `You should go to http://www.yahoo.com`,
 * then the result will be `You should go to &lt;a href="http://www.yahoo.com"&gt;http://www.yahoo.com&lt;/a&gt;`
 *
 * Example:
 *
 *     var linkedText = Autolinker.link( "Go to google.com", { newWindow: false } );
 *     // Produces: "Go to <a href="http://google.com">google.com</a>"
 *
 * @static
 * @param {String} textOrHtml The HTML or text to find matches within (depending
 *   on if the {@link #urls}, {@link #email}, {@link #phone}, {@link #twitter},
 *   and {@link #hashtag} options are enabled).
 * @param {Object} [options] Any of the configuration options for the Autolinker
 *   class, specified in an Object (map). See the class description for an
 *   example call.
 * @return {String} The HTML text, with matches automatically linked.
 */
Autolinker.link = function( textOrHtml, options ) {
	var autolinker = new Autolinker( options );
	return autolinker.link( textOrHtml );
};


// Autolinker Namespaces
Autolinker.match = {};
Autolinker.htmlParser = {};
Autolinker.matchParser = {};

/*global Autolinker */
/*jshint eqnull:true, boss:true */
/**
 * @class Autolinker.Util
 * @singleton
 *
 * A few utility methods for Autolinker.
 */
Autolinker.Util = {

	/**
	 * @property {Function} abstractMethod
	 *
	 * A function object which represents an abstract method.
	 */
	abstractMethod : function() { throw "abstract"; },


	/**
	 * @private
	 * @property {RegExp} trimRegex
	 *
	 * The regular expression used to trim the leading and trailing whitespace
	 * from a string.
	 */
	trimRegex : /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,


	/**
	 * Assigns (shallow copies) the properties of `src` onto `dest`.
	 *
	 * @param {Object} dest The destination object.
	 * @param {Object} src The source object.
	 * @return {Object} The destination object (`dest`)
	 */
	assign : function( dest, src ) {
		for( var prop in src ) {
			if( src.hasOwnProperty( prop ) ) {
				dest[ prop ] = src[ prop ];
			}
		}

		return dest;
	},


	/**
	 * Extends `superclass` to create a new subclass, adding the `protoProps` to the new subclass's prototype.
	 *
	 * @param {Function} superclass The constructor function for the superclass.
	 * @param {Object} protoProps The methods/properties to add to the subclass's prototype. This may contain the
	 *   special property `constructor`, which will be used as the new subclass's constructor function.
	 * @return {Function} The new subclass function.
	 */
	extend : function( superclass, protoProps ) {
		var superclassProto = superclass.prototype;

		var F = function() {};
		F.prototype = superclassProto;

		var subclass;
		if( protoProps.hasOwnProperty( 'constructor' ) ) {
			subclass = protoProps.constructor;
		} else {
			subclass = function() { superclassProto.constructor.apply( this, arguments ); };
		}

		var subclassProto = subclass.prototype = new F();  // set up prototype chain
		subclassProto.constructor = subclass;  // fix constructor property
		subclassProto.superclass = superclassProto;

		delete protoProps.constructor;  // don't re-assign constructor property to the prototype, since a new function may have been created (`subclass`), which is now already there
		Autolinker.Util.assign( subclassProto, protoProps );

		return subclass;
	},


	/**
	 * Truncates the `str` at `len - ellipsisChars.length`, and adds the `ellipsisChars` to the
	 * end of the string (by default, two periods: '..'). If the `str` length does not exceed
	 * `len`, the string will be returned unchanged.
	 *
	 * @param {String} str The string to truncate and add an ellipsis to.
	 * @param {Number} truncateLen The length to truncate the string at.
	 * @param {String} [ellipsisChars=..] The ellipsis character(s) to add to the end of `str`
	 *   when truncated. Defaults to '..'
	 */
	ellipsis : function( str, truncateLen, ellipsisChars ) {
		if( str.length > truncateLen ) {
			ellipsisChars = ( ellipsisChars == null ) ? '..' : ellipsisChars;
			str = str.substring( 0, truncateLen - ellipsisChars.length ) + ellipsisChars;
		}
		return str;
	},


	/**
	 * Supports `Array.prototype.indexOf()` functionality for old IE (IE8 and below).
	 *
	 * @param {Array} arr The array to find an element of.
	 * @param {*} element The element to find in the array, and return the index of.
	 * @return {Number} The index of the `element`, or -1 if it was not found.
	 */
	indexOf : function( arr, element ) {
		if( Array.prototype.indexOf ) {
			return arr.indexOf( element );

		} else {
			for( var i = 0, len = arr.length; i < len; i++ ) {
				if( arr[ i ] === element ) return i;
			}
			return -1;
		}
	},



	/**
	 * Performs the functionality of what modern browsers do when `String.prototype.split()` is called
	 * with a regular expression that contains capturing parenthesis.
	 *
	 * For example:
	 *
	 *     // Modern browsers:
	 *     "a,b,c".split( /(,)/ );  // --> [ 'a', ',', 'b', ',', 'c' ]
	 *
	 *     // Old IE (including IE8):
	 *     "a,b,c".split( /(,)/ );  // --> [ 'a', 'b', 'c' ]
	 *
	 * This method emulates the functionality of modern browsers for the old IE case.
	 *
	 * @param {String} str The string to split.
	 * @param {RegExp} splitRegex The regular expression to split the input `str` on. The splitting
	 *   character(s) will be spliced into the array, as in the "modern browsers" example in the
	 *   description of this method.
	 *   Note #1: the supplied regular expression **must** have the 'g' flag specified.
	 *   Note #2: for simplicity's sake, the regular expression does not need
	 *   to contain capturing parenthesis - it will be assumed that any match has them.
	 * @return {String[]} The split array of strings, with the splitting character(s) included.
	 */
	splitAndCapture : function( str, splitRegex ) {
		if( !splitRegex.global ) throw new Error( "`splitRegex` must have the 'g' flag set" );

		var result = [],
		    lastIdx = 0,
		    match;

		while( match = splitRegex.exec( str ) ) {
			result.push( str.substring( lastIdx, match.index ) );
			result.push( match[ 0 ] );  // push the splitting char(s)

			lastIdx = match.index + match[ 0 ].length;
		}
		result.push( str.substring( lastIdx ) );

		return result;
	},


	/**
	 * Trims the leading and trailing whitespace from a string.
	 *
	 * @param {String} str The string to trim.
	 * @return {String}
	 */
	trim : function( str ) {
		return str.replace( this.trimRegex, '' );
	}

};
/*global Autolinker */
/*jshint boss:true */
/**
 * @class Autolinker.HtmlTag
 * @extends Object
 *
 * Represents an HTML tag, which can be used to easily build/modify HTML tags programmatically.
 *
 * Autolinker uses this abstraction to create HTML tags, and then write them out as strings. You may also use
 * this class in your code, especially within a {@link Autolinker#replaceFn replaceFn}.
 *
 * ## Examples
 *
 * Example instantiation:
 *
 *     var tag = new Autolinker.HtmlTag( {
 *         tagName : 'a',
 *         attrs   : { 'href': 'http://google.com', 'class': 'external-link' },
 *         innerHtml : 'Google'
 *     } );
 *
 *     tag.toAnchorString();  // <a href="http://google.com" class="external-link">Google</a>
 *
 *     // Individual accessor methods
 *     tag.getTagName();                 // 'a'
 *     tag.getAttr( 'href' );            // 'http://google.com'
 *     tag.hasClass( 'external-link' );  // true
 *
 *
 * Using mutator methods (which may be used in combination with instantiation config properties):
 *
 *     var tag = new Autolinker.HtmlTag();
 *     tag.setTagName( 'a' );
 *     tag.setAttr( 'href', 'http://google.com' );
 *     tag.addClass( 'external-link' );
 *     tag.setInnerHtml( 'Google' );
 *
 *     tag.getTagName();                 // 'a'
 *     tag.getAttr( 'href' );            // 'http://google.com'
 *     tag.hasClass( 'external-link' );  // true
 *
 *     tag.toAnchorString();  // <a href="http://google.com" class="external-link">Google</a>
 *
 *
 * ## Example use within a {@link Autolinker#replaceFn replaceFn}
 *
 *     var html = Autolinker.link( "Test google.com", {
 *         replaceFn : function( autolinker, match ) {
 *             var tag = autolinker.getTagBuilder().build( match );  // returns an {@link Autolinker.HtmlTag} instance, configured with the Match's href and anchor text
 *             tag.setAttr( 'rel', 'nofollow' );
 *
 *             return tag;
 *         }
 *     } );
 *
 *     // generated html:
 *     //   Test <a href="http://google.com" target="_blank" rel="nofollow">google.com</a>
 *
 *
 * ## Example use with a new tag for the replacement
 *
 *     var html = Autolinker.link( "Test google.com", {
 *         replaceFn : function( autolinker, match ) {
 *             var tag = new Autolinker.HtmlTag( {
 *                 tagName : 'button',
 *                 attrs   : { 'title': 'Load URL: ' + match.getAnchorHref() },
 *                 innerHtml : 'Load URL: ' + match.getAnchorText()
 *             } );
 *
 *             return tag;
 *         }
 *     } );
 *
 *     // generated html:
 *     //   Test <button title="Load URL: http://google.com">Load URL: google.com</button>
 */
Autolinker.HtmlTag = Autolinker.Util.extend( Object, {

	/**
	 * @cfg {String} tagName
	 *
	 * The tag name. Ex: 'a', 'button', etc.
	 *
	 * Not required at instantiation time, but should be set using {@link #setTagName} before {@link #toAnchorString}
	 * is executed.
	 */

	/**
	 * @cfg {Object.<String, String>} attrs
	 *
	 * An key/value Object (map) of attributes to create the tag with. The keys are the attribute names, and the
	 * values are the attribute values.
	 */

	/**
	 * @cfg {String} innerHtml
	 *
	 * The inner HTML for the tag.
	 *
	 * Note the camel case name on `innerHtml`. Acronyms are camelCased in this utility (such as not to run into the acronym
	 * naming inconsistency that the DOM developers created with `XMLHttpRequest`). You may alternatively use {@link #innerHTML}
	 * if you prefer, but this one is recommended.
	 */

	/**
	 * @cfg {String} innerHTML
	 *
	 * Alias of {@link #innerHtml}, accepted for consistency with the browser DOM api, but prefer the camelCased version
	 * for acronym names.
	 */


	/**
	 * @protected
	 * @property {RegExp} whitespaceRegex
	 *
	 * Regular expression used to match whitespace in a string of CSS classes.
	 */
	whitespaceRegex : /\s+/,


	/**
	 * @constructor
	 * @param {Object} [cfg] The configuration properties for this class, in an Object (map)
	 */
	constructor : function( cfg ) {
		Autolinker.Util.assign( this, cfg );

		this.innerHtml = this.innerHtml || this.innerHTML;  // accept either the camelCased form or the fully capitalized acronym
	},


	/**
	 * Sets the tag name that will be used to generate the tag with.
	 *
	 * @param {String} tagName
	 * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.
	 */
	setTagName : function( tagName ) {
		this.tagName = tagName;
		return this;
	},


	/**
	 * Retrieves the tag name.
	 *
	 * @return {String}
	 */
	getTagName : function() {
		return this.tagName || "";
	},


	/**
	 * Sets an attribute on the HtmlTag.
	 *
	 * @param {String} attrName The attribute name to set.
	 * @param {String} attrValue The attribute value to set.
	 * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.
	 */
	setAttr : function( attrName, attrValue ) {
		var tagAttrs = this.getAttrs();
		tagAttrs[ attrName ] = attrValue;

		return this;
	},


	/**
	 * Retrieves an attribute from the HtmlTag. If the attribute does not exist, returns `undefined`.
	 *
	 * @param {String} name The attribute name to retrieve.
	 * @return {String} The attribute's value, or `undefined` if it does not exist on the HtmlTag.
	 */
	getAttr : function( attrName ) {
		return this.getAttrs()[ attrName ];
	},


	/**
	 * Sets one or more attributes on the HtmlTag.
	 *
	 * @param {Object.<String, String>} attrs A key/value Object (map) of the attributes to set.
	 * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.
	 */
	setAttrs : function( attrs ) {
		var tagAttrs = this.getAttrs();
		Autolinker.Util.assign( tagAttrs, attrs );

		return this;
	},


	/**
	 * Retrieves the attributes Object (map) for the HtmlTag.
	 *
	 * @return {Object.<String, String>} A key/value object of the attributes for the HtmlTag.
	 */
	getAttrs : function() {
		return this.attrs || ( this.attrs = {} );
	},


	/**
	 * Sets the provided `cssClass`, overwriting any current CSS classes on the HtmlTag.
	 *
	 * @param {String} cssClass One or more space-separated CSS classes to set (overwrite).
	 * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.
	 */
	setClass : function( cssClass ) {
		return this.setAttr( 'class', cssClass );
	},


	/**
	 * Convenience method to add one or more CSS classes to the HtmlTag. Will not add duplicate CSS classes.
	 *
	 * @param {String} cssClass One or more space-separated CSS classes to add.
	 * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.
	 */
	addClass : function( cssClass ) {
		var classAttr = this.getClass(),
		    whitespaceRegex = this.whitespaceRegex,
		    indexOf = Autolinker.Util.indexOf,  // to support IE8 and below
		    classes = ( !classAttr ) ? [] : classAttr.split( whitespaceRegex ),
		    newClasses = cssClass.split( whitespaceRegex ),
		    newClass;

		while( newClass = newClasses.shift() ) {
			if( indexOf( classes, newClass ) === -1 ) {
				classes.push( newClass );
			}
		}

		this.getAttrs()[ 'class' ] = classes.join( " " );
		return this;
	},


	/**
	 * Convenience method to remove one or more CSS classes from the HtmlTag.
	 *
	 * @param {String} cssClass One or more space-separated CSS classes to remove.
	 * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.
	 */
	removeClass : function( cssClass ) {
		var classAttr = this.getClass(),
		    whitespaceRegex = this.whitespaceRegex,
		    indexOf = Autolinker.Util.indexOf,  // to support IE8 and below
		    classes = ( !classAttr ) ? [] : classAttr.split( whitespaceRegex ),
		    removeClasses = cssClass.split( whitespaceRegex ),
		    removeClass;

		while( classes.length && ( removeClass = removeClasses.shift() ) ) {
			var idx = indexOf( classes, removeClass );
			if( idx !== -1 ) {
				classes.splice( idx, 1 );
			}
		}

		this.getAttrs()[ 'class' ] = classes.join( " " );
		return this;
	},


	/**
	 * Convenience method to retrieve the CSS class(es) for the HtmlTag, which will each be separated by spaces when
	 * there are multiple.
	 *
	 * @return {String}
	 */
	getClass : function() {
		return this.getAttrs()[ 'class' ] || "";
	},


	/**
	 * Convenience method to check if the tag has a CSS class or not.
	 *
	 * @param {String} cssClass The CSS class to check for.
	 * @return {Boolean} `true` if the HtmlTag has the CSS class, `false` otherwise.
	 */
	hasClass : function( cssClass ) {
		return ( ' ' + this.getClass() + ' ' ).indexOf( ' ' + cssClass + ' ' ) !== -1;
	},


	/**
	 * Sets the inner HTML for the tag.
	 *
	 * @param {String} html The inner HTML to set.
	 * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.
	 */
	setInnerHtml : function( html ) {
		this.innerHtml = html;

		return this;
	},


	/**
	 * Retrieves the inner HTML for the tag.
	 *
	 * @return {String}
	 */
	getInnerHtml : function() {
		return this.innerHtml || "";
	},


	/**
	 * Override of superclass method used to generate the HTML string for the tag.
	 *
	 * @return {String}
	 */
	toAnchorString : function() {
		var tagName = this.getTagName(),
		    attrsStr = this.buildAttrsStr();

		attrsStr = ( attrsStr ) ? ' ' + attrsStr : '';  // prepend a space if there are actually attributes

		return [ '<', tagName, attrsStr, '>', this.getInnerHtml(), '</', tagName, '>' ].join( "" );
	},


	/**
	 * Support method for {@link #toAnchorString}, returns the string space-separated key="value" pairs, used to populate
	 * the stringified HtmlTag.
	 *
	 * @protected
	 * @return {String} Example return: `attr1="value1" attr2="value2"`
	 */
	buildAttrsStr : function() {
		if( !this.attrs ) return "";  // no `attrs` Object (map) has been set, return empty string

		var attrs = this.getAttrs(),
		    attrsArr = [];

		for( var prop in attrs ) {
			if( attrs.hasOwnProperty( prop ) ) {
				attrsArr.push( prop + '="' + attrs[ prop ] + '"' );
			}
		}
		return attrsArr.join( " " );
	}

} );

/*global Autolinker */
/*jshint sub:true */
/**
 * @protected
 * @class Autolinker.AnchorTagBuilder
 * @extends Object
 *
 * Builds anchor (&lt;a&gt;) tags for the Autolinker utility when a match is found.
 *
 * Normally this class is instantiated, configured, and used internally by an {@link Autolinker} instance, but may
 * actually be retrieved in a {@link Autolinker#replaceFn replaceFn} to create {@link Autolinker.HtmlTag HtmlTag} instances
 * which may be modified before returning from the {@link Autolinker#replaceFn replaceFn}. For example:
 *
 *     var html = Autolinker.link( "Test google.com", {
 *         replaceFn : function( autolinker, match ) {
 *             var tag = autolinker.getTagBuilder().build( match );  // returns an {@link Autolinker.HtmlTag} instance
 *             tag.setAttr( 'rel', 'nofollow' );
 *
 *             return tag;
 *         }
 *     } );
 *
 *     // generated html:
 *     //   Test <a href="http://google.com" target="_blank" rel="nofollow">google.com</a>
 */
Autolinker.AnchorTagBuilder = Autolinker.Util.extend( Object, {

	/**
	 * @cfg {Boolean} newWindow
	 * @inheritdoc Autolinker#newWindow
	 */

	/**
	 * @cfg {Number} truncate
	 * @inheritdoc Autolinker#truncate
	 */

	/**
	 * @cfg {String} className
	 * @inheritdoc Autolinker#className
	 */


	/**
	 * @constructor
	 * @param {Object} [cfg] The configuration options for the AnchorTagBuilder instance, specified in an Object (map).
	 */
	constructor : function( cfg ) {
		Autolinker.Util.assign( this, cfg );
	},


	/**
	 * Generates the actual anchor (&lt;a&gt;) tag to use in place of the
	 * matched text, via its `match` object.
	 *
	 * @param {Autolinker.match.Match} match The Match instance to generate an
	 *   anchor tag from.
	 * @return {Autolinker.HtmlTag} The HtmlTag instance for the anchor tag.
	 */
	build : function( match ) {
		var tag = new Autolinker.HtmlTag( {
			tagName   : 'a',
			attrs     : this.createAttrs( match.getType(), match.getAnchorHref() ),
			innerHtml : this.processAnchorText( match.getAnchorText() )
		} );

		return tag;
	},


	/**
	 * Creates the Object (map) of the HTML attributes for the anchor (&lt;a&gt;)
	 *   tag being generated.
	 *
	 * @protected
	 * @param {"url"/"email"/"phone"/"twitter"/"hashtag"} matchType The type of
	 *   match that an anchor tag is being generated for.
	 * @param {String} href The href for the anchor tag.
	 * @return {Object} A key/value Object (map) of the anchor tag's attributes.
	 */
	createAttrs : function( matchType, anchorHref ) {
		var attrs = {
			'href' : anchorHref  // we'll always have the `href` attribute
		};

		var cssClass = this.createCssClass( matchType );
		if( cssClass ) {
			attrs[ 'class' ] = cssClass;
		}
		if( this.newWindow ) {
			attrs[ 'target' ] = "_blank";
		}

		return attrs;
	},


	/**
	 * Creates the CSS class that will be used for a given anchor tag, based on
	 * the `matchType` and the {@link #className} config.
	 *
	 * @private
	 * @param {"url"/"email"/"phone"/"twitter"/"hashtag"} matchType The type of
	 *   match that an anchor tag is being generated for.
	 * @return {String} The CSS class string for the link. Example return:
	 *   "myLink myLink-url". If no {@link #className} was configured, returns
	 *   an empty string.
	 */
	createCssClass : function( matchType ) {
		var className = this.className;

		if( !className )
			return "";
		else
			return className + " " + className + "-" + matchType;  // ex: "myLink myLink-url", "myLink myLink-email", "myLink myLink-phone", "myLink myLink-twitter", or "myLink myLink-hashtag"
	},


	/**
	 * Processes the `anchorText` by truncating the text according to the
	 * {@link #truncate} config.
	 *
	 * @private
	 * @param {String} anchorText The anchor tag's text (i.e. what will be
	 *   displayed).
	 * @return {String} The processed `anchorText`.
	 */
	processAnchorText : function( anchorText ) {
		anchorText = this.doTruncate( anchorText );

		return anchorText;
	},


	/**
	 * Performs the truncation of the `anchorText`, if the `anchorText` is
	 * longer than the {@link #truncate} option. Truncates the text to 2
	 * characters fewer than the {@link #truncate} option, and adds ".." to the
	 * end.
	 *
	 * @private
	 * @param {String} text The anchor tag's text (i.e. what will be displayed).
	 * @return {String} The truncated anchor text.
	 */
	doTruncate : function( anchorText ) {
		return Autolinker.Util.ellipsis( anchorText, this.truncate || Number.POSITIVE_INFINITY );
	}

} );
/*global Autolinker */
/**
 * @private
 * @class Autolinker.htmlParser.HtmlParser
 * @extends Object
 *
 * An HTML parser implementation which simply walks an HTML string and returns an array of
 * {@link Autolinker.htmlParser.HtmlNode HtmlNodes} that represent the basic HTML structure of the input string.
 *
 * Autolinker uses this to only link URLs/emails/Twitter handles within text nodes, effectively ignoring / "walking
 * around" HTML tags.
 */
Autolinker.htmlParser.HtmlParser = Autolinker.Util.extend( Object, {

	/**
	 * @private
	 * @property {RegExp} htmlRegex
	 *
	 * The regular expression used to pull out HTML tags from a string. Handles namespaced HTML tags and
	 * attribute names, as specified by http://www.w3.org/TR/html-markup/syntax.html.
	 *
	 * Capturing groups:
	 *
	 * 1. The "!DOCTYPE" tag name, if a tag is a &lt;!DOCTYPE&gt; tag.
	 * 2. If it is an end tag, this group will have the '/'.
	 * 3. If it is a comment tag, this group will hold the comment text (i.e.
	 *    the text inside the `&lt;!--` and `--&gt;`.
	 * 4. The tag name for all tags (other than the &lt;!DOCTYPE&gt; tag)
	 */
	htmlRegex : (function() {
		var commentTagRegex = /!--([\s\S]+?)--/,
		    tagNameRegex = /[0-9a-zA-Z][0-9a-zA-Z:]*/,
		    attrNameRegex = /[^\s\0"'>\/=\x01-\x1F\x7F]+/,   // the unicode range accounts for excluding control chars, and the delete char
		    attrValueRegex = /(?:"[^"]*?"|'[^']*?'|[^'"=<>`\s]+)/, // double quoted, single quoted, or unquoted attribute values
		    nameEqualsValueRegex = attrNameRegex.source + '(?:\\s*=\\s*' + attrValueRegex.source + ')?';  // optional '=[value]'

		return new RegExp( [
			// for <!DOCTYPE> tag. Ex: <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">)
			'(?:',
				'<(!DOCTYPE)',  // *** Capturing Group 1 - If it's a doctype tag

					// Zero or more attributes following the tag name
					'(?:',
						'\\s+',  // one or more whitespace chars before an attribute

						// Either:
						// A. attr="value", or
						// B. "value" alone (To cover example doctype tag: <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">)
						'(?:', nameEqualsValueRegex, '|', attrValueRegex.source + ')',
					')*',
				'>',
			')',

			'|',

			// All other HTML tags (i.e. tags that are not <!DOCTYPE>)
			'(?:',
				'<(/)?',  // Beginning of a tag or comment. Either '<' for a start tag, or '</' for an end tag.
				          // *** Capturing Group 2: The slash or an empty string. Slash ('/') for end tag, empty string for start or self-closing tag.

					'(?:',
						commentTagRegex.source,  // *** Capturing Group 3 - A Comment Tag's Text

						'|',

						'(?:',

							// *** Capturing Group 4 - The tag name
							'(' + tagNameRegex.source + ')',

							// Zero or more attributes following the tag name
							'(?:',
								'\\s+',                // one or more whitespace chars before an attribute
								nameEqualsValueRegex,  // attr="value" (with optional ="value" part)
							')*',

							'\\s*/?',  // any trailing spaces and optional '/' before the closing '>'

						')',
					')',
				'>',
			')'
		].join( "" ), 'gi' );
	} )(),

	/**
	 * @private
	 * @property {RegExp} htmlCharacterEntitiesRegex
	 *
	 * The regular expression that matches common HTML character entities.
	 *
	 * Ignoring &amp; as it could be part of a query string -- handling it separately.
	 */
	htmlCharacterEntitiesRegex: /(&nbsp;|&#160;|&lt;|&#60;|&gt;|&#62;|&quot;|&#34;|&#39;)/gi,


	/**
	 * Parses an HTML string and returns a simple array of {@link Autolinker.htmlParser.HtmlNode HtmlNodes}
	 * to represent the HTML structure of the input string.
	 *
	 * @param {String} html The HTML to parse.
	 * @return {Autolinker.htmlParser.HtmlNode[]}
	 */
	parse : function( html ) {
		var htmlRegex = this.htmlRegex,
		    currentResult,
		    lastIndex = 0,
		    textAndEntityNodes,
		    nodes = [];  // will be the result of the method

		while( ( currentResult = htmlRegex.exec( html ) ) !== null ) {
			var tagText = currentResult[ 0 ],
			    commentText = currentResult[ 3 ], // if we've matched a comment
			    tagName = currentResult[ 1 ] || currentResult[ 4 ],  // The <!DOCTYPE> tag (ex: "!DOCTYPE"), or another tag (ex: "a" or "img")
			    isClosingTag = !!currentResult[ 2 ],
			    inBetweenTagsText = html.substring( lastIndex, currentResult.index );

			// Push TextNodes and EntityNodes for any text found between tags
			if( inBetweenTagsText ) {
				textAndEntityNodes = this.parseTextAndEntityNodes( inBetweenTagsText );
				nodes.push.apply( nodes, textAndEntityNodes );
			}

			// Push the CommentNode or ElementNode
			if( commentText ) {
				nodes.push( this.createCommentNode( tagText, commentText ) );
			} else {
				nodes.push( this.createElementNode( tagText, tagName, isClosingTag ) );
			}

			lastIndex = currentResult.index + tagText.length;
		}

		// Process any remaining text after the last HTML element. Will process all of the text if there were no HTML elements.
		if( lastIndex < html.length ) {
			var text = html.substring( lastIndex );

			// Push TextNodes and EntityNodes for any text found between tags
			if( text ) {
				textAndEntityNodes = this.parseTextAndEntityNodes( text );
				nodes.push.apply( nodes, textAndEntityNodes );
			}
		}

		return nodes;
	},


	/**
	 * Parses text and HTML entity nodes from a given string. The input string
	 * should not have any HTML tags (elements) within it.
	 *
	 * @private
	 * @param {String} text The text to parse.
	 * @return {Autolinker.htmlParser.HtmlNode[]} An array of HtmlNodes to
	 *   represent the {@link Autolinker.htmlParser.TextNode TextNodes} and
	 *   {@link Autolinker.htmlParser.EntityNode EntityNodes} found.
	 */
	parseTextAndEntityNodes : function( text ) {
		var nodes = [],
		    textAndEntityTokens = Autolinker.Util.splitAndCapture( text, this.htmlCharacterEntitiesRegex );  // split at HTML entities, but include the HTML entities in the results array

		// Every even numbered token is a TextNode, and every odd numbered token is an EntityNode
		// For example: an input `text` of "Test &quot;this&quot; today" would turn into the
		//   `textAndEntityTokens`: [ 'Test ', '&quot;', 'this', '&quot;', ' today' ]
		for( var i = 0, len = textAndEntityTokens.length; i < len; i += 2 ) {
			var textToken = textAndEntityTokens[ i ],
			    entityToken = textAndEntityTokens[ i + 1 ];

			if( textToken ) nodes.push( this.createTextNode( textToken ) );
			if( entityToken ) nodes.push( this.createEntityNode( entityToken ) );
		}
		return nodes;
	},


	/**
	 * Factory method to create an {@link Autolinker.htmlParser.CommentNode CommentNode}.
	 *
	 * @private
	 * @param {String} tagText The full text of the tag (comment) that was
	 *   matched, including its &lt;!-- and --&gt;.
	 * @param {String} comment The full text of the comment that was matched.
	 */
	createCommentNode : function( tagText, commentText ) {
		return new Autolinker.htmlParser.CommentNode( {
			text: tagText,
			comment: Autolinker.Util.trim( commentText )
		} );
	},


	/**
	 * Factory method to create an {@link Autolinker.htmlParser.ElementNode ElementNode}.
	 *
	 * @private
	 * @param {String} tagText The full text of the tag (element) that was
	 *   matched, including its attributes.
	 * @param {String} tagName The name of the tag. Ex: An &lt;img&gt; tag would
	 *   be passed to this method as "img".
	 * @param {Boolean} isClosingTag `true` if it's a closing tag, false
	 *   otherwise.
	 * @return {Autolinker.htmlParser.ElementNode}
	 */
	createElementNode : function( tagText, tagName, isClosingTag ) {
		return new Autolinker.htmlParser.ElementNode( {
			text    : tagText,
			tagName : tagName.toLowerCase(),
			closing : isClosingTag
		} );
	},


	/**
	 * Factory method to create a {@link Autolinker.htmlParser.EntityNode EntityNode}.
	 *
	 * @private
	 * @param {String} text The text that was matched for the HTML entity (such
	 *   as '&amp;nbsp;').
	 * @return {Autolinker.htmlParser.EntityNode}
	 */
	createEntityNode : function( text ) {
		return new Autolinker.htmlParser.EntityNode( { text: text } );
	},


	/**
	 * Factory method to create a {@link Autolinker.htmlParser.TextNode TextNode}.
	 *
	 * @private
	 * @param {String} text The text that was matched.
	 * @return {Autolinker.htmlParser.TextNode}
	 */
	createTextNode : function( text ) {
		return new Autolinker.htmlParser.TextNode( { text: text } );
	}

} );
/*global Autolinker */
/**
 * @abstract
 * @class Autolinker.htmlParser.HtmlNode
 * 
 * Represents an HTML node found in an input string. An HTML node is one of the following:
 * 
 * 1. An {@link Autolinker.htmlParser.ElementNode ElementNode}, which represents HTML tags.
 * 2. A {@link Autolinker.htmlParser.TextNode TextNode}, which represents text outside or within HTML tags.
 * 3. A {@link Autolinker.htmlParser.EntityNode EntityNode}, which represents one of the known HTML
 *    entities that Autolinker looks for. This includes common ones such as &amp;quot; and &amp;nbsp;
 */
Autolinker.htmlParser.HtmlNode = Autolinker.Util.extend( Object, {
	
	/**
	 * @cfg {String} text (required)
	 * 
	 * The original text that was matched for the HtmlNode. 
	 * 
	 * - In the case of an {@link Autolinker.htmlParser.ElementNode ElementNode}, this will be the tag's
	 *   text.
	 * - In the case of a {@link Autolinker.htmlParser.TextNode TextNode}, this will be the text itself.
	 * - In the case of a {@link Autolinker.htmlParser.EntityNode EntityNode}, this will be the text of
	 *   the HTML entity.
	 */
	text : "",
	
	
	/**
	 * @constructor
	 * @param {Object} cfg The configuration properties for the Match instance, specified in an Object (map).
	 */
	constructor : function( cfg ) {
		Autolinker.Util.assign( this, cfg );
	},

	
	/**
	 * Returns a string name for the type of node that this class represents.
	 * 
	 * @abstract
	 * @return {String}
	 */
	getType : Autolinker.Util.abstractMethod,
	
	
	/**
	 * Retrieves the {@link #text} for the HtmlNode.
	 * 
	 * @return {String}
	 */
	getText : function() {
		return this.text;
	}

} );
/*global Autolinker */
/**
 * @class Autolinker.htmlParser.CommentNode
 * @extends Autolinker.htmlParser.HtmlNode
 *
 * Represents an HTML comment node that has been parsed by the
 * {@link Autolinker.htmlParser.HtmlParser}.
 *
 * See this class's superclass ({@link Autolinker.htmlParser.HtmlNode}) for more
 * details.
 */
Autolinker.htmlParser.CommentNode = Autolinker.Util.extend( Autolinker.htmlParser.HtmlNode, {

	/**
	 * @cfg {String} comment (required)
	 *
	 * The text inside the comment tag. This text is stripped of any leading or
	 * trailing whitespace.
	 */
	comment : '',


	/**
	 * Returns a string name for the type of node that this class represents.
	 *
	 * @return {String}
	 */
	getType : function() {
		return 'comment';
	},


	/**
	 * Returns the comment inside the comment tag.
	 *
	 * @return {String}
	 */
	getComment : function() {
		return this.comment;
	}

} );
/*global Autolinker */
/**
 * @class Autolinker.htmlParser.ElementNode
 * @extends Autolinker.htmlParser.HtmlNode
 * 
 * Represents an HTML element node that has been parsed by the {@link Autolinker.htmlParser.HtmlParser}.
 * 
 * See this class's superclass ({@link Autolinker.htmlParser.HtmlNode}) for more details.
 */
Autolinker.htmlParser.ElementNode = Autolinker.Util.extend( Autolinker.htmlParser.HtmlNode, {
	
	/**
	 * @cfg {String} tagName (required)
	 * 
	 * The name of the tag that was matched.
	 */
	tagName : '',
	
	/**
	 * @cfg {Boolean} closing (required)
	 * 
	 * `true` if the element (tag) is a closing tag, `false` if its an opening tag.
	 */
	closing : false,

	
	/**
	 * Returns a string name for the type of node that this class represents.
	 * 
	 * @return {String}
	 */
	getType : function() {
		return 'element';
	},
	

	/**
	 * Returns the HTML element's (tag's) name. Ex: for an &lt;img&gt; tag, returns "img".
	 * 
	 * @return {String}
	 */
	getTagName : function() {
		return this.tagName;
	},
	
	
	/**
	 * Determines if the HTML element (tag) is a closing tag. Ex: &lt;div&gt; returns
	 * `false`, while &lt;/div&gt; returns `true`.
	 * 
	 * @return {Boolean}
	 */
	isClosing : function() {
		return this.closing;
	}
	
} );
/*global Autolinker */
/**
 * @class Autolinker.htmlParser.EntityNode
 * @extends Autolinker.htmlParser.HtmlNode
 * 
 * Represents a known HTML entity node that has been parsed by the {@link Autolinker.htmlParser.HtmlParser}.
 * Ex: '&amp;nbsp;', or '&amp#160;' (which will be retrievable from the {@link #getText} method.
 * 
 * Note that this class will only be returned from the HtmlParser for the set of checked HTML entity nodes 
 * defined by the {@link Autolinker.htmlParser.HtmlParser#htmlCharacterEntitiesRegex}.
 * 
 * See this class's superclass ({@link Autolinker.htmlParser.HtmlNode}) for more details.
 */
Autolinker.htmlParser.EntityNode = Autolinker.Util.extend( Autolinker.htmlParser.HtmlNode, {
	
	/**
	 * Returns a string name for the type of node that this class represents.
	 * 
	 * @return {String}
	 */
	getType : function() {
		return 'entity';
	}
	
} );
/*global Autolinker */
/**
 * @class Autolinker.htmlParser.TextNode
 * @extends Autolinker.htmlParser.HtmlNode
 * 
 * Represents a text node that has been parsed by the {@link Autolinker.htmlParser.HtmlParser}.
 * 
 * See this class's superclass ({@link Autolinker.htmlParser.HtmlNode}) for more details.
 */
Autolinker.htmlParser.TextNode = Autolinker.Util.extend( Autolinker.htmlParser.HtmlNode, {
	
	/**
	 * Returns a string name for the type of node that this class represents.
	 * 
	 * @return {String}
	 */
	getType : function() {
		return 'text';
	}
	
} );
/*global Autolinker */
/**
 * @private
 * @class Autolinker.matchParser.MatchParser
 * @extends Object
 *
 * Used by Autolinker to parse potential matches, given an input string of text.
 *
 * The MatchParser is fed a non-HTML string in order to search for matches.
 * Autolinker first uses the {@link Autolinker.htmlParser.HtmlParser} to "walk
 * around" HTML tags, and then the text around the HTML tags is passed into the
 * MatchParser in order to find the actual matches.
 */
Autolinker.matchParser.MatchParser = Autolinker.Util.extend( Object, {

	/**
	 * @cfg {Boolean} urls
	 * @inheritdoc Autolinker#urls
	 */
	urls : true,

	/**
	 * @cfg {Boolean} email
	 * @inheritdoc Autolinker#email
	 */
	email : true,

	/**
	 * @cfg {Boolean} twitter
	 * @inheritdoc Autolinker#twitter
	 */
	twitter : true,

	/**
	 * @cfg {Boolean} phone
	 * @inheritdoc Autolinker#phone
	 */
	phone: true,

	/**
	 * @cfg {Boolean/String} hashtag
	 * @inheritdoc Autolinker#hashtag
	 */
	hashtag : false,

	/**
	 * @cfg {Boolean} stripPrefix
	 * @inheritdoc Autolinker#stripPrefix
	 */
	stripPrefix : true,


	/**
	 * @private
	 * @property {RegExp} matcherRegex
	 *
	 * The regular expression that matches URLs, email addresses, phone #s,
	 * Twitter handles, and Hashtags.
	 *
	 * This regular expression has the following capturing groups:
	 *
	 * 1.  Group that is used to determine if there is a Twitter handle match
	 *     (i.e. \@someTwitterUser). Simply check for its existence to determine
	 *     if there is a Twitter handle match. The next couple of capturing
	 *     groups give information about the Twitter handle match.
	 * 2.  The whitespace character before the \@sign in a Twitter handle. This
	 *     is needed because there are no lookbehinds in JS regular expressions,
	 *     and can be used to reconstruct the original string in a replace().
	 * 3.  The Twitter handle itself in a Twitter match. If the match is
	 *     '@someTwitterUser', the handle is 'someTwitterUser'.
	 * 4.  Group that matches an email address. Used to determine if the match
	 *     is an email address, as well as holding the full address. Ex:
	 *     'me@my.com'
	 * 5.  Group that matches a URL in the input text. Ex: 'http://google.com',
	 *     'www.google.com', or just 'google.com'. This also includes a path,
	 *     url parameters, or hash anchors. Ex: google.com/path/to/file?q1=1&q2=2#myAnchor
	 * 6.  Group that matches a protocol URL (i.e. 'http://google.com'). This is
	 *     used to match protocol URLs with just a single word, like 'http://localhost',
	 *     where we won't double check that the domain name has at least one '.'
	 *     in it.
	 * 7.  A protocol-relative ('//') match for the case of a 'www.' prefixed
	 *     URL. Will be an empty string if it is not a protocol-relative match.
	 *     We need to know the character before the '//' in order to determine
	 *     if it is a valid match or the // was in a string we don't want to
	 *     auto-link.
	 * 8.  A protocol-relative ('//') match for the case of a known TLD prefixed
	 *     URL. Will be an empty string if it is not a protocol-relative match.
	 *     See #6 for more info.
	 * 9.  Group that is used to determine if there is a phone number match. The
	 *     next 3 groups give segments of the phone number.
	 * 10. Group that is used to determine if there is a Hashtag match
	 *     (i.e. \#someHashtag). Simply check for its existence to determine if
	 *     there is a Hashtag match. The next couple of capturing groups give
	 *     information about the Hashtag match.
	 * 11. The whitespace character before the #sign in a Hashtag handle. This
	 *     is needed because there are no look-behinds in JS regular
	 *     expressions, and can be used to reconstruct the original string in a
	 *     replace().
	 * 12. The Hashtag itself in a Hashtag match. If the match is
	 *     '#someHashtag', the hashtag is 'someHashtag'.
	 */
	matcherRegex : (function() {
		var twitterRegex = /(^|[^\w])@(\w{1,15})/,              // For matching a twitter handle. Ex: @gregory_jacobs

		    hashtagRegex = /(^|[^\w])#(\w{1,15})/,              // For matching a Hashtag. Ex: #games

		    emailRegex = /(?:[\-;:&=\+\$,\w\.]+@)/,             // something@ for email addresses (a.k.a. local-part)
		    phoneRegex = /(?:\+?\d{1,3}[-\s.])?\(?\d{3}\)?[-\s.]?\d{3}[-\s.]\d{4}/,  // ex: (123) 456-7890, 123 456 7890, 123-456-7890, etc.
		    protocolRegex = /(?:[A-Za-z][-.+A-Za-z0-9]+:(?![A-Za-z][-.+A-Za-z0-9]+:\/\/)(?!\d+\/?)(?:\/\/)?)/,  // match protocol, allow in format "http://" or "mailto:". However, do not match the first part of something like 'link:http://www.google.com' (i.e. don't match "link:"). Also, make sure we don't interpret 'google.com:8000' as if 'google.com' was a protocol here (i.e. ignore a trailing port number in this regex)
		    wwwRegex = /(?:www\.)/,                             // starting with 'www.'
		    domainNameRegex = /[A-Za-z0-9\.\-]*[A-Za-z0-9\-]/,  // anything looking at all like a domain, non-unicode domains, not ending in a period
		    tldRegex = /\.(?:international|construction|contractors|enterprises|photography|productions|foundation|immobilien|industries|management|properties|technology|christmas|community|directory|education|equipment|institute|marketing|solutions|vacations|bargains|boutique|builders|catering|cleaning|clothing|computer|democrat|diamonds|graphics|holdings|lighting|partners|plumbing|supplies|training|ventures|academy|careers|company|cruises|domains|exposed|flights|florist|gallery|guitars|holiday|kitchen|neustar|okinawa|recipes|rentals|reviews|shiksha|singles|support|systems|agency|berlin|camera|center|coffee|condos|dating|estate|events|expert|futbol|kaufen|luxury|maison|monash|museum|nagoya|photos|repair|report|social|supply|tattoo|tienda|travel|viajes|villas|vision|voting|voyage|actor|build|cards|cheap|codes|dance|email|glass|house|mango|ninja|parts|photo|shoes|solar|today|tokyo|tools|watch|works|aero|arpa|asia|best|bike|blue|buzz|camp|club|cool|coop|farm|fish|gift|guru|info|jobs|kiwi|kred|land|limo|link|menu|mobi|moda|name|pics|pink|post|qpon|rich|ruhr|sexy|tips|vote|voto|wang|wien|wiki|zone|bar|bid|biz|cab|cat|ceo|com|edu|gov|int|kim|mil|net|onl|org|pro|pub|red|tel|uno|wed|xxx|xyz|ac|ad|ae|af|ag|ai|al|am|an|ao|aq|ar|as|at|au|aw|ax|az|ba|bb|bd|be|bf|bg|bh|bi|bj|bm|bn|bo|br|bs|bt|bv|bw|by|bz|ca|cc|cd|cf|cg|ch|ci|ck|cl|cm|cn|co|cr|cu|cv|cw|cx|cy|cz|de|dj|dk|dm|do|dz|ec|ee|eg|er|es|et|eu|fi|fj|fk|fm|fo|fr|ga|gb|gd|ge|gf|gg|gh|gi|gl|gm|gn|gp|gq|gr|gs|gt|gu|gw|gy|hk|hm|hn|hr|ht|hu|id|ie|il|im|in|io|iq|ir|is|it|je|jm|jo|jp|ke|kg|kh|ki|km|kn|kp|kr|kw|ky|kz|la|lb|lc|li|lk|lr|ls|lt|lu|lv|ly|ma|mc|md|me|mg|mh|mk|ml|mm|mn|mo|mp|mq|mr|ms|mt|mu|mv|mw|mx|my|mz|na|nc|ne|nf|ng|ni|nl|no|np|nr|nu|nz|om|pa|pe|pf|pg|ph|pk|pl|pm|pn|pr|ps|pt|pw|py|qa|re|ro|rs|ru|rw|sa|sb|sc|sd|se|sg|sh|si|sj|sk|sl|sm|sn|so|sr|st|su|sv|sx|sy|sz|tc|td|tf|tg|th|tj|tk|tl|tm|tn|to|tp|tr|tt|tv|tw|tz|ua|ug|uk|us|uy|uz|va|vc|ve|vg|vi|vn|vu|wf|ws|ye|yt|za|zm|zw)\b/,   // match our known top level domains (TLDs)

		    // Allow optional path, query string, and hash anchor, not ending in the following characters: "?!:,.;"
		    // http://blog.codinghorror.com/the-problem-with-urls/
		    urlSuffixRegex = /[\-A-Za-z0-9+&@#\/%=~_()|'$*\[\]?!:,.;]*[\-A-Za-z0-9+&@#\/%=~_()|'$*\[\]]/;

		return new RegExp( [
			'(',  // *** Capturing group $1, which can be used to check for a twitter handle match. Use group $3 for the actual twitter handle though. $2 may be used to reconstruct the original string in a replace()
				// *** Capturing group $2, which matches the whitespace character before the '@' sign (needed because of no lookbehinds), and
				// *** Capturing group $3, which matches the actual twitter handle
				twitterRegex.source,
			')',

			'|',

			'(',  // *** Capturing group $4, which is used to determine an email match
				emailRegex.source,
				domainNameRegex.source,
				tldRegex.source,
			')',

			'|',

			'(',  // *** Capturing group $5, which is used to match a URL
				'(?:', // parens to cover match for protocol (optional), and domain
					'(',  // *** Capturing group $6, for a protocol-prefixed url (ex: http://google.com)
						protocolRegex.source,
						domainNameRegex.source,
					')',

					'|',

					'(?:',  // non-capturing paren for a 'www.' prefixed url (ex: www.google.com)
						'(.?//)?',  // *** Capturing group $7 for an optional protocol-relative URL. Must be at the beginning of the string or start with a non-word character
						wwwRegex.source,
						domainNameRegex.source,
					')',

					'|',

					'(?:',  // non-capturing paren for known a TLD url (ex: google.com)
						'(.?//)?',  // *** Capturing group $8 for an optional protocol-relative URL. Must be at the beginning of the string or start with a non-word character
						domainNameRegex.source,
						tldRegex.source,
					')',
				')',

				'(?:' + urlSuffixRegex.source + ')?',  // match for path, query string, and/or hash anchor - optional
			')',

			'|',

			// this setup does not scale well for open extension :( Need to rethink design of autolinker...
			// ***  Capturing group $9, which matches a (USA for now) phone number
			'(',
				phoneRegex.source,
			')',

			'|',

			'(',  // *** Capturing group $10, which can be used to check for a Hashtag match. Use group $12 for the actual Hashtag though. $11 may be used to reconstruct the original string in a replace()
				// *** Capturing group $11, which matches the whitespace character before the '#' sign (needed because of no lookbehinds), and
				// *** Capturing group $12, which matches the actual Hashtag
				hashtagRegex.source,
			')'
		].join( "" ), 'gi' );
	} )(),

	/**
	 * @private
	 * @property {RegExp} charBeforeProtocolRelMatchRegex
	 *
	 * The regular expression used to retrieve the character before a
	 * protocol-relative URL match.
	 *
	 * This is used in conjunction with the {@link #matcherRegex}, which needs
	 * to grab the character before a protocol-relative '//' due to the lack of
	 * a negative look-behind in JavaScript regular expressions. The character
	 * before the match is stripped from the URL.
	 */
	charBeforeProtocolRelMatchRegex : /^(.)?\/\//,

	/**
	 * @private
	 * @property {Autolinker.MatchValidator} matchValidator
	 *
	 * The MatchValidator object, used to filter out any false positives from
	 * the {@link #matcherRegex}. See {@link Autolinker.MatchValidator} for details.
	 */


	/**
	 * @constructor
	 * @param {Object} [cfg] The configuration options for the AnchorTagBuilder
	 * instance, specified in an Object (map).
	 */
	constructor : function( cfg ) {
		Autolinker.Util.assign( this, cfg );

		this.matchValidator = new Autolinker.MatchValidator();
	},


	/**
	 * Parses the input `text` to search for matches, and calls the `replaceFn`
	 * to allow replacements of the matches. Returns the `text` with matches
	 * replaced.
	 *
	 * @param {String} text The text to search and repace matches in.
	 * @param {Function} replaceFn The iterator function to handle the
	 *   replacements. The function takes a single argument, a {@link Autolinker.match.Match}
	 *   object, and should return the text that should make the replacement.
	 * @param {Object} [contextObj=window] The context object ("scope") to run
	 *   the `replaceFn` in.
	 * @return {String}
	 */
	replace : function( text, replaceFn, contextObj ) {
		var me = this;  // for closure

		return text.replace( this.matcherRegex, function( matchStr, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12 ) {
			var matchDescObj = me.processCandidateMatch( matchStr, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12 );  // "match description" object

			// Return out with no changes for match types that are disabled (url,
			// email, phone, etc.), or for matches that are invalid (false
			// positives from the matcherRegex, which can't use look-behinds
			// since they are unavailable in JS).
			if( !matchDescObj ) {
				return matchStr;

			} else {
				// Generate replacement text for the match from the `replaceFn`
				var replaceStr = replaceFn.call( contextObj, matchDescObj.match );
				return matchDescObj.prefixStr + replaceStr + matchDescObj.suffixStr;
			}
		} );
	},


	/**
	 * Processes a candidate match from the {@link #matcherRegex}.
	 *
	 * Not all matches found by the regex are actual URL/Email/Phone/Twitter/Hashtag
	 * matches, as determined by the {@link #matchValidator}. In this case, the
	 * method returns `null`. Otherwise, a valid Object with `prefixStr`,
	 * `match`, and `suffixStr` is returned.
	 *
	 * @private
	 * @param {String} matchStr The full match that was found by the
	 *   {@link #matcherRegex}.
	 * @param {String} twitterMatch The matched text of a Twitter handle, if the
	 *   match is a Twitter match.
	 * @param {String} twitterHandlePrefixWhitespaceChar The whitespace char
	 *   before the @ sign in a Twitter handle match. This is needed because of
	 *   no lookbehinds in JS regexes, and is need to re-include the character
	 *   for the anchor tag replacement.
	 * @param {String} twitterHandle The actual Twitter user (i.e the word after
	 *   the @ sign in a Twitter match).
	 * @param {String} emailAddressMatch The matched email address for an email
	 *   address match.
	 * @param {String} urlMatch The matched URL string for a URL match.
	 * @param {String} protocolUrlMatch The match URL string for a protocol
	 *   match. Ex: 'http://yahoo.com'. This is used to match something like
	 *   'http://localhost', where we won't double check that the domain name
	 *   has at least one '.' in it.
	 * @param {String} wwwProtocolRelativeMatch The '//' for a protocol-relative
	 *   match from a 'www' url, with the character that comes before the '//'.
	 * @param {String} tldProtocolRelativeMatch The '//' for a protocol-relative
	 *   match from a TLD (top level domain) match, with the character that
	 *   comes before the '//'.
	 * @param {String} phoneMatch The matched text of a phone number
	 * @param {String} hashtagMatch The matched text of a Twitter
	 *   Hashtag, if the match is a Hashtag match.
	 * @param {String} hashtagPrefixWhitespaceChar The whitespace char
	 *   before the # sign in a Hashtag match. This is needed because of no
	 *   lookbehinds in JS regexes, and is need to re-include the character for
	 *   the anchor tag replacement.
	 * @param {String} hashtag The actual Hashtag (i.e the word
	 *   after the # sign in a Hashtag match).
	 *
	 * @return {Object} A "match description object". This will be `null` if the
	 *   match was invalid, or if a match type is disabled. Otherwise, this will
	 *   be an Object (map) with the following properties:
	 * @return {String} return.prefixStr The char(s) that should be prepended to
	 *   the replacement string. These are char(s) that were needed to be
	 *   included from the regex match that were ignored by processing code, and
	 *   should be re-inserted into the replacement stream.
	 * @return {String} return.suffixStr The char(s) that should be appended to
	 *   the replacement string. These are char(s) that were needed to be
	 *   included from the regex match that were ignored by processing code, and
	 *   should be re-inserted into the replacement stream.
	 * @return {Autolinker.match.Match} return.match The Match object that
	 *   represents the match that was found.
	 */
	processCandidateMatch : function(
		matchStr, twitterMatch, twitterHandlePrefixWhitespaceChar, twitterHandle,
		emailAddressMatch, urlMatch, protocolUrlMatch, wwwProtocolRelativeMatch,
		tldProtocolRelativeMatch, phoneMatch, hashtagMatch,
		hashtagPrefixWhitespaceChar, hashtag
	) {
		// Note: The `matchStr` variable wil be fixed up to remove characters that are no longer needed (which will
		// be added to `prefixStr` and `suffixStr`).

		var protocolRelativeMatch = wwwProtocolRelativeMatch || tldProtocolRelativeMatch,
		    match,  // Will be an Autolinker.match.Match object

		    prefixStr = "",  // A string to use to prefix the anchor tag that is created. This is needed for the Twitter and Hashtag matches.
		    suffixStr = "";  // A string to suffix the anchor tag that is created. This is used if there is a trailing parenthesis that should not be auto-linked.

		// Return out with `null` for match types that are disabled (url, email,
		// twitter, hashtag), or for matches that are invalid (false positives
		// from the matcherRegex, which can't use look-behinds since they are
		// unavailable in JS).
		if(
			( urlMatch && !this.urls ) ||
			( emailAddressMatch && !this.email ) ||
			( phoneMatch && !this.phone ) ||
			( twitterMatch && !this.twitter ) ||
			( hashtagMatch && !this.hashtag ) ||
			!this.matchValidator.isValidMatch( urlMatch, protocolUrlMatch, protocolRelativeMatch )
		) {
			return null;
		}

		// Handle a closing parenthesis at the end of the match, and exclude it
		// if there is not a matching open parenthesis
		// in the match itself.
		if( this.matchHasUnbalancedClosingParen( matchStr ) ) {
			matchStr = matchStr.substr( 0, matchStr.length - 1 );  // remove the trailing ")"
			suffixStr = ")";  // this will be added after the generated <a> tag
		}

		if( emailAddressMatch ) {
			match = new Autolinker.match.Email( { matchedText: matchStr, email: emailAddressMatch } );

		} else if( twitterMatch ) {
			// fix up the `matchStr` if there was a preceding whitespace char,
			// which was needed to determine the match itself (since there are
			// no look-behinds in JS regexes)
			if( twitterHandlePrefixWhitespaceChar ) {
				prefixStr = twitterHandlePrefixWhitespaceChar;
				matchStr = matchStr.slice( 1 );  // remove the prefixed whitespace char from the match
			}
			match = new Autolinker.match.Twitter( { matchedText: matchStr, twitterHandle: twitterHandle } );

		} else if( phoneMatch ) {
			// remove non-numeric values from phone number string
			var cleanNumber = matchStr.replace( /\D/g, '' );
 			match = new Autolinker.match.Phone( { matchedText: matchStr, number: cleanNumber } );

		} else if( hashtagMatch ) {
			// fix up the `matchStr` if there was a preceding whitespace char,
			// which was needed to determine the match itself (since there are
			// no look-behinds in JS regexes)
			if( hashtagPrefixWhitespaceChar ) {
				prefixStr = hashtagPrefixWhitespaceChar;
				matchStr = matchStr.slice( 1 );  // remove the prefixed whitespace char from the match
			}
			match = new Autolinker.match.Hashtag( { matchedText: matchStr, serviceName: this.hashtag, hashtag: hashtag } );

		} else {  // url match
			// If it's a protocol-relative '//' match, remove the character
			// before the '//' (which the matcherRegex needed to match due to
			// the lack of a negative look-behind in JavaScript regular
			// expressions)
			if( protocolRelativeMatch ) {
				var charBeforeMatch = protocolRelativeMatch.match( this.charBeforeProtocolRelMatchRegex )[ 1 ] || "";

				if( charBeforeMatch ) {  // fix up the `matchStr` if there was a preceding char before a protocol-relative match, which was needed to determine the match itself (since there are no look-behinds in JS regexes)
					prefixStr = charBeforeMatch;
					matchStr = matchStr.slice( 1 );  // remove the prefixed char from the match
				}
			}

			match = new Autolinker.match.Url( {
				matchedText : matchStr,
				url : matchStr,
				protocolUrlMatch : !!protocolUrlMatch,
				protocolRelativeMatch : !!protocolRelativeMatch,
				stripPrefix : this.stripPrefix
			} );
		}

		return {
			prefixStr : prefixStr,
			suffixStr : suffixStr,
			match     : match
		};
	},


	/**
	 * Determines if a match found has an unmatched closing parenthesis. If so,
	 * this parenthesis will be removed from the match itself, and appended
	 * after the generated anchor tag in {@link #processCandidateMatch}.
	 *
	 * A match may have an extra closing parenthesis at the end of the match
	 * because the regular expression must include parenthesis for URLs such as
	 * "wikipedia.com/something_(disambiguation)", which should be auto-linked.
	 *
	 * However, an extra parenthesis *will* be included when the URL itself is
	 * wrapped in parenthesis, such as in the case of "(wikipedia.com/something_(disambiguation))".
	 * In this case, the last closing parenthesis should *not* be part of the
	 * URL itself, and this method will return `true`.
	 *
	 * @private
	 * @param {String} matchStr The full match string from the {@link #matcherRegex}.
	 * @return {Boolean} `true` if there is an unbalanced closing parenthesis at
	 *   the end of the `matchStr`, `false` otherwise.
	 */
	matchHasUnbalancedClosingParen : function( matchStr ) {
		var lastChar = matchStr.charAt( matchStr.length - 1 );

		if( lastChar === ')' ) {
			var openParensMatch = matchStr.match( /\(/g ),
			    closeParensMatch = matchStr.match( /\)/g ),
			    numOpenParens = ( openParensMatch && openParensMatch.length ) || 0,
			    numCloseParens = ( closeParensMatch && closeParensMatch.length ) || 0;

			if( numOpenParens < numCloseParens ) {
				return true;
			}
		}

		return false;
	}

} );
/*global Autolinker */
/*jshint scripturl:true */
/**
 * @private
 * @class Autolinker.MatchValidator
 * @extends Object
 *
 * Used by Autolinker to filter out false positives from the
 * {@link Autolinker.matchParser.MatchParser#matcherRegex}.
 *
 * Due to the limitations of regular expressions (including the missing feature
 * of look-behinds in JS regular expressions), we cannot always determine the
 * validity of a given match. This class applies a bit of additional logic to
 * filter out any false positives that have been matched by the
 * {@link Autolinker.matchParser.MatchParser#matcherRegex}.
 */
Autolinker.MatchValidator = Autolinker.Util.extend( Object, {

	/**
	 * @private
	 * @property {RegExp} invalidProtocolRelMatchRegex
	 *
	 * The regular expression used to check a potential protocol-relative URL
	 * match, coming from the {@link Autolinker.matchParser.MatchParser#matcherRegex}.
	 * A protocol-relative URL is, for example, "//yahoo.com"
	 *
	 * This regular expression checks to see if there is a word character before
	 * the '//' match in order to determine if we should actually autolink a
	 * protocol-relative URL. This is needed because there is no negative
	 * look-behind in JavaScript regular expressions.
	 *
	 * For instance, we want to autolink something like "Go to: //google.com",
	 * but we don't want to autolink something like "abc//google.com"
	 */
	invalidProtocolRelMatchRegex : /^[\w]\/\//,

	/**
	 * Regex to test for a full protocol, with the two trailing slashes. Ex: 'http://'
	 *
	 * @private
	 * @property {RegExp} hasFullProtocolRegex
	 */
	hasFullProtocolRegex : /^[A-Za-z][-.+A-Za-z0-9]+:\/\//,

	/**
	 * Regex to find the URI scheme, such as 'mailto:'.
	 *
	 * This is used to filter out 'javascript:' and 'vbscript:' schemes.
	 *
	 * @private
	 * @property {RegExp} uriSchemeRegex
	 */
	uriSchemeRegex : /^[A-Za-z][-.+A-Za-z0-9]+:/,

	/**
	 * Regex to determine if at least one word char exists after the protocol (i.e. after the ':')
	 *
	 * @private
	 * @property {RegExp} hasWordCharAfterProtocolRegex
	 */
	hasWordCharAfterProtocolRegex : /:[^\s]*?[A-Za-z]/,


	/**
	 * Determines if a given match found by the {@link Autolinker.matchParser.MatchParser}
	 * is valid. Will return `false` for:
	 *
	 * 1) URL matches which do not have at least have one period ('.') in the
	 *    domain name (effectively skipping over matches like "abc:def").
	 *    However, URL matches with a protocol will be allowed (ex: 'http://localhost')
	 * 2) URL matches which do not have at least one word character in the
	 *    domain name (effectively skipping over matches like "git:1.0").
	 * 3) A protocol-relative url match (a URL beginning with '//') whose
	 *    previous character is a word character (effectively skipping over
	 *    strings like "abc//google.com")
	 *
	 * Otherwise, returns `true`.
	 *
	 * @param {String} urlMatch The matched URL, if there was one. Will be an
	 *   empty string if the match is not a URL match.
	 * @param {String} protocolUrlMatch The match URL string for a protocol
	 *   match. Ex: 'http://yahoo.com'. This is used to match something like
	 *   'http://localhost', where we won't double check that the domain name
	 *   has at least one '.' in it.
	 * @param {String} protocolRelativeMatch The protocol-relative string for a
	 *   URL match (i.e. '//'), possibly with a preceding character (ex, a
	 *   space, such as: ' //', or a letter, such as: 'a//'). The match is
	 *   invalid if there is a word character preceding the '//'.
	 * @return {Boolean} `true` if the match given is valid and should be
	 *   processed, or `false` if the match is invalid and/or should just not be
	 *   processed.
	 */
	isValidMatch : function( urlMatch, protocolUrlMatch, protocolRelativeMatch ) {
		if(
			( protocolUrlMatch && !this.isValidUriScheme( protocolUrlMatch ) ) ||
			this.urlMatchDoesNotHaveProtocolOrDot( urlMatch, protocolUrlMatch ) ||       // At least one period ('.') must exist in the URL match for us to consider it an actual URL, *unless* it was a full protocol match (like 'http://localhost')
			this.urlMatchDoesNotHaveAtLeastOneWordChar( urlMatch, protocolUrlMatch ) ||  // At least one letter character must exist in the domain name after a protocol match. Ex: skip over something like "git:1.0"
			this.isInvalidProtocolRelativeMatch( protocolRelativeMatch )                 // A protocol-relative match which has a word character in front of it (so we can skip something like "abc//google.com")
		) {
			return false;
		}

		return true;
	},


	/**
	 * Determines if the URI scheme is a valid scheme to be autolinked. Returns
	 * `false` if the scheme is 'javascript:' or 'vbscript:'
	 *
	 * @private
	 * @param {String} uriSchemeMatch The match URL string for a full URI scheme
	 *   match. Ex: 'http://yahoo.com' or 'mailto:a@a.com'.
	 * @return {Boolean} `true` if the scheme is a valid one, `false` otherwise.
	 */
	isValidUriScheme : function( uriSchemeMatch ) {
		var uriScheme = uriSchemeMatch.match( this.uriSchemeRegex )[ 0 ].toLowerCase();

		return ( uriScheme !== 'javascript:' && uriScheme !== 'vbscript:' );
	},


	/**
	 * Determines if a URL match does not have either:
	 *
	 * a) a full protocol (i.e. 'http://'), or
	 * b) at least one dot ('.') in the domain name (for a non-full-protocol
	 *    match).
	 *
	 * Either situation is considered an invalid URL (ex: 'git:d' does not have
	 * either the '://' part, or at least one dot in the domain name. If the
	 * match was 'git:abc.com', we would consider this valid.)
	 *
	 * @private
	 * @param {String} urlMatch The matched URL, if there was one. Will be an
	 *   empty string if the match is not a URL match.
	 * @param {String} protocolUrlMatch The match URL string for a protocol
	 *   match. Ex: 'http://yahoo.com'. This is used to match something like
	 *   'http://localhost', where we won't double check that the domain name
	 *   has at least one '.' in it.
	 * @return {Boolean} `true` if the URL match does not have a full protocol,
	 *   or at least one dot ('.') in a non-full-protocol match.
	 */
	urlMatchDoesNotHaveProtocolOrDot : function( urlMatch, protocolUrlMatch ) {
		return ( !!urlMatch && ( !protocolUrlMatch || !this.hasFullProtocolRegex.test( protocolUrlMatch ) ) && urlMatch.indexOf( '.' ) === -1 );
	},


	/**
	 * Determines if a URL match does not have at least one word character after
	 * the protocol (i.e. in the domain name).
	 *
	 * At least one letter character must exist in the domain name after a
	 * protocol match. Ex: skip over something like "git:1.0"
	 *
	 * @private
	 * @param {String} urlMatch The matched URL, if there was one. Will be an
	 *   empty string if the match is not a URL match.
	 * @param {String} protocolUrlMatch The match URL string for a protocol
	 *   match. Ex: 'http://yahoo.com'. This is used to know whether or not we
	 *   have a protocol in the URL string, in order to check for a word
	 *   character after the protocol separator (':').
	 * @return {Boolean} `true` if the URL match does not have at least one word
	 *   character in it after the protocol, `false` otherwise.
	 */
	urlMatchDoesNotHaveAtLeastOneWordChar : function( urlMatch, protocolUrlMatch ) {
		if( urlMatch && protocolUrlMatch ) {
			return !this.hasWordCharAfterProtocolRegex.test( urlMatch );
		} else {
			return false;
		}
	},


	/**
	 * Determines if a protocol-relative match is an invalid one. This method
	 * returns `true` if there is a `protocolRelativeMatch`, and that match
	 * contains a word character before the '//' (i.e. it must contain
	 * whitespace or nothing before the '//' in order to be considered valid).
	 *
	 * @private
	 * @param {String} protocolRelativeMatch The protocol-relative string for a
	 *   URL match (i.e. '//'), possibly with a preceding character (ex, a
	 *   space, such as: ' //', or a letter, such as: 'a//'). The match is
	 *   invalid if there is a word character preceding the '//'.
	 * @return {Boolean} `true` if it is an invalid protocol-relative match,
	 *   `false` otherwise.
	 */
	isInvalidProtocolRelativeMatch : function( protocolRelativeMatch ) {
		return ( !!protocolRelativeMatch && this.invalidProtocolRelMatchRegex.test( protocolRelativeMatch ) );
	}

} );
/*global Autolinker */
/**
 * @abstract
 * @class Autolinker.match.Match
 * 
 * Represents a match found in an input string which should be Autolinked. A Match object is what is provided in a 
 * {@link Autolinker#replaceFn replaceFn}, and may be used to query for details about the match.
 * 
 * For example:
 * 
 *     var input = "...";  // string with URLs, Email Addresses, and Twitter Handles
 *     
 *     var linkedText = Autolinker.link( input, {
 *         replaceFn : function( autolinker, match ) {
 *             console.log( "href = ", match.getAnchorHref() );
 *             console.log( "text = ", match.getAnchorText() );
 *         
 *             switch( match.getType() ) {
 *                 case 'url' : 
 *                     console.log( "url: ", match.getUrl() );
 *                     
 *                 case 'email' :
 *                     console.log( "email: ", match.getEmail() );
 *                     
 *                 case 'twitter' :
 *                     console.log( "twitter: ", match.getTwitterHandle() );
 *             }
 *         }
 *     } );
 *     
 * See the {@link Autolinker} class for more details on using the {@link Autolinker#replaceFn replaceFn}.
 */
Autolinker.match.Match = Autolinker.Util.extend( Object, {
	
	/**
	 * @cfg {String} matchedText (required)
	 * 
	 * The original text that was matched.
	 */
	
	
	/**
	 * @constructor
	 * @param {Object} cfg The configuration properties for the Match instance, specified in an Object (map).
	 */
	constructor : function( cfg ) {
		Autolinker.Util.assign( this, cfg );
	},

	
	/**
	 * Returns a string name for the type of match that this class represents.
	 * 
	 * @abstract
	 * @return {String}
	 */
	getType : Autolinker.Util.abstractMethod,
	
	
	/**
	 * Returns the original text that was matched.
	 * 
	 * @return {String}
	 */
	getMatchedText : function() {
		return this.matchedText;
	},
	

	/**
	 * Returns the anchor href that should be generated for the match.
	 * 
	 * @abstract
	 * @return {String}
	 */
	getAnchorHref : Autolinker.Util.abstractMethod,
	
	
	/**
	 * Returns the anchor text that should be generated for the match.
	 * 
	 * @abstract
	 * @return {String}
	 */
	getAnchorText : Autolinker.Util.abstractMethod

} );
/*global Autolinker */
/**
 * @class Autolinker.match.Email
 * @extends Autolinker.match.Match
 * 
 * Represents a Email match found in an input string which should be Autolinked.
 * 
 * See this class's superclass ({@link Autolinker.match.Match}) for more details.
 */
Autolinker.match.Email = Autolinker.Util.extend( Autolinker.match.Match, {
	
	/**
	 * @cfg {String} email (required)
	 * 
	 * The email address that was matched.
	 */
	

	/**
	 * Returns a string name for the type of match that this class represents.
	 * 
	 * @return {String}
	 */
	getType : function() {
		return 'email';
	},
	
	
	/**
	 * Returns the email address that was matched.
	 * 
	 * @return {String}
	 */
	getEmail : function() {
		return this.email;
	},
	

	/**
	 * Returns the anchor href that should be generated for the match.
	 * 
	 * @return {String}
	 */
	getAnchorHref : function() {
		return 'mailto:' + this.email;
	},
	
	
	/**
	 * Returns the anchor text that should be generated for the match.
	 * 
	 * @return {String}
	 */
	getAnchorText : function() {
		return this.email;
	}
	
} );
/*global Autolinker */
/**
 * @class Autolinker.match.Hashtag
 * @extends Autolinker.match.Match
 *
 * Represents a Hashtag match found in an input string which should be
 * Autolinked.
 *
 * See this class's superclass ({@link Autolinker.match.Match}) for more
 * details.
 */
Autolinker.match.Hashtag = Autolinker.Util.extend( Autolinker.match.Match, {

	/**
	 * @cfg {String} serviceName (required)
	 *
	 * The service to point hashtag matches to. See {@link Autolinker#hashtag}
	 * for available values.
	 */

	/**
	 * @cfg {String} hashtag (required)
	 *
	 * The Hashtag that was matched, without the '#'.
	 */


	/**
	 * Returns the type of match that this class represents.
	 *
	 * @return {String}
	 */
	getType : function() {
		return 'hashtag';
	},


	/**
	 * Returns the matched hashtag.
	 *
	 * @return {String}
	 */
	getHashtag : function() {
		return this.hashtag;
	},


	/**
	 * Returns the anchor href that should be generated for the match.
	 *
	 * @return {String}
	 */
	getAnchorHref : function() {
		var serviceName = this.serviceName,
		    hashtag = this.hashtag;

		switch( serviceName ) {
			case 'twitter' :
				return 'https://twitter.com/hashtag/' + hashtag;
			case 'facebook' :
				return 'https://www.facebook.com/hashtag/' + hashtag;

			default :  // Shouldn't happen because Autolinker's constructor should block any invalid values, but just in case.
				throw new Error( 'Unknown service name to point hashtag to: ', serviceName );
		}
	},


	/**
	 * Returns the anchor text that should be generated for the match.
	 *
	 * @return {String}
	 */
	getAnchorText : function() {
		return '#' + this.hashtag;
	}

} );
/*global Autolinker */
/**
 * @class Autolinker.match.Phone
 * @extends Autolinker.match.Match
 *
 * Represents a Phone number match found in an input string which should be
 * Autolinked.
 *
 * See this class's superclass ({@link Autolinker.match.Match}) for more
 * details.
 */
Autolinker.match.Phone = Autolinker.Util.extend( Autolinker.match.Match, {

	/**
	 * @cfg {String} number (required)
	 *
	 * The phone number that was matched.
	 */


	/**
	 * Returns a string name for the type of match that this class represents.
	 *
	 * @return {String}
	 */
	getType : function() {
		return 'phone';
	},


	/**
	 * Returns the phone number that was matched.
	 *
	 * @return {String}
	 */
	getNumber: function() {
		return this.number;
	},


	/**
	 * Returns the anchor href that should be generated for the match.
	 *
	 * @return {String}
	 */
	getAnchorHref : function() {
		return 'tel:' + this.number;
	},


	/**
	 * Returns the anchor text that should be generated for the match.
	 *
	 * @return {String}
	 */
	getAnchorText : function() {
		return this.matchedText;
	}

} );

/*global Autolinker */
/**
 * @class Autolinker.match.Twitter
 * @extends Autolinker.match.Match
 * 
 * Represents a Twitter match found in an input string which should be Autolinked.
 * 
 * See this class's superclass ({@link Autolinker.match.Match}) for more details.
 */
Autolinker.match.Twitter = Autolinker.Util.extend( Autolinker.match.Match, {
	
	/**
	 * @cfg {String} twitterHandle (required)
	 * 
	 * The Twitter handle that was matched.
	 */
	

	/**
	 * Returns the type of match that this class represents.
	 * 
	 * @return {String}
	 */
	getType : function() {
		return 'twitter';
	},
	
	
	/**
	 * Returns a string name for the type of match that this class represents.
	 * 
	 * @return {String}
	 */
	getTwitterHandle : function() {
		return this.twitterHandle;
	},
	

	/**
	 * Returns the anchor href that should be generated for the match.
	 * 
	 * @return {String}
	 */
	getAnchorHref : function() {
		return 'https://twitter.com/' + this.twitterHandle;
	},
	
	
	/**
	 * Returns the anchor text that should be generated for the match.
	 * 
	 * @return {String}
	 */
	getAnchorText : function() {
		return '@' + this.twitterHandle;
	}
	
} );
/*global Autolinker */
/**
 * @class Autolinker.match.Url
 * @extends Autolinker.match.Match
 * 
 * Represents a Url match found in an input string which should be Autolinked.
 * 
 * See this class's superclass ({@link Autolinker.match.Match}) for more details.
 */
Autolinker.match.Url = Autolinker.Util.extend( Autolinker.match.Match, {
	
	/**
	 * @cfg {String} url (required)
	 * 
	 * The url that was matched.
	 */
	
	/**
	 * @cfg {Boolean} protocolUrlMatch (required)
	 * 
	 * `true` if the URL is a match which already has a protocol (i.e. 'http://'), `false` if the match was from a 'www' or
	 * known TLD match.
	 */
	
	/**
	 * @cfg {Boolean} protocolRelativeMatch (required)
	 * 
	 * `true` if the URL is a protocol-relative match. A protocol-relative match is a URL that starts with '//',
	 * and will be either http:// or https:// based on the protocol that the site is loaded under.
	 */
	
	/**
	 * @cfg {Boolean} stripPrefix (required)
	 * @inheritdoc Autolinker#stripPrefix
	 */
	

	/**
	 * @private
	 * @property {RegExp} urlPrefixRegex
	 * 
	 * A regular expression used to remove the 'http://' or 'https://' and/or the 'www.' from URLs.
	 */
	urlPrefixRegex: /^(https?:\/\/)?(www\.)?/i,
	
	/**
	 * @private
	 * @property {RegExp} protocolRelativeRegex
	 * 
	 * The regular expression used to remove the protocol-relative '//' from the {@link #url} string, for purposes
	 * of {@link #getAnchorText}. A protocol-relative URL is, for example, "//yahoo.com"
	 */
	protocolRelativeRegex : /^\/\//,
	
	/**
	 * @private
	 * @property {Boolean} protocolPrepended
	 * 
	 * Will be set to `true` if the 'http://' protocol has been prepended to the {@link #url} (because the
	 * {@link #url} did not have a protocol)
	 */
	protocolPrepended : false,
	

	/**
	 * Returns a string name for the type of match that this class represents.
	 * 
	 * @return {String}
	 */
	getType : function() {
		return 'url';
	},
	
	
	/**
	 * Returns the url that was matched, assuming the protocol to be 'http://' if the original
	 * match was missing a protocol.
	 * 
	 * @return {String}
	 */
	getUrl : function() {
		var url = this.url;
		
		// if the url string doesn't begin with a protocol, assume 'http://'
		if( !this.protocolRelativeMatch && !this.protocolUrlMatch && !this.protocolPrepended ) {
			url = this.url = 'http://' + url;
			
			this.protocolPrepended = true;
		}
		
		return url;
	},
	

	/**
	 * Returns the anchor href that should be generated for the match.
	 * 
	 * @return {String}
	 */
	getAnchorHref : function() {
		var url = this.getUrl();
		
		return url.replace( /&amp;/g, '&' );  // any &amp;'s in the URL should be converted back to '&' if they were displayed as &amp; in the source html 
	},
	
	
	/**
	 * Returns the anchor text that should be generated for the match.
	 * 
	 * @return {String}
	 */
	getAnchorText : function() {
		var anchorText = this.getUrl();
		
		if( this.protocolRelativeMatch ) {
			// Strip off any protocol-relative '//' from the anchor text
			anchorText = this.stripProtocolRelativePrefix( anchorText );
		}
		if( this.stripPrefix ) {
			anchorText = this.stripUrlPrefix( anchorText );
		}
		anchorText = this.removeTrailingSlash( anchorText );  // remove trailing slash, if there is one
		
		return anchorText;
	},
	
	
	// ---------------------------------------
	
	// Utility Functionality
	
	/**
	 * Strips the URL prefix (such as "http://" or "https://") from the given text.
	 * 
	 * @private
	 * @param {String} text The text of the anchor that is being generated, for which to strip off the
	 *   url prefix (such as stripping off "http://")
	 * @return {String} The `anchorText`, with the prefix stripped.
	 */
	stripUrlPrefix : function( text ) {
		return text.replace( this.urlPrefixRegex, '' );
	},
	
	
	/**
	 * Strips any protocol-relative '//' from the anchor text.
	 * 
	 * @private
	 * @param {String} text The text of the anchor that is being generated, for which to strip off the
	 *   protocol-relative prefix (such as stripping off "//")
	 * @return {String} The `anchorText`, with the protocol-relative prefix stripped.
	 */
	stripProtocolRelativePrefix : function( text ) {
		return text.replace( this.protocolRelativeRegex, '' );
	},
	
	
	/**
	 * Removes any trailing slash from the given `anchorText`, in preparation for the text to be displayed.
	 * 
	 * @private
	 * @param {String} anchorText The text of the anchor that is being generated, for which to remove any trailing
	 *   slash ('/') that may exist.
	 * @return {String} The `anchorText`, with the trailing slash removed.
	 */
	removeTrailingSlash : function( anchorText ) {
		if( anchorText.charAt( anchorText.length - 1 ) === '/' ) {
			anchorText = anchorText.slice( 0, -1 );
		}
		return anchorText;
	}
	
} );
return Autolinker;

}));


/***/ }),

/***/ 1215:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
    'use strict';
    /**
     * Representation of <Camera> from KML
     * @alias KmlCamera
     * @constructor
     *
     * @param {Cartesian3} position camera position
     * @param {HeadingPitchRoll} headingPitchRoll camera orientation
     */
    function KmlCamera(position, headingPitchRoll) {
        this.position = position;
        this.headingPitchRoll = headingPitchRoll;
    }

    return KmlCamera;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 1216:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
    'use strict';
    /**
     * @alias KmlLookAt
     * @constructor
     *
     * @param {Cartesian3} position camera position
     * @param {HeadingPitchRange} headingPitchRange camera orientation
     */
    function KmlLookAt(position, headingPitchRange) {
        this.position = position;
        this.headingPitchRange = headingPitchRange;
    }

    return KmlLookAt;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 1217:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(0),
        __webpack_require__(11)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
        defined,
        Event) {
    'use strict';
    /**
     * @alias KmlTour
     * @constructor
     *
     * @param {String} name name parsed from KML
     * @param {String} id id parsed from KML
     * @param {Array} playlist array with KMLTourFlyTos, KMLTourWaits and KMLTourSoundCues
     */
    function KmlTour(name, id) {
        /**
         * Id of kml gx:Tour entry
         * @type String
         */
        this.id = id;
        /**
         * Tour name
         * @type String
         */
        this.name = name;
        /**
         * Index of current entry from playlist
         * @type Number
         */
        this.playlistIndex = 0;
        /**
         * Array of playlist entries
         * @type Array
         */
        this.playlist = [];
        /**
         * Event will be called when tour starts to play,
         * before any playlist entry starts to play.
         * @type Event
         */
        this.tourStart = new Event();
        /**
         * Event will be called when all playlist entries are
         * played, or tour playback being canceled.
         *
         * If tour playback was terminated, event callback will
         * be called with terminated=true parameter.
         * @type Event
         */
        this.tourEnd = new Event();
        /**
         * Event will be called when entry from playlist starts to play.
         *
         * Event callback will be called with curent entry as first parameter.
         * @type Event
         */
        this.entryStart = new Event();
        /**
         * Event will be called when entry from playlist ends to play.
         *
         * Event callback will be called with following parameters:
         * 1. entry - entry
         * 2. terminated - true if playback was terminated by calling {@link KmlTour#stop}
         * @type Event
         */
        this.entryEnd = new Event();

        this._activeEntries = [];
    }

    /**
     * Add entry to this tour playlist.
     *
     * @param {KmlTourFlyTo|KmlTourWait} entry an entry to add to the playlist.
     */
    KmlTour.prototype.addPlaylistEntry = function(entry) {
        this.playlist.push(entry);
    };

    /**
     * Play this tour.
     *
     * @param {Viewer} viewer viewer widget.
     * @param {Object} [cameraOptions] these options will be merged with {@link Camera#flyTo}
     * options for FlyTo playlist entries.
     */
    KmlTour.prototype.play = function(viewer, cameraOptions) {
        this.tourStart.raiseEvent();

        var tour = this;
        playEntry.call(this, viewer, cameraOptions, function(terminated) {
            tour.playlistIndex = 0;
            // Stop nonblocking entries
            if (!terminated) {
                cancelAllEntries(tour._activeEntries);
            }
            tour.tourEnd.raiseEvent(terminated);
        });
    };

    /**
     * Stop curently playing tour.
     */
    KmlTour.prototype.stop = function() {
        cancelAllEntries(this._activeEntries);
    };

    /**
     * Stop all activeEntries.
     * @param {Array} activeEntries
     */
    function cancelAllEntries(activeEntries) {
        for(var entry = activeEntries.pop(); entry !== undefined; entry = activeEntries.pop()) {
            entry.stop();
        }
    }

    /**
     * Play playlist entry.
     * This function is called recursevly with playNext
     * and iterates over all entries from playlist.
     *
     * @param {ViewerWidget} viewer Cesium viewer.
     * @param {Object} cameraOptions see {@link Camera#flyTo}.
     * @param {Function} allDone a function will be called when all entries from playlist
     * being played or user call {@link KmlTour#stop}.
     */
    function playEntry(viewer, cameraOptions, allDone) {
        var entry = this.playlist[this.playlistIndex];
        if (entry) {
            var _playNext = playNext.bind(this, viewer, cameraOptions, allDone);
            this._activeEntries.push(entry);
            this.entryStart.raiseEvent(entry);
            if (entry.blocking) {
                entry.play(_playNext, viewer.scene.camera, cameraOptions);
            }
            else {
                var tour = this;
                entry.play(function() {
                    tour.entryEnd.raiseEvent(entry);
                    var indx = tour._activeEntries.indexOf(entry);
                    if (indx >= 0) {
                        tour._activeEntries.splice(indx, 1);
                    }
                });
                _playNext(viewer, cameraOptions, allDone);
            }
        }
        else if(defined(allDone)) {
            allDone(false);
        }
    }

    /**
     * Increment playlistIndex and call playEntry
     * if terminated isn't true.
     *
     * @param {ViewerWidget} viewer passed for recursion.
     * @param {Object} cameraOptions passed for recursion.
     * @param {Function} allDone passed for recursion.
     * @param {Boolean} terminated true if active entry was terminated,
     * and the whole tour should be terminated.
     */
    function playNext(viewer, cameraOptions, allDone, terminated) {
        var entry = this.playlist[this.playlistIndex];
        this.entryEnd.raiseEvent(entry, terminated);

        if (terminated) {
            allDone(terminated);
        }
        else {
            var indx = this._activeEntries.indexOf(entry);
            if (indx >= 0) {
                this._activeEntries.splice(indx, 1);
            }
            this.playlistIndex++;
            playEntry.call(this, viewer, cameraOptions, allDone);
        }
    }

    return KmlTour;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 1218:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(28),
        __webpack_require__(36),
        __webpack_require__(0),
        __webpack_require__(308)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
        BoundingSphere,
        combine,
        defined,
        EasingFunction) {
    'use strict';
    /**
     * @alias KmlTourFlyTo
     * @constructor
     *
     * @param {Number} duration entry duration
     * @param {String} flyToMode KML fly to mode: bounce, smooth, etc
     * @param {KmlCamera|KmlLookAt} view KmlCamera or KmlLookAt
     */
    function KmlTourFlyTo(duration, flyToMode, view) {
        this.type = 'KmlTourFlyTo';
        this.blocking = true;
        this.activeCamera = null;
        this.activeCallback = null;

        this.duration = duration;
        this.view = view;
        this.flyToMode = flyToMode;
    }

    /**
     * Play this playlist entry
     *
     * @param {KmlTourFlyTo~DoneCallback} done function which will be called when playback ends
     * @param {Camera} camera Cesium camera
     * @param {Object} [cameraOptions] which will be merged with camera flyTo options. See {@link Camera#flyTo}
     */
    KmlTourFlyTo.prototype.play = function(done, camera, cameraOptions) {
        this.activeCamera = camera;
        if (defined(done) && done !== null) {
            var self = this;
            this.activeCallback = function(terminated) {
                delete self.activeCallback;
                delete self.activeCamera;
                done(defined(terminated) ? false : terminated);
            };
        }

        var options = this.getCameraOptions(cameraOptions);
        if (this.view.headingPitchRoll) {
            camera.flyTo(options);
        }
        else if (this.view.headingPitchRange) {
            var target = new BoundingSphere(this.view.position);
            camera.flyToBoundingSphere(target, options);
        }
    };

    /**
     * Stop execution of curent entry. Cancel camera flyTo
     */
    KmlTourFlyTo.prototype.stop = function() {
        if (defined(this.activeCamera)) {
            this.activeCamera.cancelFlight();
        }
        if (defined(this.activeCallback)) {
            this.activeCallback(true);
        }
    };

    /**
     * Returns options for {@link Camera#flyTo} or {@link Camera#flyToBoundingSphere}
     * depends on this.view type.
     *
     * @param {Object} cameraOptions options to merge with generated. See {@link Camera#flyTo}
     * @returns {Object} {@link Camera#flyTo} or {@link Camera#flyToBoundingSphere} options
     */
    KmlTourFlyTo.prototype.getCameraOptions = function(cameraOptions) {
        var options = {
            duration: this.duration
        };

        if (defined(this.activeCallback)) {
            options.complete = this.activeCallback;
        }

        if (this.flyToMode === 'smooth' ) {
            options.easingFunction = EasingFunction.LINEAR_NONE;
        }

        if (this.view.headingPitchRoll) {
            options.destination = this.view.position;
            options.orientation = this.view.headingPitchRoll;
        }
        else if (this.view.headingPitchRange) {
            options.offset = this.view.headingPitchRange;
        }

        if (defined(cameraOptions)) {
            options = combine(options, cameraOptions);
        }
        return options;
    };

    /**
     * A function that will be executed when the flight completes.
     * @callback KmlTourFlyTo~DoneCallback
     *
     * @param {Boolean} terminated true if {@link KmlTourFlyTo#stop} was
     * called before entry done playback.
     */

    return KmlTourFlyTo;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 1219:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(0)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
        defined) {
    'use strict';
    /**
     * @alias KmlTourWait
     * @constructor
     *
     * @param {Number} duration entry duration
     */
    function KmlTourWait(duration) {
        this.type = 'KmlTourWait';
        this.blocking = true;
        this.duration = duration;

        this.timeout = null;
    }

    /**
     * Play this playlist entry
     *
     * @param {KmlTourWait~DoneCallback} done function which will be called when playback ends
     */
    KmlTourWait.prototype.play = function(done) {
        var self = this;
        this.activeCallback = done;
        this.timeout = setTimeout(function() {
            delete self.activeCallback;
            done(false);
        }, this.duration * 1000);
    };

    /**
     * Stop execution of curent entry, cancel curent timeout
     */
    KmlTourWait.prototype.stop = function() {
        clearTimeout(this.timeout);
        if (defined(this.activeCallback)) {
            this.activeCallback(true);
        }
    };

    /**
     * A function which will be called when playback ends.
     *
     * @callback KmlTourWait~DoneCallback
     * @param {Boolean} terminated true if {@link KmlTourWait#stop} was
     * called before entry done playback.
     */

    return KmlTourWait;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 1220:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(0),
        __webpack_require__(2),
        __webpack_require__(3),
        __webpack_require__(22),
        __webpack_require__(11),
        __webpack_require__(167),
        __webpack_require__(86)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
        defined,
        defineProperties,
        DeveloperError,
        Ellipsoid,
        Event,
        ReferenceFrame,
        Property) {
    'use strict';

    /**
     * This is a temporary class for scaling position properties to the WGS84 surface.
     * It will go away or be refactored to support data with arbitrary height references.
     * @private
     */
    function ScaledPositionProperty(value) {
        this._definitionChanged = new Event();
        this._value = undefined;
        this._removeSubscription = undefined;
        this.setValue(value);
    }

    defineProperties(ScaledPositionProperty.prototype, {
        isConstant : {
            get : function() {
                return Property.isConstant(this._value);
            }
        },
        definitionChanged : {
            get : function() {
                return this._definitionChanged;
            }
        },
        referenceFrame : {
            get : function() {
                return defined(this._value) ? this._value.referenceFrame : ReferenceFrame.FIXED;
            }
        }
    });

    ScaledPositionProperty.prototype.getValue = function(time, result) {
        return this.getValueInReferenceFrame(time, ReferenceFrame.FIXED, result);
    };

    ScaledPositionProperty.prototype.setValue = function(value) {
        if (this._value !== value) {
            this._value = value;

            if (defined(this._removeSubscription)) {
                this._removeSubscription();
                this._removeSubscription = undefined;
            }

            if (defined(value)) {
                this._removeSubscription = value.definitionChanged.addEventListener(this._raiseDefinitionChanged, this);
            }
            this._definitionChanged.raiseEvent(this);
        }
    };

    ScaledPositionProperty.prototype.getValueInReferenceFrame = function(time, referenceFrame, result) {
        //>>includeStart('debug', pragmas.debug);
        if (!defined(time)) {
            throw new DeveloperError('time is required.');
        }
        if (!defined(referenceFrame)) {
            throw new DeveloperError('referenceFrame is required.');
        }
        //>>includeEnd('debug');

        if (!defined(this._value)) {
            return undefined;
        }

        result = this._value.getValueInReferenceFrame(time, referenceFrame, result);
        return defined(result) ? Ellipsoid.WGS84.scaleToGeodeticSurface(result, result) : undefined;
    };

    ScaledPositionProperty.prototype.equals = function(other) {
        return this === other || (other instanceof ScaledPositionProperty && this._value === other._value);
    };

    ScaledPositionProperty.prototype._raiseDefinitionChanged = function() {
        this._definitionChanged.raiseEvent(this);
    };

    return ScaledPositionProperty;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 539:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(6),
        __webpack_require__(21),
        __webpack_require__(87),
        __webpack_require__(1),
        __webpack_require__(0),
        __webpack_require__(2),
        __webpack_require__(3),
        __webpack_require__(11),
        __webpack_require__(1192),
        __webpack_require__(1194),
        __webpack_require__(525),
        __webpack_require__(18),
        __webpack_require__(16),
        __webpack_require__(121),
        __webpack_require__(106),
        __webpack_require__(538),
        __webpack_require__(5),
        __webpack_require__(516),
        __webpack_require__(307),
        __webpack_require__(305),
        __webpack_require__(520),
        __webpack_require__(304),
        __webpack_require__(518),
        __webpack_require__(300),
        __webpack_require__(301),
        __webpack_require__(517),
        __webpack_require__(299)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
        Cartesian3,
        Color,
        createGuid,
        defaultValue,
        defined,
        defineProperties,
        DeveloperError,
        Event,
        getFilenameFromUri,
        PinBuilder,
        PolygonHierarchy,
        Resource,
        RuntimeError,
        HeightReference,
        VerticalOrigin,
        topojson,
        when,
        BillboardGraphics,
        CallbackProperty,
        ColorMaterialProperty,
        ConstantPositionProperty,
        ConstantProperty,
        DataSource,
        EntityCluster,
        EntityCollection,
        PolygonGraphics,
        PolylineGraphics) {
    'use strict';

    function defaultCrsFunction(coordinates) {
        return Cartesian3.fromDegrees(coordinates[0], coordinates[1], coordinates[2]);
    }

    var crsNames = {
        'urn:ogc:def:crs:OGC:1.3:CRS84' : defaultCrsFunction,
        'EPSG:4326' : defaultCrsFunction,
        'urn:ogc:def:crs:EPSG::4326' : defaultCrsFunction
    };

    var crsLinkHrefs = {};
    var crsLinkTypes = {};
    var defaultMarkerSize = 48;
    var defaultMarkerSymbol;
    var defaultMarkerColor = Color.ROYALBLUE;
    var defaultStroke = Color.YELLOW;
    var defaultStrokeWidth = 2;
    var defaultFill = Color.fromBytes(255, 255, 0, 100);
    var defaultClampToGround = false;

    var sizes = {
        small : 24,
        medium : 48,
        large : 64
    };

    var simpleStyleIdentifiers = ['title', 'description', //
    'marker-size', 'marker-symbol', 'marker-color', 'stroke', //
    'stroke-opacity', 'stroke-width', 'fill', 'fill-opacity'];

    function defaultDescribe(properties, nameProperty) {
        var html = '';
        for ( var key in properties) {
            if (properties.hasOwnProperty(key)) {
                if (key === nameProperty || simpleStyleIdentifiers.indexOf(key) !== -1) {
                    continue;
                }
                var value = properties[key];
                if (defined(value)) {
                    if (typeof value === 'object') {
                        html += '<tr><th>' + key + '</th><td>' + defaultDescribe(value) + '</td></tr>';
                    } else {
                        html += '<tr><th>' + key + '</th><td>' + value + '</td></tr>';
                    }
                }
            }
        }

        if (html.length > 0) {
            html = '<table class="cesium-infoBox-defaultTable"><tbody>' + html + '</tbody></table>';
        }

        return html;
    }

    function createDescriptionCallback(describe, properties, nameProperty) {
        var description;
        return function(time, result) {
            if (!defined(description)) {
                description = describe(properties, nameProperty);
            }
            return description;
        };
    }

    function defaultDescribeProperty(properties, nameProperty) {
        return new CallbackProperty(createDescriptionCallback(defaultDescribe, properties, nameProperty), true);
    }

    //GeoJSON specifies only the Feature object has a usable id property
    //But since "multi" geometries create multiple entity,
    //we can't use it for them either.
    function createObject(geoJson, entityCollection, describe) {
        var id = geoJson.id;
        if (!defined(id) || geoJson.type !== 'Feature') {
            id = createGuid();
        } else {
            var i = 2;
            var finalId = id;
            while (defined(entityCollection.getById(finalId))) {
                finalId = id + '_' + i;
                i++;
            }
            id = finalId;
        }

        var entity = entityCollection.getOrCreateEntity(id);
        var properties = geoJson.properties;
        if (defined(properties)) {
            entity.properties = properties;

            var nameProperty;

            //Check for the simplestyle specified name first.
            var name = properties.title;
            if (defined(name)) {
                entity.name = name;
                nameProperty = 'title';
            } else {
                //Else, find the name by selecting an appropriate property.
                //The name will be obtained based on this order:
                //1) The first case-insensitive property with the name 'title',
                //2) The first case-insensitive property with the name 'name',
                //3) The first property containing the word 'title'.
                //4) The first property containing the word 'name',
                var namePropertyPrecedence = Number.MAX_VALUE;
                for ( var key in properties) {
                    if (properties.hasOwnProperty(key) && properties[key]) {
                        var lowerKey = key.toLowerCase();

                        if (namePropertyPrecedence > 1 && lowerKey === 'title') {
                            namePropertyPrecedence = 1;
                            nameProperty = key;
                            break;
                        } else if (namePropertyPrecedence > 2 && lowerKey === 'name') {
                            namePropertyPrecedence = 2;
                            nameProperty = key;
                        } else if (namePropertyPrecedence > 3 && /title/i.test(key)) {
                            namePropertyPrecedence = 3;
                            nameProperty = key;
                        } else if (namePropertyPrecedence > 4 && /name/i.test(key)) {
                            namePropertyPrecedence = 4;
                            nameProperty = key;
                        }
                    }
                }
                if (defined(nameProperty)) {
                    entity.name = properties[nameProperty];
                }
            }

            var description = properties.description;
            if (description !== null) {
                entity.description = !defined(description) ? describe(properties, nameProperty) : new ConstantProperty(description);
            }
        }
        return entity;
    }

    function coordinatesArrayToCartesianArray(coordinates, crsFunction) {
        var positions = new Array(coordinates.length);
        for (var i = 0; i < coordinates.length; i++) {
            positions[i] = crsFunction(coordinates[i]);
        }
        return positions;
    }

    var geoJsonObjectTypes = {
        Feature : processFeature,
        FeatureCollection : processFeatureCollection,
        GeometryCollection : processGeometryCollection,
        LineString : processLineString,
        MultiLineString : processMultiLineString,
        MultiPoint : processMultiPoint,
        MultiPolygon : processMultiPolygon,
        Point : processPoint,
        Polygon : processPolygon,
        Topology : processTopology
    };

    var geometryTypes = {
        GeometryCollection : processGeometryCollection,
        LineString : processLineString,
        MultiLineString : processMultiLineString,
        MultiPoint : processMultiPoint,
        MultiPolygon : processMultiPolygon,
        Point : processPoint,
        Polygon : processPolygon,
        Topology : processTopology
    };

    // GeoJSON processing functions
    function processFeature(dataSource, feature, notUsed, crsFunction, options) {
        if (feature.geometry === null) {
            //Null geometry is allowed, so just create an empty entity instance for it.
            createObject(feature, dataSource._entityCollection, options.describe);
            return;
        }

        if (!defined(feature.geometry)) {
            throw new RuntimeError('feature.geometry is required.');
        }

        var geometryType = feature.geometry.type;
        var geometryHandler = geometryTypes[geometryType];
        if (!defined(geometryHandler)) {
            throw new RuntimeError('Unknown geometry type: ' + geometryType);
        }
        geometryHandler(dataSource, feature, feature.geometry, crsFunction, options);
    }

    function processFeatureCollection(dataSource, featureCollection, notUsed, crsFunction, options) {
        var features = featureCollection.features;
        for (var i = 0, len = features.length; i < len; i++) {
            processFeature(dataSource, features[i], undefined, crsFunction, options);
        }
    }

    function processGeometryCollection(dataSource, geoJson, geometryCollection, crsFunction, options) {
        var geometries = geometryCollection.geometries;
        for (var i = 0, len = geometries.length; i < len; i++) {
            var geometry = geometries[i];
            var geometryType = geometry.type;
            var geometryHandler = geometryTypes[geometryType];
            if (!defined(geometryHandler)) {
                throw new RuntimeError('Unknown geometry type: ' + geometryType);
            }
            geometryHandler(dataSource, geoJson, geometry, crsFunction, options);
        }
    }

    function createPoint(dataSource, geoJson, crsFunction, coordinates, options) {
        var symbol = options.markerSymbol;
        var color = options.markerColor;
        var size = options.markerSize;

        var properties = geoJson.properties;
        if (defined(properties)) {
            var cssColor = properties['marker-color'];
            if (defined(cssColor)) {
                color = Color.fromCssColorString(cssColor);
            }

            size = defaultValue(sizes[properties['marker-size']], size);
            var markerSymbol = properties['marker-symbol'];
            if (defined(markerSymbol)) {
                symbol = markerSymbol;
            }
        }

        var canvasOrPromise;
        if (defined(symbol)) {
            if (symbol.length === 1) {
                canvasOrPromise = dataSource._pinBuilder.fromText(symbol.toUpperCase(), color, size);
            } else {
                canvasOrPromise = dataSource._pinBuilder.fromMakiIconId(symbol, color, size);
            }
        } else {
            canvasOrPromise = dataSource._pinBuilder.fromColor(color, size);
        }

        var billboard = new BillboardGraphics();
        billboard.verticalOrigin = new ConstantProperty(VerticalOrigin.BOTTOM);

        // Clamp to ground if there isn't a height specified
        if (coordinates.length === 2 && options.clampToGround) {
            billboard.heightReference = HeightReference.CLAMP_TO_GROUND;
        }

        var entity = createObject(geoJson, dataSource._entityCollection, options.describe);
        entity.billboard = billboard;
        entity.position = new ConstantPositionProperty(crsFunction(coordinates));

        var promise = when(canvasOrPromise).then(function(image) {
            billboard.image = new ConstantProperty(image);
        }).otherwise(function() {
            billboard.image = new ConstantProperty(dataSource._pinBuilder.fromColor(color, size));
        });

        dataSource._promises.push(promise);
    }

    function processPoint(dataSource, geoJson, geometry, crsFunction, options) {
        createPoint(dataSource, geoJson, crsFunction, geometry.coordinates, options);
    }

    function processMultiPoint(dataSource, geoJson, geometry, crsFunction, options) {
        var coordinates = geometry.coordinates;
        for (var i = 0; i < coordinates.length; i++) {
            createPoint(dataSource, geoJson, crsFunction, coordinates[i], options);
        }
    }

    function createLineString(dataSource, geoJson, crsFunction, coordinates, options) {
        var material = options.polylineStrokeMaterialProperty;
        var widthProperty = options.strokeWidthProperty;

        var properties = geoJson.properties;
        if (defined(properties)) {
            var width = properties['stroke-width'];
            if (defined(width)) {
                widthProperty = new ConstantProperty(width);
            }

            var color;
            var stroke = properties.stroke;
            if (defined(stroke)) {
                color = Color.fromCssColorString(stroke);
            }
            var opacity = properties['stroke-opacity'];
            if (defined(opacity) && opacity !== 1.0) {
                if (!defined(color)) {
                    color = material.color.clone();
                }
                color.alpha = opacity;
            }
            if (defined(color)) {
                material = new ColorMaterialProperty(color);
            }
        }

        var entity = createObject(geoJson, dataSource._entityCollection, options.describe);
        var polylineGraphics = new PolylineGraphics();
        entity.polyline = polylineGraphics;

        polylineGraphics.clampToGround = options.clampToGround;
        polylineGraphics.material = material;
        polylineGraphics.width = widthProperty;
        polylineGraphics.positions = new ConstantProperty(coordinatesArrayToCartesianArray(coordinates, crsFunction));
    }

    function processLineString(dataSource, geoJson, geometry, crsFunction, options) {
        createLineString(dataSource, geoJson, crsFunction, geometry.coordinates, options);
    }

    function processMultiLineString(dataSource, geoJson, geometry, crsFunction, options) {
        var lineStrings = geometry.coordinates;
        for (var i = 0; i < lineStrings.length; i++) {
            createLineString(dataSource, geoJson, crsFunction, lineStrings[i], options);
        }
    }

    function createPolygon(dataSource, geoJson, crsFunction, coordinates, options) {
        if (coordinates.length === 0 || coordinates[0].length === 0) {
            return;
        }

        var outlineColorProperty = options.polygonStrokeColor;
        var material = options.fillMaterialProperty;
        var widthProperty = options.strokeWidthProperty;

        var properties = geoJson.properties;
        if (defined(properties)) {
            var width = properties['stroke-width'];
            if (defined(width)) {
                widthProperty = new ConstantProperty(width);
            }

            var color;
            var stroke = properties.stroke;
            if (defined(stroke)) {
                color = Color.fromCssColorString(stroke);
            }
            var opacity = properties['stroke-opacity'];
            if (defined(opacity) && opacity !== 1.0) {
                if (!defined(color)) {
                    color = options.polygonStrokeColor.clone();
                }
                color.alpha = opacity;
            }

            if (defined(color)) {
                outlineColorProperty = new ConstantProperty(color);
            }

            var fillColor;
            var fill = properties.fill;
            if (defined(fill)) {
                fillColor = Color.fromCssColorString(fill);
                fillColor.alpha = material.color.alpha;
            }
            opacity = properties['fill-opacity'];
            if (defined(opacity) && opacity !== material.color.alpha) {
                if (!defined(fillColor)) {
                    fillColor = material.color.clone();
                }
                fillColor.alpha = opacity;
            }
            if (defined(fillColor)) {
                material = new ColorMaterialProperty(fillColor);
            }
        }

        var polygon = new PolygonGraphics();
        polygon.outline = new ConstantProperty(true);
        polygon.outlineColor = outlineColorProperty;
        polygon.outlineWidth = widthProperty;
        polygon.material = material;

        var holes = [];
        for (var i = 1, len = coordinates.length; i < len; i++) {
            holes.push(new PolygonHierarchy(coordinatesArrayToCartesianArray(coordinates[i], crsFunction)));
        }

        var positions = coordinates[0];
        polygon.hierarchy = new ConstantProperty(new PolygonHierarchy(coordinatesArrayToCartesianArray(positions, crsFunction), holes));
        if (positions[0].length > 2) {
            polygon.perPositionHeight = new ConstantProperty(true);
        } else if (!options.clampToGround) {
            polygon.height = 0;
        }

        var entity = createObject(geoJson, dataSource._entityCollection, options.describe);
        entity.polygon = polygon;
    }

    function processPolygon(dataSource, geoJson, geometry, crsFunction, options) {
        createPolygon(dataSource, geoJson, crsFunction, geometry.coordinates, options);
    }

    function processMultiPolygon(dataSource, geoJson, geometry, crsFunction, options) {
        var polygons = geometry.coordinates;
        for (var i = 0; i < polygons.length; i++) {
            createPolygon(dataSource, geoJson, crsFunction, polygons[i], options);
        }
    }

    function processTopology(dataSource, geoJson, geometry, crsFunction, options) {
        for ( var property in geometry.objects) {
            if (geometry.objects.hasOwnProperty(property)) {
                var feature = topojson.feature(geometry, geometry.objects[property]);
                var typeHandler = geoJsonObjectTypes[feature.type];
                typeHandler(dataSource, feature, feature, crsFunction, options);
            }
        }
    }

    /**
     * A {@link DataSource} which processes both
     * {@link http://www.geojson.org/|GeoJSON} and {@link https://github.com/mbostock/topojson|TopoJSON} data.
     * {@link https://github.com/mapbox/simplestyle-spec|simplestyle-spec} properties will also be used if they
     * are present.
     *
     * @alias GeoJsonDataSource
     * @constructor
     *
     * @param {String} [name] The name of this data source.  If undefined, a name will be taken from
     *                        the name of the GeoJSON file.
     *
     * @demo {@link https://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=GeoJSON%20and%20TopoJSON.html|Cesium Sandcastle GeoJSON and TopoJSON Demo}
     * @demo {@link https://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=GeoJSON%20simplestyle.html|Cesium Sandcastle GeoJSON simplestyle Demo}
     *
     * @example
     * var viewer = new Cesium.Viewer('cesiumContainer');
     * viewer.dataSources.add(Cesium.GeoJsonDataSource.load('../../SampleData/ne_10m_us_states.topojson', {
     *   stroke: Cesium.Color.HOTPINK,
     *   fill: Cesium.Color.PINK,
     *   strokeWidth: 3,
     *   markerSymbol: '?'
     * }));
     */
    function GeoJsonDataSource(name) {
        this._name = name;
        this._changed = new Event();
        this._error = new Event();
        this._isLoading = false;
        this._loading = new Event();
        this._entityCollection = new EntityCollection(this);
        this._promises = [];
        this._pinBuilder = new PinBuilder();
        this._entityCluster = new EntityCluster();
    }

    /**
     * Creates a Promise to a new instance loaded with the provided GeoJSON or TopoJSON data.
     *
     * @param {Resource|String|Object} data A url, GeoJSON object, or TopoJSON object to be loaded.
     * @param {Object} [options] An object with the following properties:
     * @param {String} [options.sourceUri] Overrides the url to use for resolving relative links.
     * @param {Number} [options.markerSize=GeoJsonDataSource.markerSize] The default size of the map pin created for each point, in pixels.
     * @param {String} [options.markerSymbol=GeoJsonDataSource.markerSymbol] The default symbol of the map pin created for each point.
     * @param {Color} [options.markerColor=GeoJsonDataSource.markerColor] The default color of the map pin created for each point.
     * @param {Color} [options.stroke=GeoJsonDataSource.stroke] The default color of polylines and polygon outlines.
     * @param {Number} [options.strokeWidth=GeoJsonDataSource.strokeWidth] The default width of polylines and polygon outlines.
     * @param {Color} [options.fill=GeoJsonDataSource.fill] The default color for polygon interiors.
     * @param {Boolean} [options.clampToGround=GeoJsonDataSource.clampToGround] true if we want the geometry features (polygons or linestrings) clamped to the ground.
     *
     * @returns {Promise.<GeoJsonDataSource>} A promise that will resolve when the data is loaded.
     */
    GeoJsonDataSource.load = function(data, options) {
        return new GeoJsonDataSource().load(data, options);
    };

    defineProperties(GeoJsonDataSource, {
        /**
         * Gets or sets the default size of the map pin created for each point, in pixels.
         * @memberof GeoJsonDataSource
         * @type {Number}
         * @default 48
         */
        markerSize : {
            get : function() {
                return defaultMarkerSize;
            },
            set : function(value) {
                defaultMarkerSize = value;
            }
        },
        /**
         * Gets or sets the default symbol of the map pin created for each point.
         * This can be any valid {@link http://mapbox.com/maki/|Maki} identifier, any single character,
         * or blank if no symbol is to be used.
         * @memberof GeoJsonDataSource
         * @type {String}
         */
        markerSymbol : {
            get : function() {
                return defaultMarkerSymbol;
            },
            set : function(value) {
                defaultMarkerSymbol = value;
            }
        },
        /**
         * Gets or sets the default color of the map pin created for each point.
         * @memberof GeoJsonDataSource
         * @type {Color}
         * @default Color.ROYALBLUE
         */
        markerColor : {
            get : function() {
                return defaultMarkerColor;
            },
            set : function(value) {
                defaultMarkerColor = value;
            }
        },
        /**
         * Gets or sets the default color of polylines and polygon outlines.
         * @memberof GeoJsonDataSource
         * @type {Color}
         * @default Color.BLACK
         */
        stroke : {
            get : function() {
                return defaultStroke;
            },
            set : function(value) {
                defaultStroke = value;
            }
        },
        /**
         * Gets or sets the default width of polylines and polygon outlines.
         * @memberof GeoJsonDataSource
         * @type {Number}
         * @default 2.0
         */
        strokeWidth : {
            get : function() {
                return defaultStrokeWidth;
            },
            set : function(value) {
                defaultStrokeWidth = value;
            }
        },
        /**
         * Gets or sets default color for polygon interiors.
         * @memberof GeoJsonDataSource
         * @type {Color}
         * @default Color.YELLOW
         */
        fill : {
            get : function() {
                return defaultFill;
            },
            set : function(value) {
                defaultFill = value;
            }
        },
        /**
         * Gets or sets default of whether to clamp to the ground.
         * @memberof GeoJsonDataSource
         * @type {Boolean}
         * @default false
         */
        clampToGround : {
            get : function() {
                return defaultClampToGround;
            },
            set : function(value) {
                defaultClampToGround = value;
            }
        },

        /**
         * Gets an object that maps the name of a crs to a callback function which takes a GeoJSON coordinate
         * and transforms it into a WGS84 Earth-fixed Cartesian.  Older versions of GeoJSON which
         * supported the EPSG type can be added to this list as well, by specifying the complete EPSG name,
         * for example 'EPSG:4326'.
         * @memberof GeoJsonDataSource
         * @type {Object}
         */
        crsNames : {
            get : function() {
                return crsNames;
            }
        },

        /**
         * Gets an object that maps the href property of a crs link to a callback function
         * which takes the crs properties object and returns a Promise that resolves
         * to a function that takes a GeoJSON coordinate and transforms it into a WGS84 Earth-fixed Cartesian.
         * Items in this object take precedence over those defined in <code>crsLinkHrefs</code>, assuming
         * the link has a type specified.
         * @memberof GeoJsonDataSource
         * @type {Object}
         */
        crsLinkHrefs : {
            get : function() {
                return crsLinkHrefs;
            }
        },

        /**
         * Gets an object that maps the type property of a crs link to a callback function
         * which takes the crs properties object and returns a Promise that resolves
         * to a function that takes a GeoJSON coordinate and transforms it into a WGS84 Earth-fixed Cartesian.
         * Items in <code>crsLinkHrefs</code> take precedence over this object.
         * @memberof GeoJsonDataSource
         * @type {Object}
         */
        crsLinkTypes : {
            get : function() {
                return crsLinkTypes;
            }
        }
    });

    defineProperties(GeoJsonDataSource.prototype, {
        /**
         * Gets or sets a human-readable name for this instance.
         * @memberof GeoJsonDataSource.prototype
         * @type {String}
         */
        name : {
            get : function() {
                return this._name;
            },
            set : function(value) {
                if (this._name !== value) {
                    this._name = value;
                    this._changed.raiseEvent(this);
                }
            }
        },
        /**
         * This DataSource only defines static data, therefore this property is always undefined.
         * @memberof GeoJsonDataSource.prototype
         * @type {DataSourceClock}
         */
        clock : {
            value : undefined,
            writable : false
        },
        /**
         * Gets the collection of {@link Entity} instances.
         * @memberof GeoJsonDataSource.prototype
         * @type {EntityCollection}
         */
        entities : {
            get : function() {
                return this._entityCollection;
            }
        },
        /**
         * Gets a value indicating if the data source is currently loading data.
         * @memberof GeoJsonDataSource.prototype
         * @type {Boolean}
         */
        isLoading : {
            get : function() {
                return this._isLoading;
            }
        },
        /**
         * Gets an event that will be raised when the underlying data changes.
         * @memberof GeoJsonDataSource.prototype
         * @type {Event}
         */
        changedEvent : {
            get : function() {
                return this._changed;
            }
        },
        /**
         * Gets an event that will be raised if an error is encountered during processing.
         * @memberof GeoJsonDataSource.prototype
         * @type {Event}
         */
        errorEvent : {
            get : function() {
                return this._error;
            }
        },
        /**
         * Gets an event that will be raised when the data source either starts or stops loading.
         * @memberof GeoJsonDataSource.prototype
         * @type {Event}
         */
        loadingEvent : {
            get : function() {
                return this._loading;
            }
        },
        /**
         * Gets whether or not this data source should be displayed.
         * @memberof GeoJsonDataSource.prototype
         * @type {Boolean}
         */
        show : {
            get : function() {
                return this._entityCollection.show;
            },
            set : function(value) {
                this._entityCollection.show = value;
            }
        },

        /**
         * Gets or sets the clustering options for this data source. This object can be shared between multiple data sources.
         *
         * @memberof GeoJsonDataSource.prototype
         * @type {EntityCluster}
         */
        clustering : {
            get : function() {
                return this._entityCluster;
            },
            set : function(value) {
                //>>includeStart('debug', pragmas.debug);
                if (!defined(value)) {
                    throw new DeveloperError('value must be defined.');
                }
                //>>includeEnd('debug');
                this._entityCluster = value;
            }
        }
    });

    /**
     * Asynchronously loads the provided GeoJSON or TopoJSON data, replacing any existing data.
     *
     * @param {Resource|String|Object} data A url, GeoJSON object, or TopoJSON object to be loaded.
     * @param {Object} [options] An object with the following properties:
     * @param {String} [options.sourceUri] Overrides the url to use for resolving relative links.
     * @param {GeoJsonDataSource~describe} [options.describe=GeoJsonDataSource.defaultDescribeProperty] A function which returns a Property object (or just a string),
     *                                                                                which converts the properties into an html description.
     * @param {Number} [options.markerSize=GeoJsonDataSource.markerSize] The default size of the map pin created for each point, in pixels.
     * @param {String} [options.markerSymbol=GeoJsonDataSource.markerSymbol] The default symbol of the map pin created for each point.
     * @param {Color} [options.markerColor=GeoJsonDataSource.markerColor] The default color of the map pin created for each point.
     * @param {Color} [options.stroke=GeoJsonDataSource.stroke] The default color of polylines and polygon outlines.
     * @param {Number} [options.strokeWidth=GeoJsonDataSource.strokeWidth] The default width of polylines and polygon outlines.
     * @param {Color} [options.fill=GeoJsonDataSource.fill] The default color for polygon interiors.
     * @param {Boolean} [options.clampToGround=GeoJsonDataSource.clampToGround] true if we want the features clamped to the ground.
     *
     * @returns {Promise.<GeoJsonDataSource>} a promise that will resolve when the GeoJSON is loaded.
     */
    GeoJsonDataSource.prototype.load = function(data, options) {
        //>>includeStart('debug', pragmas.debug);
        if (!defined(data)) {
            throw new DeveloperError('data is required.');
        }
        //>>includeEnd('debug');

        DataSource.setLoading(this, true);

        var promise = data;
        options = defaultValue(options, defaultValue.EMPTY_OBJECT);
        var sourceUri = options.sourceUri;
        if (typeof data === 'string' || (data instanceof Resource)) {
            data = Resource.createIfNeeded(data);

            promise = data.fetchJson();

            sourceUri = defaultValue(sourceUri, data.getUrlComponent());
        }

        options = {
            describe: defaultValue(options.describe, defaultDescribeProperty),
            markerSize : defaultValue(options.markerSize, defaultMarkerSize),
            markerSymbol : defaultValue(options.markerSymbol, defaultMarkerSymbol),
            markerColor : defaultValue(options.markerColor, defaultMarkerColor),
            strokeWidthProperty : new ConstantProperty(defaultValue(options.strokeWidth, defaultStrokeWidth)),
            polylineStrokeMaterialProperty : new ColorMaterialProperty(defaultValue(getColor(options.polylineStroke), defaultValue(getColor(options.stroke), defaultStroke))),
            polygonStrokeColor : defaultValue(getColor(options.polygonStroke), defaultValue(getColor(options.stroke), defaultStroke)),
            fillMaterialProperty : new ColorMaterialProperty(defaultValue(options.fill, defaultFill)),
            clampToGround : defaultValue(options.clampToGround, defaultClampToGround)
        };

        var that = this;
        return when(promise, function(geoJson) {
            return load(that, geoJson, options, sourceUri);
        }).otherwise(function(error) {
            DataSource.setLoading(that, false);
            that._error.raiseEvent(that, error);
            console.log(error);
            return when.reject(error);
        });
    };

    function getColor(color) {
        if (typeof color === 'string' || color instanceof String) {
            return Color.fromCssColorString(color);
        } else {
            return color;
        }
    }

    function load(that, geoJson, options, sourceUri) {
        var name;
        if (defined(sourceUri)) {
            name = getFilenameFromUri(sourceUri);
        }

        if (defined(name) && that._name !== name) {
            that._name = name;
            that._changed.raiseEvent(that);
        }

        var typeHandler = geoJsonObjectTypes[geoJson.type];
        if (!defined(typeHandler)) {
            throw new RuntimeError('Unsupported GeoJSON object type: ' + geoJson.type);
        }

        //Check for a Coordinate Reference System.
        var crs = geoJson.crs;
        var crsFunction = crs !== null ? defaultCrsFunction : null;

        if (defined(crs)) {
            if (!defined(crs.properties)) {
                throw new RuntimeError('crs.properties is undefined.');
            }

            var properties = crs.properties;
            if (crs.type === 'name') {
                crsFunction = crsNames[properties.name];
                if (!defined(crsFunction)) {
                    throw new RuntimeError('Unknown crs name: ' + properties.name);
                }
            } else if (crs.type === 'link') {
                var handler = crsLinkHrefs[properties.href];
                if (!defined(handler)) {
                    handler = crsLinkTypes[properties.type];
                }

                if (!defined(handler)) {
                    throw new RuntimeError('Unable to resolve crs link: ' + JSON.stringify(properties));
                }

                crsFunction = handler(properties);
            } else if (crs.type === 'EPSG') {
                crsFunction = crsNames['EPSG:' + properties.code];
                if (!defined(crsFunction)) {
                    throw new RuntimeError('Unknown crs EPSG code: ' + properties.code);
                }
            } else {
                throw new RuntimeError('Unknown crs type: ' + crs.type);
            }
        }

        return when(crsFunction, function(crsFunction) {
            that._entityCollection.removeAll();

            // null is a valid value for the crs, but means the entire load process becomes a no-op
            // because we can't assume anything about the coordinates.
            if (crsFunction !== null) {
                typeHandler(that, geoJson, geoJson, crsFunction, options);
            }

            return when.all(that._promises, function() {
                that._promises.length = 0;
                DataSource.setLoading(that, false);
                return that;
            });
        });
    }

    /**
     * This callback is displayed as part of the GeoJsonDataSource class.
     * @callback GeoJsonDataSource~describe
     * @param {Object} properties The properties of the feature.
     * @param {String} nameProperty The property key that Cesium estimates to have the name of the feature.
     */

    return GeoJsonDataSource;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 545:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(78),
        __webpack_require__(13),
        __webpack_require__(6),
        __webpack_require__(19),
        __webpack_require__(222),
        __webpack_require__(303),
        __webpack_require__(21),
        __webpack_require__(1200),
        __webpack_require__(87),
        __webpack_require__(1),
        __webpack_require__(0),
        __webpack_require__(2),
        __webpack_require__(3),
        __webpack_require__(123),
        __webpack_require__(22),
        __webpack_require__(11),
        __webpack_require__(541),
        __webpack_require__(1192),
        __webpack_require__(1201),
        __webpack_require__(53),
        __webpack_require__(168),
        __webpack_require__(29),
        __webpack_require__(1202),
        __webpack_require__(542),
        __webpack_require__(7),
        __webpack_require__(169),
        __webpack_require__(52),
        __webpack_require__(12),
        __webpack_require__(167),
        __webpack_require__(18),
        __webpack_require__(16),
        __webpack_require__(1203),
        __webpack_require__(64),
        __webpack_require__(105),
        __webpack_require__(544),
        __webpack_require__(121),
        __webpack_require__(122),
        __webpack_require__(223),
        __webpack_require__(146),
        __webpack_require__(106),
        __webpack_require__(70),
        __webpack_require__(5),
        __webpack_require__(516),
        __webpack_require__(529),
        __webpack_require__(305),
        __webpack_require__(1204),
        __webpack_require__(1195),
        __webpack_require__(1193),
        __webpack_require__(520),
        __webpack_require__(304),
        __webpack_require__(531),
        __webpack_require__(532),
        __webpack_require__(518),
        __webpack_require__(302),
        __webpack_require__(533),
        __webpack_require__(534),
        __webpack_require__(300),
        __webpack_require__(301),
        __webpack_require__(1205),
        __webpack_require__(530),
        __webpack_require__(521),
        __webpack_require__(535),
        __webpack_require__(536),
        __webpack_require__(522),
        __webpack_require__(311),
        __webpack_require__(517),
        __webpack_require__(1206),
        __webpack_require__(1207),
        __webpack_require__(1208),
        __webpack_require__(299),
        __webpack_require__(1209),
        __webpack_require__(1196),
        __webpack_require__(1210),
        __webpack_require__(310),
        __webpack_require__(523),
        __webpack_require__(1197),
        __webpack_require__(1211),
        __webpack_require__(526),
        __webpack_require__(313),
        __webpack_require__(1212),
        __webpack_require__(1198),
        __webpack_require__(543),
        __webpack_require__(527),
        __webpack_require__(1213),
        __webpack_require__(1199),
        __webpack_require__(524)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
        BoundingRectangle,
        Cartesian2,
        Cartesian3,
        Cartographic,
        ClockRange,
        ClockStep,
        Color,
        CornerType,
        createGuid,
        defaultValue,
        defined,
        defineProperties,
        DeveloperError,
        DistanceDisplayCondition,
        Ellipsoid,
        Event,
        ExtrapolationType,
        getFilenameFromUri,
        HermitePolynomialApproximation,
        isArray,
        Iso8601,
        JulianDate,
        LagrangePolynomialApproximation,
        LinearApproximation,
        CesiumMath,
        NearFarScalar,
        Quaternion,
        Rectangle,
        ReferenceFrame,
        Resource,
        RuntimeError,
        Spherical,
        TimeInterval,
        TimeIntervalCollection,
        ColorBlendMode,
        HeightReference,
        HorizontalOrigin,
        LabelStyle,
        ShadowMode,
        VerticalOrigin,
        Uri,
        when,
        BillboardGraphics,
        BoxGraphics,
        ColorMaterialProperty,
        CompositeMaterialProperty,
        CompositePositionProperty,
        CompositeProperty,
        ConstantPositionProperty,
        ConstantProperty,
        CorridorGraphics,
        CylinderGraphics,
        DataSource,
        DataSourceClock,
        EllipseGraphics,
        EllipsoidGraphics,
        EntityCluster,
        EntityCollection,
        GridMaterialProperty,
        ImageMaterialProperty,
        LabelGraphics,
        ModelGraphics,
        NodeTransformationProperty,
        PathGraphics,
        PointGraphics,
        PolygonGraphics,
        PolylineArrowMaterialProperty,
        PolylineDashMaterialProperty,
        PolylineGlowMaterialProperty,
        PolylineGraphics,
        PolylineOutlineMaterialProperty,
        PositionPropertyArray,
        PropertyArray,
        PropertyBag,
        RectangleGraphics,
        ReferenceProperty,
        Rotation,
        SampledPositionProperty,
        SampledProperty,
        StripeMaterialProperty,
        StripeOrientation,
        TimeIntervalCollectionPositionProperty,
        TimeIntervalCollectionProperty,
        VelocityOrientationProperty,
        VelocityVectorProperty,
        WallGraphics) {
    'use strict';

    // A marker type to distinguish CZML properties where we need to end up with a unit vector.
    // The data is still loaded into Cartesian3 objects but they are normalized.
    function UnitCartesian3() {}
    UnitCartesian3.packedLength = Cartesian3.packedLength;
    UnitCartesian3.unpack = Cartesian3.unpack;
    UnitCartesian3.pack = Cartesian3.pack;

    // As a side note, for the purposes of CZML, Quaternion always indicates a unit quaternion.

    var currentId;

    function createReferenceProperty(entityCollection, referenceString) {
        if (referenceString[0] === '#') {
            referenceString = currentId + referenceString;
        }
        return ReferenceProperty.fromString(entityCollection, referenceString);
    }

    function createSpecializedProperty(type, entityCollection, packetData) {
        if (defined(packetData.reference)) {
            return createReferenceProperty(entityCollection, packetData.reference);
        }

        if (defined(packetData.velocityReference)) {
            var referenceProperty = createReferenceProperty(entityCollection, packetData.velocityReference);
            switch (type) {
                case Cartesian3:
                case UnitCartesian3:
                    return new VelocityVectorProperty(referenceProperty, type === UnitCartesian3);
                case Quaternion:
                    return new VelocityOrientationProperty(referenceProperty);
            }
        }

        throw new RuntimeError(JSON.stringify(packetData) + ' is not valid CZML.');
    }

    var scratchCartesian = new Cartesian3();
    var scratchSpherical = new Spherical();
    var scratchCartographic = new Cartographic();
    var scratchTimeInterval = new TimeInterval();
    var scratchQuaternion = new Quaternion();

    function unwrapColorInterval(czmlInterval) {
        var rgbaf = czmlInterval.rgbaf;
        if (defined(rgbaf)) {
            return rgbaf;
        }

        var rgba = czmlInterval.rgba;
        if (!defined(rgba)) {
            return undefined;
        }

        var length = rgba.length;
        if (length === Color.packedLength) {
            return [Color.byteToFloat(rgba[0]), Color.byteToFloat(rgba[1]), Color.byteToFloat(rgba[2]), Color.byteToFloat(rgba[3])];
        }

        rgbaf = new Array(length);
        for (var i = 0; i < length; i += 5) {
            rgbaf[i] = rgba[i];
            rgbaf[i + 1] = Color.byteToFloat(rgba[i + 1]);
            rgbaf[i + 2] = Color.byteToFloat(rgba[i + 2]);
            rgbaf[i + 3] = Color.byteToFloat(rgba[i + 3]);
            rgbaf[i + 4] = Color.byteToFloat(rgba[i + 4]);
        }
        return rgbaf;
    }

    function unwrapUriInterval(czmlInterval, sourceUri) {
        var uri = defaultValue(czmlInterval.uri, czmlInterval);
        if (defined(sourceUri)) {
            return sourceUri.getDerivedResource({
                url: uri
            });
        }

        return Resource.createIfNeeded(uri);
    }

    function unwrapRectangleInterval(czmlInterval) {
        var wsen = czmlInterval.wsen;
        if (defined(wsen)) {
            return wsen;
        }

        var wsenDegrees = czmlInterval.wsenDegrees;
        if (!defined(wsenDegrees)) {
            return undefined;
        }

        var length = wsenDegrees.length;
        if (length === Rectangle.packedLength) {
            return [CesiumMath.toRadians(wsenDegrees[0]), CesiumMath.toRadians(wsenDegrees[1]), CesiumMath.toRadians(wsenDegrees[2]), CesiumMath.toRadians(wsenDegrees[3])];
        }

        wsen = new Array(length);
        for (var i = 0; i < length; i += 5) {
            wsen[i] = wsenDegrees[i];
            wsen[i + 1] = CesiumMath.toRadians(wsenDegrees[i + 1]);
            wsen[i + 2] = CesiumMath.toRadians(wsenDegrees[i + 2]);
            wsen[i + 3] = CesiumMath.toRadians(wsenDegrees[i + 3]);
            wsen[i + 4] = CesiumMath.toRadians(wsenDegrees[i + 4]);
        }
        return wsen;
    }

    function convertUnitSphericalToCartesian(unitSpherical) {
        var length = unitSpherical.length;
        scratchSpherical.magnitude = 1.0;
        if (length === 2) {
            scratchSpherical.clock = unitSpherical[0];
            scratchSpherical.cone = unitSpherical[1];
            Cartesian3.fromSpherical(scratchSpherical, scratchCartesian);
            return [scratchCartesian.x, scratchCartesian.y, scratchCartesian.z];
        }

        var result = new Array(length / 3 * 4);
        for (var i = 0, j = 0; i < length; i += 3, j += 4) {
            result[j] = unitSpherical[i];

            scratchSpherical.clock = unitSpherical[i + 1];
            scratchSpherical.cone = unitSpherical[i + 2];
            Cartesian3.fromSpherical(scratchSpherical, scratchCartesian);

            result[j + 1] = scratchCartesian.x;
            result[j + 2] = scratchCartesian.y;
            result[j + 3] = scratchCartesian.z;
        }
        return result;
    }

    function convertSphericalToCartesian(spherical) {
        var length = spherical.length;
        if (length === 3) {
            scratchSpherical.clock = spherical[0];
            scratchSpherical.cone = spherical[1];
            scratchSpherical.magnitude = spherical[2];
            Cartesian3.fromSpherical(scratchSpherical, scratchCartesian);
            return [scratchCartesian.x, scratchCartesian.y, scratchCartesian.z];
        }

        var result = new Array(length);
        for (var i = 0; i < length; i += 4) {
            result[i] = spherical[i];

            scratchSpherical.clock = spherical[i + 1];
            scratchSpherical.cone = spherical[i + 2];
            scratchSpherical.magnitude = spherical[i + 3];
            Cartesian3.fromSpherical(scratchSpherical, scratchCartesian);

            result[i + 1] = scratchCartesian.x;
            result[i + 2] = scratchCartesian.y;
            result[i + 3] = scratchCartesian.z;
        }
        return result;
    }

    function convertCartographicRadiansToCartesian(cartographicRadians) {
        var length = cartographicRadians.length;
        if (length === 3) {
            scratchCartographic.longitude = cartographicRadians[0];
            scratchCartographic.latitude = cartographicRadians[1];
            scratchCartographic.height = cartographicRadians[2];
            Ellipsoid.WGS84.cartographicToCartesian(scratchCartographic, scratchCartesian);
            return [scratchCartesian.x, scratchCartesian.y, scratchCartesian.z];
        }

        var result = new Array(length);
        for (var i = 0; i < length; i += 4) {
            result[i] = cartographicRadians[i];

            scratchCartographic.longitude = cartographicRadians[i + 1];
            scratchCartographic.latitude = cartographicRadians[i + 2];
            scratchCartographic.height = cartographicRadians[i + 3];
            Ellipsoid.WGS84.cartographicToCartesian(scratchCartographic, scratchCartesian);

            result[i + 1] = scratchCartesian.x;
            result[i + 2] = scratchCartesian.y;
            result[i + 3] = scratchCartesian.z;
        }
        return result;
    }

    function convertCartographicDegreesToCartesian(cartographicDegrees) {
        var length = cartographicDegrees.length;
        if (length === 3) {
            scratchCartographic.longitude = CesiumMath.toRadians(cartographicDegrees[0]);
            scratchCartographic.latitude = CesiumMath.toRadians(cartographicDegrees[1]);
            scratchCartographic.height = cartographicDegrees[2];
            Ellipsoid.WGS84.cartographicToCartesian(scratchCartographic, scratchCartesian);
            return [scratchCartesian.x, scratchCartesian.y, scratchCartesian.z];
        }

        var result = new Array(length);
        for (var i = 0; i < length; i += 4) {
            result[i] = cartographicDegrees[i];

            scratchCartographic.longitude = CesiumMath.toRadians(cartographicDegrees[i + 1]);
            scratchCartographic.latitude = CesiumMath.toRadians(cartographicDegrees[i + 2]);
            scratchCartographic.height = cartographicDegrees[i + 3];
            Ellipsoid.WGS84.cartographicToCartesian(scratchCartographic, scratchCartesian);

            result[i + 1] = scratchCartesian.x;
            result[i + 2] = scratchCartesian.y;
            result[i + 3] = scratchCartesian.z;
        }
        return result;
    }

    function unwrapCartesianInterval(czmlInterval) {
        var cartesian = czmlInterval.cartesian;
        if (defined(cartesian)) {
            return cartesian;
        }

        var cartesianVelocity = czmlInterval.cartesianVelocity;
        if (defined(cartesianVelocity)) {
            return cartesianVelocity;
        }

        var unitCartesian = czmlInterval.unitCartesian;
        if (defined(unitCartesian)) {
            return unitCartesian;
        }

        var unitSpherical = czmlInterval.unitSpherical;
        if (defined(unitSpherical)) {
            return convertUnitSphericalToCartesian(unitSpherical);
        }

        var spherical = czmlInterval.spherical;
        if (defined(spherical)) {
            return convertSphericalToCartesian(spherical);
        }

        var cartographicRadians = czmlInterval.cartographicRadians;
        if (defined(cartographicRadians)) {
            return convertCartographicRadiansToCartesian(cartographicRadians);
        }

        var cartographicDegrees = czmlInterval.cartographicDegrees;
        if (defined(cartographicDegrees)) {
            return convertCartographicDegreesToCartesian(cartographicDegrees);
        }

        throw new RuntimeError(JSON.stringify(czmlInterval) + ' is not a valid CZML interval.');
    }

    function normalizePackedCartesianArray(array, startingIndex) {
        Cartesian3.unpack(array, startingIndex, scratchCartesian);
        Cartesian3.normalize(scratchCartesian, scratchCartesian);
        Cartesian3.pack(scratchCartesian, array, startingIndex);
    }

    function unwrapUnitCartesianInterval(czmlInterval) {
        var cartesian = unwrapCartesianInterval(czmlInterval);
        if (cartesian.length === 3) {
            normalizePackedCartesianArray(cartesian, 0);
            return cartesian;
        }

        for (var i = 1; i < cartesian.length; i += 4) {
            normalizePackedCartesianArray(cartesian, i);
        }

        return cartesian;
    }

    function normalizePackedQuaternionArray(array, startingIndex) {
        Quaternion.unpack(array, startingIndex, scratchQuaternion);
        Quaternion.normalize(scratchQuaternion, scratchQuaternion);
        Quaternion.pack(scratchQuaternion, array, startingIndex);
    }

    function unwrapQuaternionInterval(czmlInterval) {
        var unitQuaternion = czmlInterval.unitQuaternion;
        if (defined(unitQuaternion)) {
            if (unitQuaternion.length === 4) {
                normalizePackedQuaternionArray(unitQuaternion, 0);
                return unitQuaternion;
            }

            for (var i = 1; i < unitQuaternion.length; i += 5) {
                normalizePackedQuaternionArray(unitQuaternion, i);
            }
        }
        return unitQuaternion;
    }

    function getPropertyType(czmlInterval) {
        // The associations in this function need to be kept in sync with the
        // associations in unwrapInterval.

        // Intentionally omitted due to conficts in CZML property names:
        // * Image (conflicts with Uri)
        // * Rotation (conflicts with Number)
        //
        // cartesianVelocity is also omitted due to incomplete support for
        // derivative information in CZML properties.
        // (Currently cartesianVelocity is hacked directly into the position processing code)
        if (typeof czmlInterval === 'boolean') {
            return Boolean;
        } else if (typeof czmlInterval === 'number') {
            return Number;
        } else if (typeof czmlInterval === 'string') {
            return String;
        } else if (czmlInterval.hasOwnProperty('array')) {
            return Array;
        } else if (czmlInterval.hasOwnProperty('boolean')) {
            return Boolean;
        } else if (czmlInterval.hasOwnProperty('boundingRectangle')) {
            return BoundingRectangle;
        } else if (czmlInterval.hasOwnProperty('cartesian2')) {
            return Cartesian2;
        } else if (czmlInterval.hasOwnProperty('cartesian') ||
                   czmlInterval.hasOwnProperty('spherical') ||
                   czmlInterval.hasOwnProperty('cartographicRadians') ||
                   czmlInterval.hasOwnProperty('cartographicDegrees')) {
            return Cartesian3;
        } else if (czmlInterval.hasOwnProperty('unitCartesian') ||
                   czmlInterval.hasOwnProperty('unitSpherical')) {
            return UnitCartesian3;
        } else if (czmlInterval.hasOwnProperty('rgba') ||
                   czmlInterval.hasOwnProperty('rgbaf')) {
            return Color;
        } else if (czmlInterval.hasOwnProperty('colorBlendMode')) {
            return ColorBlendMode;
        } else if (czmlInterval.hasOwnProperty('cornerType')) {
            return CornerType;
        } else if (czmlInterval.hasOwnProperty('heightReference')) {
            return HeightReference;
        } else if (czmlInterval.hasOwnProperty('horizontalOrigin')) {
            return HorizontalOrigin;
        } else if (czmlInterval.hasOwnProperty('date')) {
            return JulianDate;
        } else if (czmlInterval.hasOwnProperty('labelStyle')) {
            return LabelStyle;
        } else if (czmlInterval.hasOwnProperty('number')) {
            return Number;
        } else if (czmlInterval.hasOwnProperty('nearFarScalar')) {
            return NearFarScalar;
        } else if (czmlInterval.hasOwnProperty('distanceDisplayCondition')) {
            return DistanceDisplayCondition;
        } else if (czmlInterval.hasOwnProperty('object') ||
                   czmlInterval.hasOwnProperty('value')) {
            return Object;
        } else if (czmlInterval.hasOwnProperty('unitQuaternion')) {
            return Quaternion;
        } else if (czmlInterval.hasOwnProperty('shadowMode')) {
            return ShadowMode;
        } else if (czmlInterval.hasOwnProperty('string')) {
            return String;
        } else if (czmlInterval.hasOwnProperty('stripeOrientation')) {
            return StripeOrientation;
        } else if (czmlInterval.hasOwnProperty('wsen') ||
                   czmlInterval.hasOwnProperty('wsenDegrees')) {
            return Rectangle;
        } else if (czmlInterval.hasOwnProperty('uri')) {
            return Uri;
        } else if (czmlInterval.hasOwnProperty('verticalOrigin')) {
            return VerticalOrigin;
        }
        // fallback case
        return Object;
    }

    function unwrapInterval(type, czmlInterval, sourceUri) {
        // The associations in this function need to be kept in sync with the
        // associations in getPropertyType
        switch (type) {
            case Array:
                return czmlInterval.array;
            case Boolean:
                return defaultValue(czmlInterval['boolean'], czmlInterval);
            case BoundingRectangle:
                return czmlInterval.boundingRectangle;
            case Cartesian2:
                return czmlInterval.cartesian2;
            case Cartesian3:
                return unwrapCartesianInterval(czmlInterval);
            case UnitCartesian3:
                return unwrapUnitCartesianInterval(czmlInterval);
            case Color:
                return unwrapColorInterval(czmlInterval);
            case ColorBlendMode:
                return ColorBlendMode[defaultValue(czmlInterval.colorBlendMode, czmlInterval)];
            case CornerType:
                return CornerType[defaultValue(czmlInterval.cornerType, czmlInterval)];
            case HeightReference:
                return HeightReference[defaultValue(czmlInterval.heightReference, czmlInterval)];
            case HorizontalOrigin:
                return HorizontalOrigin[defaultValue(czmlInterval.horizontalOrigin, czmlInterval)];
            case Image:
                return unwrapUriInterval(czmlInterval, sourceUri);
            case JulianDate:
                return JulianDate.fromIso8601(defaultValue(czmlInterval.date, czmlInterval));
            case LabelStyle:
                return LabelStyle[defaultValue(czmlInterval.labelStyle, czmlInterval)];
            case Number:
                return defaultValue(czmlInterval.number, czmlInterval);
            case NearFarScalar:
                return czmlInterval.nearFarScalar;
            case DistanceDisplayCondition:
                return czmlInterval.distanceDisplayCondition;
            case Object:
                return defaultValue(defaultValue(czmlInterval.object, czmlInterval.value), czmlInterval);
            case Quaternion:
                return unwrapQuaternionInterval(czmlInterval);
            case Rectangle:
                return unwrapRectangleInterval(czmlInterval);
            case Rotation:
                return defaultValue(czmlInterval.number, czmlInterval);
            case ShadowMode:
                return ShadowMode[defaultValue(defaultValue(czmlInterval.shadowMode, czmlInterval.shadows), czmlInterval)];
            case String:
                return defaultValue(czmlInterval.string, czmlInterval);
            case StripeOrientation:
                return StripeOrientation[defaultValue(czmlInterval.stripeOrientation, czmlInterval)];
            case Uri:
                return unwrapUriInterval(czmlInterval, sourceUri);
            case VerticalOrigin:
                return VerticalOrigin[defaultValue(czmlInterval.verticalOrigin, czmlInterval)];
            default:
                throw new RuntimeError(type);
        }
    }

    var interpolators = {
        HERMITE : HermitePolynomialApproximation,
        LAGRANGE : LagrangePolynomialApproximation,
        LINEAR : LinearApproximation
    };

    function updateInterpolationSettings(packetData, property) {
        var interpolationAlgorithm = packetData.interpolationAlgorithm;
        if (defined(interpolationAlgorithm) || defined(packetData.interpolationDegree)) {
            property.setInterpolationOptions({
                interpolationAlgorithm : interpolators[interpolationAlgorithm],
                interpolationDegree : packetData.interpolationDegree
            });
        }

        var forwardExtrapolationType = packetData.forwardExtrapolationType;
        if (defined(forwardExtrapolationType)) {
            property.forwardExtrapolationType = ExtrapolationType[forwardExtrapolationType];
        }

        var forwardExtrapolationDuration = packetData.forwardExtrapolationDuration;
        if (defined(forwardExtrapolationDuration)) {
            property.forwardExtrapolationDuration = forwardExtrapolationDuration;
        }

        var backwardExtrapolationType = packetData.backwardExtrapolationType;
        if (defined(backwardExtrapolationType)) {
            property.backwardExtrapolationType = ExtrapolationType[backwardExtrapolationType];
        }

        var backwardExtrapolationDuration = packetData.backwardExtrapolationDuration;
        if (defined(backwardExtrapolationDuration)) {
            property.backwardExtrapolationDuration = backwardExtrapolationDuration;
        }
    }

    var iso8601Scratch = {
        iso8601 : undefined
    };

    function processProperty(type, object, propertyName, packetData, constrainedInterval, sourceUri, entityCollection) {
        var combinedInterval;
        var packetInterval = packetData.interval;
        if (defined(packetInterval)) {
            iso8601Scratch.iso8601 = packetInterval;
            combinedInterval = TimeInterval.fromIso8601(iso8601Scratch);
            if (defined(constrainedInterval)) {
                combinedInterval = TimeInterval.intersect(combinedInterval, constrainedInterval, scratchTimeInterval);
            }
        } else if (defined(constrainedInterval)) {
            combinedInterval = constrainedInterval;
        }

        var packedLength;
        var isSampled;
        var unwrappedInterval;
        var unwrappedIntervalLength;

        // CZML properties can be defined in many ways.  Most ways represent a structure for
        // encoding a single value (number, string, cartesian, etc.)  Regardless of the value type,
        // if it encodes a single value it will get loaded into a ConstantProperty eventually.
        // Alternatively, there are ways of defining a property that require specialized
        // client-side representation. Currently, these are ReferenceProperty,
        // and client-side velocity computation properties such as VelocityVectorProperty.
        var isValue = !defined(packetData.reference) && !defined(packetData.velocityReference);
        var hasInterval = defined(combinedInterval) && !combinedInterval.equals(Iso8601.MAXIMUM_INTERVAL);

        if (isValue) {
            unwrappedInterval = unwrapInterval(type, packetData, sourceUri);
            packedLength = defaultValue(type.packedLength, 1);
            unwrappedIntervalLength = defaultValue(unwrappedInterval.length, 1);
            isSampled = !defined(packetData.array) && (typeof unwrappedInterval !== 'string') && (unwrappedIntervalLength > packedLength) && (type !== Object);
        }

        //Rotation is a special case because it represents a native type (Number)
        //and therefore does not need to be unpacked when loaded as a constant value.
        var needsUnpacking = typeof type.unpack === 'function' && type !== Rotation;

        //Any time a constant value is assigned, it completely blows away anything else.
        if (!isSampled && !hasInterval) {
            if (isValue) {
                object[propertyName] = new ConstantProperty(needsUnpacking ? type.unpack(unwrappedInterval, 0) : unwrappedInterval);
            } else {
                object[propertyName] = createSpecializedProperty(type, entityCollection, packetData);
            }
            return;
        }

        var property = object[propertyName];

        var epoch;
        var packetEpoch = packetData.epoch;
        if (defined(packetEpoch)) {
            epoch = JulianDate.fromIso8601(packetEpoch);
        }

        //Without an interval, any sampled value is infinite, meaning it completely
        //replaces any non-sampled property that may exist.
        if (isSampled && !hasInterval) {
            if (!(property instanceof SampledProperty)) {
                property = new SampledProperty(type);
                object[propertyName] = property;
            }
            property.addSamplesPackedArray(unwrappedInterval, epoch);
            updateInterpolationSettings(packetData, property);
            return;
        }

        var interval;

        //A constant value with an interval is normally part of a TimeIntervalCollection,
        //However, if the current property is not a time-interval collection, we need
        //to turn it into a Composite, preserving the old data with the new interval.
        if (!isSampled && hasInterval) {
            //Create a new interval for the constant value.
            combinedInterval = combinedInterval.clone();
            if (isValue) {
                combinedInterval.data = needsUnpacking ? type.unpack(unwrappedInterval, 0) : unwrappedInterval;
            } else {
                combinedInterval.data = createSpecializedProperty(type, entityCollection, packetData);
            }

            //If no property exists, simply use a new interval collection
            if (!defined(property)) {
                if (isValue) {
                    property = new TimeIntervalCollectionProperty();
                } else {
                    property = new CompositeProperty();
                }
                object[propertyName] = property;
            }

            if (isValue && property instanceof TimeIntervalCollectionProperty) {
                //If we create a collection, or it already existed, use it.
                property.intervals.addInterval(combinedInterval);
            } else if (property instanceof CompositeProperty) {
                //If the collection was already a CompositeProperty, use it.
                if (isValue) {
                    combinedInterval.data = new ConstantProperty(combinedInterval.data);
                }
                property.intervals.addInterval(combinedInterval);
            } else {
                //Otherwise, create a CompositeProperty but preserve the existing data.

                //Put the old property in an infinite interval.
                interval = Iso8601.MAXIMUM_INTERVAL.clone();
                interval.data = property;

                //Create the composite.
                property = new CompositeProperty();
                object[propertyName] = property;

                //add the old property interval
                property.intervals.addInterval(interval);

                //Change the new data to a ConstantProperty and add it.
                if (isValue) {
                    combinedInterval.data = new ConstantProperty(combinedInterval.data);
                }
                property.intervals.addInterval(combinedInterval);
            }

            return;
        }

        //isSampled && hasInterval
        if (!defined(property)) {
            property = new CompositeProperty();
            object[propertyName] = property;
        }

        //create a CompositeProperty but preserve the existing data.
        if (!(property instanceof CompositeProperty)) {
            //Put the old property in an infinite interval.
            interval = Iso8601.MAXIMUM_INTERVAL.clone();
            interval.data = property;

            //Create the composite.
            property = new CompositeProperty();
            object[propertyName] = property;

            //add the old property interval
            property.intervals.addInterval(interval);
        }

        //Check if the interval already exists in the composite
        var intervals = property.intervals;
        interval = intervals.findInterval(combinedInterval);
        if (!defined(interval) || !(interval.data instanceof SampledProperty)) {
            //If not, create a SampledProperty for it.
            interval = combinedInterval.clone();
            interval.data = new SampledProperty(type);
            intervals.addInterval(interval);
        }
        interval.data.addSamplesPackedArray(unwrappedInterval, epoch);
        updateInterpolationSettings(packetData, interval.data);
    }

    function processPacketData(type, object, propertyName, packetData, interval, sourceUri, entityCollection) {
        if (!defined(packetData)) {
            return;
        }

        if (isArray(packetData)) {
            for (var i = 0, len = packetData.length; i < len; i++) {
                processProperty(type, object, propertyName, packetData[i], interval, sourceUri, entityCollection);
            }
        } else {
            processProperty(type, object, propertyName, packetData, interval, sourceUri, entityCollection);
        }
    }

    function processPositionProperty(object, propertyName, packetData, constrainedInterval, sourceUri, entityCollection) {
        var combinedInterval;
        var packetInterval = packetData.interval;
        if (defined(packetInterval)) {
            iso8601Scratch.iso8601 = packetInterval;
            combinedInterval = TimeInterval.fromIso8601(iso8601Scratch);
            if (defined(constrainedInterval)) {
                combinedInterval = TimeInterval.intersect(combinedInterval, constrainedInterval, scratchTimeInterval);
            }
        } else if (defined(constrainedInterval)) {
            combinedInterval = constrainedInterval;
        }

        var referenceFrame;
        var unwrappedInterval;
        var isSampled = false;
        var unwrappedIntervalLength;
        var numberOfDerivatives = defined(packetData.cartesianVelocity) ? 1 : 0;
        var packedLength = Cartesian3.packedLength * (numberOfDerivatives + 1);
        var isValue = !defined(packetData.reference);
        var hasInterval = defined(combinedInterval) && !combinedInterval.equals(Iso8601.MAXIMUM_INTERVAL);

        if (isValue) {
            if (defined(packetData.referenceFrame)) {
                referenceFrame = ReferenceFrame[packetData.referenceFrame];
            }
            referenceFrame = defaultValue(referenceFrame, ReferenceFrame.FIXED);
            unwrappedInterval = unwrapCartesianInterval(packetData);
            unwrappedIntervalLength = defaultValue(unwrappedInterval.length, 1);
            isSampled = unwrappedIntervalLength > packedLength;
        }

        //Any time a constant value is assigned, it completely blows away anything else.
        if (!isSampled && !hasInterval) {
            if (isValue) {
                object[propertyName] = new ConstantPositionProperty(Cartesian3.unpack(unwrappedInterval), referenceFrame);
            } else {
                object[propertyName] = createReferenceProperty(entityCollection, packetData.reference);
            }
            return;
        }

        var property = object[propertyName];

        var epoch;
        var packetEpoch = packetData.epoch;
        if (defined(packetEpoch)) {
            epoch = JulianDate.fromIso8601(packetEpoch);
        }

        //Without an interval, any sampled value is infinite, meaning it completely
        //replaces any non-sampled property that may exist.
        if (isSampled && !hasInterval) {
            if (!(property instanceof SampledPositionProperty) || (defined(referenceFrame) && property.referenceFrame !== referenceFrame)) {
                property = new SampledPositionProperty(referenceFrame, numberOfDerivatives);
                object[propertyName] = property;
            }
            property.addSamplesPackedArray(unwrappedInterval, epoch);
            updateInterpolationSettings(packetData, property);
            return;
        }

        var interval;

        //A constant value with an interval is normally part of a TimeIntervalCollection,
        //However, if the current property is not a time-interval collection, we need
        //to turn it into a Composite, preserving the old data with the new interval.
        if (!isSampled && hasInterval) {
            //Create a new interval for the constant value.
            combinedInterval = combinedInterval.clone();
            if (isValue) {
                combinedInterval.data = Cartesian3.unpack(unwrappedInterval);
            } else {
                combinedInterval.data = createReferenceProperty(entityCollection, packetData.reference);
            }

            //If no property exists, simply use a new interval collection
            if (!defined(property)) {
                if (isValue) {
                    property = new TimeIntervalCollectionPositionProperty(referenceFrame);
                } else {
                    property = new CompositePositionProperty(referenceFrame);
                }
                object[propertyName] = property;
            }

            if (isValue && property instanceof TimeIntervalCollectionPositionProperty && (defined(referenceFrame) && property.referenceFrame === referenceFrame)) {
                //If we create a collection, or it already existed, use it.
                property.intervals.addInterval(combinedInterval);
            } else if (property instanceof CompositePositionProperty) {
                //If the collection was already a CompositePositionProperty, use it.
                if (isValue) {
                    combinedInterval.data = new ConstantPositionProperty(combinedInterval.data, referenceFrame);
                }
                property.intervals.addInterval(combinedInterval);
            } else {
                //Otherwise, create a CompositePositionProperty but preserve the existing data.

                //Put the old property in an infinite interval.
                interval = Iso8601.MAXIMUM_INTERVAL.clone();
                interval.data = property;

                //Create the composite.
                property = new CompositePositionProperty(property.referenceFrame);
                object[propertyName] = property;

                //add the old property interval
                property.intervals.addInterval(interval);

                //Change the new data to a ConstantPositionProperty and add it.
                if (isValue) {
                    combinedInterval.data = new ConstantPositionProperty(combinedInterval.data, referenceFrame);
                }
                property.intervals.addInterval(combinedInterval);
            }

            return;
        }

        //isSampled && hasInterval
        if (!defined(property)) {
            property = new CompositePositionProperty(referenceFrame);
            object[propertyName] = property;
        } else if (!(property instanceof CompositePositionProperty)) {
            //create a CompositeProperty but preserve the existing data.
            //Put the old property in an infinite interval.
            interval = Iso8601.MAXIMUM_INTERVAL.clone();
            interval.data = property;

            //Create the composite.
            property = new CompositePositionProperty(property.referenceFrame);
            object[propertyName] = property;

            //add the old property interval
            property.intervals.addInterval(interval);
        }

        //Check if the interval already exists in the composite
        var intervals = property.intervals;
        interval = intervals.findInterval(combinedInterval);
        if (!defined(interval) || !(interval.data instanceof SampledPositionProperty) || (defined(referenceFrame) && interval.data.referenceFrame !== referenceFrame)) {
            //If not, create a SampledPositionProperty for it.
            interval = combinedInterval.clone();
            interval.data = new SampledPositionProperty(referenceFrame, numberOfDerivatives);
            intervals.addInterval(interval);
        }
        interval.data.addSamplesPackedArray(unwrappedInterval, epoch);
        updateInterpolationSettings(packetData, interval.data);
    }

    function processPositionPacketData(object, propertyName, packetData, interval, sourceUri, entityCollection) {
        if (!defined(packetData)) {
            return;
        }

        if (isArray(packetData)) {
            for (var i = 0, len = packetData.length; i < len; i++) {
                processPositionProperty(object, propertyName, packetData[i], interval, sourceUri, entityCollection);
            }
        } else {
            processPositionProperty(object, propertyName, packetData, interval, sourceUri, entityCollection);
        }
    }

    function processMaterialProperty(object, propertyName, packetData, constrainedInterval, sourceUri, entityCollection) {
        var combinedInterval;
        var packetInterval = packetData.interval;
        if (defined(packetInterval)) {
            iso8601Scratch.iso8601 = packetInterval;
            combinedInterval = TimeInterval.fromIso8601(iso8601Scratch);
            if (defined(constrainedInterval)) {
                combinedInterval = TimeInterval.intersect(combinedInterval, constrainedInterval, scratchTimeInterval);
            }
        } else if (defined(constrainedInterval)) {
            combinedInterval = constrainedInterval;
        }

        var property = object[propertyName];
        var existingMaterial;
        var existingInterval;

        if (defined(combinedInterval)) {
            if (!(property instanceof CompositeMaterialProperty)) {
                property = new CompositeMaterialProperty();
                object[propertyName] = property;
            }
            //See if we already have data at that interval.
            var thisIntervals = property.intervals;
            existingInterval = thisIntervals.findInterval({
                start : combinedInterval.start,
                stop : combinedInterval.stop
            });
            if (defined(existingInterval)) {
                //We have an interval, but we need to make sure the
                //new data is the same type of material as the old data.
                existingMaterial = existingInterval.data;
            } else {
                //If not, create it.
                existingInterval = combinedInterval.clone();
                thisIntervals.addInterval(existingInterval);
            }
        } else {
            existingMaterial = property;
        }

        var materialData;
        if (defined(packetData.solidColor)) {
            if (!(existingMaterial instanceof ColorMaterialProperty)) {
                existingMaterial = new ColorMaterialProperty();
            }
            materialData = packetData.solidColor;
            processPacketData(Color, existingMaterial, 'color', materialData.color, undefined, undefined, entityCollection);
        } else if (defined(packetData.grid)) {
            if (!(existingMaterial instanceof GridMaterialProperty)) {
                existingMaterial = new GridMaterialProperty();
            }
            materialData = packetData.grid;
            processPacketData(Color, existingMaterial, 'color', materialData.color, undefined, sourceUri, entityCollection);
            processPacketData(Number, existingMaterial, 'cellAlpha', materialData.cellAlpha, undefined, sourceUri, entityCollection);
            processPacketData(Cartesian2, existingMaterial, 'lineCount', materialData.lineCount, undefined, sourceUri, entityCollection);
            processPacketData(Cartesian2, existingMaterial, 'lineThickness', materialData.lineThickness, undefined, sourceUri, entityCollection);
            processPacketData(Cartesian2, existingMaterial, 'lineOffset', materialData.lineOffset, undefined, sourceUri, entityCollection);
        } else if (defined(packetData.image)) {
            if (!(existingMaterial instanceof ImageMaterialProperty)) {
                existingMaterial = new ImageMaterialProperty();
            }
            materialData = packetData.image;
            processPacketData(Image, existingMaterial, 'image', materialData.image, undefined, sourceUri, entityCollection);
            processPacketData(Cartesian2, existingMaterial, 'repeat', materialData.repeat, undefined, sourceUri, entityCollection);
            processPacketData(Color, existingMaterial, 'color', materialData.color, undefined, sourceUri, entityCollection);
            processPacketData(Boolean, existingMaterial, 'transparent', materialData.transparent, undefined, sourceUri, entityCollection);
        } else if (defined(packetData.stripe)) {
            if (!(existingMaterial instanceof StripeMaterialProperty)) {
                existingMaterial = new StripeMaterialProperty();
            }
            materialData = packetData.stripe;
            processPacketData(StripeOrientation, existingMaterial, 'orientation', materialData.orientation, undefined, sourceUri, entityCollection);
            processPacketData(Color, existingMaterial, 'evenColor', materialData.evenColor, undefined, sourceUri, entityCollection);
            processPacketData(Color, existingMaterial, 'oddColor', materialData.oddColor, undefined, sourceUri, entityCollection);
            processPacketData(Number, existingMaterial, 'offset', materialData.offset, undefined, sourceUri, entityCollection);
            processPacketData(Number, existingMaterial, 'repeat', materialData.repeat, undefined, sourceUri, entityCollection);
        } else if (defined(packetData.polylineOutline)) {
            if (!(existingMaterial instanceof PolylineOutlineMaterialProperty)) {
                existingMaterial = new PolylineOutlineMaterialProperty();
            }
            materialData = packetData.polylineOutline;
            processPacketData(Color, existingMaterial, 'color', materialData.color, undefined, sourceUri, entityCollection);
            processPacketData(Color, existingMaterial, 'outlineColor', materialData.outlineColor, undefined, sourceUri, entityCollection);
            processPacketData(Number, existingMaterial, 'outlineWidth', materialData.outlineWidth, undefined, sourceUri, entityCollection);
        } else if (defined(packetData.polylineGlow)) {
            if (!(existingMaterial instanceof PolylineGlowMaterialProperty)) {
                existingMaterial = new PolylineGlowMaterialProperty();
            }
            materialData = packetData.polylineGlow;
            processPacketData(Color, existingMaterial, 'color', materialData.color, undefined, sourceUri, entityCollection);
            processPacketData(Number, existingMaterial, 'glowPower', materialData.glowPower, undefined, sourceUri, entityCollection);
        } else if (defined(packetData.polylineArrow)) {
            if (!(existingMaterial instanceof PolylineArrowMaterialProperty)) {
                existingMaterial = new PolylineArrowMaterialProperty();
            }
            materialData = packetData.polylineArrow;
            processPacketData(Color, existingMaterial, 'color', materialData.color, undefined, undefined, entityCollection);
        } else if (defined(packetData.polylineDash)) {
            if (!(existingMaterial instanceof PolylineDashMaterialProperty)) {
                existingMaterial = new PolylineDashMaterialProperty();
            }
            materialData = packetData.polylineDash;
            processPacketData(Color, existingMaterial, 'color', materialData.color, undefined, undefined, entityCollection);
            processPacketData(Color, existingMaterial, 'gapColor', materialData.gapColor, undefined, undefined, entityCollection);
            processPacketData(Number, existingMaterial, 'dashLength', materialData.dashLength, undefined, sourceUri, entityCollection);
            processPacketData(Number, existingMaterial, 'dashPattern', materialData.dashPattern, undefined, sourceUri, entityCollection);
        }

        if (defined(existingInterval)) {
            existingInterval.data = existingMaterial;
        } else {
            object[propertyName] = existingMaterial;
        }
    }

    function processMaterialPacketData(object, propertyName, packetData, interval, sourceUri, entityCollection) {
        if (!defined(packetData)) {
            return;
        }

        if (isArray(packetData)) {
            for (var i = 0, len = packetData.length; i < len; i++) {
                processMaterialProperty(object, propertyName, packetData[i], interval, sourceUri, entityCollection);
            }
        } else {
            processMaterialProperty(object, propertyName, packetData, interval, sourceUri, entityCollection);
        }
    }

    function processName(entity, packet, entityCollection, sourceUri) {
        entity.name = defaultValue(packet.name, entity.name);
    }

    function processDescription(entity, packet, entityCollection, sourceUri) {
        var descriptionData = packet.description;
        if (defined(descriptionData)) {
            processPacketData(String, entity, 'description', descriptionData, undefined, sourceUri, entityCollection);
        }
    }

    function processPosition(entity, packet, entityCollection, sourceUri) {
        var positionData = packet.position;
        if (defined(positionData)) {
            processPositionPacketData(entity, 'position', positionData, undefined, sourceUri, entityCollection);
        }
    }

    function processViewFrom(entity, packet, entityCollection, sourceUri) {
        var viewFromData = packet.viewFrom;
        if (defined(viewFromData)) {
            processPacketData(Cartesian3, entity, 'viewFrom', viewFromData, undefined, sourceUri, entityCollection);
        }
    }

    function processOrientation(entity, packet, entityCollection, sourceUri) {
        var orientationData = packet.orientation;
        if (defined(orientationData)) {
            processPacketData(Quaternion, entity, 'orientation', orientationData, undefined, sourceUri, entityCollection);
        }
    }

    function processProperties(entity, packet, entityCollection, sourceUri) {
        var propertiesData = packet.properties;
        if (defined(propertiesData)) {
            if (!defined(entity.properties)) {
                entity.properties = new PropertyBag();
            }
            //We cannot simply call processPacketData(entity, 'properties', propertyData, undefined, sourceUri, entityCollection)
            //because each property of "properties" may vary separately.
            //The properties will be accessible as entity.properties.myprop.getValue(time).

            for (var key in propertiesData) {
                if (propertiesData.hasOwnProperty(key)) {
                    if (!entity.properties.hasProperty(key)) {
                        entity.properties.addProperty(key);
                    }

                    var propertyData = propertiesData[key];
                    if (isArray(propertyData)) {
                        for (var i = 0, len = propertyData.length; i < len; i++) {
                            processProperty(getPropertyType(propertyData[i]), entity.properties, key, propertyData[i], undefined, sourceUri, entityCollection);
                        }
                    } else {
                        processProperty(getPropertyType(propertyData), entity.properties, key, propertyData, undefined, sourceUri, entityCollection);
                    }
                }
            }
        }
    }

    function processArrayPacketData(object, propertyName, packetData, entityCollection) {
        var references = packetData.references;
        if (defined(references)) {
            var properties = references.map(function(reference) {
                return createReferenceProperty(entityCollection, reference);
            });

            var iso8601Interval = packetData.interval;
            if (defined(iso8601Interval)) {
                iso8601Interval = TimeInterval.fromIso8601(iso8601Interval);
                if (!(object[propertyName] instanceof CompositePositionProperty)) {
                    iso8601Interval.data = new PropertyArray(properties);
                    var property = new CompositeProperty();
                    property.intervals.addInterval(iso8601Interval);
                    object[propertyName] = property;
                }
            } else {
                object[propertyName] = new PropertyArray(properties);
            }
        } else {
            processPacketData(Array, object, propertyName, packetData, undefined, undefined, entityCollection);
        }
    }

    function processArray(object, propertyName, packetData, entityCollection) {
        if (!defined(packetData)) {
            return;
        }

        if (isArray(packetData)) {
            for (var i = 0, length = packetData.length; i < length; ++i) {
                processArrayPacketData(object, propertyName, packetData[i], entityCollection);
            }
        } else {
            processArrayPacketData(object, propertyName, packetData, entityCollection);
        }
    }

    function processPositionsPacketData(object, propertyName, positionsData, entityCollection) {
        if (defined(positionsData.references)) {
            var properties = positionsData.references.map(function(reference) {
                return createReferenceProperty(entityCollection, reference);
            });

            var iso8601Interval = positionsData.interval;
            if (defined(iso8601Interval)) {
                iso8601Interval = TimeInterval.fromIso8601(iso8601Interval);
                if (!(object[propertyName] instanceof CompositePositionProperty)) {
                    iso8601Interval.data = new PositionPropertyArray(properties);
                    var property = new CompositePositionProperty();
                    property.intervals.addInterval(iso8601Interval);
                    object[propertyName] = property;
                }
            } else {
                object[propertyName] = new PositionPropertyArray(properties);
            }
        } else {
            if (defined(positionsData.cartesian)) {
                positionsData.array = Cartesian3.unpackArray(positionsData.cartesian);
            } else if (defined(positionsData.cartographicRadians)) {
                positionsData.array = Cartesian3.fromRadiansArrayHeights(positionsData.cartographicRadians);
            } else if (defined(positionsData.cartographicDegrees)) {
                positionsData.array = Cartesian3.fromDegreesArrayHeights(positionsData.cartographicDegrees);
            }

            if (defined(positionsData.array)) {
                processPacketData(Array, object, propertyName, positionsData, undefined, undefined, entityCollection);
            }
        }
    }

    function processPositions(object, propertyName, positionsData, entityCollection) {
        if (!defined(positionsData)) {
            return;
        }

        if (isArray(positionsData)) {
            for (var i = 0, length = positionsData.length; i < length; i++) {
                processPositionsPacketData(object, propertyName, positionsData[i], entityCollection);
            }
        } else {
            processPositionsPacketData(object, propertyName, positionsData, entityCollection);
        }
    }

    function processAvailability(entity, packet, entityCollection, sourceUri) {
        var interval;
        var packetData = packet.availability;
        if (!defined(packetData)) {
            return;
        }

        var intervals;
        if (isArray(packetData)) {
            var length = packetData.length;
            for (var i = 0; i < length; i++) {
                if (!defined(intervals)) {
                    intervals = new TimeIntervalCollection();
                }
                iso8601Scratch.iso8601 = packetData[i];
                interval = TimeInterval.fromIso8601(iso8601Scratch);
                intervals.addInterval(interval);
            }
        } else {
            iso8601Scratch.iso8601 = packetData;
            interval = TimeInterval.fromIso8601(iso8601Scratch);
            intervals = new TimeIntervalCollection();
            intervals.addInterval(interval);
        }
        entity.availability = intervals;
    }

    function processAlignedAxis(billboard, packetData, interval, sourceUri, entityCollection) {
        if (!defined(packetData)) {
            return;
        }

        processPacketData(UnitCartesian3, billboard, 'alignedAxis', packetData, interval, sourceUri, entityCollection);
    }

    function processBillboard(entity, packet, entityCollection, sourceUri) {
        var billboardData = packet.billboard;
        if (!defined(billboardData)) {
            return;
        }

        var interval;
        var intervalString = billboardData.interval;
        if (defined(intervalString)) {
            iso8601Scratch.iso8601 = intervalString;
            interval = TimeInterval.fromIso8601(iso8601Scratch);
        }

        var billboard = entity.billboard;
        if (!defined(billboard)) {
            entity.billboard = billboard = new BillboardGraphics();
        }

        processPacketData(Boolean, billboard, 'show', billboardData.show, interval, sourceUri, entityCollection);
        processPacketData(Image, billboard, 'image', billboardData.image, interval, sourceUri, entityCollection);
        processPacketData(Number, billboard, 'scale', billboardData.scale, interval, sourceUri, entityCollection);
        processPacketData(Cartesian2, billboard, 'pixelOffset', billboardData.pixelOffset, interval, sourceUri, entityCollection);
        processPacketData(Cartesian3, billboard, 'eyeOffset', billboardData.eyeOffset, interval, sourceUri, entityCollection);
        processPacketData(HorizontalOrigin, billboard, 'horizontalOrigin', billboardData.horizontalOrigin, interval, sourceUri, entityCollection);
        processPacketData(VerticalOrigin, billboard, 'verticalOrigin', billboardData.verticalOrigin, interval, sourceUri, entityCollection);
        processPacketData(HeightReference, billboard, 'heightReference', billboardData.heightReference, interval, sourceUri, entityCollection);
        processPacketData(Color, billboard, 'color', billboardData.color, interval, sourceUri, entityCollection);
        processPacketData(Rotation, billboard, 'rotation', billboardData.rotation, interval, sourceUri, entityCollection);
        processAlignedAxis(billboard, billboardData.alignedAxis, interval, sourceUri, entityCollection);
        processPacketData(Boolean, billboard, 'sizeInMeters', billboardData.sizeInMeters, interval, sourceUri, entityCollection);
        processPacketData(Number, billboard, 'width', billboardData.width, interval, sourceUri, entityCollection);
        processPacketData(Number, billboard, 'height', billboardData.height, interval, sourceUri, entityCollection);
        processPacketData(NearFarScalar, billboard, 'scaleByDistance', billboardData.scaleByDistance, interval, sourceUri, entityCollection);
        processPacketData(NearFarScalar, billboard, 'translucencyByDistance', billboardData.translucencyByDistance, interval, sourceUri, entityCollection);
        processPacketData(NearFarScalar, billboard, 'pixelOffsetScaleByDistance', billboardData.pixelOffsetScaleByDistance, interval, sourceUri, entityCollection);
        processPacketData(BoundingRectangle, billboard, 'imageSubRegion', billboardData.imageSubRegion, interval, sourceUri, entityCollection);
        processPacketData(DistanceDisplayCondition, billboard, 'distanceDisplayCondition', billboardData.distanceDisplayCondition, interval, sourceUri, entityCollection);
        processPacketData(Number, billboard, 'disableDepthTestDistance', billboardData.disableDepthTestDistance, interval, sourceUri, entityCollection);
    }

    function processBox(entity, packet, entityCollection, sourceUri) {
        var boxData = packet.box;
        if (!defined(boxData)) {
            return;
        }

        var interval;
        var intervalString = boxData.interval;
        if (defined(intervalString)) {
            iso8601Scratch.iso8601 = intervalString;
            interval = TimeInterval.fromIso8601(iso8601Scratch);
        }

        var box = entity.box;
        if (!defined(box)) {
            entity.box = box = new BoxGraphics();
        }

        processPacketData(Boolean, box, 'show', boxData.show, interval, sourceUri, entityCollection);
        processPacketData(Cartesian3, box, 'dimensions', boxData.dimensions, interval, sourceUri, entityCollection);
        processPacketData(Boolean, box, 'fill', boxData.fill, interval, sourceUri, entityCollection);
        processMaterialPacketData(box, 'material', boxData.material, interval, sourceUri, entityCollection);
        processPacketData(Boolean, box, 'outline', boxData.outline, interval, sourceUri, entityCollection);
        processPacketData(Color, box, 'outlineColor', boxData.outlineColor, interval, sourceUri, entityCollection);
        processPacketData(Number, box, 'outlineWidth', boxData.outlineWidth, interval, sourceUri, entityCollection);
        processPacketData(ShadowMode, box, 'shadows', boxData.shadows, interval, sourceUri, entityCollection);
        processPacketData(DistanceDisplayCondition, box, 'distanceDisplayCondition', boxData.distanceDisplayCondition, interval, sourceUri, entityCollection);
    }

    function processCorridor(entity, packet, entityCollection, sourceUri) {
        var corridorData = packet.corridor;
        if (!defined(corridorData)) {
            return;
        }

        var interval;
        var intervalString = corridorData.interval;
        if (defined(intervalString)) {
            iso8601Scratch.iso8601 = intervalString;
            interval = TimeInterval.fromIso8601(iso8601Scratch);
        }

        var corridor = entity.corridor;
        if (!defined(corridor)) {
            entity.corridor = corridor = new CorridorGraphics();
        }

        processPacketData(Boolean, corridor, 'show', corridorData.show, interval, sourceUri, entityCollection);
        processPositions(corridor, 'positions', corridorData.positions, entityCollection);
        processPacketData(Number, corridor, 'width', corridorData.width, interval, sourceUri, entityCollection);
        processPacketData(Number, corridor, 'height', corridorData.height, interval, sourceUri, entityCollection);
        processPacketData(Number, corridor, 'extrudedHeight', corridorData.extrudedHeight, interval, sourceUri, entityCollection);
        processPacketData(CornerType, corridor, 'cornerType', corridorData.cornerType, interval, sourceUri, entityCollection);
        processPacketData(Number, corridor, 'granularity', corridorData.granularity, interval, sourceUri, entityCollection);
        processPacketData(Boolean, corridor, 'fill', corridorData.fill, interval, sourceUri, entityCollection);
        processMaterialPacketData(corridor, 'material', corridorData.material, interval, sourceUri, entityCollection);
        processPacketData(Boolean, corridor, 'outline', corridorData.outline, interval, sourceUri, entityCollection);
        processPacketData(Color, corridor, 'outlineColor', corridorData.outlineColor, interval, sourceUri, entityCollection);
        processPacketData(Number, corridor, 'outlineWidth', corridorData.outlineWidth, interval, sourceUri, entityCollection);
        processPacketData(ShadowMode, corridor, 'shadows', corridorData.shadows, interval, sourceUri, entityCollection);
        processPacketData(DistanceDisplayCondition, corridor, 'distanceDisplayCondition', corridorData.distanceDisplayCondition, interval, sourceUri, entityCollection);
        processPacketData(Number, corridor, 'zIndex', corridorData.zIndex, interval, sourceUri, entityCollection);
    }

    function processCylinder(entity, packet, entityCollection, sourceUri) {
        var cylinderData = packet.cylinder;
        if (!defined(cylinderData)) {
            return;
        }

        var interval;
        var intervalString = cylinderData.interval;
        if (defined(intervalString)) {
            iso8601Scratch.iso8601 = intervalString;
            interval = TimeInterval.fromIso8601(iso8601Scratch);
        }

        var cylinder = entity.cylinder;
        if (!defined(cylinder)) {
            entity.cylinder = cylinder = new CylinderGraphics();
        }

        processPacketData(Boolean, cylinder, 'show', cylinderData.show, interval, sourceUri, entityCollection);
        processPacketData(Number, cylinder, 'length', cylinderData.length, interval, sourceUri, entityCollection);
        processPacketData(Number, cylinder, 'topRadius', cylinderData.topRadius, interval, sourceUri, entityCollection);
        processPacketData(Number, cylinder, 'bottomRadius', cylinderData.bottomRadius, interval, sourceUri, entityCollection);
        processPacketData(Boolean, cylinder, 'fill', cylinderData.fill, interval, sourceUri, entityCollection);
        processMaterialPacketData(cylinder, 'material', cylinderData.material, interval, sourceUri, entityCollection);
        processPacketData(Boolean, cylinder, 'outline', cylinderData.outline, interval, sourceUri, entityCollection);
        processPacketData(Color, cylinder, 'outlineColor', cylinderData.outlineColor, interval, sourceUri, entityCollection);
        processPacketData(Number, cylinder, 'outlineWidth', cylinderData.outlineWidth, interval, sourceUri, entityCollection);
        processPacketData(Number, cylinder, 'numberOfVerticalLines', cylinderData.numberOfVerticalLines, interval, sourceUri, entityCollection);
        processPacketData(Number, cylinder, 'slices', cylinderData.slices, interval, sourceUri, entityCollection);
        processPacketData(ShadowMode, cylinder, 'shadows', cylinderData.shadows, interval, sourceUri, entityCollection);
        processPacketData(DistanceDisplayCondition, cylinder, 'distanceDisplayCondition', cylinderData.distanceDisplayCondition, interval, sourceUri, entityCollection);
    }

    function processDocument(packet, dataSource) {
        var version = packet.version;
        if (defined(version)) {
            if (typeof version === 'string') {
                var tokens = version.split('.');
                if (tokens.length === 2) {
                    if (tokens[0] !== '1') {
                        throw new RuntimeError('Cesium only supports CZML version 1.');
                    }
                    dataSource._version = version;
                }
            }
        }

        if (!defined(dataSource._version)) {
            throw new RuntimeError('CZML version information invalid.  It is expected to be a property on the document object in the <Major>.<Minor> version format.');
        }

        var documentPacket = dataSource._documentPacket;

        if (defined(packet.name)) {
            documentPacket.name = packet.name;
        }

        var clockPacket = packet.clock;
        if (defined(clockPacket)) {
            var clock = documentPacket.clock;
            if (!defined(clock)) {
                documentPacket.clock = {
                    interval : clockPacket.interval,
                    currentTime : clockPacket.currentTime,
                    range : clockPacket.range,
                    step : clockPacket.step,
                    multiplier : clockPacket.multiplier
                };
            } else {
                clock.interval = defaultValue(clockPacket.interval, clock.interval);
                clock.currentTime = defaultValue(clockPacket.currentTime, clock.currentTime);
                clock.range = defaultValue(clockPacket.range, clock.range);
                clock.step = defaultValue(clockPacket.step, clock.step);
                clock.multiplier = defaultValue(clockPacket.multiplier, clock.multiplier);
            }
        }
    }

    function processEllipse(entity, packet, entityCollection, sourceUri) {
        var ellipseData = packet.ellipse;
        if (!defined(ellipseData)) {
            return;
        }

        var interval;
        var intervalString = ellipseData.interval;
        if (defined(intervalString)) {
            iso8601Scratch.iso8601 = intervalString;
            interval = TimeInterval.fromIso8601(iso8601Scratch);
        }

        var ellipse = entity.ellipse;
        if (!defined(ellipse)) {
            entity.ellipse = ellipse = new EllipseGraphics();
        }

        processPacketData(Boolean, ellipse, 'show', ellipseData.show, interval, sourceUri, entityCollection);
        processPacketData(Number, ellipse, 'semiMajorAxis', ellipseData.semiMajorAxis, interval, sourceUri, entityCollection);
        processPacketData(Number, ellipse, 'semiMinorAxis', ellipseData.semiMinorAxis, interval, sourceUri, entityCollection);
        processPacketData(Number, ellipse, 'height', ellipseData.height, interval, sourceUri, entityCollection);
        processPacketData(Number, ellipse, 'extrudedHeight', ellipseData.extrudedHeight, interval, sourceUri, entityCollection);
        processPacketData(Rotation, ellipse, 'rotation', ellipseData.rotation, interval, sourceUri, entityCollection);
        processPacketData(Rotation, ellipse, 'stRotation', ellipseData.stRotation, interval, sourceUri, entityCollection);
        processPacketData(Number, ellipse, 'granularity', ellipseData.granularity, interval, sourceUri, entityCollection);
        processPacketData(Boolean, ellipse, 'fill', ellipseData.fill, interval, sourceUri, entityCollection);
        processMaterialPacketData(ellipse, 'material', ellipseData.material, interval, sourceUri, entityCollection);
        processPacketData(Boolean, ellipse, 'outline', ellipseData.outline, interval, sourceUri, entityCollection);
        processPacketData(Color, ellipse, 'outlineColor', ellipseData.outlineColor, interval, sourceUri, entityCollection);
        processPacketData(Number, ellipse, 'outlineWidth', ellipseData.outlineWidth, interval, sourceUri, entityCollection);
        processPacketData(Number, ellipse, 'numberOfVerticalLines', ellipseData.numberOfVerticalLines, interval, sourceUri, entityCollection);
        processPacketData(ShadowMode, ellipse, 'shadows', ellipseData.shadows, interval, sourceUri, entityCollection);
        processPacketData(DistanceDisplayCondition, ellipse, 'distanceDisplayCondition', ellipseData.distanceDisplayCondition, interval, sourceUri, entityCollection);
        processPacketData(Number, ellipse, 'zIndex', ellipseData.zIndex, interval, sourceUri, entityCollection);
    }

    function processEllipsoid(entity, packet, entityCollection, sourceUri) {
        var ellipsoidData = packet.ellipsoid;
        if (!defined(ellipsoidData)) {
            return;
        }

        var interval;
        var intervalString = ellipsoidData.interval;
        if (defined(intervalString)) {
            iso8601Scratch.iso8601 = intervalString;
            interval = TimeInterval.fromIso8601(iso8601Scratch);
        }

        var ellipsoid = entity.ellipsoid;
        if (!defined(ellipsoid)) {
            entity.ellipsoid = ellipsoid = new EllipsoidGraphics();
        }

        processPacketData(Boolean, ellipsoid, 'show', ellipsoidData.show, interval, sourceUri, entityCollection);
        processPacketData(Cartesian3, ellipsoid, 'radii', ellipsoidData.radii, interval, sourceUri, entityCollection);
        processPacketData(Boolean, ellipsoid, 'fill', ellipsoidData.fill, interval, sourceUri, entityCollection);
        processMaterialPacketData(ellipsoid, 'material', ellipsoidData.material, interval, sourceUri, entityCollection);
        processPacketData(Boolean, ellipsoid, 'outline', ellipsoidData.outline, interval, sourceUri, entityCollection);
        processPacketData(Color, ellipsoid, 'outlineColor', ellipsoidData.outlineColor, interval, sourceUri, entityCollection);
        processPacketData(Number, ellipsoid, 'outlineWidth', ellipsoidData.outlineWidth, interval, sourceUri, entityCollection);
        processPacketData(Number, ellipsoid, 'stackPartitions', ellipsoidData.stackPartitions, interval, sourceUri, entityCollection);
        processPacketData(Number, ellipsoid, 'slicePartitions', ellipsoidData.slicePartitions, interval, sourceUri, entityCollection);
        processPacketData(Number, ellipsoid, 'subdivisions', ellipsoidData.subdivisions, interval, sourceUri, entityCollection);
        processPacketData(ShadowMode, ellipsoid, 'shadows', ellipsoidData.shadows, interval, sourceUri, entityCollection);
        processPacketData(DistanceDisplayCondition, ellipsoid, 'distanceDisplayCondition', ellipsoidData.distanceDisplayCondition, interval, sourceUri, entityCollection);
    }

    function processLabel(entity, packet, entityCollection, sourceUri) {
        var labelData = packet.label;
        if (!defined(labelData)) {
            return;
        }

        var interval;
        var intervalString = labelData.interval;
        if (defined(intervalString)) {
            iso8601Scratch.iso8601 = intervalString;
            interval = TimeInterval.fromIso8601(iso8601Scratch);
        }

        var label = entity.label;
        if (!defined(label)) {
            entity.label = label = new LabelGraphics();
        }

        processPacketData(Boolean, label, 'show', labelData.show, interval, sourceUri, entityCollection);
        processPacketData(String, label, 'text', labelData.text, interval, sourceUri, entityCollection);
        processPacketData(String, label, 'font', labelData.font, interval, sourceUri, entityCollection);
        processPacketData(LabelStyle, label, 'style', labelData.style, interval, sourceUri, entityCollection);
        processPacketData(Number, label, 'scale', labelData.scale, interval, sourceUri, entityCollection);
        processPacketData(Boolean, label, 'showBackground', labelData.showBackground, interval, sourceUri, entityCollection);
        processPacketData(Color, label, 'backgroundColor', labelData.backgroundColor, interval, sourceUri, entityCollection);
        processPacketData(Cartesian2, label, 'backgroundPadding', labelData.backgroundPadding, interval, sourceUri, entityCollection);
        processPacketData(Cartesian2, label, 'pixelOffset', labelData.pixelOffset, interval, sourceUri, entityCollection);
        processPacketData(Cartesian3, label, 'eyeOffset', labelData.eyeOffset, interval, sourceUri, entityCollection);
        processPacketData(HorizontalOrigin, label, 'horizontalOrigin', labelData.horizontalOrigin, interval, sourceUri, entityCollection);
        processPacketData(VerticalOrigin, label, 'verticalOrigin', labelData.verticalOrigin, interval, sourceUri, entityCollection);
        processPacketData(HeightReference, label, 'heightReference', labelData.heightReference, interval, sourceUri, entityCollection);
        processPacketData(Color, label, 'fillColor', labelData.fillColor, interval, sourceUri, entityCollection);
        processPacketData(Color, label, 'outlineColor', labelData.outlineColor, interval, sourceUri, entityCollection);
        processPacketData(Number, label, 'outlineWidth', labelData.outlineWidth, interval, sourceUri, entityCollection);
        processPacketData(NearFarScalar, label, 'translucencyByDistance', labelData.translucencyByDistance, interval, sourceUri, entityCollection);
        processPacketData(NearFarScalar, label, 'pixelOffsetScaleByDistance', labelData.pixelOffsetScaleByDistance, interval, sourceUri, entityCollection);
        processPacketData(NearFarScalar, label, 'scaleByDistance', labelData.scaleByDistance, interval, sourceUri, entityCollection);
        processPacketData(DistanceDisplayCondition, label, 'distanceDisplayCondition', labelData.distanceDisplayCondition, interval, sourceUri, entityCollection);
        processPacketData(Number, label, 'disableDepthTestDistance', labelData.disableDepthTestDistance, interval, sourceUri, entityCollection);
    }

    function processModel(entity, packet, entityCollection, sourceUri) {
        var modelData = packet.model;
        if (!defined(modelData)) {
            return;
        }

        var interval;
        var intervalString = modelData.interval;
        if (defined(intervalString)) {
            iso8601Scratch.iso8601 = intervalString;
            interval = TimeInterval.fromIso8601(iso8601Scratch);
        }

        var model = entity.model;
        if (!defined(model)) {
            entity.model = model = new ModelGraphics();
        }

        processPacketData(Boolean, model, 'show', modelData.show, interval, sourceUri, entityCollection);
        processPacketData(Uri, model, 'uri', modelData.gltf, interval, sourceUri, entityCollection);
        processPacketData(Number, model, 'scale', modelData.scale, interval, sourceUri, entityCollection);
        processPacketData(Number, model, 'minimumPixelSize', modelData.minimumPixelSize, interval, sourceUri, entityCollection);
        processPacketData(Number, model, 'maximumScale', modelData.maximumScale, interval, sourceUri, entityCollection);
        processPacketData(Boolean, model, 'incrementallyLoadTextures', modelData.incrementallyLoadTextures, interval, sourceUri, entityCollection);
        processPacketData(Boolean, model, 'runAnimations', modelData.runAnimations, interval, sourceUri, entityCollection);
        processPacketData(Boolean, model, 'clampAnimations', modelData.clampAnimations, interval, sourceUri, entityCollection);
        processPacketData(ShadowMode, model, 'shadows', modelData.shadows, interval, sourceUri, entityCollection);
        processPacketData(HeightReference, model, 'heightReference', modelData.heightReference, interval, sourceUri, entityCollection);
        processPacketData(Color, model, 'silhouetteColor', modelData.silhouetteColor, interval, sourceUri, entityCollection);
        processPacketData(Number, model, 'silhouetteSize', modelData.silhouetteSize, interval, sourceUri, entityCollection);
        processPacketData(Color, model, 'color', modelData.color, interval, sourceUri, entityCollection);
        processPacketData(ColorBlendMode, model, 'colorBlendMode', modelData.colorBlendMode, interval, sourceUri, entityCollection);
        processPacketData(Number, model, 'colorBlendAmount', modelData.colorBlendAmount, interval, sourceUri, entityCollection);
        processPacketData(DistanceDisplayCondition, model, 'distanceDisplayCondition', modelData.distanceDisplayCondition, interval, sourceUri, entityCollection);

        var nodeTransformationsData = modelData.nodeTransformations;
        if (defined(nodeTransformationsData)) {
            if (isArray(nodeTransformationsData)) {
                for (var i = 0, len = nodeTransformationsData.length; i < len; i++) {
                    processNodeTransformations(model, nodeTransformationsData[i], interval, sourceUri, entityCollection);
                }
            } else {
                processNodeTransformations(model, nodeTransformationsData, interval, sourceUri, entityCollection);
            }
        }
    }

    function processNodeTransformations(model, nodeTransformationsData, constrainedInterval, sourceUri, entityCollection) {
        var combinedInterval;
        var packetInterval = nodeTransformationsData.interval;
        if (defined(packetInterval)) {
            iso8601Scratch.iso8601 = packetInterval;
            combinedInterval = TimeInterval.fromIso8601(iso8601Scratch);
            if (defined(constrainedInterval)) {
                combinedInterval = TimeInterval.intersect(combinedInterval, constrainedInterval, scratchTimeInterval);
            }
        } else if (defined(constrainedInterval)) {
            combinedInterval = constrainedInterval;
        }

        var nodeTransformations = model.nodeTransformations;
        var nodeNames = Object.keys(nodeTransformationsData);
        for (var i = 0, len = nodeNames.length; i < len; ++i) {
            var nodeName = nodeNames[i];

            if (nodeName === 'interval') {
                continue;
            }

            var nodeTransformationData = nodeTransformationsData[nodeName];

            if (!defined(nodeTransformationData)) {
                continue;
            }

            if (!defined(nodeTransformations)) {
                model.nodeTransformations = nodeTransformations = new PropertyBag();
            }

            if (!nodeTransformations.hasProperty(nodeName)) {
                nodeTransformations.addProperty(nodeName);
            }

            var nodeTransformation = nodeTransformations[nodeName];
            if (!defined(nodeTransformation)) {
                nodeTransformations[nodeName] = nodeTransformation = new NodeTransformationProperty();
            }

            processPacketData(Cartesian3, nodeTransformation, 'translation', nodeTransformationData.translation, combinedInterval, sourceUri, entityCollection);
            processPacketData(Quaternion, nodeTransformation, 'rotation', nodeTransformationData.rotation, combinedInterval, sourceUri, entityCollection);
            processPacketData(Cartesian3, nodeTransformation, 'scale', nodeTransformationData.scale, combinedInterval, sourceUri, entityCollection);
        }
    }

    function processPath(entity, packet, entityCollection, sourceUri) {
        var pathData = packet.path;
        if (!defined(pathData)) {
            return;
        }

        var interval;
        var intervalString = pathData.interval;
        if (defined(intervalString)) {
            iso8601Scratch.iso8601 = intervalString;
            interval = TimeInterval.fromIso8601(iso8601Scratch);
        }

        var path = entity.path;
        if (!defined(path)) {
            entity.path = path = new PathGraphics();
        }

        processPacketData(Boolean, path, 'show', pathData.show, interval, sourceUri, entityCollection);
        processPacketData(Number, path, 'width', pathData.width, interval, sourceUri, entityCollection);
        processPacketData(Number, path, 'resolution', pathData.resolution, interval, sourceUri, entityCollection);
        processPacketData(Number, path, 'leadTime', pathData.leadTime, interval, sourceUri, entityCollection);
        processPacketData(Number, path, 'trailTime', pathData.trailTime, interval, sourceUri, entityCollection);
        processMaterialPacketData(path, 'material', pathData.material, interval, sourceUri, entityCollection);
        processPacketData(DistanceDisplayCondition, path, 'distanceDisplayCondition', pathData.distanceDisplayCondition, interval, sourceUri, entityCollection);
    }

    function processPoint(entity, packet, entityCollection, sourceUri) {
        var pointData = packet.point;
        if (!defined(pointData)) {
            return;
        }

        var interval;
        var intervalString = pointData.interval;
        if (defined(intervalString)) {
            iso8601Scratch.iso8601 = intervalString;
            interval = TimeInterval.fromIso8601(iso8601Scratch);
        }

        var point = entity.point;
        if (!defined(point)) {
            entity.point = point = new PointGraphics();
        }

        processPacketData(Boolean, point, 'show', pointData.show, interval, sourceUri, entityCollection);
        processPacketData(Number, point, 'pixelSize', pointData.pixelSize, interval, sourceUri, entityCollection);
        processPacketData(HeightReference, point, 'heightReference', pointData.heightReference, interval, sourceUri, entityCollection);
        processPacketData(Color, point, 'color', pointData.color, interval, sourceUri, entityCollection);
        processPacketData(Color, point, 'outlineColor', pointData.outlineColor, interval, sourceUri, entityCollection);
        processPacketData(Number, point, 'outlineWidth', pointData.outlineWidth, interval, sourceUri, entityCollection);
        processPacketData(NearFarScalar, point, 'scaleByDistance', pointData.scaleByDistance, interval, sourceUri, entityCollection);
        processPacketData(NearFarScalar, point, 'translucencyByDistance', pointData.translucencyByDistance, interval, sourceUri, entityCollection);
        processPacketData(DistanceDisplayCondition, point, 'distanceDisplayCondition', pointData.distanceDisplayCondition, interval, sourceUri, entityCollection);
        processPacketData(Number, point, 'disableDepthTestDistance', pointData.disableDepthTestDistance, interval, sourceUri, entityCollection);
    }

    function processPolygon(entity, packet, entityCollection, sourceUri) {
        var polygonData = packet.polygon;
        if (!defined(polygonData)) {
            return;
        }

        var interval;
        var intervalString = polygonData.interval;
        if (defined(intervalString)) {
            iso8601Scratch.iso8601 = intervalString;
            interval = TimeInterval.fromIso8601(iso8601Scratch);
        }

        var polygon = entity.polygon;
        if (!defined(polygon)) {
            entity.polygon = polygon = new PolygonGraphics();
        }

        processPacketData(Boolean, polygon, 'show', polygonData.show, interval, sourceUri, entityCollection);
        processPositions(polygon, 'hierarchy', polygonData.positions, entityCollection);
        processPacketData(Number, polygon, 'height', polygonData.height, interval, sourceUri, entityCollection);
        processPacketData(Number, polygon, 'extrudedHeight', polygonData.extrudedHeight, interval, sourceUri, entityCollection);
        processPacketData(Rotation, polygon, 'stRotation', polygonData.stRotation, interval, sourceUri, entityCollection);
        processPacketData(Number, polygon, 'granularity', polygonData.granularity, interval, sourceUri, entityCollection);
        processPacketData(Boolean, polygon, 'fill', polygonData.fill, interval, sourceUri, entityCollection);
        processMaterialPacketData(polygon, 'material', polygonData.material, interval, sourceUri, entityCollection);
        processPacketData(Boolean, polygon, 'outline', polygonData.outline, interval, sourceUri, entityCollection);
        processPacketData(Color, polygon, 'outlineColor', polygonData.outlineColor, interval, sourceUri, entityCollection);
        processPacketData(Number, polygon, 'outlineWidth', polygonData.outlineWidth, interval, sourceUri, entityCollection);
        processPacketData(Boolean, polygon, 'perPositionHeight', polygonData.perPositionHeight, interval, sourceUri, entityCollection);
        processPacketData(Boolean, polygon, 'closeTop', polygonData.closeTop, interval, sourceUri, entityCollection);
        processPacketData(Boolean, polygon, 'closeBottom', polygonData.closeBottom, interval, sourceUri, entityCollection);
        processPacketData(ShadowMode, polygon, 'shadows', polygonData.shadows, interval, sourceUri, entityCollection);
        processPacketData(DistanceDisplayCondition, polygon, 'distanceDisplayCondition', polygonData.distanceDisplayCondition, interval, sourceUri, entityCollection);
        processPacketData(Number, polygon, 'zIndex', polygonData.zIndex, interval, sourceUri, entityCollection);
    }

    function processPolyline(entity, packet, entityCollection, sourceUri) {
        var polylineData = packet.polyline;
        if (!defined(polylineData)) {
            return;
        }

        var interval;
        var intervalString = polylineData.interval;
        if (defined(intervalString)) {
            iso8601Scratch.iso8601 = intervalString;
            interval = TimeInterval.fromIso8601(iso8601Scratch);
        }

        var polyline = entity.polyline;
        if (!defined(polyline)) {
            entity.polyline = polyline = new PolylineGraphics();
        }

        processPacketData(Boolean, polyline, 'show', polylineData.show, interval, sourceUri, entityCollection);
        processPositions(polyline, 'positions', polylineData.positions, entityCollection);
        processPacketData(Number, polyline, 'width', polylineData.width, interval, sourceUri, entityCollection);
        processPacketData(Number, polyline, 'granularity', polylineData.granularity, interval, sourceUri, entityCollection);
        processMaterialPacketData(polyline, 'material', polylineData.material, interval, sourceUri, entityCollection);
        processMaterialPacketData(polyline, 'depthFailMaterial', polylineData.depthFailMaterial, interval, sourceUri, entityCollection);
        processPacketData(Boolean, polyline, 'followSurface', polylineData.followSurface, interval, sourceUri, entityCollection);
        processPacketData(Boolean, polyline, 'clampToGround', polylineData.clampToGround, interval, sourceUri, entityCollection);
        processPacketData(ShadowMode, polyline, 'shadows', polylineData.shadows, interval, sourceUri, entityCollection);
        processPacketData(DistanceDisplayCondition, polyline, 'distanceDisplayCondition', polylineData.distanceDisplayCondition, interval, sourceUri, entityCollection);
        processPacketData(Number, polyline, 'zIndex', polylineData.zIndex, interval, sourceUri, entityCollection);
    }

    function processRectangle(entity, packet, entityCollection, sourceUri) {
        var rectangleData = packet.rectangle;
        if (!defined(rectangleData)) {
            return;
        }

        var interval;
        var intervalString = rectangleData.interval;
        if (defined(intervalString)) {
            iso8601Scratch.iso8601 = intervalString;
            interval = TimeInterval.fromIso8601(iso8601Scratch);
        }

        var rectangle = entity.rectangle;
        if (!defined(rectangle)) {
            entity.rectangle = rectangle = new RectangleGraphics();
        }

        processPacketData(Boolean, rectangle, 'show', rectangleData.show, interval, sourceUri, entityCollection);
        processPacketData(Rectangle, rectangle, 'coordinates', rectangleData.coordinates, interval, sourceUri, entityCollection);
        processPacketData(Number, rectangle, 'height', rectangleData.height, interval, sourceUri, entityCollection);
        processPacketData(Number, rectangle, 'extrudedHeight', rectangleData.extrudedHeight, interval, sourceUri, entityCollection);
        processPacketData(Rotation, rectangle, 'rotation', rectangleData.rotation, interval, sourceUri, entityCollection);
        processPacketData(Rotation, rectangle, 'stRotation', rectangleData.stRotation, interval, sourceUri, entityCollection);
        processPacketData(Number, rectangle, 'granularity', rectangleData.granularity, interval, sourceUri, entityCollection);
        processPacketData(Boolean, rectangle, 'fill', rectangleData.fill, interval, sourceUri, entityCollection);
        processMaterialPacketData(rectangle, 'material', rectangleData.material, interval, sourceUri, entityCollection);
        processPacketData(Boolean, rectangle, 'outline', rectangleData.outline, interval, sourceUri, entityCollection);
        processPacketData(Color, rectangle, 'outlineColor', rectangleData.outlineColor, interval, sourceUri, entityCollection);
        processPacketData(Number, rectangle, 'outlineWidth', rectangleData.outlineWidth, interval, sourceUri, entityCollection);
        processPacketData(ShadowMode, rectangle, 'shadows', rectangleData.shadows, interval, sourceUri, entityCollection);
        processPacketData(DistanceDisplayCondition, rectangle, 'distanceDisplayCondition', rectangleData.distanceDisplayCondition, interval, sourceUri, entityCollection);
        processPacketData(Number, rectangle, 'zIndex', rectangleData.zIndex, interval, sourceUri, entityCollection);
    }

    function processWall(entity, packet, entityCollection, sourceUri) {
        var wallData = packet.wall;
        if (!defined(wallData)) {
            return;
        }

        var interval;
        var intervalString = wallData.interval;
        if (defined(intervalString)) {
            iso8601Scratch.iso8601 = intervalString;
            interval = TimeInterval.fromIso8601(iso8601Scratch);
        }

        var wall = entity.wall;
        if (!defined(wall)) {
            entity.wall = wall = new WallGraphics();
        }

        processPacketData(Boolean, wall, 'show', wallData.show, interval, sourceUri, entityCollection);
        processPositions(wall, 'positions', wallData.positions, entityCollection);
        processArray(wall, 'minimumHeights', wallData.minimumHeights, entityCollection);
        processArray(wall, 'maximumHeights', wallData.maximumHeights, entityCollection);
        processPacketData(Number, wall, 'granularity', wallData.granularity, interval, sourceUri, entityCollection);
        processPacketData(Boolean, wall, 'fill', wallData.fill, interval, sourceUri, entityCollection);
        processMaterialPacketData(wall, 'material', wallData.material, interval, sourceUri, entityCollection);
        processPacketData(Boolean, wall, 'outline', wallData.outline, interval, sourceUri, entityCollection);
        processPacketData(Color, wall, 'outlineColor', wallData.outlineColor, interval, sourceUri, entityCollection);
        processPacketData(Number, wall, 'outlineWidth', wallData.outlineWidth, interval, sourceUri, entityCollection);
        processPacketData(ShadowMode, wall, 'shadows', wallData.shadows, interval, sourceUri, entityCollection);
        processPacketData(DistanceDisplayCondition, wall, 'distanceDisplayCondition', wallData.distanceDisplayCondition, interval, sourceUri, entityCollection);
    }

    function processCzmlPacket(packet, entityCollection, updaterFunctions, sourceUri, dataSource) {
        var objectId = packet.id;
        if (!defined(objectId)) {
            objectId = createGuid();
        }

        currentId = objectId;

        if (!defined(dataSource._version) && objectId !== 'document') {
            throw new RuntimeError('The first CZML packet is required to be the document object.');
        }

        if (packet['delete'] === true) {
            entityCollection.removeById(objectId);
        } else if (objectId === 'document') {
            processDocument(packet, dataSource);
        } else {
            var entity = entityCollection.getOrCreateEntity(objectId);

            var parentId = packet.parent;
            if (defined(parentId)) {
                entity.parent = entityCollection.getOrCreateEntity(parentId);
            }

            for (var i = updaterFunctions.length - 1; i > -1; i--) {
                updaterFunctions[i](entity, packet, entityCollection, sourceUri);
            }
        }

        currentId = undefined;
    }

    function updateClock(dataSource) {
        var clock;
        var clockPacket = dataSource._documentPacket.clock;
        if (!defined(clockPacket)) {
            if (!defined(dataSource._clock)) {
                var availability = dataSource._entityCollection.computeAvailability();
                if (!availability.start.equals(Iso8601.MINIMUM_VALUE)) {
                    var startTime = availability.start;
                    var stopTime = availability.stop;
                    var totalSeconds = JulianDate.secondsDifference(stopTime, startTime);
                    var multiplier = Math.round(totalSeconds / 120.0);

                    clock = new DataSourceClock();
                    clock.startTime = JulianDate.clone(startTime);
                    clock.stopTime = JulianDate.clone(stopTime);
                    clock.clockRange = ClockRange.LOOP_STOP;
                    clock.multiplier = multiplier;
                    clock.currentTime = JulianDate.clone(startTime);
                    clock.clockStep = ClockStep.SYSTEM_CLOCK_MULTIPLIER;
                    dataSource._clock = clock;
                    return true;
                }
            }
            return false;
        }

        if (defined(dataSource._clock)) {
            clock = dataSource._clock.clone();
        } else {
            clock = new DataSourceClock();
            clock.startTime = Iso8601.MINIMUM_VALUE.clone();
            clock.stopTime = Iso8601.MAXIMUM_VALUE.clone();
            clock.currentTime = Iso8601.MINIMUM_VALUE.clone();
            clock.clockRange = ClockRange.LOOP_STOP;
            clock.clockStep = ClockStep.SYSTEM_CLOCK_MULTIPLIER;
            clock.multiplier = 1.0;
        }
        if (defined(clockPacket.interval)) {
            iso8601Scratch.iso8601 = clockPacket.interval;
            var interval = TimeInterval.fromIso8601(iso8601Scratch);
            clock.startTime = interval.start;
            clock.stopTime = interval.stop;
        }
        if (defined(clockPacket.currentTime)) {
            clock.currentTime = JulianDate.fromIso8601(clockPacket.currentTime);
        }
        if (defined(clockPacket.range)) {
            clock.clockRange = defaultValue(ClockRange[clockPacket.range], ClockRange.LOOP_STOP);
        }
        if (defined(clockPacket.step)) {
            clock.clockStep = defaultValue(ClockStep[clockPacket.step], ClockStep.SYSTEM_CLOCK_MULTIPLIER);
        }
        if (defined(clockPacket.multiplier)) {
            clock.multiplier = clockPacket.multiplier;
        }

        if (!clock.equals(dataSource._clock)) {
            dataSource._clock = clock.clone(dataSource._clock);
            return true;
        }

        return false;
    }

    function load(dataSource, czml, options, clear) {
        //>>includeStart('debug', pragmas.debug);
        if (!defined(czml)) {
            throw new DeveloperError('czml is required.');
        }
        //>>includeEnd('debug');

        options = defaultValue(options, defaultValue.EMPTY_OBJECT);

        var promise = czml;
        var sourceUri = options.sourceUri;

        // If the czml is a URL
        if (typeof czml === 'string' || (czml instanceof Resource)) {
            czml = Resource.createIfNeeded(czml);
            promise = czml.fetchJson();
            sourceUri = defaultValue(sourceUri, czml.clone());
        }

        sourceUri = Resource.createIfNeeded(sourceUri);

        DataSource.setLoading(dataSource, true);

        return when(promise, function(czml) {
            return loadCzml(dataSource, czml, sourceUri, clear);
        }).otherwise(function(error) {
            DataSource.setLoading(dataSource, false);
            dataSource._error.raiseEvent(dataSource, error);
            console.log(error);
            return when.reject(error);
        });
    }

    function loadCzml(dataSource, czml, sourceUri, clear) {
        DataSource.setLoading(dataSource, true);
        var entityCollection = dataSource._entityCollection;

        if (clear) {
            dataSource._version = undefined;
            dataSource._documentPacket = new DocumentPacket();
            entityCollection.removeAll();
        }

        CzmlDataSource._processCzml(czml, entityCollection, sourceUri, undefined, dataSource);

        var raiseChangedEvent = updateClock(dataSource);

        var documentPacket = dataSource._documentPacket;
        if (defined(documentPacket.name) && dataSource._name !== documentPacket.name) {
            dataSource._name = documentPacket.name;
            raiseChangedEvent = true;
        } else if (!defined(dataSource._name) && defined(sourceUri)) {
            dataSource._name = getFilenameFromUri(sourceUri.getUrlComponent());
            raiseChangedEvent = true;
        }

        DataSource.setLoading(dataSource, false);
        if (raiseChangedEvent) {
            dataSource._changed.raiseEvent(dataSource);
        }

        return dataSource;
    }

    function DocumentPacket() {
        this.name = undefined;
        this.clock = undefined;
    }

    /**
     * A {@link DataSource} which processes {@link https://github.com/AnalyticalGraphicsInc/cesium/wiki/CZML-Guide|CZML}.
     * @alias CzmlDataSource
     * @constructor
     *
     * @param {String} [name] An optional name for the data source.  This value will be overwritten if a loaded document contains a name.
     *
     * @demo {@link https://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=CZML.html|Cesium Sandcastle CZML Demo}
     */
    function CzmlDataSource(name) {
        this._name = name;
        this._changed = new Event();
        this._error = new Event();
        this._isLoading = false;
        this._loading = new Event();
        this._clock = undefined;
        this._documentPacket = new DocumentPacket();
        this._version = undefined;
        this._entityCollection = new EntityCollection(this);
        this._entityCluster = new EntityCluster();
    }

    /**
     * Creates a Promise to a new instance loaded with the provided CZML data.
     *
     * @param {Resource|String|Object} czml A url or CZML object to be processed.
     * @param {Object} [options] An object with the following properties:
     * @param {Resource|String} [options.sourceUri] Overrides the url to use for resolving relative links.
     * @returns {Promise.<CzmlDataSource>} A promise that resolves to the new instance once the data is processed.
     */
    CzmlDataSource.load = function(czml, options) {
        return new CzmlDataSource().load(czml, options);
    };

    defineProperties(CzmlDataSource.prototype, {
        /**
         * Gets a human-readable name for this instance.
         * @memberof CzmlDataSource.prototype
         * @type {String}
         */
        name : {
            get : function() {
                return this._name;
            }
        },
        /**
         * Gets the clock settings defined by the loaded CZML.  If no clock is explicitly
         * defined in the CZML, the combined availability of all objects is returned.  If
         * only static data exists, this value is undefined.
         * @memberof CzmlDataSource.prototype
         * @type {DataSourceClock}
         */
        clock : {
            get : function() {
                return this._clock;
            }
        },
        /**
         * Gets the collection of {@link Entity} instances.
         * @memberof CzmlDataSource.prototype
         * @type {EntityCollection}
         */
        entities : {
            get : function() {
                return this._entityCollection;
            }
        },
        /**
         * Gets a value indicating if the data source is currently loading data.
         * @memberof CzmlDataSource.prototype
         * @type {Boolean}
         */
        isLoading : {
            get : function() {
                return this._isLoading;
            }
        },
        /**
         * Gets an event that will be raised when the underlying data changes.
         * @memberof CzmlDataSource.prototype
         * @type {Event}
         */
        changedEvent : {
            get : function() {
                return this._changed;
            }
        },
        /**
         * Gets an event that will be raised if an error is encountered during processing.
         * @memberof CzmlDataSource.prototype
         * @type {Event}
         */
        errorEvent : {
            get : function() {
                return this._error;
            }
        },
        /**
         * Gets an event that will be raised when the data source either starts or stops loading.
         * @memberof CzmlDataSource.prototype
         * @type {Event}
         */
        loadingEvent : {
            get : function() {
                return this._loading;
            }
        },
        /**
         * Gets whether or not this data source should be displayed.
         * @memberof CzmlDataSource.prototype
         * @type {Boolean}
         */
        show : {
            get : function() {
                return this._entityCollection.show;
            },
            set : function(value) {
                this._entityCollection.show = value;
            }
        },

        /**
         * Gets or sets the clustering options for this data source. This object can be shared between multiple data sources.
         *
         * @memberof CzmlDataSource.prototype
         * @type {EntityCluster}
         */
        clustering : {
            get : function() {
                return this._entityCluster;
            },
            set : function(value) {
                //>>includeStart('debug', pragmas.debug);
                if (!defined(value)) {
                    throw new DeveloperError('value must be defined.');
                }
                //>>includeEnd('debug');
                this._entityCluster = value;
            }
        }
    });

    /**
     * Gets the array of CZML processing functions.
     * @memberof CzmlDataSource
     * @type Array
     */
    CzmlDataSource.updaters = [
        processBillboard, //
        processBox, //
        processCorridor, //
        processCylinder, //
        processEllipse, //
        processEllipsoid, //
        processLabel, //
        processModel, //
        processName, //
        processDescription, //
        processPath, //
        processPoint, //
        processPolygon, //
        processPolyline, //
        processProperties, //
        processRectangle, //
        processPosition, //
        processViewFrom, //
        processWall, //
        processOrientation, //
        processAvailability];

    /**
     * Processes the provided url or CZML object without clearing any existing data.
     *
     * @param {Resource|String|Object} czml A url or CZML object to be processed.
     * @param {Object} [options] An object with the following properties:
     * @param {String} [options.sourceUri] Overrides the url to use for resolving relative links.
     * @returns {Promise.<CzmlDataSource>} A promise that resolves to this instances once the data is processed.
     */
    CzmlDataSource.prototype.process = function(czml, options) {
        return load(this, czml, options, false);
    };

    /**
     * Loads the provided url or CZML object, replacing any existing data.
     *
     * @param {Resource|String|Object} czml A url or CZML object to be processed.
     * @param {Object} [options] An object with the following properties:
     * @param {String} [options.sourceUri] Overrides the url to use for resolving relative links.
     * @returns {Promise.<CzmlDataSource>} A promise that resolves to this instances once the data is processed.
     */
    CzmlDataSource.prototype.load = function(czml, options) {
        return load(this, czml, options, true);
    };

    /**
     * A helper function used by custom CZML updater functions
     * which creates or updates a {@link Property} from a CZML packet.
     * @function
     *
     * @param {Function} type The constructor function for the property being processed.
     * @param {Object} object The object on which the property will be added or updated.
     * @param {String} propertyName The name of the property on the object.
     * @param {Object} packetData The CZML packet being processed.
     * @param {TimeInterval} interval A constraining interval for which the data is valid.
     * @param {String} sourceUri The originating uri of the data being processed.
     * @param {EntityCollection} entityCollection The collection being processsed.
     */
    CzmlDataSource.processPacketData = processPacketData;

    /**
     * A helper function used by custom CZML updater functions
     * which creates or updates a {@link PositionProperty} from a CZML packet.
     * @function
     *
     * @param {Object} object The object on which the property will be added or updated.
     * @param {String} propertyName The name of the property on the object.
     * @param {Object} packetData The CZML packet being processed.
     * @param {TimeInterval} interval A constraining interval for which the data is valid.
     * @param {String} sourceUri The originating uri of the data being processed.
     * @param {EntityCollection} entityCollection The collection being processsed.
     */
    CzmlDataSource.processPositionPacketData = processPositionPacketData;

    /**
     * A helper function used by custom CZML updater functions
     * which creates or updates a {@link MaterialProperty} from a CZML packet.
     * @function
     *
     * @param {Object} object The object on which the property will be added or updated.
     * @param {String} propertyName The name of the property on the object.
     * @param {Object} packetData The CZML packet being processed.
     * @param {TimeInterval} interval A constraining interval for which the data is valid.
     * @param {String} sourceUri The originating uri of the data being processed.
     * @param {EntityCollection} entityCollection The collection being processsed.
     */
    CzmlDataSource.processMaterialPacketData = processMaterialPacketData;

    CzmlDataSource._processCzml = function(czml, entityCollection, sourceUri, updaterFunctions, dataSource) {
        updaterFunctions = defined(updaterFunctions) ? updaterFunctions : CzmlDataSource.updaters;

        if (isArray(czml)) {
            for (var i = 0, len = czml.length; i < len; i++) {
                processCzmlPacket(czml[i], entityCollection, updaterFunctions, sourceUri, dataSource);
            }
        } else {
            processCzmlPacket(czml, entityCollection, updaterFunctions, sourceUri, dataSource);
        }
    };

    return CzmlDataSource;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 546:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(312),
        __webpack_require__(78),
        __webpack_require__(13),
        __webpack_require__(6),
        __webpack_require__(19),
        __webpack_require__(222),
        __webpack_require__(303),
        __webpack_require__(21),
        __webpack_require__(87),
        __webpack_require__(1),
        __webpack_require__(0),
        __webpack_require__(2),
        __webpack_require__(3),
        __webpack_require__(22),
        __webpack_require__(11),
        __webpack_require__(528),
        __webpack_require__(1192),
        __webpack_require__(547),
        __webpack_require__(309),
        __webpack_require__(168),
        __webpack_require__(29),
        __webpack_require__(7),
        __webpack_require__(169),
        __webpack_require__(145),
        __webpack_require__(306),
        __webpack_require__(1194),
        __webpack_require__(525),
        __webpack_require__(224),
        __webpack_require__(12),
        __webpack_require__(18),
        __webpack_require__(16),
        __webpack_require__(64),
        __webpack_require__(105),
        __webpack_require__(121),
        __webpack_require__(122),
        __webpack_require__(223),
        __webpack_require__(37),
        __webpack_require__(1214),
        __webpack_require__(70),
        __webpack_require__(5),
        __webpack_require__(537),
        __webpack_require__(516),
        __webpack_require__(1195),
        __webpack_require__(518),
        __webpack_require__(302),
        __webpack_require__(170),
        __webpack_require__(300),
        __webpack_require__(301),
        __webpack_require__(1215),
        __webpack_require__(1216),
        __webpack_require__(1217),
        __webpack_require__(1218),
        __webpack_require__(1219),
        __webpack_require__(521),
        __webpack_require__(522),
        __webpack_require__(517),
        __webpack_require__(299),
        __webpack_require__(1196),
        __webpack_require__(523),
        __webpack_require__(1197),
        __webpack_require__(526),
        __webpack_require__(1220),
        __webpack_require__(527),
        __webpack_require__(524)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
        AssociativeArray,
        BoundingRectangle,
        Cartesian2,
        Cartesian3,
        Cartographic,
        ClockRange,
        ClockStep,
        Color,
        createGuid,
        defaultValue,
        defined,
        defineProperties,
        DeveloperError,
        Ellipsoid,
        Event,
        getExtensionFromUri,
        getFilenameFromUri,
        HeadingPitchRange,
        HeadingPitchRoll,
        Iso8601,
        JulianDate,
        CesiumMath,
        NearFarScalar,
        objectToQuery,
        oneTimeWarning,
        PinBuilder,
        PolygonHierarchy,
        queryToObject,
        Rectangle,
        Resource,
        RuntimeError,
        TimeInterval,
        TimeIntervalCollection,
        HeightReference,
        HorizontalOrigin,
        LabelStyle,
        SceneMode,
        Autolinker,
        Uri,
        when,
        zip,
        BillboardGraphics,
        CompositePositionProperty,
        DataSource,
        DataSourceClock,
        Entity,
        EntityCluster,
        EntityCollection,
        KmlCamera,
        KmlLookAt,
        KmlTour,
        KmlTourFlyTo,
        KmlTourWait,
        LabelGraphics,
        PathGraphics,
        PolygonGraphics,
        PolylineGraphics,
        PositionPropertyArray,
        RectangleGraphics,
        ReferenceProperty,
        SampledPositionProperty,
        ScaledPositionProperty,
        TimeIntervalCollectionProperty,
        WallGraphics) {
    'use strict';

    // IE 8 doesn't have a DOM parser and can't run Cesium anyway, so just bail.
    if (typeof DOMParser === 'undefined') {
        return {};
    }

    //This is by no means an exhaustive list of MIME types.
    //The purpose of this list is to be able to accurately identify content embedded
    //in KMZ files. Eventually, we can make this configurable by the end user so they can add
    //there own content types if they have KMZ files that require it.
    var MimeTypes = {
        avi : 'video/x-msvideo',
        bmp : 'image/bmp',
        bz2 : 'application/x-bzip2',
        chm : 'application/vnd.ms-htmlhelp',
        css : 'text/css',
        csv : 'text/csv',
        doc : 'application/msword',
        dvi : 'application/x-dvi',
        eps : 'application/postscript',
        flv : 'video/x-flv',
        gif : 'image/gif',
        gz : 'application/x-gzip',
        htm : 'text/html',
        html : 'text/html',
        ico : 'image/vnd.microsoft.icon',
        jnlp : 'application/x-java-jnlp-file',
        jpeg : 'image/jpeg',
        jpg : 'image/jpeg',
        m3u : 'audio/x-mpegurl',
        m4v : 'video/mp4',
        mathml : 'application/mathml+xml',
        mid : 'audio/midi',
        midi : 'audio/midi',
        mov : 'video/quicktime',
        mp3 : 'audio/mpeg',
        mp4 : 'video/mp4',
        mp4v : 'video/mp4',
        mpeg : 'video/mpeg',
        mpg : 'video/mpeg',
        odp : 'application/vnd.oasis.opendocument.presentation',
        ods : 'application/vnd.oasis.opendocument.spreadsheet',
        odt : 'application/vnd.oasis.opendocument.text',
        ogg : 'application/ogg',
        pdf : 'application/pdf',
        png : 'image/png',
        pps : 'application/vnd.ms-powerpoint',
        ppt : 'application/vnd.ms-powerpoint',
        ps : 'application/postscript',
        qt : 'video/quicktime',
        rdf : 'application/rdf+xml',
        rss : 'application/rss+xml',
        rtf : 'application/rtf',
        svg : 'image/svg+xml',
        swf : 'application/x-shockwave-flash',
        text : 'text/plain',
        tif : 'image/tiff',
        tiff : 'image/tiff',
        txt : 'text/plain',
        wav : 'audio/x-wav',
        wma : 'audio/x-ms-wma',
        wmv : 'video/x-ms-wmv',
        xml : 'application/xml',
        zip : 'application/zip',

        detectFromFilename : function(filename) {
            var ext = filename.toLowerCase();
            ext = getExtensionFromUri(ext);
            return MimeTypes[ext];
        }
    };

    var parser = new DOMParser();
    var autolinker = new Autolinker({
        stripPrefix : false,
        twitter : false,
        email : false,
        replaceFn : function(linker, match) {
            if (!match.protocolUrlMatch) {
                //Prevent matching of non-explicit urls.
                //i.e. foo.id won't match but http://foo.id will
                return false;
            }
        }
    });

    var BILLBOARD_SIZE = 32;

    var BILLBOARD_NEAR_DISTANCE = 2414016;
    var BILLBOARD_NEAR_RATIO = 1.0;
    var BILLBOARD_FAR_DISTANCE = 1.6093e+7;
    var BILLBOARD_FAR_RATIO = 0.1;

    function isZipFile(blob) {
        var magicBlob = blob.slice(0, Math.min(4, blob.size));
        var deferred = when.defer();
        var reader = new FileReader();
        reader.addEventListener('load', function() {
            deferred.resolve(new DataView(reader.result).getUint32(0, false) === 0x504b0304);
        });
        reader.addEventListener('error', function() {
            deferred.reject(reader.error);
        });
        reader.readAsArrayBuffer(magicBlob);
        return deferred.promise;
    }

    function readBlobAsText(blob) {
        var deferred = when.defer();
        var reader = new FileReader();
        reader.addEventListener('load', function() {
            deferred.resolve(reader.result);
        });
        reader.addEventListener('error', function() {
            deferred.reject(reader.error);
        });
        reader.readAsText(blob);
        return deferred.promise;
    }

    function insertNamespaces(text) {
        var namespaceMap = {
            xsi : 'http://www.w3.org/2001/XMLSchema-instance'
        };
        var firstPart, lastPart, reg, declaration;

        for (var key in namespaceMap) {
            if (namespaceMap.hasOwnProperty(key)) {
                reg = RegExp('[< ]' + key + ':');
                declaration = 'xmlns:' + key + '=';
                if (reg.test(text) && text.indexOf(declaration) === -1) {
                    if (!defined(firstPart)) {
                        firstPart = text.substr(0, text.indexOf('<kml') + 4);
                        lastPart = text.substr(firstPart.length);
                    }
                    firstPart += ' ' + declaration + '"' + namespaceMap[key] + '"';
                }
            }
        }

        if (defined(firstPart)) {
            text = firstPart + lastPart;
        }

        return text;
    }

    function removeDuplicateNamespaces(text) {
        var index = text.indexOf('xmlns:');
        var endDeclaration = text.indexOf('>', index);
        var namespace, startIndex, endIndex;

        while ((index !== -1) && (index < endDeclaration)) {
            namespace = text.slice(index, text.indexOf('\"', index));
            startIndex = index;
            index = text.indexOf(namespace, index + 1);
            if (index !== -1) {
                endIndex = text.indexOf('\"', (text.indexOf('\"', index) + 1));
                text = text.slice(0, index -1) + text.slice(endIndex + 1, text.length);
                index = text.indexOf('xmlns:', startIndex - 1);
            } else {
                index = text.indexOf('xmlns:', startIndex + 1);
            }
        }

        return text;
    }

    function loadXmlFromZip(entry, uriResolver, deferred) {
        entry.getData(new zip.TextWriter(), function(text) {
            text = insertNamespaces(text);
            text = removeDuplicateNamespaces(text);
            uriResolver.kml = parser.parseFromString(text, 'application/xml');
            deferred.resolve();
        });
    }

    function loadDataUriFromZip(entry, uriResolver, deferred) {
        var mimeType = defaultValue(MimeTypes.detectFromFilename(entry.filename), 'application/octet-stream');
        entry.getData(new zip.Data64URIWriter(mimeType), function(dataUri) {
            uriResolver[entry.filename] = dataUri;
            deferred.resolve();
        });
    }

    function embedDataUris(div, elementType, attributeName, uriResolver) {
        var keys = uriResolver.keys;
        var baseUri = new Uri('.');
        var elements = div.querySelectorAll(elementType);
        for (var i = 0; i < elements.length; i++) {
            var element = elements[i];
            var value = element.getAttribute(attributeName);
            var uri = new Uri(value).resolve(baseUri).toString();
            var index = keys.indexOf(uri);
            if (index !== -1) {
                var key = keys[index];
                element.setAttribute(attributeName, uriResolver[key]);
                if (elementType === 'a' && element.getAttribute('download') === null) {
                    element.setAttribute('download', key);
                }
            }
        }
    }

    function applyBasePath(div, elementType, attributeName, sourceResource) {
        var elements = div.querySelectorAll(elementType);
        for (var i = 0; i < elements.length; i++) {
            var element = elements[i];
            var value = element.getAttribute(attributeName);
            var resource = resolveHref(value, sourceResource);
            element.setAttribute(attributeName, resource.url);
        }
    }

    // an optional context is passed to allow for some malformed kmls (those with multiple geometries with same ids) to still parse
    // correctly, as they do in Google Earth.
    function createEntity(node, entityCollection, context) {
        var id = queryStringAttribute(node, 'id');
        id = defined(id) && id.length !== 0 ? id : createGuid();
        if (defined(context)) {
            id = context + id;
        }

        // If we have a duplicate ID just generate one.
        // This isn't valid KML but Google Earth handles this case.
        var entity = entityCollection.getById(id);
        if (defined(entity)) {
            id = createGuid();
            if (defined(context)) {
                id = context + id;
            }
        }

        entity = entityCollection.add(new Entity({id : id}));
        if (!defined(entity.kml)) {
            entity.addProperty('kml');
            entity.kml = new KmlFeatureData();
        }
        return entity;
    }

    function isExtrudable(altitudeMode, gxAltitudeMode) {
        return altitudeMode === 'absolute' || altitudeMode === 'relativeToGround' || gxAltitudeMode === 'relativeToSeaFloor';
    }

    function readCoordinate(value, ellipsoid) {
        //Google Earth treats empty or missing coordinates as 0.
        if (!defined(value)) {
            return Cartesian3.fromDegrees(0, 0, 0, ellipsoid);
        }

        var digits = value.match(/[^\s,\n]+/g);
        if (!defined(digits)) {
            return Cartesian3.fromDegrees(0, 0, 0, ellipsoid);
        }

        var longitude = parseFloat(digits[0]);
        var latitude = parseFloat(digits[1]);
        var height = parseFloat(digits[2]);

        longitude = isNaN(longitude) ? 0.0 : longitude;
        latitude = isNaN(latitude) ? 0.0 : latitude;
        height = isNaN(height) ? 0.0 : height;

        return Cartesian3.fromDegrees(longitude, latitude, height, ellipsoid);
    }

    function readCoordinates(element, ellipsoid) {
        if (!defined(element)) {
            return undefined;
        }

        var tuples = element.textContent.match(/[^\s\n]+/g);
        if (!defined(tuples)) {
            return undefined;
        }

        var length = tuples.length;
        var result = new Array(length);
        var resultIndex = 0;
        for (var i = 0; i < length; i++) {
            result[resultIndex++] = readCoordinate(tuples[i], ellipsoid);
        }
        return result;
    }

    var kmlNamespaces = [null, undefined, 'http://www.opengis.net/kml/2.2', 'http://earth.google.com/kml/2.2', 'http://earth.google.com/kml/2.1', 'http://earth.google.com/kml/2.0'];
    var gxNamespaces = ['http://www.google.com/kml/ext/2.2'];
    var atomNamespaces = ['http://www.w3.org/2005/Atom'];
    var namespaces = {
        kml : kmlNamespaces,
        gx : gxNamespaces,
        atom : atomNamespaces,
        kmlgx : kmlNamespaces.concat(gxNamespaces)
    };

    function queryNumericAttribute(node, attributeName) {
        if (!defined(node)) {
            return undefined;
        }

        var value = node.getAttribute(attributeName);
        if (value !== null) {
            var result = parseFloat(value);
            return !isNaN(result) ? result : undefined;
        }
        return undefined;
    }

    function queryStringAttribute(node, attributeName) {
        if (!defined(node)) {
            return undefined;
        }
        var value = node.getAttribute(attributeName);
        return value !== null ? value : undefined;
    }

    function queryFirstNode(node, tagName, namespace) {
        if (!defined(node)) {
            return undefined;
        }
        var childNodes = node.childNodes;
        var length = childNodes.length;
        for (var q = 0; q < length; q++) {
            var child = childNodes[q];
            if (child.localName === tagName && namespace.indexOf(child.namespaceURI) !== -1) {
                return child;
            }
        }
        return undefined;
    }

    function queryNodes(node, tagName, namespace) {
        if (!defined(node)) {
            return undefined;
        }
        var result = [];
        var childNodes = node.getElementsByTagNameNS('*', tagName);
        var length = childNodes.length;
        for (var q = 0; q < length; q++) {
            var child = childNodes[q];
            if (child.localName === tagName && namespace.indexOf(child.namespaceURI) !== -1) {
                result.push(child);
            }
        }
        return result;
    }

    function queryChildNodes(node, tagName, namespace) {
        if (!defined(node)) {
            return [];
        }
        var result = [];
        var childNodes = node.childNodes;
        var length = childNodes.length;
        for (var q = 0; q < length; q++) {
            var child = childNodes[q];
            if (child.localName === tagName && namespace.indexOf(child.namespaceURI) !== -1) {
                result.push(child);
            }
        }
        return result;
    }

    function queryNumericValue(node, tagName, namespace) {
        var resultNode = queryFirstNode(node, tagName, namespace);
        if (defined(resultNode)) {
            var result = parseFloat(resultNode.textContent);
            return !isNaN(result) ? result : undefined;
        }
        return undefined;
    }

    function queryStringValue(node, tagName, namespace) {
        var result = queryFirstNode(node, tagName, namespace);
        if (defined(result)) {
            return result.textContent.trim();
        }
        return undefined;
    }

    function queryBooleanValue(node, tagName, namespace) {
        var result = queryFirstNode(node, tagName, namespace);
        if (defined(result)) {
            var value = result.textContent.trim();
            return value === '1' || /^true$/i.test(value);
        }
        return undefined;
    }

    function resolveHref(href, sourceResource, uriResolver) {
        if (!defined(href)) {
            return undefined;
        }

        var resource;
        if (defined(uriResolver)) {
            var blob = uriResolver[href];
            if (defined(blob)) {
                resource = new Resource({
                    url: blob
                });
            } else {
                // Needed for multiple levels of KML files in a KMZ
                var baseUri = new Uri(sourceResource.getUrlComponent());
                var uri = new Uri(href);
                blob = uriResolver[uri.resolve(baseUri)];
                if (defined(blob)) {
                    resource = new Resource({
                        url: blob
                    });
                }
            }
        }

        if (!defined(resource)) {
            resource = sourceResource.getDerivedResource({
                url: href
            });
        }

        return resource;
    }

    var colorOptions = {
        maximumRed : undefined,
        red : undefined,
        maximumGreen : undefined,
        green : undefined,
        maximumBlue : undefined,
        blue : undefined
    };

    function parseColorString(value, isRandom) {
        if (!defined(value) || /^\s*$/gm.test(value)) {
            return undefined;
        }

        if (value[0] === '#') {
            value = value.substring(1);
        }

        var alpha = parseInt(value.substring(0, 2), 16) / 255.0;
        var blue = parseInt(value.substring(2, 4), 16) / 255.0;
        var green = parseInt(value.substring(4, 6), 16) / 255.0;
        var red = parseInt(value.substring(6, 8), 16) / 255.0;

        if (!isRandom) {
            return new Color(red, green, blue, alpha);
        }

        if (red > 0) {
            colorOptions.maximumRed = red;
            colorOptions.red = undefined;
        } else {
            colorOptions.maximumRed = undefined;
            colorOptions.red = 0;
        }
        if (green > 0) {
            colorOptions.maximumGreen = green;
            colorOptions.green = undefined;
        } else {
            colorOptions.maximumGreen = undefined;
            colorOptions.green = 0;
        }
        if (blue > 0) {
            colorOptions.maximumBlue = blue;
            colorOptions.blue = undefined;
        } else {
            colorOptions.maximumBlue = undefined;
            colorOptions.blue = 0;
        }
        colorOptions.alpha = alpha;
        return Color.fromRandom(colorOptions);
    }

    function queryColorValue(node, tagName, namespace) {
        var value = queryStringValue(node, tagName, namespace);
        if (!defined(value)) {
            return undefined;
        }
        return parseColorString(value, queryStringValue(node, 'colorMode', namespace) === 'random');
    }

    function processTimeStamp(featureNode) {
        var node = queryFirstNode(featureNode, 'TimeStamp', namespaces.kmlgx);
        var whenString = queryStringValue(node, 'when', namespaces.kmlgx);

        if (!defined(node) || !defined(whenString) || whenString.length === 0) {
            return undefined;
        }

        //According to the KML spec, a TimeStamp represents a "single moment in time"
        //However, since Cesium animates much differently than Google Earth, that doesn't
        //Make much sense here.  Instead, we use the TimeStamp as the moment the feature
        //comes into existence.  This works much better and gives a similar feel to
        //GE's experience.
        var when = JulianDate.fromIso8601(whenString);
        var result = new TimeIntervalCollection();
        result.addInterval(new TimeInterval({
            start : when,
            stop : Iso8601.MAXIMUM_VALUE
        }));
        return result;
    }

    function processTimeSpan(featureNode) {
        var node = queryFirstNode(featureNode, 'TimeSpan', namespaces.kmlgx);
        if (!defined(node)) {
            return undefined;
        }
        var result;

        var beginNode = queryFirstNode(node, 'begin', namespaces.kmlgx);
        var beginDate = defined(beginNode) ? JulianDate.fromIso8601(beginNode.textContent) : undefined;

        var endNode = queryFirstNode(node, 'end', namespaces.kmlgx);
        var endDate = defined(endNode) ? JulianDate.fromIso8601(endNode.textContent) : undefined;

        if (defined(beginDate) && defined(endDate)) {
            if (JulianDate.lessThan(endDate, beginDate)) {
                var tmp = beginDate;
                beginDate = endDate;
                endDate = tmp;
            }
            result = new TimeIntervalCollection();
            result.addInterval(new TimeInterval({
                start : beginDate,
                stop : endDate
            }));
        } else if (defined(beginDate)) {
            result = new TimeIntervalCollection();
            result.addInterval(new TimeInterval({
                start : beginDate,
                stop : Iso8601.MAXIMUM_VALUE
            }));
        } else if (defined(endDate)) {
            result = new TimeIntervalCollection();
            result.addInterval(new TimeInterval({
                start : Iso8601.MINIMUM_VALUE,
                stop : endDate
            }));
        }

        return result;
    }

    function createDefaultBillboard() {
        var billboard = new BillboardGraphics();
        billboard.width = BILLBOARD_SIZE;
        billboard.height = BILLBOARD_SIZE;
        billboard.scaleByDistance = new NearFarScalar(BILLBOARD_NEAR_DISTANCE, BILLBOARD_NEAR_RATIO, BILLBOARD_FAR_DISTANCE, BILLBOARD_FAR_RATIO);
        billboard.pixelOffsetScaleByDistance = new NearFarScalar(BILLBOARD_NEAR_DISTANCE, BILLBOARD_NEAR_RATIO, BILLBOARD_FAR_DISTANCE, BILLBOARD_FAR_RATIO);
        return billboard;
    }

    function createDefaultPolygon() {
        var polygon = new PolygonGraphics();
        polygon.outline = true;
        polygon.outlineColor = Color.WHITE;
        return polygon;
    }

    function createDefaultLabel() {
        var label = new LabelGraphics();
        label.translucencyByDistance = new NearFarScalar(3000000, 1.0, 5000000, 0.0);
        label.pixelOffset = new Cartesian2(17, 0);
        label.horizontalOrigin = HorizontalOrigin.LEFT;
        label.font = '16px sans-serif';
        label.style = LabelStyle.FILL_AND_OUTLINE;
        return label;
    }

    function getIconHref(iconNode, dataSource, sourceResource, uriResolver, canRefresh) {
        var href = queryStringValue(iconNode, 'href', namespaces.kml);
        if (!defined(href) || (href.length === 0)) {
            return undefined;
        }

        if (href.indexOf('root://icons/palette-') === 0) {
            var palette = href.charAt(21);

            // Get the icon number
            var x = defaultValue(queryNumericValue(iconNode, 'x', namespaces.gx), 0);
            var y = defaultValue(queryNumericValue(iconNode, 'y', namespaces.gx), 0);
            x = Math.min(x / 32, 7);
            y = 7 - Math.min(y / 32, 7);
            var iconNum = (8 * y) + x;

            href = 'https://maps.google.com/mapfiles/kml/pal' + palette + '/icon' + iconNum + '.png';
        }

        var hrefResource = resolveHref(href, sourceResource, uriResolver);

        if (canRefresh) {
            var refreshMode = queryStringValue(iconNode, 'refreshMode', namespaces.kml);
            var viewRefreshMode = queryStringValue(iconNode, 'viewRefreshMode', namespaces.kml);
            if (refreshMode === 'onInterval' || refreshMode === 'onExpire') {
                oneTimeWarning('kml-refreshMode-' + refreshMode, 'KML - Unsupported Icon refreshMode: ' + refreshMode);
            } else if (viewRefreshMode === 'onStop' || viewRefreshMode === 'onRegion') {
                oneTimeWarning('kml-refreshMode-' + viewRefreshMode, 'KML - Unsupported Icon viewRefreshMode: ' + viewRefreshMode);
            }

            var viewBoundScale = defaultValue(queryStringValue(iconNode, 'viewBoundScale', namespaces.kml), 1.0);
            var defaultViewFormat = (viewRefreshMode === 'onStop') ? 'BBOX=[bboxWest],[bboxSouth],[bboxEast],[bboxNorth]' : '';
            var viewFormat = defaultValue(queryStringValue(iconNode, 'viewFormat', namespaces.kml), defaultViewFormat);
            var httpQuery = queryStringValue(iconNode, 'httpQuery', namespaces.kml);
            if (defined(viewFormat)) {
                hrefResource.setQueryParameters(queryToObject(cleanupString(viewFormat)));
            }
            if (defined(httpQuery)) {
                hrefResource.setQueryParameters(queryToObject(cleanupString(httpQuery)));
            }

            var ellipsoid = dataSource._ellipsoid;
            processNetworkLinkQueryString(hrefResource, dataSource._camera, dataSource._canvas, viewBoundScale, dataSource._lastCameraView.bbox, ellipsoid);

            return hrefResource;
        }

        return hrefResource;
    }

    function processBillboardIcon(dataSource, node, targetEntity, sourceResource, uriResolver) {
        var scale = queryNumericValue(node, 'scale', namespaces.kml);
        var heading = queryNumericValue(node, 'heading', namespaces.kml);
        var color = queryColorValue(node, 'color', namespaces.kml);

        var iconNode = queryFirstNode(node, 'Icon', namespaces.kml);
        var icon = getIconHref(iconNode, dataSource, sourceResource, uriResolver, false);

        // If icon tags are present but blank, we do not want to show an icon
        if (defined(iconNode) && !defined(icon)) {
            icon = false;
        }

        var x = queryNumericValue(iconNode, 'x', namespaces.gx);
        var y = queryNumericValue(iconNode, 'y', namespaces.gx);
        var w = queryNumericValue(iconNode, 'w', namespaces.gx);
        var h = queryNumericValue(iconNode, 'h', namespaces.gx);

        var hotSpotNode = queryFirstNode(node, 'hotSpot', namespaces.kml);
        var hotSpotX = queryNumericAttribute(hotSpotNode, 'x');
        var hotSpotY = queryNumericAttribute(hotSpotNode, 'y');
        var hotSpotXUnit = queryStringAttribute(hotSpotNode, 'xunits');
        var hotSpotYUnit = queryStringAttribute(hotSpotNode, 'yunits');

        var billboard = targetEntity.billboard;
        if (!defined(billboard)) {
            billboard = createDefaultBillboard();
            targetEntity.billboard = billboard;
        }

        billboard.image = icon;
        billboard.scale = scale;
        billboard.color = color;

        if (defined(x) || defined(y) || defined(w) || defined(h)) {
            billboard.imageSubRegion = new BoundingRectangle(x, y, w, h);
        }

        //GE treats a heading of zero as no heading
        //You can still point north using a 360 degree angle (or any multiple of 360)
        if (defined(heading) && heading !== 0) {
            billboard.rotation = CesiumMath.toRadians(-heading);
            billboard.alignedAxis = Cartesian3.UNIT_Z;
        }

        //Hotpot is the KML equivalent of pixel offset
        //The hotspot origin is the lower left, but we leave
        //our billboard origin at the center and simply
        //modify the pixel offset to take this into account
        scale = defaultValue(scale, 1.0);

        var xOffset;
        var yOffset;
        if (defined(hotSpotX)) {
            if (hotSpotXUnit === 'pixels') {
                xOffset = -hotSpotX * scale;
            } else if (hotSpotXUnit === 'insetPixels') {
                xOffset = (hotSpotX - BILLBOARD_SIZE) * scale;
            } else if (hotSpotXUnit === 'fraction') {
                xOffset = -hotSpotX * BILLBOARD_SIZE * scale;
            }
            xOffset += BILLBOARD_SIZE * 0.5 * scale;
        }

        if (defined(hotSpotY)) {
            if (hotSpotYUnit === 'pixels') {
                yOffset = hotSpotY * scale;
            } else if (hotSpotYUnit === 'insetPixels') {
                yOffset = (-hotSpotY + BILLBOARD_SIZE) * scale;
            } else if (hotSpotYUnit === 'fraction') {
                yOffset = hotSpotY * BILLBOARD_SIZE * scale;
            }

            yOffset -= BILLBOARD_SIZE * 0.5 * scale;
        }

        if (defined(xOffset) || defined(yOffset)) {
            billboard.pixelOffset = new Cartesian2(xOffset, yOffset);
        }
    }

    function applyStyle(dataSource, styleNode, targetEntity, sourceResource, uriResolver) {
        for (var i = 0, len = styleNode.childNodes.length; i < len; i++) {
            var node = styleNode.childNodes.item(i);
            if (node.localName === 'IconStyle') {
                processBillboardIcon(dataSource, node, targetEntity, sourceResource, uriResolver);
            } else if (node.localName === 'LabelStyle') {
                var label = targetEntity.label;
                if (!defined(label)) {
                    label = createDefaultLabel();
                    targetEntity.label = label;
                }
                label.scale = defaultValue(queryNumericValue(node, 'scale', namespaces.kml), label.scale);
                label.fillColor = defaultValue(queryColorValue(node, 'color', namespaces.kml), label.fillColor);
                label.text = targetEntity.name;
            } else if (node.localName === 'LineStyle') {
                var polyline = targetEntity.polyline;
                if (!defined(polyline)) {
                    polyline = new PolylineGraphics();
                    targetEntity.polyline = polyline;
                }
                polyline.width = queryNumericValue(node, 'width', namespaces.kml);
                polyline.material = queryColorValue(node, 'color', namespaces.kml);
                if (defined(queryColorValue(node, 'outerColor', namespaces.gx))) {
                    oneTimeWarning('kml-gx:outerColor', 'KML - gx:outerColor is not supported in a LineStyle');
                }
                if (defined(queryNumericValue(node, 'outerWidth', namespaces.gx))) {
                    oneTimeWarning('kml-gx:outerWidth', 'KML - gx:outerWidth is not supported in a LineStyle');
                }
                if (defined(queryNumericValue(node, 'physicalWidth', namespaces.gx))) {
                    oneTimeWarning('kml-gx:physicalWidth', 'KML - gx:physicalWidth is not supported in a LineStyle');
                }
                if (defined(queryBooleanValue(node, 'labelVisibility', namespaces.gx))) {
                    oneTimeWarning('kml-gx:labelVisibility', 'KML - gx:labelVisibility is not supported in a LineStyle');
                }
            } else if (node.localName === 'PolyStyle') {
                var polygon = targetEntity.polygon;
                if (!defined(polygon)) {
                    polygon = createDefaultPolygon();
                    targetEntity.polygon = polygon;
                }
                polygon.material = defaultValue(queryColorValue(node, 'color', namespaces.kml), polygon.material);
                polygon.fill = defaultValue(queryBooleanValue(node, 'fill', namespaces.kml), polygon.fill);
                polygon.outline = defaultValue(queryBooleanValue(node, 'outline', namespaces.kml), polygon.outline);
            } else if (node.localName === 'BalloonStyle') {
                var bgColor = defaultValue(parseColorString(queryStringValue(node, 'bgColor', namespaces.kml)), Color.WHITE);
                var textColor = defaultValue(parseColorString(queryStringValue(node, 'textColor', namespaces.kml)), Color.BLACK);
                var text = queryStringValue(node, 'text', namespaces.kml);

                //This is purely an internal property used in style processing,
                //it never ends up on the final entity.
                targetEntity.addProperty('balloonStyle');
                targetEntity.balloonStyle = {
                    bgColor : bgColor,
                    textColor : textColor,
                    text : text
                };
            } else if (node.localName === 'ListStyle') {
                var listItemType = queryStringValue(node, 'listItemType', namespaces.kml);
                if (listItemType === 'radioFolder' || listItemType === 'checkOffOnly') {
                    oneTimeWarning('kml-listStyle-' + listItemType, 'KML - Unsupported ListStyle with listItemType: ' + listItemType);
                }
            }
        }
    }

    //Processes and merges any inline styles for the provided node into the provided entity.
    function computeFinalStyle(dataSource, placeMark, styleCollection, sourceResource, uriResolver) {
        var result = new Entity();
        var styleEntity;

        //Google earth seems to always use the last inline Style/StyleMap only
        var styleIndex = -1;
        var childNodes = placeMark.childNodes;
        var length = childNodes.length;
        for (var q = 0; q < length; q++) {
            var child = childNodes[q];
            if (child.localName === 'Style' || child.localName === 'StyleMap') {
                styleIndex = q;
            }
        }

        if (styleIndex !== -1) {
            var inlineStyleNode = childNodes[styleIndex];
            if (inlineStyleNode.localName === 'Style') {
                applyStyle(dataSource, inlineStyleNode, result, sourceResource, uriResolver);
            } else { // StyleMap
                var pairs = queryChildNodes(inlineStyleNode, 'Pair', namespaces.kml);
                for (var p = 0; p < pairs.length; p++) {
                    var pair = pairs[p];
                    var key = queryStringValue(pair, 'key', namespaces.kml);
                    if (key === 'normal') {
                        var styleUrl = queryStringValue(pair, 'styleUrl', namespaces.kml);
                        if (defined(styleUrl)) {
                            styleEntity = styleCollection.getById(styleUrl);
                            if (!defined(styleEntity)) {
                                styleEntity = styleCollection.getById('#' + styleUrl);
                            }
                            if (defined(styleEntity)) {
                                result.merge(styleEntity);
                            }
                        } else {
                            var node = queryFirstNode(pair, 'Style', namespaces.kml);
                            applyStyle(dataSource, node, result, sourceResource, uriResolver);
                        }
                    } else {
                        oneTimeWarning('kml-styleMap-' + key, 'KML - Unsupported StyleMap key: ' + key);
                    }
                }
            }
        }

        //Google earth seems to always use the first external style only.
        var externalStyle = queryStringValue(placeMark, 'styleUrl', namespaces.kml);
        if (defined(externalStyle)) {
            var id = externalStyle;
            if (externalStyle[0] !== '#' && externalStyle.indexOf('#') !== -1) {
                var tokens = externalStyle.split('#');
                var uri = tokens[0];
                var resource = sourceResource.getDerivedResource({
                    url: uri
                });

                id = resource.getUrlComponent() + '#' + tokens[1];
            }

            styleEntity = styleCollection.getById(id);
            if (!defined(styleEntity)) {
                styleEntity = styleCollection.getById('#' + id);
            }
            if (defined(styleEntity)) {
                result.merge(styleEntity);
            }
        }

        return result;
    }

    //Asynchronously processes an external style file.
    function processExternalStyles(dataSource, resource, styleCollection) {
        return resource.fetchXML().then(function(styleKml) {
            return processStyles(dataSource, styleKml, styleCollection, resource, true);
        });
    }

    //Processes all shared and external styles and stores
    //their id into the provided styleCollection.
    //Returns an array of promises that will resolve when
    //each style is loaded.
    function processStyles(dataSource, kml, styleCollection, sourceResource, isExternal, uriResolver) {
        var i;
        var id;
        var styleEntity;

        var node;
        var styleNodes = queryNodes(kml, 'Style', namespaces.kml);
        if (defined(styleNodes)) {
            var styleNodesLength = styleNodes.length;
            for (i = 0; i < styleNodesLength; i++) {
                node = styleNodes[i];
                id = queryStringAttribute(node, 'id');
                if (defined(id)) {
                    id = '#' + id;
                    if (isExternal && defined(sourceResource)) {
                        id = sourceResource.getUrlComponent() + id;
                    }
                    if (!defined(styleCollection.getById(id))) {
                        styleEntity = new Entity({
                            id : id
                        });
                        styleCollection.add(styleEntity);
                        applyStyle(dataSource, node, styleEntity, sourceResource, uriResolver);
                    }
                }
            }
        }

        var styleMaps = queryNodes(kml, 'StyleMap', namespaces.kml);
        if (defined(styleMaps)) {
            var styleMapsLength = styleMaps.length;
            for (i = 0; i < styleMapsLength; i++) {
                var styleMap = styleMaps[i];
                id = queryStringAttribute(styleMap, 'id');
                if (defined(id)) {
                    var pairs = queryChildNodes(styleMap, 'Pair', namespaces.kml);
                    for (var p = 0; p < pairs.length; p++) {
                        var pair = pairs[p];
                        var key = queryStringValue(pair, 'key', namespaces.kml);
                        if (key === 'normal') {
                            id = '#' + id;
                            if (isExternal && defined(sourceResource)) {
                                id = sourceResource.getUrlComponent() + id;
                            }
                            if (!defined(styleCollection.getById(id))) {
                                styleEntity = styleCollection.getOrCreateEntity(id);

                                var styleUrl = queryStringValue(pair, 'styleUrl', namespaces.kml);
                                if (defined(styleUrl)) {
                                    if (styleUrl[0] !== '#') {
                                        styleUrl = '#' + styleUrl;
                                    }

                                    if (isExternal && defined(sourceResource)) {
                                        styleUrl = sourceResource.getUrlComponent() + styleUrl;
                                    }
                                    var base = styleCollection.getById(styleUrl);

                                    if (defined(base)) {
                                        styleEntity.merge(base);
                                    }
                                } else {
                                    node = queryFirstNode(pair, 'Style', namespaces.kml);
                                    applyStyle(dataSource, node, styleEntity, sourceResource, uriResolver);
                                }
                            }
                        } else {
                            oneTimeWarning('kml-styleMap-' + key, 'KML - Unsupported StyleMap key: ' + key);
                        }
                    }
                }
            }
        }

        var promises = [];
        var styleUrlNodes = kml.getElementsByTagName('styleUrl');
        var styleUrlNodesLength = styleUrlNodes.length;
        for (i = 0; i < styleUrlNodesLength; i++) {
            var styleReference = styleUrlNodes[i].textContent;
            if (styleReference[0] !== '#') {
                //According to the spec, all local styles should start with a #
                //and everything else is an external style that has a # seperating
                //the URL of the document and the style.  However, Google Earth
                //also accepts styleUrls without a # as meaning a local style.
                var tokens = styleReference.split('#');
                if (tokens.length === 2) {
                    var uri = tokens[0];
                    var resource = sourceResource.getDerivedResource({
                        url: uri
                    });

                    promises.push(processExternalStyles(dataSource, resource, styleCollection));
                }
            }
        }

        return promises;
    }

    function createDropLine(entityCollection, entity, styleEntity) {
        var entityPosition = new ReferenceProperty(entityCollection, entity.id, ['position']);
        var surfacePosition = new ScaledPositionProperty(entity.position);
        entity.polyline = defined(styleEntity.polyline) ? styleEntity.polyline.clone() : new PolylineGraphics();
        entity.polyline.positions = new PositionPropertyArray([entityPosition, surfacePosition]);
    }

    function heightReferenceFromAltitudeMode(altitudeMode, gxAltitudeMode) {
        if (!defined(altitudeMode) && !defined(gxAltitudeMode) || altitudeMode === 'clampToGround') {
            return HeightReference.CLAMP_TO_GROUND;
        }

        if (altitudeMode === 'relativeToGround') {
            return HeightReference.RELATIVE_TO_GROUND;
        }

        if (altitudeMode === 'absolute') {
            return HeightReference.NONE;
        }

        if (gxAltitudeMode === 'clampToSeaFloor') {
            oneTimeWarning('kml-gx:altitudeMode-clampToSeaFloor', 'KML - <gx:altitudeMode>:clampToSeaFloor is currently not supported, using <kml:altitudeMode>:clampToGround.');
            return HeightReference.CLAMP_TO_GROUND;
        }

        if (gxAltitudeMode === 'relativeToSeaFloor') {
            oneTimeWarning('kml-gx:altitudeMode-relativeToSeaFloor', 'KML - <gx:altitudeMode>:relativeToSeaFloor is currently not supported, using <kml:altitudeMode>:relativeToGround.');
            return HeightReference.RELATIVE_TO_GROUND;
        }

        if (defined(altitudeMode)) {
            oneTimeWarning('kml-altitudeMode-unknown', 'KML - Unknown <kml:altitudeMode>:' + altitudeMode + ', using <kml:altitudeMode>:CLAMP_TO_GROUND.');
        } else {
            oneTimeWarning('kml-gx:altitudeMode-unknown', 'KML - Unknown <gx:altitudeMode>:' + gxAltitudeMode + ', using <kml:altitudeMode>:CLAMP_TO_GROUND.');
        }

        // Clamp to ground is the default
        return HeightReference.CLAMP_TO_GROUND;
    }

    function createPositionPropertyFromAltitudeMode(property, altitudeMode, gxAltitudeMode) {
        if (gxAltitudeMode === 'relativeToSeaFloor' || altitudeMode === 'absolute' || altitudeMode === 'relativeToGround') {
            //Just return the ellipsoid referenced property until we support MSL
            return property;
        }

        if ((defined(altitudeMode) && altitudeMode !== 'clampToGround') || //
            (defined(gxAltitudeMode) && gxAltitudeMode !== 'clampToSeaFloor')) {
            oneTimeWarning('kml-altitudeMode-unknown', 'KML - Unknown altitudeMode: ' + defaultValue(altitudeMode, gxAltitudeMode));
        }

        // Clamp to ground is the default
        return new ScaledPositionProperty(property);
    }

    function createPositionPropertyArrayFromAltitudeMode(properties, altitudeMode, gxAltitudeMode, ellipsoid) {
        if (!defined(properties)) {
            return undefined;
        }

        if (gxAltitudeMode === 'relativeToSeaFloor' || altitudeMode === 'absolute' || altitudeMode === 'relativeToGround') {
            //Just return the ellipsoid referenced property until we support MSL
            return properties;
        }

        if ((defined(altitudeMode) && altitudeMode !== 'clampToGround') || //
            (defined(gxAltitudeMode) && gxAltitudeMode !== 'clampToSeaFloor')) {
            oneTimeWarning('kml-altitudeMode-unknown', 'KML - Unknown altitudeMode: ' + defaultValue(altitudeMode, gxAltitudeMode));
        }

        // Clamp to ground is the default
        var propertiesLength = properties.length;
        for (var i = 0; i < propertiesLength; i++) {
            var property = properties[i];
            ellipsoid.scaleToGeodeticSurface(property, property);
        }
        return properties;
    }

    function processPositionGraphics(dataSource, entity, styleEntity, heightReference) {
        var label = entity.label;
        if (!defined(label)) {
            label = defined(styleEntity.label) ? styleEntity.label.clone() : createDefaultLabel();
            entity.label = label;
        }
        label.text = entity.name;

        var billboard = entity.billboard;
        if (!defined(billboard)) {
            billboard = defined(styleEntity.billboard) ? styleEntity.billboard.clone() : createDefaultBillboard();
            entity.billboard = billboard;
        }

        if (!defined(billboard.image)) {
            billboard.image = dataSource._pinBuilder.fromColor(Color.YELLOW, 64);

        // If there were empty <Icon> tags in the KML, then billboard.image was set to false above
        // However, in this case, the false value would have been converted to a property afterwards
        // Thus, we check if billboard.image is defined with value of false
        } else if (!billboard.image.getValue()) {
            billboard.image = undefined;
        }

        var scale = 1.0;
        if (defined(billboard.scale)) {
            scale = billboard.scale.getValue();
            if (scale !== 0) {
                label.pixelOffset = new Cartesian2((scale * 16) + 1, 0);
            } else {
                //Minor tweaks to better match Google Earth.
                label.pixelOffset = undefined;
                label.horizontalOrigin = undefined;
            }
        }

        if (defined(heightReference) && dataSource._clampToGround) {
            billboard.heightReference = heightReference;
            label.heightReference = heightReference;
        }
    }

    function processPathGraphics(entity, styleEntity) {
        var path = entity.path;
        if (!defined(path)) {
            path = new PathGraphics();
            path.leadTime = 0;
            entity.path = path;
        }

        var polyline = styleEntity.polyline;
        if (defined(polyline)) {
            path.material = polyline.material;
            path.width = polyline.width;
        }
    }

    function processPoint(dataSource, entityCollection, geometryNode, entity, styleEntity) {
        var coordinatesString = queryStringValue(geometryNode, 'coordinates', namespaces.kml);
        var altitudeMode = queryStringValue(geometryNode, 'altitudeMode', namespaces.kml);
        var gxAltitudeMode = queryStringValue(geometryNode, 'altitudeMode', namespaces.gx);
        var extrude = queryBooleanValue(geometryNode, 'extrude', namespaces.kml);
        var ellipsoid = dataSource._ellipsoid;
        var position = readCoordinate(coordinatesString, ellipsoid);

        entity.position = position;
        processPositionGraphics(dataSource, entity, styleEntity, heightReferenceFromAltitudeMode(altitudeMode, gxAltitudeMode));

        if (extrude && isExtrudable(altitudeMode, gxAltitudeMode)) {
            createDropLine(entityCollection, entity, styleEntity);
        }

        return true;
    }

    function processLineStringOrLinearRing(dataSource, entityCollection, geometryNode, entity, styleEntity) {
        var coordinatesNode = queryFirstNode(geometryNode, 'coordinates', namespaces.kml);
        var altitudeMode = queryStringValue(geometryNode, 'altitudeMode', namespaces.kml);
        var gxAltitudeMode = queryStringValue(geometryNode, 'altitudeMode', namespaces.gx);
        var extrude = queryBooleanValue(geometryNode, 'extrude', namespaces.kml);
        var tessellate = queryBooleanValue(geometryNode, 'tessellate', namespaces.kml);
        var canExtrude = isExtrudable(altitudeMode, gxAltitudeMode);
        var zIndex = queryNumericValue(geometryNode, 'drawOrder', namespaces.gx);

        var ellipsoid = dataSource._ellipsoid;
        var coordinates = readCoordinates(coordinatesNode, ellipsoid);
        var polyline = styleEntity.polyline;
        if (canExtrude && extrude) {
            var wall = new WallGraphics();
            entity.wall = wall;
            wall.positions = coordinates;
            var polygon = styleEntity.polygon;

            if (defined(polygon)) {
                wall.fill = polygon.fill;
                wall.material = polygon.material;
            }

            //Always outline walls so they show up in 2D.
            wall.outline = true;
            if (defined(polyline)) {
                wall.outlineColor = defined(polyline.material) ? polyline.material.color : Color.WHITE;
                wall.outlineWidth = polyline.width;
            } else if (defined(polygon)) {
                wall.outlineColor = defined(polygon.material) ? polygon.material.color : Color.WHITE;
            }
        } else if (dataSource._clampToGround && !canExtrude && tessellate) {
            var polylineGraphics = new PolylineGraphics();
            polylineGraphics.clampToGround = true;
            entity.polyline = polylineGraphics;
            polylineGraphics.positions = coordinates;
            if (defined(polyline)) {
                polylineGraphics.material = defined(polyline.material) ? polyline.material.color.getValue(Iso8601.MINIMUM_VALUE) : Color.WHITE;
                polylineGraphics.width = defaultValue(polyline.width, 1.0);
            } else {
                polylineGraphics.material = Color.WHITE;
                polylineGraphics.width = 1.0;
            }
            polylineGraphics.zIndex = zIndex;
        } else {
            if (defined(zIndex)) {
                oneTimeWarning('kml-gx:drawOrder', 'KML - gx:drawOrder is not supported in LineStrings when clampToGround is false');
            }

            polyline = defined(polyline) ? polyline.clone() : new PolylineGraphics();
            entity.polyline = polyline;
            polyline.positions = createPositionPropertyArrayFromAltitudeMode(coordinates, altitudeMode, gxAltitudeMode, ellipsoid);
            if (!tessellate || canExtrude) {
                polyline.followSurface = false;
            }
        }

        return true;
    }

    function processPolygon(dataSource, entityCollection, geometryNode, entity, styleEntity) {
        var outerBoundaryIsNode = queryFirstNode(geometryNode, 'outerBoundaryIs', namespaces.kml);
        var linearRingNode = queryFirstNode(outerBoundaryIsNode, 'LinearRing', namespaces.kml);
        var coordinatesNode = queryFirstNode(linearRingNode, 'coordinates', namespaces.kml);
        var ellipsoid = dataSource._ellipsoid;
        var coordinates = readCoordinates(coordinatesNode, ellipsoid);
        var extrude = queryBooleanValue(geometryNode, 'extrude', namespaces.kml);
        var altitudeMode = queryStringValue(geometryNode, 'altitudeMode', namespaces.kml);
        var gxAltitudeMode = queryStringValue(geometryNode, 'altitudeMode', namespaces.gx);
        var canExtrude = isExtrudable(altitudeMode, gxAltitudeMode);

        var polygon = defined(styleEntity.polygon) ? styleEntity.polygon.clone() : createDefaultPolygon();

        var polyline = styleEntity.polyline;
        if (defined(polyline)) {
            polygon.outlineColor = defined(polyline.material) ? polyline.material.color : Color.WHITE;
            polygon.outlineWidth = polyline.width;
        }
        entity.polygon = polygon;

        if (canExtrude) {
            polygon.perPositionHeight = true;
            polygon.extrudedHeight = extrude ? 0 : undefined;
        } else if (!dataSource._clampToGround) {
            polygon.height = 0;
        }

        if (defined(coordinates)) {
            var hierarchy = new PolygonHierarchy(coordinates);
            var innerBoundaryIsNodes = queryChildNodes(geometryNode, 'innerBoundaryIs', namespaces.kml);
            for (var j = 0; j < innerBoundaryIsNodes.length; j++) {
                linearRingNode = queryChildNodes(innerBoundaryIsNodes[j], 'LinearRing', namespaces.kml);
                for (var k = 0; k < linearRingNode.length; k++) {
                    coordinatesNode = queryFirstNode(linearRingNode[k], 'coordinates', namespaces.kml);
                    coordinates = readCoordinates(coordinatesNode, ellipsoid);
                    if (defined(coordinates)) {
                        hierarchy.holes.push(new PolygonHierarchy(coordinates));
                    }
                }
            }
            polygon.hierarchy = hierarchy;
        }

        return true;
    }

    function processTrack(dataSource, entityCollection, geometryNode, entity, styleEntity) {
        var altitudeMode = queryStringValue(geometryNode, 'altitudeMode', namespaces.kml);
        var gxAltitudeMode = queryStringValue(geometryNode, 'altitudeMode', namespaces.gx);
        var coordNodes = queryChildNodes(geometryNode, 'coord', namespaces.gx);
        var angleNodes = queryChildNodes(geometryNode, 'angles', namespaces.gx);
        var timeNodes = queryChildNodes(geometryNode, 'when', namespaces.kml);
        var extrude = queryBooleanValue(geometryNode, 'extrude', namespaces.kml);
        var canExtrude = isExtrudable(altitudeMode, gxAltitudeMode);
        var ellipsoid = dataSource._ellipsoid;

        if (angleNodes.length > 0) {
            oneTimeWarning('kml-gx:angles', 'KML - gx:angles are not supported in gx:Tracks');
        }

        var length = Math.min(coordNodes.length, timeNodes.length);
        var coordinates = [];
        var times = [];
        for (var i = 0; i < length; i++) {
            var position = readCoordinate(coordNodes[i].textContent, ellipsoid);
            coordinates.push(position);
            times.push(JulianDate.fromIso8601(timeNodes[i].textContent));
        }
        var property = new SampledPositionProperty();
        property.addSamples(times, coordinates);
        entity.position = property;
        processPositionGraphics(dataSource, entity, styleEntity, heightReferenceFromAltitudeMode(altitudeMode, gxAltitudeMode));
        processPathGraphics(entity, styleEntity);

        entity.availability = new TimeIntervalCollection();

        if (timeNodes.length > 0) {
            entity.availability.addInterval(new TimeInterval({
                start : times[0],
                stop : times[times.length - 1]
            }));
        }

        if (canExtrude && extrude) {
            createDropLine(entityCollection, entity, styleEntity);
        }

        return true;
    }

    function addToMultiTrack(times, positions, composite, availability, dropShowProperty, extrude, altitudeMode, gxAltitudeMode, includeEndPoints) {
        var start = times[0];
        var stop = times[times.length - 1];

        var data = new SampledPositionProperty();
        data.addSamples(times, positions);

        composite.intervals.addInterval(new TimeInterval({
            start : start,
            stop : stop,
            isStartIncluded : includeEndPoints,
            isStopIncluded : includeEndPoints,
            data : createPositionPropertyFromAltitudeMode(data, altitudeMode, gxAltitudeMode)
        }));
        availability.addInterval(new TimeInterval({
            start : start,
            stop : stop,
            isStartIncluded : includeEndPoints,
            isStopIncluded : includeEndPoints
        }));
        dropShowProperty.intervals.addInterval(new TimeInterval({
            start : start,
            stop : stop,
            isStartIncluded : includeEndPoints,
            isStopIncluded : includeEndPoints,
            data : extrude
        }));
    }

    function processMultiTrack(dataSource, entityCollection, geometryNode, entity, styleEntity) {
        // Multitrack options do not work in GE as detailed in the spec,
        // rather than altitudeMode being at the MultiTrack level,
        // GE just defers all settings to the underlying track.

        var interpolate = queryBooleanValue(geometryNode, 'interpolate', namespaces.gx);
        var trackNodes = queryChildNodes(geometryNode, 'Track', namespaces.gx);

        var times;
        var lastStop;
        var lastStopPosition;
        var needDropLine = false;
        var dropShowProperty = new TimeIntervalCollectionProperty();
        var availability = new TimeIntervalCollection();
        var composite = new CompositePositionProperty();
        var ellipsoid = dataSource._ellipsoid;
        for (var i = 0, len = trackNodes.length; i < len; i++) {
            var trackNode = trackNodes[i];
            var timeNodes = queryChildNodes(trackNode, 'when', namespaces.kml);
            var coordNodes = queryChildNodes(trackNode, 'coord', namespaces.gx);
            var altitudeMode = queryStringValue(trackNode, 'altitudeMode', namespaces.kml);
            var gxAltitudeMode = queryStringValue(trackNode, 'altitudeMode', namespaces.gx);
            var canExtrude = isExtrudable(altitudeMode, gxAltitudeMode);
            var extrude = queryBooleanValue(trackNode, 'extrude', namespaces.kml);

            var length = Math.min(coordNodes.length, timeNodes.length);

            var positions = [];
            times = [];
            for (var x = 0; x < length; x++) {
                var position = readCoordinate(coordNodes[x].textContent, ellipsoid);
                positions.push(position);
                times.push(JulianDate.fromIso8601(timeNodes[x].textContent));
            }

            if (interpolate) {
                //If we are interpolating, then we need to fill in the end of
                //the last track and the beginning of this one with a sampled
                //property.  From testing in Google Earth, this property
                //is never extruded and always absolute.
                if (defined(lastStop)) {
                    addToMultiTrack([lastStop, times[0]], [lastStopPosition, positions[0]], composite, availability, dropShowProperty, false, 'absolute', undefined, false);
                }
                lastStop = times[length - 1];
                lastStopPosition = positions[positions.length - 1];
            }

            addToMultiTrack(times, positions, composite, availability, dropShowProperty, canExtrude && extrude, altitudeMode, gxAltitudeMode, true);
            needDropLine = needDropLine || (canExtrude && extrude);
        }

        entity.availability = availability;
        entity.position = composite;
        processPositionGraphics(dataSource, entity, styleEntity);
        processPathGraphics(entity, styleEntity);
        if (needDropLine) {
            createDropLine(entityCollection, entity, styleEntity);
            entity.polyline.show = dropShowProperty;
        }

        return true;
    }

    var geometryTypes = {
        Point : processPoint,
        LineString : processLineStringOrLinearRing,
        LinearRing : processLineStringOrLinearRing,
        Polygon : processPolygon,
        Track : processTrack,
        MultiTrack : processMultiTrack,
        MultiGeometry : processMultiGeometry,
        Model : processUnsupportedGeometry
    };

    function processMultiGeometry(dataSource, entityCollection, geometryNode, entity, styleEntity, context) {
        var childNodes = geometryNode.childNodes;
        var hasGeometry = false;
        for (var i = 0, len = childNodes.length; i < len; i++) {
            var childNode = childNodes.item(i);
            var geometryProcessor = geometryTypes[childNode.localName];
            if (defined(geometryProcessor)) {
                var childEntity = createEntity(childNode, entityCollection, context);
                childEntity.parent = entity;
                childEntity.name = entity.name;
                childEntity.availability = entity.availability;
                childEntity.description = entity.description;
                childEntity.kml = entity.kml;
                if (geometryProcessor(dataSource, entityCollection, childNode, childEntity, styleEntity)) {
                    hasGeometry = true;
                }
            }
        }

        return hasGeometry;
    }

    function processUnsupportedGeometry(dataSource, entityCollection, geometryNode, entity, styleEntity) {
        oneTimeWarning('kml-unsupportedGeometry', 'KML - Unsupported geometry: ' + geometryNode.localName);
        return false;
    }

    function processExtendedData(node, entity) {
        var extendedDataNode = queryFirstNode(node, 'ExtendedData', namespaces.kml);

        if (!defined(extendedDataNode)) {
            return undefined;
        }

        if (defined(queryFirstNode(extendedDataNode, 'SchemaData', namespaces.kml))) {
            oneTimeWarning('kml-schemaData', 'KML - SchemaData is unsupported');
        }
        if (defined(queryStringAttribute(extendedDataNode, 'xmlns:prefix'))) {
            oneTimeWarning('kml-extendedData', 'KML - ExtendedData with xmlns:prefix is unsupported');
        }

        var result = {};
        var dataNodes = queryChildNodes(extendedDataNode, 'Data', namespaces.kml);
        if (defined(dataNodes)) {
            var length = dataNodes.length;
            for (var i = 0; i < length; i++) {
                var dataNode = dataNodes[i];
                var name = queryStringAttribute(dataNode, 'name');
                if (defined(name)) {
                    result[name] = {
                        displayName : queryStringValue(dataNode, 'displayName', namespaces.kml),
                        value : queryStringValue(dataNode, 'value', namespaces.kml)
                    };
                }
            }
        }
        entity.kml.extendedData = result;
    }

    var scratchDiv = document.createElement('div');

    function processDescription(node, entity, styleEntity, uriResolver, sourceResource) {
        var i;
        var key;
        var keys;

        var kmlData = entity.kml;
        var extendedData = kmlData.extendedData;
        var description = queryStringValue(node, 'description', namespaces.kml);

        var balloonStyle = defaultValue(entity.balloonStyle, styleEntity.balloonStyle);

        var background = Color.WHITE;
        var foreground = Color.BLACK;
        var text = description;

        if (defined(balloonStyle)) {
            background = defaultValue(balloonStyle.bgColor, Color.WHITE);
            foreground = defaultValue(balloonStyle.textColor, Color.BLACK);
            text = defaultValue(balloonStyle.text, description);
        }

        var value;
        if (defined(text)) {
            text = text.replace('$[name]', defaultValue(entity.name, ''));
            text = text.replace('$[description]', defaultValue(description, ''));
            text = text.replace('$[address]', defaultValue(kmlData.address, ''));
            text = text.replace('$[Snippet]', defaultValue(kmlData.snippet, ''));
            text = text.replace('$[id]', entity.id);

            //While not explicitly defined by the OGC spec, in Google Earth
            //The appearance of geDirections adds the directions to/from links
            //We simply replace this string with nothing.
            text = text.replace('$[geDirections]', '');

            if (defined(extendedData)) {
                var matches = text.match(/\$\[.+?\]/g);
                if (matches !== null) {
                    for (i = 0; i < matches.length; i++) {
                        var token = matches[i];
                        var propertyName = token.substr(2, token.length - 3);
                        var isDisplayName = /\/displayName$/.test(propertyName);
                        propertyName = propertyName.replace(/\/displayName$/, '');

                        value = extendedData[propertyName];
                        if (defined(value)) {
                            value = isDisplayName ? value.displayName : value.value;
                        }
                        if (defined(value)) {
                            text = text.replace(token, defaultValue(value, ''));
                        }
                    }
                }
            }
        } else if (defined(extendedData)) {
            //If no description exists, build a table out of the extended data
            keys = Object.keys(extendedData);
            if (keys.length > 0) {
                text = '<table class="cesium-infoBox-defaultTable cesium-infoBox-defaultTable-lighter"><tbody>';
                for (i = 0; i < keys.length; i++) {
                    key = keys[i];
                    value = extendedData[key];
                    text += '<tr><th>' + defaultValue(value.displayName, key) + '</th><td>' + defaultValue(value.value, '') + '</td></tr>';
                }
                text += '</tbody></table>';
            }
        }

        if (!defined(text)) {
            //No description
            return;
        }

        //Turns non-explicit links into clickable links.
        text = autolinker.link(text);

        //Use a temporary div to manipulate the links
        //so that they open in a new window.
        scratchDiv.innerHTML = text;
        var links = scratchDiv.querySelectorAll('a');
        for (i = 0; i < links.length; i++) {
            links[i].setAttribute('target', '_blank');
        }

        //Rewrite any KMZ embedded urls
        if (defined(uriResolver) && uriResolver.keys.length > 1) {
            embedDataUris(scratchDiv, 'a', 'href', uriResolver);
            embedDataUris(scratchDiv, 'img', 'src', uriResolver);
        }

        //Make relative urls absolute using the sourceResource
        applyBasePath(scratchDiv, 'a', 'href', sourceResource);
        applyBasePath(scratchDiv, 'img', 'src', sourceResource);

        var tmp = '<div class="cesium-infoBox-description-lighter" style="';
        tmp += 'overflow:auto;';
        tmp += 'word-wrap:break-word;';
        tmp += 'background-color:' + background.toCssColorString() + ';';
        tmp += 'color:' + foreground.toCssColorString() + ';';
        tmp += '">';
        tmp += scratchDiv.innerHTML + '</div>';
        scratchDiv.innerHTML = '';

        //Set the final HTML as the description.
        entity.description = tmp;
    }

    function processFeature(dataSource, parent, featureNode, entityCollection, styleCollection, sourceResource, uriResolver, promises, context) {
        var entity = createEntity(featureNode, entityCollection, context);
        var kmlData = entity.kml;
        var styleEntity = computeFinalStyle(dataSource, featureNode, styleCollection, sourceResource, uriResolver);

        var name = queryStringValue(featureNode, 'name', namespaces.kml);
        entity.name = name;
        entity.parent = parent;

        var availability = processTimeSpan(featureNode);
        if (!defined(availability)) {
            availability = processTimeStamp(featureNode);
        }
        entity.availability = availability;

        mergeAvailabilityWithParent(entity);

        // Per KML spec "A Feature is visible only if it and all its ancestors are visible."
        function ancestryIsVisible(parentEntity) {
            if (!parentEntity) {
                return true;
            }
            return parentEntity.show && ancestryIsVisible(parentEntity.parent);
        }

        var visibility = queryBooleanValue(featureNode, 'visibility', namespaces.kml);
        entity.show = ancestryIsVisible(parent) && defaultValue(visibility, true);
        //var open = queryBooleanValue(featureNode, 'open', namespaces.kml);

        var authorNode = queryFirstNode(featureNode, 'author', namespaces.atom);
        var author = kmlData.author;
        author.name = queryStringValue(authorNode, 'name', namespaces.atom);
        author.uri = queryStringValue(authorNode, 'uri', namespaces.atom);
        author.email = queryStringValue(authorNode, 'email', namespaces.atom);

        var linkNode = queryFirstNode(featureNode, 'link', namespaces.atom);
        var link = kmlData.link;
        link.href = queryStringAttribute(linkNode, 'href');
        link.hreflang = queryStringAttribute(linkNode, 'hreflang');
        link.rel = queryStringAttribute(linkNode, 'rel');
        link.type = queryStringAttribute(linkNode, 'type');
        link.title = queryStringAttribute(linkNode, 'title');
        link.length = queryStringAttribute(linkNode, 'length');

        kmlData.address = queryStringValue(featureNode, 'address', namespaces.kml);
        kmlData.phoneNumber = queryStringValue(featureNode, 'phoneNumber', namespaces.kml);
        kmlData.snippet = queryStringValue(featureNode, 'Snippet', namespaces.kml);

        processExtendedData(featureNode, entity);
        processDescription(featureNode, entity, styleEntity, uriResolver, sourceResource);

        var ellipsoid = dataSource._ellipsoid;
        processLookAt(featureNode, entity, ellipsoid);
        processCamera(featureNode, entity, ellipsoid);

        if (defined(queryFirstNode(featureNode, 'Region', namespaces.kml))) {
            oneTimeWarning('kml-region', 'KML - Placemark Regions are unsupported');
        }

        return {
            entity : entity,
            styleEntity : styleEntity
        };
    }

    // Ensure Specs/Data/KML/unsupported.kml is kept up to date with these supported types
    var featureTypes = {
        Document : processDocument,
        Folder : processFolder,
        Placemark : processPlacemark,
        NetworkLink : processNetworkLink,
        GroundOverlay : processGroundOverlay,
        PhotoOverlay : processUnsupportedFeature,
        ScreenOverlay : processUnsupportedFeature,
        Tour : processTour
    };

    function processDocument(dataSource, parent, node, entityCollection, styleCollection, sourceResource, uriResolver, promises, context) {
        var featureTypeNames = Object.keys(featureTypes);
        var featureTypeNamesLength = featureTypeNames.length;

        for (var i = 0; i < featureTypeNamesLength; i++) {
            var featureName = featureTypeNames[i];
            var processFeatureNode = featureTypes[featureName];

            var childNodes = node.childNodes;
            var length = childNodes.length;
            for (var q = 0; q < length; q++) {
                var child = childNodes[q];
                if (child.localName === featureName &&
                    ((namespaces.kml.indexOf(child.namespaceURI) !== -1) || (namespaces.gx.indexOf(child.namespaceURI) !== -1))) {
                    processFeatureNode(dataSource, parent, child, entityCollection, styleCollection, sourceResource, uriResolver, promises, context);
                }
            }
        }
    }

    function processFolder(dataSource, parent, node, entityCollection, styleCollection, sourceResource, uriResolver, promises, context) {
        var r = processFeature(dataSource, parent, node, entityCollection, styleCollection, sourceResource, uriResolver, promises, context);
        processDocument(dataSource, r.entity, node, entityCollection, styleCollection, sourceResource, uriResolver, promises, context);
    }

    function processPlacemark(dataSource, parent, placemark, entityCollection, styleCollection, sourceResource, uriResolver, promises, context) {
        var r = processFeature(dataSource, parent, placemark, entityCollection, styleCollection, sourceResource, uriResolver, promises, context);
        var entity = r.entity;
        var styleEntity = r.styleEntity;

        var hasGeometry = false;
        var childNodes = placemark.childNodes;
        for (var i = 0, len = childNodes.length; i < len && !hasGeometry; i++) {
            var childNode = childNodes.item(i);
            var geometryProcessor = geometryTypes[childNode.localName];
            if (defined(geometryProcessor)) {
                // pass the placemark entity id as a context for case of defining multiple child entities together to handle case
                // where some malformed kmls reuse the same id across placemarks, which works in GE, but is not technically to spec.
                geometryProcessor(dataSource, entityCollection, childNode, entity, styleEntity, entity.id);
                hasGeometry = true;
            }
        }

        if (!hasGeometry) {
            entity.merge(styleEntity);
            processPositionGraphics(dataSource, entity, styleEntity);
        }
    }

    var playlistNodeProcessors = {
        FlyTo: processTourFlyTo,
        Wait: processTourWait,
        SoundCue: processTourUnsupportedNode,
        AnimatedUpdate: processTourUnsupportedNode,
        TourControl: processTourUnsupportedNode
    };

    function processTour(dataSource, parent, node, entityCollection, styleCollection, sourceResource, uriResolver, promises, context) {
        var name = queryStringValue(node, 'name', namespaces.kml);
        var id = queryStringAttribute(node, 'id');
        var tour = new KmlTour(name, id);

        var playlistNode = queryFirstNode(node, 'Playlist', namespaces.gx);
        if(playlistNode) {
            var ellipsoid = dataSource._ellipsoid;
            var childNodes = playlistNode.childNodes;
            for(var i = 0; i < childNodes.length; i++) {
                var entryNode = childNodes[i];
                if (entryNode.localName) {
                    var playlistNodeProcessor = playlistNodeProcessors[entryNode.localName];
                    if (playlistNodeProcessor) {
                        playlistNodeProcessor(tour, entryNode, ellipsoid);
                    }
                    else {
                        console.log('Unknown KML Tour playlist entry type ' + entryNode.localName);
                    }
                }
            }
        }

        if (!defined(dataSource.kmlTours)) {
            dataSource.kmlTours = [];
        }

        dataSource.kmlTours.push(tour);
    }

    function processTourUnsupportedNode(tour, entryNode) {
        oneTimeWarning('KML Tour unsupported node ' + entryNode.localName);
    }

    function processTourWait(tour, entryNode) {
        var duration = queryNumericValue(entryNode, 'duration', namespaces.gx);
        tour.addPlaylistEntry(new KmlTourWait(duration));
    }

    function processTourFlyTo(tour, entryNode, ellipsoid) {
        var duration = queryNumericValue(entryNode, 'duration', namespaces.gx);
        var flyToMode = queryStringValue(entryNode, 'flyToMode', namespaces.gx);

        var t = {kml: {}};

        processLookAt(entryNode, t, ellipsoid);
        processCamera(entryNode, t, ellipsoid);

        var view = t.kml.lookAt || t.kml.camera;

        var flyto = new KmlTourFlyTo(duration, flyToMode, view);
        tour.addPlaylistEntry(flyto);
    }

    function processCamera(featureNode, entity, ellipsoid) {
        var camera = queryFirstNode(featureNode, 'Camera', namespaces.kml);
        if(defined(camera)) {
            var lon = defaultValue(queryNumericValue(camera, 'longitude', namespaces.kml), 0.0);
            var lat = defaultValue(queryNumericValue(camera, 'latitude', namespaces.kml), 0.0);
            var altitude = defaultValue(queryNumericValue(camera, 'altitude', namespaces.kml), 0.0);

            var heading = defaultValue(queryNumericValue(camera, 'heading', namespaces.kml), 0.0);
            var tilt = defaultValue(queryNumericValue(camera, 'tilt', namespaces.kml), 0.0);
            var roll = defaultValue(queryNumericValue(camera, 'roll', namespaces.kml), 0.0);

            var position = Cartesian3.fromDegrees(lon, lat, altitude, ellipsoid);
            var hpr = HeadingPitchRoll.fromDegrees(heading, tilt - 90.0, roll);

            entity.kml.camera = new KmlCamera(position, hpr);
        }
    }

    function processLookAt(featureNode, entity, ellipsoid) {
        var lookAt = queryFirstNode(featureNode, 'LookAt', namespaces.kml);
        if(defined(lookAt)) {
            var lon = defaultValue(queryNumericValue(lookAt, 'longitude', namespaces.kml), 0.0);
            var lat = defaultValue(queryNumericValue(lookAt, 'latitude', namespaces.kml), 0.0);
            var altitude = defaultValue(queryNumericValue(lookAt, 'altitude', namespaces.kml), 0.0);
            var heading = queryNumericValue(lookAt, 'heading', namespaces.kml);
            var tilt = queryNumericValue(lookAt, 'tilt', namespaces.kml);
            var range = defaultValue(queryNumericValue(lookAt, 'range', namespaces.kml), 0.0);

            tilt = CesiumMath.toRadians(defaultValue(tilt, 0.0));
            heading = CesiumMath.toRadians(defaultValue(heading, 0.0));

            var hpr = new HeadingPitchRange(heading, tilt - CesiumMath.PI_OVER_TWO, range);
            var viewPoint = Cartesian3.fromDegrees(lon, lat, altitude, ellipsoid);

            entity.kml.lookAt = new KmlLookAt(viewPoint, hpr);
        }
    }

    function processGroundOverlay(dataSource, parent, groundOverlay, entityCollection, styleCollection, sourceResource, uriResolver, promises, context) {
        var r = processFeature(dataSource, parent, groundOverlay, entityCollection, styleCollection, sourceResource, uriResolver, promises, context);
        var entity = r.entity;

        var geometry;
        var isLatLonQuad = false;

        var ellipsoid = dataSource._ellipsoid;
        var positions = readCoordinates(queryFirstNode(groundOverlay, 'LatLonQuad', namespaces.gx), ellipsoid);
        var zIndex = queryNumericValue(groundOverlay, 'drawOrder', namespaces.kml);
        if (defined(positions)) {
            geometry = createDefaultPolygon();
            geometry.hierarchy = new PolygonHierarchy(positions);
            geometry.zIndex = zIndex;
            entity.polygon = geometry;
            isLatLonQuad = true;
        } else {
            geometry = new RectangleGraphics();
            geometry.zIndex = zIndex;
            entity.rectangle = geometry;

            var latLonBox = queryFirstNode(groundOverlay, 'LatLonBox', namespaces.kml);
            if (defined(latLonBox)) {
                var west = queryNumericValue(latLonBox, 'west', namespaces.kml);
                var south = queryNumericValue(latLonBox, 'south', namespaces.kml);
                var east = queryNumericValue(latLonBox, 'east', namespaces.kml);
                var north = queryNumericValue(latLonBox, 'north', namespaces.kml);

                if (defined(west)) {
                    west = CesiumMath.negativePiToPi(CesiumMath.toRadians(west));
                }
                if (defined(south)) {
                    south = CesiumMath.clampToLatitudeRange(CesiumMath.toRadians(south));
                }
                if (defined(east)) {
                    east = CesiumMath.negativePiToPi(CesiumMath.toRadians(east));
                }
                if (defined(north)) {
                    north = CesiumMath.clampToLatitudeRange(CesiumMath.toRadians(north));
                }
                geometry.coordinates = new Rectangle(west, south, east, north);

                var rotation = queryNumericValue(latLonBox, 'rotation', namespaces.kml);
                if (defined(rotation)) {
                    var rotationRadians = CesiumMath.toRadians(rotation);
                    geometry.rotation = rotationRadians;
                    geometry.stRotation = rotationRadians;
                }
            }
        }

        var iconNode = queryFirstNode(groundOverlay, 'Icon', namespaces.kml);
        var href = getIconHref(iconNode, dataSource, sourceResource, uriResolver, true);
        if (defined(href)) {
            if (isLatLonQuad) {
                oneTimeWarning('kml-gx:LatLonQuad', 'KML - gx:LatLonQuad Icon does not support texture projection.');
            }
            var x = queryNumericValue(iconNode, 'x', namespaces.gx);
            var y = queryNumericValue(iconNode, 'y', namespaces.gx);
            var w = queryNumericValue(iconNode, 'w', namespaces.gx);
            var h = queryNumericValue(iconNode, 'h', namespaces.gx);

            if (defined(x) || defined(y) || defined(w) || defined(h)) {
                oneTimeWarning('kml-groundOverlay-xywh', 'KML - gx:x, gx:y, gx:w, gx:h aren\'t supported for GroundOverlays');
            }

            geometry.material = href;
            geometry.material.color = queryColorValue(groundOverlay, 'color', namespaces.kml);
            geometry.material.transparent = true;
        } else {
            geometry.material = queryColorValue(groundOverlay, 'color', namespaces.kml);
        }

        var altitudeMode = queryStringValue(groundOverlay, 'altitudeMode', namespaces.kml);

        if (defined(altitudeMode)) {
            if (altitudeMode === 'absolute') {
                //Use height above ellipsoid until we support MSL.
                geometry.height = queryNumericValue(groundOverlay, 'altitude', namespaces.kml);
                geometry.zIndex = undefined;
            } else if (altitudeMode !== 'clampToGround') {
                oneTimeWarning('kml-altitudeMode-unknown', 'KML - Unknown altitudeMode: ' + altitudeMode);
            }
            // else just use the default of 0 until we support 'clampToGround'
        } else {
            altitudeMode = queryStringValue(groundOverlay, 'altitudeMode', namespaces.gx);
            if (altitudeMode === 'relativeToSeaFloor') {
                oneTimeWarning('kml-altitudeMode-relativeToSeaFloor', 'KML - altitudeMode relativeToSeaFloor is currently not supported, treating as absolute.');
                geometry.height = queryNumericValue(groundOverlay, 'altitude', namespaces.kml);
                geometry.zIndex = undefined;
            } else if (altitudeMode === 'clampToSeaFloor') {
                oneTimeWarning('kml-altitudeMode-clampToSeaFloor', 'KML - altitudeMode clampToSeaFloor is currently not supported, treating as clampToGround.');
            } else if (defined(altitudeMode)) {
                oneTimeWarning('kml-altitudeMode-unknown', 'KML - Unknown altitudeMode: ' + altitudeMode);
            }
        }
    }

    function processUnsupportedFeature(dataSource, parent, node, entityCollection, styleCollection, sourceResource, uriResolver, promises, context) {
        dataSource._unsupportedNode.raiseEvent(dataSource, parent, node, entityCollection, styleCollection, sourceResource, uriResolver);
        oneTimeWarning('kml-unsupportedFeature-' + node.nodeName, 'KML - Unsupported feature: ' + node.nodeName);
    }

    var RefreshMode = {
        INTERVAL : 0,
        EXPIRE : 1,
        STOP : 2
    };

    function cleanupString(s) {
        if (!defined(s) || s.length === 0) {
            return '';
        }

        var sFirst = s[0];
        if (sFirst === '&' || sFirst === '?') {
            s = s.substring(1);
        }

        return s;
    }

    var zeroRectangle = new Rectangle();
    var scratchCartographic = new Cartographic();
    var scratchCartesian2 = new Cartesian2();
    var scratchCartesian3 = new Cartesian3();

    function processNetworkLinkQueryString(resource, camera, canvas, viewBoundScale, bbox, ellipsoid) {
        function fixLatitude(value) {
            if (value < -CesiumMath.PI_OVER_TWO) {
                return -CesiumMath.PI_OVER_TWO;
            } else if (value > CesiumMath.PI_OVER_TWO) {
                return CesiumMath.PI_OVER_TWO;
            }
            return value;
        }

        function fixLongitude(value) {
            if (value > CesiumMath.PI) {
                return value - CesiumMath.TWO_PI;
            } else if (value < -CesiumMath.PI) {
                return value + CesiumMath.TWO_PI;
            }

            return value;
        }

        var queryString = objectToQuery(resource.queryParameters);

        // objectToQuery escapes [ and ], so fix that
        queryString = queryString.replace(/%5B/g, '[').replace(/%5D/g, ']');

        if (defined(camera) && camera._mode !== SceneMode.MORPHING) {
            var centerCartesian;
            var centerCartographic;

            bbox = defaultValue(bbox, zeroRectangle);
            if (defined(canvas)) {
                scratchCartesian2.x = canvas.clientWidth * 0.5;
                scratchCartesian2.y = canvas.clientHeight * 0.5;
                centerCartesian = camera.pickEllipsoid(scratchCartesian2, ellipsoid, scratchCartesian3);
            }

            if (defined(centerCartesian)) {
                centerCartographic = ellipsoid.cartesianToCartographic(centerCartesian, scratchCartographic);
            } else {
                centerCartographic = Rectangle.center(bbox, scratchCartographic);
                centerCartesian = ellipsoid.cartographicToCartesian(centerCartographic);
            }

            if (defined(viewBoundScale) && !CesiumMath.equalsEpsilon(viewBoundScale, 1.0, CesiumMath.EPSILON9)) {
                var newHalfWidth = bbox.width * viewBoundScale * 0.5;
                var newHalfHeight = bbox.height * viewBoundScale * 0.5;
                bbox = new Rectangle(fixLongitude(centerCartographic.longitude - newHalfWidth),
                    fixLatitude(centerCartographic.latitude - newHalfHeight),
                    fixLongitude(centerCartographic.longitude + newHalfWidth),
                    fixLatitude(centerCartographic.latitude + newHalfHeight)
                );
            }

            queryString = queryString.replace('[bboxWest]', CesiumMath.toDegrees(bbox.west).toString());
            queryString = queryString.replace('[bboxSouth]', CesiumMath.toDegrees(bbox.south).toString());
            queryString = queryString.replace('[bboxEast]', CesiumMath.toDegrees(bbox.east).toString());
            queryString = queryString.replace('[bboxNorth]', CesiumMath.toDegrees(bbox.north).toString());

            var lon = CesiumMath.toDegrees(centerCartographic.longitude).toString();
            var lat = CesiumMath.toDegrees(centerCartographic.latitude).toString();
            queryString = queryString.replace('[lookatLon]', lon);
            queryString = queryString.replace('[lookatLat]', lat);
            queryString = queryString.replace('[lookatTilt]', CesiumMath.toDegrees(camera.pitch).toString());
            queryString = queryString.replace('[lookatHeading]', CesiumMath.toDegrees(camera.heading).toString());
            queryString = queryString.replace('[lookatRange]', Cartesian3.distance(camera.positionWC, centerCartesian));
            queryString = queryString.replace('[lookatTerrainLon]', lon);
            queryString = queryString.replace('[lookatTerrainLat]', lat);
            queryString = queryString.replace('[lookatTerrainAlt]', centerCartographic.height.toString());

            ellipsoid.cartesianToCartographic(camera.positionWC, scratchCartographic);
            queryString = queryString.replace('[cameraLon]', CesiumMath.toDegrees(scratchCartographic.longitude).toString());
            queryString = queryString.replace('[cameraLat]', CesiumMath.toDegrees(scratchCartographic.latitude).toString());
            queryString = queryString.replace('[cameraAlt]', CesiumMath.toDegrees(scratchCartographic.height).toString());

            var frustum = camera.frustum;
            var aspectRatio = frustum.aspectRatio;
            var horizFov = '';
            var vertFov = '';
            if (defined(aspectRatio)) {
                var fov = CesiumMath.toDegrees(frustum.fov);
                if (aspectRatio > 1.0) {
                    horizFov = fov;
                    vertFov = fov / aspectRatio;
                } else {
                    vertFov = fov;
                    horizFov = fov * aspectRatio;
                }
            }
            queryString = queryString.replace('[horizFov]', horizFov.toString());
            queryString = queryString.replace('[vertFov]', vertFov.toString());
        } else {
            queryString = queryString.replace('[bboxWest]', '-180');
            queryString = queryString.replace('[bboxSouth]', '-90');
            queryString = queryString.replace('[bboxEast]', '180');
            queryString = queryString.replace('[bboxNorth]', '90');

            queryString = queryString.replace('[lookatLon]', '');
            queryString = queryString.replace('[lookatLat]', '');
            queryString = queryString.replace('[lookatRange]', '');
            queryString = queryString.replace('[lookatTilt]', '');
            queryString = queryString.replace('[lookatHeading]', '');
            queryString = queryString.replace('[lookatTerrainLon]', '');
            queryString = queryString.replace('[lookatTerrainLat]', '');
            queryString = queryString.replace('[lookatTerrainAlt]', '');

            queryString = queryString.replace('[cameraLon]', '');
            queryString = queryString.replace('[cameraLat]', '');
            queryString = queryString.replace('[cameraAlt]', '');
            queryString = queryString.replace('[horizFov]', '');
            queryString = queryString.replace('[vertFov]', '');
        }

        if (defined(canvas)) {
            queryString = queryString.replace('[horizPixels]', canvas.clientWidth);
            queryString = queryString.replace('[vertPixels]', canvas.clientHeight);
        } else {
            queryString = queryString.replace('[horizPixels]', '');
            queryString = queryString.replace('[vertPixels]', '');
        }

        queryString = queryString.replace('[terrainEnabled]', '1');
        queryString = queryString.replace('[clientVersion]', '1');
        queryString = queryString.replace('[kmlVersion]', '2.2');
        queryString = queryString.replace('[clientName]', 'Cesium');
        queryString = queryString.replace('[language]', 'English');

        resource.setQueryParameters(queryToObject(queryString));
    }

    function processNetworkLink(dataSource, parent, node, entityCollection, styleCollection, sourceResource, uriResolver, promises, context) {
        var r = processFeature(dataSource, parent, node, entityCollection, styleCollection, sourceResource, uriResolver, promises, context);
        var networkEntity = r.entity;

        var link = queryFirstNode(node, 'Link', namespaces.kml);

        if (!defined(link)) {
            link = queryFirstNode(node, 'Url', namespaces.kml);
        }
        if (defined(link)) {
            var href = queryStringValue(link, 'href', namespaces.kml);
            var viewRefreshMode;
            var viewBoundScale;
            if (defined(href)) {
                var newSourceUri = href;
                href = resolveHref(href, sourceResource, uriResolver);

                // We need to pass in the original path if resolveHref returns a data uri because the network link
                //  references a document in a KMZ archive
                if (/^data:/.test(href.getUrlComponent())) {
                    // So if sourceUri isn't the kmz file, then its another kml in the archive, so resolve it
                    if (!/\.kmz/i.test(sourceResource.getUrlComponent())) {
                        newSourceUri = sourceResource.getDerivedResource({
                            url: newSourceUri
                        });
                    }
                } else {
                    newSourceUri = href.clone(); // Not a data uri so use the fully qualified uri
                    viewRefreshMode = queryStringValue(link, 'viewRefreshMode', namespaces.kml);
                    viewBoundScale = defaultValue(queryStringValue(link, 'viewBoundScale', namespaces.kml), 1.0);
                    var defaultViewFormat = (viewRefreshMode === 'onStop') ? 'BBOX=[bboxWest],[bboxSouth],[bboxEast],[bboxNorth]' : '';
                    var viewFormat = defaultValue(queryStringValue(link, 'viewFormat', namespaces.kml), defaultViewFormat);
                    var httpQuery = queryStringValue(link, 'httpQuery', namespaces.kml);
                    if (defined(viewFormat)) {
                        href.setQueryParameters(queryToObject(cleanupString(viewFormat)));
                    }
                    if (defined(httpQuery)) {
                        href.setQueryParameters(queryToObject(cleanupString(httpQuery)));
                    }

                    var ellipsoid = dataSource._ellipsoid;
                    processNetworkLinkQueryString(href, dataSource._camera, dataSource._canvas, viewBoundScale, dataSource._lastCameraView.bbox, ellipsoid);
                }

                var options = {
                    sourceUri : newSourceUri,
                    uriResolver : uriResolver,
                    context : networkEntity.id
                };
                var networkLinkCollection = new EntityCollection();
                var promise = load(dataSource, networkLinkCollection, href, options).then(function(rootElement) {
                    var entities = dataSource._entityCollection;
                    var newEntities = networkLinkCollection.values;
                    entities.suspendEvents();
                    for (var i = 0; i < newEntities.length; i++) {
                        var newEntity = newEntities[i];
                        if (!defined(newEntity.parent)) {
                            newEntity.parent = networkEntity;
                            mergeAvailabilityWithParent(newEntity);
                        }

                        entities.add(newEntity);
                    }
                    entities.resumeEvents();

                    // Add network links to a list if we need they will need to be updated
                    var refreshMode = queryStringValue(link, 'refreshMode', namespaces.kml);
                    var refreshInterval = defaultValue(queryNumericValue(link, 'refreshInterval', namespaces.kml), 0);
                    if ((refreshMode === 'onInterval' && refreshInterval > 0 ) || (refreshMode === 'onExpire') || (viewRefreshMode === 'onStop')) {
                        var networkLinkControl = queryFirstNode(rootElement, 'NetworkLinkControl', namespaces.kml);
                        var hasNetworkLinkControl = defined(networkLinkControl);

                        var now = JulianDate.now();
                        var networkLinkInfo = {
                            id : createGuid(),
                            href : href,
                            cookie : {},
                            lastUpdated : now,
                            updating : false,
                            entity : networkEntity,
                            viewBoundScale : viewBoundScale,
                            needsUpdate : false,
                            cameraUpdateTime : now
                        };

                        var minRefreshPeriod = 0;
                        if (hasNetworkLinkControl) {
                            networkLinkInfo.cookie = queryToObject(defaultValue(queryStringValue(networkLinkControl, 'cookie', namespaces.kml), ''));
                            minRefreshPeriod = defaultValue(queryNumericValue(networkLinkControl, 'minRefreshPeriod', namespaces.kml), 0);
                        }

                        if (refreshMode === 'onInterval') {
                            if (hasNetworkLinkControl) {
                                refreshInterval = Math.max(minRefreshPeriod, refreshInterval);
                            }
                            networkLinkInfo.refreshMode = RefreshMode.INTERVAL;
                            networkLinkInfo.time = refreshInterval;
                        } else if (refreshMode === 'onExpire') {
                            var expires;
                            if (hasNetworkLinkControl) {
                                expires = queryStringValue(networkLinkControl, 'expires', namespaces.kml);
                            }
                            if (defined(expires)) {
                                try {
                                    var date = JulianDate.fromIso8601(expires);
                                    var diff = JulianDate.secondsDifference(date, now);
                                    if (diff > 0 && diff < minRefreshPeriod) {
                                        JulianDate.addSeconds(now, minRefreshPeriod, date);
                                    }
                                    networkLinkInfo.refreshMode = RefreshMode.EXPIRE;
                                    networkLinkInfo.time = date;
                                } catch (e) {
                                    oneTimeWarning('kml-refreshMode-onInterval-onExpire', 'KML - NetworkLinkControl expires is not a valid date');
                                }
                            } else {
                                oneTimeWarning('kml-refreshMode-onExpire', 'KML - refreshMode of onExpire requires the NetworkLinkControl to have an expires element');
                            }
                        } else if (dataSource._camera) { // Only allow onStop refreshes if we have a camera
                            networkLinkInfo.refreshMode = RefreshMode.STOP;
                            networkLinkInfo.time = defaultValue(queryNumericValue(link, 'viewRefreshTime', namespaces.kml), 0);
                        } else {
                            oneTimeWarning('kml-refrehMode-onStop-noCamera', 'A NetworkLink with viewRefreshMode=onStop requires a camera be passed in when creating the KmlDataSource');
                        }

                        if (defined(networkLinkInfo.refreshMode)) {
                            dataSource._networkLinks.set(networkLinkInfo.id, networkLinkInfo);
                        }
                    } else if (viewRefreshMode === 'onRegion') {
                        oneTimeWarning('kml-refrehMode-onRegion', 'KML - Unsupported viewRefreshMode: onRegion');
                    }
                }).otherwise(function(error) {
                    oneTimeWarning('An error occured during loading ' + href.url);
                    dataSource._error.raiseEvent(dataSource, error);
                });

                promises.push(promise);
            }
        }
    }

    function processFeatureNode(dataSource, node, parent, entityCollection, styleCollection, sourceResource, uriResolver, promises, context) {
        var featureProcessor = featureTypes[node.localName];
        if (defined(featureProcessor)) {
            featureProcessor(dataSource, parent, node, entityCollection, styleCollection, sourceResource, uriResolver, promises, context);
        } else {
            processUnsupportedFeature(dataSource, parent, node, entityCollection, styleCollection, sourceResource, uriResolver, promises, context);
        }
    }

    function loadKml(dataSource, entityCollection, kml, sourceResource, uriResolver, context) {
        entityCollection.removeAll();

        var promises = [];
        var documentElement = kml.documentElement;
        var document = documentElement.localName === 'Document' ? documentElement : queryFirstNode(documentElement, 'Document', namespaces.kml);
        var name = queryStringValue(document, 'name', namespaces.kml);
        if (!defined(name)) {
            name = getFilenameFromUri(sourceResource.getUrlComponent());
        }

        // Only set the name from the root document
        if (!defined(dataSource._name)) {
            dataSource._name = name;
        }

        var styleCollection = new EntityCollection(dataSource);
        return when.all(processStyles(dataSource, kml, styleCollection, sourceResource, false, uriResolver)).then(function() {
            var element = kml.documentElement;
            if (element.localName === 'kml') {
                var childNodes = element.childNodes;
                for (var i = 0; i < childNodes.length; i++) {
                    var tmp = childNodes[i];
                    if (defined(featureTypes[tmp.localName])) {
                        element = tmp;
                        break;
                    }
                }
            }
            entityCollection.suspendEvents();
            processFeatureNode(dataSource, element, undefined, entityCollection, styleCollection, sourceResource, uriResolver, promises, context);
            entityCollection.resumeEvents();

            return when.all(promises).then(function() {
                return kml.documentElement;
            });
        });
    }

    function loadKmz(dataSource, entityCollection, blob, sourceResource) {
        var deferred = when.defer();
        zip.createReader(new zip.BlobReader(blob), function(reader) {
            reader.getEntries(function(entries) {
                var promises = [];
                var uriResolver = {};
                var docEntry;
                var docDefer;
                for (var i = 0; i < entries.length; i++) {
                    var entry = entries[i];
                    if (!entry.directory) {
                        var innerDefer = when.defer();
                        promises.push(innerDefer.promise);
                        if (/\.kml$/i.test(entry.filename)) {
                            // We use the first KML document we come across
                            //  https://developers.google.com/kml/documentation/kmzarchives
                            // Unless we come across a .kml file at the root of the archive because GE does this
                            if (!defined(docEntry) || !/\//i.test(entry.filename)) {
                                if (defined(docEntry)) {
                                    // We found one at the root so load the initial kml as a data uri
                                    loadDataUriFromZip(docEntry, uriResolver, docDefer);
                                }
                                docEntry = entry;
                                docDefer = innerDefer;
                            } else {
                                // Wasn't the first kml and wasn't at the root
                                loadDataUriFromZip(entry, uriResolver, innerDefer);
                            }
                        } else {
                            loadDataUriFromZip(entry, uriResolver, innerDefer);
                        }
                    }
                }

                // Now load the root KML document
                if (defined(docEntry)) {
                    loadXmlFromZip(docEntry, uriResolver, docDefer);
                }
                when.all(promises).then(function() {
                    reader.close();
                    if (!defined(uriResolver.kml)) {
                        deferred.reject(new RuntimeError('KMZ file does not contain a KML document.'));
                        return;
                    }
                    uriResolver.keys = Object.keys(uriResolver);
                    return loadKml(dataSource, entityCollection, uriResolver.kml, sourceResource, uriResolver);
                }).then(deferred.resolve).otherwise(deferred.reject);
            });
        }, function(e) {
            deferred.reject(e);
        });

        return deferred.promise;
    }

    function load(dataSource, entityCollection, data, options) {
        options = defaultValue(options, defaultValue.EMPTY_OBJECT);
        var sourceUri = options.sourceUri;
        var uriResolver = options.uriResolver;
        var context = options.context;

        var promise = data;
        if (typeof data === 'string' || (data instanceof Resource)) {
            data = Resource.createIfNeeded(data);
            promise = data.fetchBlob();
            sourceUri = defaultValue(sourceUri, data.clone());
        } else {
            sourceUri = defaultValue(sourceUri, Resource.DEFAULT.clone());
        }

        sourceUri = Resource.createIfNeeded(sourceUri);

        return when(promise)
            .then(function(dataToLoad) {
                if (dataToLoad instanceof Blob) {
                    return isZipFile(dataToLoad).then(function(isZip) {
                        if (isZip) {
                            return loadKmz(dataSource, entityCollection, dataToLoad, sourceUri);
                        }
                        return readBlobAsText(dataToLoad).then(function(text) {
                            //There's no official way to validate if a parse was successful.
                            //The following check detects the error on various browsers.

                            //Insert missing namespaces
                            text = insertNamespaces(text);

                            //Remove Duplicate Namespaces
                            text = removeDuplicateNamespaces(text);

                            //IE raises an exception
                            var kml;
                            var error;
                            try {
                                kml = parser.parseFromString(text, 'application/xml');
                            } catch (e) {
                                error = e.toString();
                            }

                            //The parse succeeds on Chrome and Firefox, but the error
                            //handling is different in each.
                            if (defined(error) || kml.body || kml.documentElement.tagName === 'parsererror') {
                                //Firefox has error information as the firstChild nodeValue.
                                var msg = defined(error) ? error : kml.documentElement.firstChild.nodeValue;

                                //Chrome has it in the body text.
                                if (!msg) {
                                    msg = kml.body.innerText;
                                }

                                //Return the error
                                throw new RuntimeError(msg);
                            }
                            return loadKml(dataSource, entityCollection, kml, sourceUri, uriResolver, context);
                        });
                    });
                }
                return loadKml(dataSource, entityCollection, dataToLoad, sourceUri, uriResolver, context);
            })
            .otherwise(function(error) {
                dataSource._error.raiseEvent(dataSource, error);
                console.log(error);
                return when.reject(error);
            });
    }

    /**
     * A {@link DataSource} which processes Keyhole Markup Language 2.2 (KML).
     * <p>
     * KML support in Cesium is incomplete, but a large amount of the standard,
     * as well as Google's <code>gx</code> extension namespace, is supported. See Github issue
     * {@link https://github.com/AnalyticalGraphicsInc/cesium/issues/873|#873} for a
     * detailed list of what is and isn't support. Cesium will also write information to the
     * console when it encounters most unsupported features.
     * </p>
     * <p>
     * Non visual feature data, such as <code>atom:author</code> and <code>ExtendedData</code>
     * is exposed via an instance of {@link KmlFeatureData}, which is added to each {@link Entity}
     * under the <code>kml</code> property.
     * </p>
     *
     * @alias KmlDataSource
     * @constructor
     *
     * @param {Object} options An object with the following properties:
     * @param {Camera} options.camera The camera that is used for viewRefreshModes and sending camera properties to network links.
     * @param {Canvas} options.canvas The canvas that is used for sending viewer properties to network links.
     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The global ellipsoid used for geographical calculations.
     *
     * @see {@link http://www.opengeospatial.org/standards/kml/|Open Geospatial Consortium KML Standard}
     * @see {@link https://developers.google.com/kml/|Google KML Documentation}
     *
     * @demo {@link https://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=KML.html|Cesium Sandcastle KML Demo}
     *
     * @example
     * var viewer = new Cesium.Viewer('cesiumContainer');
     * viewer.dataSources.add(Cesium.KmlDataSource.load('../../SampleData/facilities.kmz',
     *      {
     *           camera: viewer.scene.camera,
     *           canvas: viewer.scene.canvas
     *      })
     * );
     */
    function KmlDataSource(options) {
        options = defaultValue(options, {});
        var camera = options.camera;
        var canvas = options.canvas;

        //>>includeStart('debug', pragmas.debug);
        if (!defined(camera)) {
            throw new DeveloperError('options.camera is required.');
        }
        if (!defined(canvas)) {
            throw new DeveloperError('options.canvas is required.');
        }
        //>>includeEnd('debug');

        this._changed = new Event();
        this._error = new Event();
        this._loading = new Event();
        this._refresh = new Event();
        this._unsupportedNode = new Event();

        this._clock = undefined;
        this._entityCollection = new EntityCollection(this);
        this._name = undefined;
        this._isLoading = false;
        this._pinBuilder = new PinBuilder();
        this._networkLinks = new AssociativeArray();
        this._entityCluster = new EntityCluster();

        this._canvas = canvas;
        this._camera = camera;
        this._lastCameraView = {
            position : defined(camera) ? Cartesian3.clone(camera.positionWC) : undefined,
            direction : defined(camera) ? Cartesian3.clone(camera.directionWC) : undefined,
            up : defined(camera) ? Cartesian3.clone(camera.upWC) : undefined,
            bbox : defined(camera) ? camera.computeViewRectangle() : Rectangle.clone(Rectangle.MAX_VALUE)
        };

        this._ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);
    }

    /**
     * Creates a Promise to a new instance loaded with the provided KML data.
     *
     * @param {Resource|String|Document|Blob} data A url, parsed KML document, or Blob containing binary KMZ data or a parsed KML document.
     * @param {Object} options An object with the following properties:
     * @param {Camera} options.camera The camera that is used for viewRefreshModes and sending camera properties to network links.
     * @param {Canvas} options.canvas The canvas that is used for sending viewer properties to network links.
     * @param {String} [options.sourceUri] Overrides the url to use for resolving relative links and other KML network features.
     * @param {Boolean} [options.clampToGround=false] true if we want the geometry features (Polygons, LineStrings and LinearRings) clamped to the ground.
     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The global ellipsoid used for geographical calculations.
     *
     * @returns {Promise.<KmlDataSource>} A promise that will resolve to a new KmlDataSource instance once the KML is loaded.
     */
    KmlDataSource.load = function(data, options) {
        options = defaultValue(options, defaultValue.EMPTY_OBJECT);
        var dataSource = new KmlDataSource(options);
        return dataSource.load(data, options);
    };

    defineProperties(KmlDataSource.prototype, {
        /**
         * Gets or sets a human-readable name for this instance.
         * This will be automatically be set to the KML document name on load.
         * @memberof KmlDataSource.prototype
         * @type {String}
         */
        name : {
            get : function() {
                return this._name;
            },
            set : function(value) {
                if (this._name !== value) {
                    this._name = value;
                    this._changed.raiseEvent(this);
                }
            }
        },
        /**
         * Gets the clock settings defined by the loaded KML. This represents the total
         * availability interval for all time-dynamic data. If the KML does not contain
         * time-dynamic data, this value is undefined.
         * @memberof KmlDataSource.prototype
         * @type {DataSourceClock}
         */
        clock : {
            get : function() {
                return this._clock;
            }
        },
        /**
         * Gets the collection of {@link Entity} instances.
         * @memberof KmlDataSource.prototype
         * @type {EntityCollection}
         */
        entities : {
            get : function() {
                return this._entityCollection;
            }
        },
        /**
         * Gets a value indicating if the data source is currently loading data.
         * @memberof KmlDataSource.prototype
         * @type {Boolean}
         */
        isLoading : {
            get : function() {
                return this._isLoading;
            }
        },
        /**
         * Gets an event that will be raised when the underlying data changes.
         * @memberof KmlDataSource.prototype
         * @type {Event}
         */
        changedEvent : {
            get : function() {
                return this._changed;
            }
        },
        /**
         * Gets an event that will be raised if an error is encountered during processing.
         * @memberof KmlDataSource.prototype
         * @type {Event}
         */
        errorEvent : {
            get : function() {
                return this._error;
            }
        },
        /**
         * Gets an event that will be raised when the data source either starts or stops loading.
         * @memberof KmlDataSource.prototype
         * @type {Event}
         */
        loadingEvent : {
            get : function() {
                return this._loading;
            }
        },
        /**
         * Gets an event that will be raised when the data source refreshes a network link.
         * @memberof KmlDataSource.prototype
         * @type {Event}
         */
        refreshEvent : {
            get : function() {
                return this._refresh;
            }
        },
        /**
         * Gets an event that will be raised when the data source finds an unsupported node type.
         * @memberof KmlDataSource.prototype
         * @type {Event}
         */
        unsupportedNodeEvent : {
            get : function() {
                return this._unsupportedNode;
            }
        },
        /**
         * Gets whether or not this data source should be displayed.
         * @memberof KmlDataSource.prototype
         * @type {Boolean}
         */
        show : {
            get : function() {
                return this._entityCollection.show;
            },
            set : function(value) {
                this._entityCollection.show = value;
            }
        },

        /**
         * Gets or sets the clustering options for this data source. This object can be shared between multiple data sources.
         *
         * @memberof KmlDataSource.prototype
         * @type {EntityCluster}
         */
        clustering : {
            get : function() {
                return this._entityCluster;
            },
            set : function(value) {
                //>>includeStart('debug', pragmas.debug);
                if (!defined(value)) {
                    throw new DeveloperError('value must be defined.');
                }
                //>>includeEnd('debug');
                this._entityCluster = value;
            }
        }
    });

    /**
     * Asynchronously loads the provided KML data, replacing any existing data.
     *
     * @param {Resource|String|Document|Blob} data A url, parsed KML document, or Blob containing binary KMZ data or a parsed KML document.
     * @param {Object} [options] An object with the following properties:
     * @param {Resource|String} [options.sourceUri] Overrides the url to use for resolving relative links and other KML network features.
     * @param {Boolean} [options.clampToGround=false] true if we want the geometry features (Polygons, LineStrings and LinearRings) clamped to the ground. If true, lines will use corridors so use Entity.corridor instead of Entity.polyline.
     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The global ellipsoid used for geographical calculations.
     *
     * @returns {Promise.<KmlDataSource>} A promise that will resolve to this instances once the KML is loaded.
     */
    KmlDataSource.prototype.load = function(data, options) {
        //>>includeStart('debug', pragmas.debug);
        if (!defined(data)) {
            throw new DeveloperError('data is required.');
        }
        //>>includeEnd('debug');

        options = defaultValue(options, {});
        DataSource.setLoading(this, true);

        var oldName = this._name;
        this._name = undefined;
        this._clampToGround = defaultValue(options.clampToGround, false);

        var that = this;
        return load(this, this._entityCollection, data, options).then(function() {
            var clock;

            var availability = that._entityCollection.computeAvailability();

            var start = availability.start;
            var stop = availability.stop;
            var isMinStart = JulianDate.equals(start, Iso8601.MINIMUM_VALUE);
            var isMaxStop = JulianDate.equals(stop, Iso8601.MAXIMUM_VALUE);
            if (!isMinStart || !isMaxStop) {
                var date;

                //If start is min time just start at midnight this morning, local time
                if (isMinStart) {
                    date = new Date();
                    date.setHours(0, 0, 0, 0);
                    start = JulianDate.fromDate(date);
                }

                //If stop is max value just stop at midnight tonight, local time
                if (isMaxStop) {
                    date = new Date();
                    date.setHours(24, 0, 0, 0);
                    stop = JulianDate.fromDate(date);
                }

                clock = new DataSourceClock();
                clock.startTime = start;
                clock.stopTime = stop;
                clock.currentTime = JulianDate.clone(start);
                clock.clockRange = ClockRange.LOOP_STOP;
                clock.clockStep = ClockStep.SYSTEM_CLOCK_MULTIPLIER;
                clock.multiplier = Math.round(Math.min(Math.max(JulianDate.secondsDifference(stop, start) / 60, 1), 3.15569e7));
            }

            var changed = false;
            if (clock !== that._clock) {
                that._clock = clock;
                changed = true;
            }

            if (oldName !== that._name) {
                changed = true;
            }

            if (changed) {
                that._changed.raiseEvent(that);
            }

            DataSource.setLoading(that, false);

            return that;
        }).otherwise(function(error) {
            DataSource.setLoading(that, false);
            that._error.raiseEvent(that, error);
            console.log(error);
            return when.reject(error);
        });
    };

    function mergeAvailabilityWithParent(child) {
        var parent = child.parent;
        if (defined(parent)) {
            var parentAvailability = parent.availability;
            if (defined(parentAvailability)) {
                var childAvailability = child.availability;
                if (defined(childAvailability)) {
                    childAvailability.intersect(parentAvailability);
                } else {
                    child.availability = parentAvailability;
                }
            }
        }
    }

    function getNetworkLinkUpdateCallback(dataSource, networkLink, newEntityCollection, networkLinks, processedHref) {
        return function(rootElement) {
            if (!networkLinks.contains(networkLink.id)) {
                // Got into the odd case where a parent network link was updated while a child
                //  network link update was in flight, so just throw it away.
                return;
            }
            var remove = false;
            var networkLinkControl = queryFirstNode(rootElement, 'NetworkLinkControl', namespaces.kml);
            var hasNetworkLinkControl = defined(networkLinkControl);

            var minRefreshPeriod = 0;
            if (hasNetworkLinkControl) {
                if (defined(queryFirstNode(networkLinkControl, 'Update', namespaces.kml))) {
                    oneTimeWarning('kml-networkLinkControl-update', 'KML - NetworkLinkControl updates aren\'t supported.');
                    networkLink.updating = false;
                    networkLinks.remove(networkLink.id);
                    return;
                }
                networkLink.cookie = queryToObject(defaultValue(queryStringValue(networkLinkControl, 'cookie', namespaces.kml), ''));
                minRefreshPeriod = defaultValue(queryNumericValue(networkLinkControl, 'minRefreshPeriod', namespaces.kml), 0);
            }

            var now = JulianDate.now();
            var refreshMode = networkLink.refreshMode;
            if (refreshMode === RefreshMode.INTERVAL) {
                if (defined(networkLinkControl)) {
                    networkLink.time = Math.max(minRefreshPeriod, networkLink.time);
                }
            } else if (refreshMode === RefreshMode.EXPIRE) {
                var expires;
                if (defined(networkLinkControl)) {
                    expires = queryStringValue(networkLinkControl, 'expires', namespaces.kml);
                }
                if (defined(expires)) {
                    try {
                        var date = JulianDate.fromIso8601(expires);
                        var diff = JulianDate.secondsDifference(date, now);
                        if (diff > 0 && diff < minRefreshPeriod) {
                            JulianDate.addSeconds(now, minRefreshPeriod, date);
                        }
                        networkLink.time = date;
                    } catch (e) {
                        oneTimeWarning('kml-networkLinkControl-expires', 'KML - NetworkLinkControl expires is not a valid date');
                        remove = true;
                    }
                } else {
                    oneTimeWarning('kml-refreshMode-onExpire', 'KML - refreshMode of onExpire requires the NetworkLinkControl to have an expires element');
                    remove = true;
                }
            }

            var networkLinkEntity = networkLink.entity;
            var entityCollection = dataSource._entityCollection;
            var newEntities = newEntityCollection.values;

            function removeChildren(entity) {
                entityCollection.remove(entity);
                var children = entity._children;
                var count = children.length;
                for (var i = 0; i < count; ++i) {
                    removeChildren(children[i]);
                }
            }

            // Remove old entities
            entityCollection.suspendEvents();
            var entitiesCopy = entityCollection.values.slice();
            var i;
            for (i = 0; i < entitiesCopy.length; ++i) {
                var entityToRemove = entitiesCopy[i];
                if (entityToRemove.parent === networkLinkEntity) {
                    entityToRemove.parent = undefined;
                    removeChildren(entityToRemove);
                }
            }
            entityCollection.resumeEvents();

            // Add new entities
            entityCollection.suspendEvents();
            for (i = 0; i < newEntities.length; i++) {
                var newEntity = newEntities[i];
                if (!defined(newEntity.parent)) {
                    newEntity.parent = networkLinkEntity;
                    mergeAvailabilityWithParent(newEntity);
                }
                entityCollection.add(newEntity);
            }
            entityCollection.resumeEvents();

            // No refresh information remove it, otherwise update lastUpdate time
            if (remove) {
                networkLinks.remove(networkLink.id);
            } else {
                networkLink.lastUpdated = now;
            }

            var availability = entityCollection.computeAvailability();

            var start = availability.start;
            var stop = availability.stop;
            var isMinStart = JulianDate.equals(start, Iso8601.MINIMUM_VALUE);
            var isMaxStop = JulianDate.equals(stop, Iso8601.MAXIMUM_VALUE);
            if (!isMinStart || !isMaxStop) {
                var clock = dataSource._clock;

                if (clock.startTime !== start || clock.stopTime !== stop) {
                    clock.startTime = start;
                    clock.stopTime = stop;
                    dataSource._changed.raiseEvent(dataSource);
                }
            }

            networkLink.updating = false;
            networkLink.needsUpdate = false;
            dataSource._refresh.raiseEvent(dataSource, processedHref.getUrlComponent(true));
        };
    }

    var entitiesToIgnore = new AssociativeArray();

    /**
     * Updates any NetworkLink that require updating
     * @function
     *
     * @param {JulianDate} time The simulation time.
     * @returns {Boolean} True if this data source is ready to be displayed at the provided time, false otherwise.
     */
    KmlDataSource.prototype.update = function(time) {
        var networkLinks = this._networkLinks;
        if (networkLinks.length === 0) {
            return true;
        }

        var now = JulianDate.now();
        var that = this;

        entitiesToIgnore.removeAll();

        function recurseIgnoreEntities(entity) {
            var children = entity._children;
            var count = children.length;
            for (var i = 0; i < count; ++i) {
                var child = children[i];
                entitiesToIgnore.set(child.id, child);
                recurseIgnoreEntities(child);
            }
        }

        var cameraViewUpdate = false;
        var lastCameraView = this._lastCameraView;
        var camera = this._camera;
        if (defined(camera) &&
            !(camera.positionWC.equalsEpsilon(lastCameraView.position, CesiumMath.EPSILON7) &&
            camera.directionWC.equalsEpsilon(lastCameraView.direction, CesiumMath.EPSILON7) &&
            camera.upWC.equalsEpsilon(lastCameraView.up, CesiumMath.EPSILON7))) {

            // Camera has changed so update the last view
            lastCameraView.position = Cartesian3.clone(camera.positionWC);
            lastCameraView.direction = Cartesian3.clone(camera.directionWC);
            lastCameraView.up = Cartesian3.clone(camera.upWC);
            lastCameraView.bbox = camera.computeViewRectangle();
            cameraViewUpdate = true;
        }

        var newNetworkLinks = new AssociativeArray();
        var changed = false;
        networkLinks.values.forEach(function(networkLink) {
            var entity = networkLink.entity;
            if (entitiesToIgnore.contains(entity.id)) {
                return;
            }

            if (!networkLink.updating) {
                var doUpdate = false;
                if (networkLink.refreshMode === RefreshMode.INTERVAL) {
                    if (JulianDate.secondsDifference(now, networkLink.lastUpdated) > networkLink.time) {
                        doUpdate = true;
                    }
                }
                else if (networkLink.refreshMode === RefreshMode.EXPIRE) {
                    if (JulianDate.greaterThan(now, networkLink.time)) {
                        doUpdate = true;
                    }

                } else if (networkLink.refreshMode === RefreshMode.STOP) {
                    if (cameraViewUpdate) {
                        networkLink.needsUpdate = true;
                        networkLink.cameraUpdateTime = now;
                    }

                    if (networkLink.needsUpdate && JulianDate.secondsDifference(now, networkLink.cameraUpdateTime) >= networkLink.time) {
                        doUpdate = true;
                    }
                }

                if (doUpdate) {
                    recurseIgnoreEntities(entity);
                    networkLink.updating = true;
                    var newEntityCollection = new EntityCollection();
                    var href = networkLink.href.clone();

                    href.setQueryParameters(networkLink.cookie);
                    var ellipsoid = defaultValue(that._ellipsoid, Ellipsoid.WGS84);
                    processNetworkLinkQueryString(href, that._camera, that._canvas, networkLink.viewBoundScale, lastCameraView.bbox, ellipsoid);

                    load(that, newEntityCollection, href, {context : entity.id})
                        .then(getNetworkLinkUpdateCallback(that, networkLink, newEntityCollection, newNetworkLinks, href))
                        .otherwise(function(error) {
                            var msg = 'NetworkLink ' + networkLink.href + ' refresh failed: ' + error;
                            console.log(msg);
                            that._error.raiseEvent(that, msg);
                        });
                    changed = true;
                }
            }
            newNetworkLinks.set(networkLink.id, networkLink);
        });

        if (changed) {
            this._networkLinks = newNetworkLinks;
            this._changed.raiseEvent(this);
        }

        return true;
    };

    /**
     * Contains KML Feature data loaded into the <code>Entity.kml</code> property by {@link KmlDataSource}.
     * @alias KmlFeatureData
     * @constructor
     */
    function KmlFeatureData() {
        /**
         * Gets the atom syndication format author field.
         * @type Object
         */
        this.author = {
            /**
             * Gets the name.
             * @type String
             * @alias author.name
             * @memberof! KmlFeatureData#
             * @property author.name
             */
            name : undefined,
            /**
             * Gets the URI.
             * @type String
             * @alias author.uri
             * @memberof! KmlFeatureData#
             * @property author.uri
             */
            uri : undefined,
            /**
             * Gets the email.
             * @type String
             * @alias author.email
             * @memberof! KmlFeatureData#
             * @property author.email
             */
            email : undefined
        };

        /**
         * Gets the link.
         * @type Object
         */
        this.link = {
            /**
             * Gets the href.
             * @type String
             * @alias link.href
             * @memberof! KmlFeatureData#
             * @property link.href
             */
            href : undefined,
            /**
             * Gets the language of the linked resource.
             * @type String
             * @alias link.hreflang
             * @memberof! KmlFeatureData#
             * @property link.hreflang
             */
            hreflang : undefined,
            /**
             * Gets the link relation.
             * @type String
             * @alias link.rel
             * @memberof! KmlFeatureData#
             * @property link.rel
             */
            rel : undefined,
            /**
             * Gets the link type.
             * @type String
             * @alias link.type
             * @memberof! KmlFeatureData#
             * @property link.type
             */
            type : undefined,
            /**
             * Gets the link title.
             * @type String
             * @alias link.title
             * @memberof! KmlFeatureData#
             * @property link.title
             */
            title : undefined,
            /**
             * Gets the link length.
             * @type String
             * @alias link.length
             * @memberof! KmlFeatureData#
             * @property link.length
             */
            length : undefined
        };

        /**
         * Gets the unstructured address field.
         * @type String
         */
        this.address = undefined;
        /**
         * Gets the phone number.
         * @type String
         */
        this.phoneNumber = undefined;
        /**
         * Gets the snippet.
         * @type String
         */
        this.snippet = undefined;
        /**
         * Gets the extended data, parsed into a JSON object.
         * Currently only the <code>Data</code> property is supported.
         * <code>SchemaData</code> and custom data are ignored.
         * @type String
         */
        this.extendedData = undefined;
    }

    return KmlDataSource;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ })

});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5idW5kbGUtZnJvbnRlbmQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGVycmlhanMtY2VzaXVtL1NvdXJjZS9Db3JlL2dldEZpbGVuYW1lRnJvbVVyaS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGVycmlhanMtY2VzaXVtL1NvdXJjZS9EYXRhU291cmNlcy9Db21wb3NpdGVQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGVycmlhanMtY2VzaXVtL1NvdXJjZS9Db3JlL1BpbkJ1aWxkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3RlcnJpYWpzLWNlc2l1bS9Tb3VyY2UvRGF0YVNvdXJjZXMvQ29tcG9zaXRlUG9zaXRpb25Qcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGVycmlhanMtY2VzaXVtL1NvdXJjZS9EYXRhU291cmNlcy9Qb3NpdGlvblByb3BlcnR5QXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3RlcnJpYWpzLWNlc2l1bS9Tb3VyY2UvRGF0YVNvdXJjZXMvUmVmZXJlbmNlUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3RlcnJpYWpzLWNlc2l1bS9Tb3VyY2UvRGF0YVNvdXJjZXMvU3RyaXBlT3JpZW50YXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3RlcnJpYWpzLWNlc2l1bS9Tb3VyY2UvRGF0YVNvdXJjZXMvVmVsb2NpdHlWZWN0b3JQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGVycmlhanMtY2VzaXVtL1NvdXJjZS9Db3JlL0Nvcm5lclR5cGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3RlcnJpYWpzLWNlc2l1bS9Tb3VyY2UvQ29yZS9IZXJtaXRlUG9seW5vbWlhbEFwcHJveGltYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3RlcnJpYWpzLWNlc2l1bS9Tb3VyY2UvQ29yZS9MYWdyYW5nZVBvbHlub21pYWxBcHByb3hpbWF0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90ZXJyaWFqcy1jZXNpdW0vU291cmNlL0NvcmUvU3BoZXJpY2FsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90ZXJyaWFqcy1jZXNpdW0vU291cmNlL0RhdGFTb3VyY2VzL0NvbXBvc2l0ZU1hdGVyaWFsUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3RlcnJpYWpzLWNlc2l1bS9Tb3VyY2UvRGF0YVNvdXJjZXMvR3JpZE1hdGVyaWFsUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3RlcnJpYWpzLWNlc2l1bS9Tb3VyY2UvRGF0YVNvdXJjZXMvUG9seWxpbmVBcnJvd01hdGVyaWFsUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3RlcnJpYWpzLWNlc2l1bS9Tb3VyY2UvRGF0YVNvdXJjZXMvUG9seWxpbmVEYXNoTWF0ZXJpYWxQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGVycmlhanMtY2VzaXVtL1NvdXJjZS9EYXRhU291cmNlcy9Qb2x5bGluZUdsb3dNYXRlcmlhbFByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90ZXJyaWFqcy1jZXNpdW0vU291cmNlL0RhdGFTb3VyY2VzL1BvbHlsaW5lT3V0bGluZU1hdGVyaWFsUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3RlcnJpYWpzLWNlc2l1bS9Tb3VyY2UvRGF0YVNvdXJjZXMvUHJvcGVydHlBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGVycmlhanMtY2VzaXVtL1NvdXJjZS9EYXRhU291cmNlcy9Sb3RhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGVycmlhanMtY2VzaXVtL1NvdXJjZS9EYXRhU291cmNlcy9TdHJpcGVNYXRlcmlhbFByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90ZXJyaWFqcy1jZXNpdW0vU291cmNlL0RhdGFTb3VyY2VzL1ZlbG9jaXR5T3JpZW50YXRpb25Qcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGVycmlhanMtY2VzaXVtL1NvdXJjZS9UaGlyZFBhcnR5L0F1dG9saW5rZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3RlcnJpYWpzLWNlc2l1bS9Tb3VyY2UvRGF0YVNvdXJjZXMvS21sQ2FtZXJhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90ZXJyaWFqcy1jZXNpdW0vU291cmNlL0RhdGFTb3VyY2VzL0ttbExvb2tBdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGVycmlhanMtY2VzaXVtL1NvdXJjZS9EYXRhU291cmNlcy9LbWxUb3VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90ZXJyaWFqcy1jZXNpdW0vU291cmNlL0RhdGFTb3VyY2VzL0ttbFRvdXJGbHlUby5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGVycmlhanMtY2VzaXVtL1NvdXJjZS9EYXRhU291cmNlcy9LbWxUb3VyV2FpdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGVycmlhanMtY2VzaXVtL1NvdXJjZS9EYXRhU291cmNlcy9TY2FsZWRQb3NpdGlvblByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90ZXJyaWFqcy1jZXNpdW0vU291cmNlL0RhdGFTb3VyY2VzL0dlb0pzb25EYXRhU291cmNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90ZXJyaWFqcy1jZXNpdW0vU291cmNlL0RhdGFTb3VyY2VzL0N6bWxEYXRhU291cmNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90ZXJyaWFqcy1jZXNpdW0vU291cmNlL0RhdGFTb3VyY2VzL0ttbERhdGFTb3VyY2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZGVmaW5lKFtcclxuICAgICAgICAnLi4vVGhpcmRQYXJ0eS9VcmknLFxyXG4gICAgICAgICcuL2RlZmluZWQnLFxyXG4gICAgICAgICcuL0RldmVsb3BlckVycm9yJ1xyXG4gICAgXSwgZnVuY3Rpb24oXHJcbiAgICAgICAgVXJpLFxyXG4gICAgICAgIGRlZmluZWQsXHJcbiAgICAgICAgRGV2ZWxvcGVyRXJyb3IpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdpdmVuIGEgVVJJLCByZXR1cm5zIHRoZSBsYXN0IHNlZ21lbnQgb2YgdGhlIFVSSSwgcmVtb3ZpbmcgYW55IHBhdGggb3IgcXVlcnkgaW5mb3JtYXRpb24uXHJcbiAgICAgKiBAZXhwb3J0cyBnZXRGaWxlbmFtZUZyb21VcmlcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXJpIFRoZSBVcmkuXHJcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgbGFzdCBzZWdtZW50IG9mIHRoZSBVcmkuXHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vZmlsZU5hbWUgd2lsbCBiZVwic2ltcGxlLmN6bWxcIjtcclxuICAgICAqIHZhciBmaWxlTmFtZSA9IENlc2l1bS5nZXRGaWxlbmFtZUZyb21VcmkoJy9HYWxsZXJ5L3NpbXBsZS5jem1sP3ZhbHVlPXRydWUmZXhhbXBsZT1mYWxzZScpO1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRGaWxlbmFtZUZyb21VcmkodXJpKSB7XHJcbiAgICAgICAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcclxuICAgICAgICBpZiAoIWRlZmluZWQodXJpKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoJ3VyaSBpcyByZXF1aXJlZC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XHJcblxyXG4gICAgICAgIHZhciB1cmlPYmplY3QgPSBuZXcgVXJpKHVyaSk7XHJcbiAgICAgICAgdXJpT2JqZWN0Lm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgIHZhciBwYXRoID0gdXJpT2JqZWN0LnBhdGg7XHJcbiAgICAgICAgdmFyIGluZGV4ID0gcGF0aC5sYXN0SW5kZXhPZignLycpO1xyXG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgcGF0aCA9IHBhdGguc3Vic3RyKGluZGV4ICsgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwYXRoO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBnZXRGaWxlbmFtZUZyb21Vcmk7XHJcbn0pO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy90ZXJyaWFqcy1jZXNpdW0vU291cmNlL0NvcmUvZ2V0RmlsZW5hbWVGcm9tVXJpLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTkyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImRlZmluZShbXHJcbiAgICAgICAgJy4uL0NvcmUvZGVmaW5lZCcsXHJcbiAgICAgICAgJy4uL0NvcmUvZGVmaW5lUHJvcGVydGllcycsXHJcbiAgICAgICAgJy4uL0NvcmUvRGV2ZWxvcGVyRXJyb3InLFxyXG4gICAgICAgICcuLi9Db3JlL0V2ZW50JyxcclxuICAgICAgICAnLi4vQ29yZS9FdmVudEhlbHBlcicsXHJcbiAgICAgICAgJy4uL0NvcmUvVGltZUludGVydmFsQ29sbGVjdGlvbicsXHJcbiAgICAgICAgJy4vUHJvcGVydHknXHJcbiAgICBdLCBmdW5jdGlvbihcclxuICAgICAgICBkZWZpbmVkLFxyXG4gICAgICAgIGRlZmluZVByb3BlcnRpZXMsXHJcbiAgICAgICAgRGV2ZWxvcGVyRXJyb3IsXHJcbiAgICAgICAgRXZlbnQsXHJcbiAgICAgICAgRXZlbnRIZWxwZXIsXHJcbiAgICAgICAgVGltZUludGVydmFsQ29sbGVjdGlvbixcclxuICAgICAgICBQcm9wZXJ0eSkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICAgIGZ1bmN0aW9uIHN1YnNjcmliZUFsbChwcm9wZXJ0eSwgZXZlbnRIZWxwZXIsIGRlZmluaXRpb25DaGFuZ2VkLCBpbnRlcnZhbHMpIHtcclxuICAgICAgICBmdW5jdGlvbiBjYWxsYmFjaygpIHtcclxuICAgICAgICAgICAgZGVmaW5pdGlvbkNoYW5nZWQucmFpc2VFdmVudChwcm9wZXJ0eSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBpdGVtcyA9IFtdO1xyXG4gICAgICAgIGV2ZW50SGVscGVyLnJlbW92ZUFsbCgpO1xyXG4gICAgICAgIHZhciBsZW5ndGggPSBpbnRlcnZhbHMubGVuZ3RoO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGludGVydmFsID0gaW50ZXJ2YWxzLmdldChpKTtcclxuICAgICAgICAgICAgaWYgKGRlZmluZWQoaW50ZXJ2YWwuZGF0YSkgJiYgaXRlbXMuaW5kZXhPZihpbnRlcnZhbC5kYXRhKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIGV2ZW50SGVscGVyLmFkZChpbnRlcnZhbC5kYXRhLmRlZmluaXRpb25DaGFuZ2VkLCBjYWxsYmFjayk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIHtAbGluayBQcm9wZXJ0eX0gd2hpY2ggaXMgZGVmaW5lZCBieSBhIHtAbGluayBUaW1lSW50ZXJ2YWxDb2xsZWN0aW9ufSwgd2hlcmUgdGhlXHJcbiAgICAgKiBkYXRhIHByb3BlcnR5IG9mIGVhY2gge0BsaW5rIFRpbWVJbnRlcnZhbH0gaXMgYW5vdGhlciBQcm9wZXJ0eSBpbnN0YW5jZSB3aGljaCBpc1xyXG4gICAgICogZXZhbHVhdGVkIGF0IHRoZSBwcm92aWRlZCB0aW1lLlxyXG4gICAgICpcclxuICAgICAqIEBhbGlhcyBDb21wb3NpdGVQcm9wZXJ0eVxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKlxyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiB2YXIgY29uc3RhbnRQcm9wZXJ0eSA9IC4uLjtcclxuICAgICAqIHZhciBzYW1wbGVkUHJvcGVydHkgPSAuLi47XHJcbiAgICAgKlxyXG4gICAgICogLy9DcmVhdGUgYSBjb21wb3NpdGUgcHJvcGVydHkgZnJvbSB0d28gcHJldmlvdXNseSBkZWZpbmVkIHByb3BlcnRpZXNcclxuICAgICAqIC8vd2hlcmUgdGhlIHByb3BlcnR5IGlzIHZhbGlkIG9uIEF1Z3VzdCAxc3QsIDIwMTIgYW5kIHVzZXMgYSBjb25zdGFudFxyXG4gICAgICogLy9wcm9wZXJ0eSBmb3IgdGhlIGZpcnN0IGhhbGYgb2YgdGhlIGRheSBhbmQgYSBzYW1wbGVkIHByb3BlcnR5IGZvciB0aGVcclxuICAgICAqIC8vcmVtYWluaW5nIGhhbGYuXHJcbiAgICAgKiB2YXIgY29tcG9zaXRlID0gbmV3IENlc2l1bS5Db21wb3NpdGVQcm9wZXJ0eSgpO1xyXG4gICAgICogY29tcG9zaXRlLmludGVydmFscy5hZGRJbnRlcnZhbChDZXNpdW0uVGltZUludGVydmFsLmZyb21Jc284NjAxKHtcclxuICAgICAqICAgICBpc284NjAxIDogJzIwMTItMDgtMDFUMDA6MDA6MDAuMDBaLzIwMTItMDgtMDFUMTI6MDA6MDAuMDBaJyxcclxuICAgICAqICAgICBkYXRhIDogY29uc3RhbnRQcm9wZXJ0eVxyXG4gICAgICogfSkpO1xyXG4gICAgICogY29tcG9zaXRlLmludGVydmFscy5hZGRJbnRlcnZhbChDZXNpdW0uVGltZUludGVydmFsLmZyb21Jc284NjAxKHtcclxuICAgICAqICAgICBpc284NjAxIDogJzIwMTItMDgtMDFUMTI6MDA6MDAuMDBaLzIwMTItMDgtMDJUMDA6MDA6MDAuMDBaJyxcclxuICAgICAqICAgICBpc1N0YXJ0SW5jbHVkZWQgOiBmYWxzZSxcclxuICAgICAqICAgICBpc1N0b3BJbmNsdWRlZCA6IGZhbHNlLFxyXG4gICAgICogICAgIGRhdGEgOiBzYW1wbGVkUHJvcGVydHlcclxuICAgICAqIH0pKTtcclxuICAgICAqXHJcbiAgICAgKiBAc2VlIENvbXBvc2l0ZU1hdGVyaWFsUHJvcGVydHlcclxuICAgICAqIEBzZWUgQ29tcG9zaXRlUG9zaXRpb25Qcm9wZXJ0eVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBDb21wb3NpdGVQcm9wZXJ0eSgpIHtcclxuICAgICAgICB0aGlzLl9ldmVudEhlbHBlciA9IG5ldyBFdmVudEhlbHBlcigpO1xyXG4gICAgICAgIHRoaXMuX2RlZmluaXRpb25DaGFuZ2VkID0gbmV3IEV2ZW50KCk7XHJcbiAgICAgICAgdGhpcy5faW50ZXJ2YWxzID0gbmV3IFRpbWVJbnRlcnZhbENvbGxlY3Rpb24oKTtcclxuICAgICAgICB0aGlzLl9pbnRlcnZhbHMuY2hhbmdlZEV2ZW50LmFkZEV2ZW50TGlzdGVuZXIoQ29tcG9zaXRlUHJvcGVydHkucHJvdG90eXBlLl9pbnRlcnZhbHNDaGFuZ2VkLCB0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICBkZWZpbmVQcm9wZXJ0aWVzKENvbXBvc2l0ZVByb3BlcnR5LnByb3RvdHlwZSwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgYSB2YWx1ZSBpbmRpY2F0aW5nIGlmIHRoaXMgcHJvcGVydHkgaXMgY29uc3RhbnQuICBBIHByb3BlcnR5IGlzIGNvbnNpZGVyZWRcclxuICAgICAgICAgKiBjb25zdGFudCBpZiBnZXRWYWx1ZSBhbHdheXMgcmV0dXJucyB0aGUgc2FtZSByZXN1bHQgZm9yIHRoZSBjdXJyZW50IGRlZmluaXRpb24uXHJcbiAgICAgICAgICogQG1lbWJlcm9mIENvbXBvc2l0ZVByb3BlcnR5LnByb3RvdHlwZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaXNDb25zdGFudCA6IHtcclxuICAgICAgICAgICAgZ2V0IDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJ2YWxzLmlzRW1wdHk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIGV2ZW50IHRoYXQgaXMgcmFpc2VkIHdoZW5ldmVyIHRoZSBkZWZpbml0aW9uIG9mIHRoaXMgcHJvcGVydHkgY2hhbmdlcy5cclxuICAgICAgICAgKiBUaGUgZGVmaW5pdGlvbiBpcyBjaGFuZ2VkIHdoZW5ldmVyIHNldFZhbHVlIGlzIGNhbGxlZCB3aXRoIGRhdGEgZGlmZmVyZW50XHJcbiAgICAgICAgICogdGhhbiB0aGUgY3VycmVudCB2YWx1ZS5cclxuICAgICAgICAgKiBAbWVtYmVyb2YgQ29tcG9zaXRlUHJvcGVydHkucHJvdG90eXBlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAdHlwZSB7RXZlbnR9XHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZGVmaW5pdGlvbkNoYW5nZWQgOiB7XHJcbiAgICAgICAgICAgIGdldCA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZmluaXRpb25DaGFuZ2VkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSBpbnRlcnZhbCBjb2xsZWN0aW9uLlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBDb21wb3NpdGVQcm9wZXJ0eS5wcm90b3R5cGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEB0eXBlIHtUaW1lSW50ZXJ2YWxDb2xsZWN0aW9ufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGludGVydmFscyA6IHtcclxuICAgICAgICAgICAgZ2V0IDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJ2YWxzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgYXQgdGhlIHByb3ZpZGVkIHRpbWUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtKdWxpYW5EYXRlfSB0aW1lIFRoZSB0aW1lIGZvciB3aGljaCB0byByZXRyaWV2ZSB0aGUgdmFsdWUuXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3Jlc3VsdF0gVGhlIG9iamVjdCB0byBzdG9yZSB0aGUgdmFsdWUgaW50bywgaWYgb21pdHRlZCwgYSBuZXcgaW5zdGFuY2UgaXMgY3JlYXRlZCBhbmQgcmV0dXJuZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgbW9kaWZpZWQgcmVzdWx0IHBhcmFtZXRlciBvciBhIG5ldyBpbnN0YW5jZSBpZiB0aGUgcmVzdWx0IHBhcmFtZXRlciB3YXMgbm90IHN1cHBsaWVkLlxyXG4gICAgICovXHJcbiAgICBDb21wb3NpdGVQcm9wZXJ0eS5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbih0aW1lLCByZXN1bHQpIHtcclxuICAgICAgICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xyXG4gICAgICAgIGlmICghZGVmaW5lZCh0aW1lKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoJ3RpbWUgaXMgcmVxdWlyZWQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XHJcblxyXG4gICAgICAgIHZhciBpbm5lclByb3BlcnR5ID0gdGhpcy5faW50ZXJ2YWxzLmZpbmREYXRhRm9ySW50ZXJ2YWxDb250YWluaW5nRGF0ZSh0aW1lKTtcclxuICAgICAgICBpZiAoZGVmaW5lZChpbm5lclByb3BlcnR5KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaW5uZXJQcm9wZXJ0eS5nZXRWYWx1ZSh0aW1lLCByZXN1bHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbXBhcmVzIHRoaXMgcHJvcGVydHkgdG8gdGhlIHByb3ZpZGVkIHByb3BlcnR5IGFuZCByZXR1cm5zXHJcbiAgICAgKiA8Y29kZT50cnVlPC9jb2RlPiBpZiB0aGV5IGFyZSBlcXVhbCwgPGNvZGU+ZmFsc2U8L2NvZGU+IG90aGVyd2lzZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1Byb3BlcnR5fSBbb3RoZXJdIFRoZSBvdGhlciBwcm9wZXJ0eS5cclxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiBpZiBsZWZ0IGFuZCByaWdodCBhcmUgZXF1YWwsIDxjb2RlPmZhbHNlPC9jb2RlPiBvdGhlcndpc2UuXHJcbiAgICAgKi9cclxuICAgIENvbXBvc2l0ZVByb3BlcnR5LnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbihvdGhlcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzID09PSBvdGhlciB8fCAvL1xyXG4gICAgICAgICAgICAgICAob3RoZXIgaW5zdGFuY2VvZiBDb21wb3NpdGVQcm9wZXJ0eSAmJiAvL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faW50ZXJ2YWxzLmVxdWFscyhvdGhlci5faW50ZXJ2YWxzLCBQcm9wZXJ0eS5lcXVhbHMpKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBDb21wb3NpdGVQcm9wZXJ0eS5wcm90b3R5cGUuX2ludGVydmFsc0NoYW5nZWQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBzdWJzY3JpYmVBbGwodGhpcywgdGhpcy5fZXZlbnRIZWxwZXIsIHRoaXMuX2RlZmluaXRpb25DaGFuZ2VkLCB0aGlzLl9pbnRlcnZhbHMpO1xyXG4gICAgICAgIHRoaXMuX2RlZmluaXRpb25DaGFuZ2VkLnJhaXNlRXZlbnQodGhpcyk7XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBDb21wb3NpdGVQcm9wZXJ0eTtcclxufSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3RlcnJpYWpzLWNlc2l1bS9Tb3VyY2UvRGF0YVNvdXJjZXMvQ29tcG9zaXRlUHJvcGVydHkuanNcbi8vIG1vZHVsZSBpZCA9IDExOTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZGVmaW5lKFtcclxuICAgICAgICAnLi9idWlsZE1vZHVsZVVybCcsXHJcbiAgICAgICAgJy4vQ29sb3InLFxyXG4gICAgICAgICcuL2RlZmluZWQnLFxyXG4gICAgICAgICcuL0RldmVsb3BlckVycm9yJyxcclxuICAgICAgICAnLi9SZXNvdXJjZScsXHJcbiAgICAgICAgJy4vd3JpdGVUZXh0VG9DYW52YXMnXHJcbiAgICBdLCBmdW5jdGlvbihcclxuICAgICAgICBidWlsZE1vZHVsZVVybCxcclxuICAgICAgICBDb2xvcixcclxuICAgICAgICBkZWZpbmVkLFxyXG4gICAgICAgIERldmVsb3BlckVycm9yLFxyXG4gICAgICAgIFJlc291cmNlLFxyXG4gICAgICAgIHdyaXRlVGV4dFRvQ2FudmFzKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIHV0aWxpdHkgY2xhc3MgZm9yIGdlbmVyYXRpbmcgY3VzdG9tIG1hcCBwaW5zIGFzIGNhbnZhcyBlbGVtZW50cy5cclxuICAgICAqIDxiciAvPjxiciAvPlxyXG4gICAgICogPGRpdiBhbGlnbj0nY2VudGVyJz5cclxuICAgICAqIDxpbWcgc3JjPSdJbWFnZXMvUGluQnVpbGRlci5wbmcnIHdpZHRoPSc1MDAnLz48YnIgLz5cclxuICAgICAqIEV4YW1wbGUgcGlucyBnZW5lcmF0ZWQgdXNpbmcgYm90aCB0aGUgbWFraSBpY29uIHNldCwgd2hpY2ggc2hpcHMgd2l0aCBDZXNpdW0sIGFuZCBzaW5nbGUgY2hhcmFjdGVyIHRleHQuXHJcbiAgICAgKiA8L2Rpdj5cclxuICAgICAqXHJcbiAgICAgKiBAYWxpYXMgUGluQnVpbGRlclxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKlxyXG4gICAgICogQGRlbW8ge0BsaW5rIGh0dHBzOi8vY2VzaXVtanMub3JnL0Nlc2l1bS9BcHBzL1NhbmRjYXN0bGUvaW5kZXguaHRtbD9zcmM9TWFwJTIwUGlucy5odG1sfENlc2l1bSBTYW5kY2FzdGxlIFBpbkJ1aWxkZXIgRGVtb31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gUGluQnVpbGRlcigpIHtcclxuICAgICAgICB0aGlzLl9jYWNoZSA9IHt9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBlbXB0eSBwaW4gb2YgdGhlIHNwZWNpZmllZCBjb2xvciBhbmQgc2l6ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0NvbG9yfSBjb2xvciBUaGUgY29sb3Igb2YgdGhlIHBpbi5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzaXplIFRoZSBzaXplIG9mIHRoZSBwaW4sIGluIHBpeGVscy5cclxuICAgICAqIEByZXR1cm5zIHtDYW52YXN9IFRoZSBjYW52YXMgZWxlbWVudCB0aGF0IHJlcHJlc2VudHMgdGhlIGdlbmVyYXRlZCBwaW4uXHJcbiAgICAgKi9cclxuICAgIFBpbkJ1aWxkZXIucHJvdG90eXBlLmZyb21Db2xvciA9IGZ1bmN0aW9uKGNvbG9yLCBzaXplKSB7XHJcbiAgICAgICAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcclxuICAgICAgICBpZiAoIWRlZmluZWQoY29sb3IpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcignY29sb3IgaXMgcmVxdWlyZWQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFkZWZpbmVkKHNpemUpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcignc2l6ZSBpcyByZXF1aXJlZCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcclxuICAgICAgICByZXR1cm4gY3JlYXRlUGluKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb2xvciwgc2l6ZSwgdGhpcy5fY2FjaGUpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBwaW4gd2l0aCB0aGUgc3BlY2lmaWVkIGljb24sIGNvbG9yLCBhbmQgc2l6ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1Jlc291cmNlfFN0cmluZ30gdXJsIFRoZSB1cmwgb2YgdGhlIGltYWdlIHRvIGJlIHN0YW1wZWQgb250byB0aGUgcGluLlxyXG4gICAgICogQHBhcmFtIHtDb2xvcn0gY29sb3IgVGhlIGNvbG9yIG9mIHRoZSBwaW4uXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2l6ZSBUaGUgc2l6ZSBvZiB0aGUgcGluLCBpbiBwaXhlbHMuXHJcbiAgICAgKiBAcmV0dXJucyB7Q2FudmFzfFByb21pc2UuPENhbnZhcz59IFRoZSBjYW52YXMgZWxlbWVudCBvciBhIFByb21pc2UgdG8gdGhlIGNhbnZhcyBlbGVtZW50IHRoYXQgcmVwcmVzZW50cyB0aGUgZ2VuZXJhdGVkIHBpbi5cclxuICAgICAqL1xyXG4gICAgUGluQnVpbGRlci5wcm90b3R5cGUuZnJvbVVybCA9IGZ1bmN0aW9uKHVybCwgY29sb3IsIHNpemUpIHtcclxuICAgICAgICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xyXG4gICAgICAgIGlmICghZGVmaW5lZCh1cmwpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcigndXJsIGlzIHJlcXVpcmVkJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghZGVmaW5lZChjb2xvcikpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKCdjb2xvciBpcyByZXF1aXJlZCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWRlZmluZWQoc2l6ZSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKCdzaXplIGlzIHJlcXVpcmVkJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVQaW4odXJsLCB1bmRlZmluZWQsIGNvbG9yLCBzaXplLCB0aGlzLl9jYWNoZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIHBpbiB3aXRoIHRoZSBzcGVjaWZpZWQge0BsaW5rIGh0dHBzOi8vd3d3Lm1hcGJveC5jb20vbWFraS98bWFraX0gaWNvbiBpZGVudGlmaWVyLCBjb2xvciwgYW5kIHNpemUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlkIFRoZSBpZCBvZiB0aGUgbWFraSBpY29uIHRvIGJlIHN0YW1wZWQgb250byB0aGUgcGluLlxyXG4gICAgICogQHBhcmFtIHtDb2xvcn0gY29sb3IgVGhlIGNvbG9yIG9mIHRoZSBwaW4uXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2l6ZSBUaGUgc2l6ZSBvZiB0aGUgcGluLCBpbiBwaXhlbHMuXHJcbiAgICAgKiBAcmV0dXJucyB7Q2FudmFzfFByb21pc2UuPENhbnZhcz59IFRoZSBjYW52YXMgZWxlbWVudCBvciBhIFByb21pc2UgdG8gdGhlIGNhbnZhcyBlbGVtZW50IHRoYXQgcmVwcmVzZW50cyB0aGUgZ2VuZXJhdGVkIHBpbi5cclxuICAgICAqL1xyXG4gICAgUGluQnVpbGRlci5wcm90b3R5cGUuZnJvbU1ha2lJY29uSWQgPSBmdW5jdGlvbihpZCwgY29sb3IsIHNpemUpIHtcclxuICAgICAgICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xyXG4gICAgICAgIGlmICghZGVmaW5lZChpZCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKCdpZCBpcyByZXF1aXJlZCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWRlZmluZWQoY29sb3IpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcignY29sb3IgaXMgcmVxdWlyZWQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFkZWZpbmVkKHNpemUpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcignc2l6ZSBpcyByZXF1aXJlZCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcclxuICAgICAgICByZXR1cm4gY3JlYXRlUGluKGJ1aWxkTW9kdWxlVXJsKCdBc3NldHMvVGV4dHVyZXMvbWFraS8nICsgZW5jb2RlVVJJQ29tcG9uZW50KGlkKSArICcucG5nJyksIHVuZGVmaW5lZCwgY29sb3IsIHNpemUsIHRoaXMuX2NhY2hlKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgcGluIHdpdGggdGhlIHNwZWNpZmllZCB0ZXh0LCBjb2xvciwgYW5kIHNpemUuICBUaGUgdGV4dCB3aWxsIGJlIHNpemVkIHRvIGJlIGFzIGxhcmdlIGFzIHBvc3NpYmxlXHJcbiAgICAgKiB3aGlsZSBzdGlsbCBiZWluZyBjb250YWluZWQgY29tcGxldGVseSB3aXRoaW4gdGhlIHBpbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCBUaGUgdGV4dCB0byBiZSBzdGFtcGVkIG9udG8gdGhlIHBpbi5cclxuICAgICAqIEBwYXJhbSB7Q29sb3J9IGNvbG9yIFRoZSBjb2xvciBvZiB0aGUgcGluLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNpemUgVGhlIHNpemUgb2YgdGhlIHBpbiwgaW4gcGl4ZWxzLlxyXG4gICAgICogQHJldHVybnMge0NhbnZhc30gVGhlIGNhbnZhcyBlbGVtZW50IHRoYXQgcmVwcmVzZW50cyB0aGUgZ2VuZXJhdGVkIHBpbi5cclxuICAgICAqL1xyXG4gICAgUGluQnVpbGRlci5wcm90b3R5cGUuZnJvbVRleHQgPSBmdW5jdGlvbih0ZXh0LCBjb2xvciwgc2l6ZSkge1xyXG4gICAgICAgIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XHJcbiAgICAgICAgaWYgKCFkZWZpbmVkKHRleHQpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcigndGV4dCBpcyByZXF1aXJlZCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWRlZmluZWQoY29sb3IpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcignY29sb3IgaXMgcmVxdWlyZWQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFkZWZpbmVkKHNpemUpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcignc2l6ZSBpcyByZXF1aXJlZCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVBpbih1bmRlZmluZWQsIHRleHQsIGNvbG9yLCBzaXplLCB0aGlzLl9jYWNoZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBjb2xvclNjcmF0Y2ggPSBuZXcgQ29sb3IoKTtcclxuXHJcbiAgICAvL1RoaXMgZnVuY3Rpb24gKGV4Y2VwdCBmb3IgdGhlIDMgY29tbWVudGVkIGxpbmVzKSB3YXMgYXV0by1nZW5lcmF0ZWQgZnJvbSBhbiBvbmxpbmUgdG9vbCxcclxuICAgIC8vaHR0cDovL3d3dy5wcm9mZXNzb3JjbG91ZC5jb20vc3ZnLXRvLWNhbnZhcy8sIHVzaW5nIEFzc2V0cy9UZXh0dXJlcy9waW4uc3ZnIGFzIGlucHV0LlxyXG4gICAgLy9UaGUgcmVhc29uIHdlIHNpbXBseSBjYW4ndCBsb2FkIGFuZCBkcmF3IHRoZSBTVkcgZGlyZWN0bHkgdG8gdGhlIGNhbnZhcyBpcyBiZWNhdXNlXHJcbiAgICAvL2l0IHRhaW50cyB0aGUgY2FudmFzIGluIEludGVybmV0IEV4cGxvcmVyIChhbmQgcG9zc2libHkgc29tZSBvdGhlciBicm93c2Vycyk7IG1ha2luZ1xyXG4gICAgLy9pdCBpbXBvc3NpYmxlIHRvIGNyZWF0ZSBhIFdlYkdMIHRleHR1cmUgZnJvbSB0aGUgcmVzdWx0LlxyXG4gICAgZnVuY3Rpb24gZHJhd1Bpbihjb250ZXh0MkQsIGNvbG9yLCBzaXplKSB7XHJcbiAgICAgICAgY29udGV4dDJELnNhdmUoKTtcclxuICAgICAgICBjb250ZXh0MkQuc2NhbGUoc2l6ZSAvIDI0LCBzaXplIC8gMjQpOyAvL0FkZGVkIHRvIGF1dG8tZ2VuZXJhdGVkIGNvZGUgdG8gc2NhbGUgdXAgdG8gZGVzaXJlZCBzaXplLlxyXG4gICAgICAgIGNvbnRleHQyRC5maWxsU3R5bGUgPSBjb2xvci50b0Nzc0NvbG9yU3RyaW5nKCk7IC8vTW9kaWZpZWQgZnJvbSBhdXRvLWdlbmVyYXRlZCBjb2RlLlxyXG4gICAgICAgIGNvbnRleHQyRC5zdHJva2VTdHlsZSA9IGNvbG9yLmJyaWdodGVuKDAuNiwgY29sb3JTY3JhdGNoKS50b0Nzc0NvbG9yU3RyaW5nKCk7IC8vTW9kaWZpZWQgZnJvbSBhdXRvLWdlbmVyYXRlZCBjb2RlLlxyXG4gICAgICAgIGNvbnRleHQyRC5saW5lV2lkdGggPSAwLjg0NjtcclxuICAgICAgICBjb250ZXh0MkQuYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgY29udGV4dDJELm1vdmVUbyg2LjcyLCAwLjQyMik7XHJcbiAgICAgICAgY29udGV4dDJELmxpbmVUbygxNy4yOCwgMC40MjIpO1xyXG4gICAgICAgIGNvbnRleHQyRC5iZXppZXJDdXJ2ZVRvKDE4LjU1MywgMC40MjIsIDE5LjU3NywgMS43NTgsIDE5LjU3NywgMy40MTUpO1xyXG4gICAgICAgIGNvbnRleHQyRC5saW5lVG8oMTkuNTc3LCAxMC45NzMpO1xyXG4gICAgICAgIGNvbnRleHQyRC5iZXppZXJDdXJ2ZVRvKDE5LjU3NywgMTIuNjMsIDE4LjU1MywgMTMuOTY2LCAxNy4yODIsIDEzLjk2Nik7XHJcbiAgICAgICAgY29udGV4dDJELmxpbmVUbygxNC4zODYsIDE0LjAwOCk7XHJcbiAgICAgICAgY29udGV4dDJELmxpbmVUbygxMS44MjYsIDIzLjU3OCk7XHJcbiAgICAgICAgY29udGV4dDJELmxpbmVUbyg5LjYxNCwgMTQuMDA4KTtcclxuICAgICAgICBjb250ZXh0MkQubGluZVRvKDYuNzE5LCAxMy45NjUpO1xyXG4gICAgICAgIGNvbnRleHQyRC5iZXppZXJDdXJ2ZVRvKDUuNDQ2LCAxMy45ODMsIDQuNDIyLCAxMi42MjksIDQuNDIyLCAxMC45NzIpO1xyXG4gICAgICAgIGNvbnRleHQyRC5saW5lVG8oNC40MjIsIDMuNDE2KTtcclxuICAgICAgICBjb250ZXh0MkQuYmV6aWVyQ3VydmVUbyg0LjQyMywgMS43NiwgNS40NDcsIDAuNDIzLCA2LjcxOCwgMC40MjMpO1xyXG4gICAgICAgIGNvbnRleHQyRC5jbG9zZVBhdGgoKTtcclxuICAgICAgICBjb250ZXh0MkQuZmlsbCgpO1xyXG4gICAgICAgIGNvbnRleHQyRC5zdHJva2UoKTtcclxuICAgICAgICBjb250ZXh0MkQucmVzdG9yZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vVGhpcyBmdW5jdGlvbiB0YWtlcyBhbiBpbWFnZSBvciBjYW52YXMgYW5kIHVzZXMgaXQgYXMgYSB0ZW1wbGF0ZVxyXG4gICAgLy90byBcInN0YW1wXCIgdGhlIHBpbiB3aXRoIGEgd2hpdGUgaW1hZ2Ugb3V0bGluZWQgaW4gYmxhY2suICBUaGUgY29sb3JcclxuICAgIC8vdmFsdWVzIG9mIHRoZSBpbnB1dCBpbWFnZSBhcmUgaWdub3JlZCBjb21wbGV0ZWx5IGFuZCBvbmx5IHRoZSBhbHBoYVxyXG4gICAgLy92YWx1ZXMgYXJlIHVzZWQuXHJcbiAgICBmdW5jdGlvbiBkcmF3SWNvbihjb250ZXh0MkQsIGltYWdlLCBzaXplKSB7XHJcbiAgICAgICAgLy9TaXplIGlzIHRoZSBsYXJnZXN0IGltYWdlIHRoYXQgbG9va3MgZ29vZCBpbnNpZGUgb2YgcGluIGJveC5cclxuICAgICAgICB2YXIgaW1hZ2VTaXplID0gc2l6ZSAvIDIuNTtcclxuICAgICAgICB2YXIgc2l6ZVggPSBpbWFnZVNpemU7XHJcbiAgICAgICAgdmFyIHNpemVZID0gaW1hZ2VTaXplO1xyXG5cclxuICAgICAgICBpZiAoaW1hZ2Uud2lkdGggPiBpbWFnZS5oZWlnaHQpIHtcclxuICAgICAgICAgICAgc2l6ZVkgPSBpbWFnZVNpemUgKiAoaW1hZ2UuaGVpZ2h0IC8gaW1hZ2Uud2lkdGgpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaW1hZ2Uud2lkdGggPCBpbWFnZS5oZWlnaHQpIHtcclxuICAgICAgICAgICAgc2l6ZVggPSBpbWFnZVNpemUgKiAoaW1hZ2Uud2lkdGggLyBpbWFnZS5oZWlnaHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy94IGFuZCB5IGFyZSB0aGUgY2VudGVyIG9mIHRoZSBwaW4gYm94XHJcbiAgICAgICAgdmFyIHggPSBNYXRoLnJvdW5kKChzaXplIC0gc2l6ZVgpIC8gMik7XHJcbiAgICAgICAgdmFyIHkgPSBNYXRoLnJvdW5kKCgoNyAvIDI0KSAqIHNpemUpIC0gKHNpemVZIC8gMikpO1xyXG5cclxuICAgICAgICBjb250ZXh0MkQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLW91dCc7XHJcbiAgICAgICAgY29udGV4dDJELmRyYXdJbWFnZShpbWFnZSwgeCAtIDEsIHksIHNpemVYLCBzaXplWSk7XHJcbiAgICAgICAgY29udGV4dDJELmRyYXdJbWFnZShpbWFnZSwgeCwgeSAtIDEsIHNpemVYLCBzaXplWSk7XHJcbiAgICAgICAgY29udGV4dDJELmRyYXdJbWFnZShpbWFnZSwgeCArIDEsIHksIHNpemVYLCBzaXplWSk7XHJcbiAgICAgICAgY29udGV4dDJELmRyYXdJbWFnZShpbWFnZSwgeCwgeSArIDEsIHNpemVYLCBzaXplWSk7XHJcblxyXG4gICAgICAgIGNvbnRleHQyRC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnZGVzdGluYXRpb24tb3Zlcic7XHJcbiAgICAgICAgY29udGV4dDJELmZpbGxTdHlsZSA9IENvbG9yLkJMQUNLLnRvQ3NzQ29sb3JTdHJpbmcoKTtcclxuICAgICAgICBjb250ZXh0MkQuZmlsbFJlY3QoeCAtIDEsIHkgLSAxLCBzaXplWCArIDIsIHNpemVZICsgMik7XHJcblxyXG4gICAgICAgIGNvbnRleHQyRC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnZGVzdGluYXRpb24tb3V0JztcclxuICAgICAgICBjb250ZXh0MkQuZHJhd0ltYWdlKGltYWdlLCB4LCB5LCBzaXplWCwgc2l6ZVkpO1xyXG5cclxuICAgICAgICBjb250ZXh0MkQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLW92ZXInO1xyXG4gICAgICAgIGNvbnRleHQyRC5maWxsU3R5bGUgPSBDb2xvci5XSElURS50b0Nzc0NvbG9yU3RyaW5nKCk7XHJcbiAgICAgICAgY29udGV4dDJELmZpbGxSZWN0KHggLSAxLCB5IC0gMiwgc2l6ZVggKyAyLCBzaXplWSArIDIpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBzdHJpbmdpZnlTY3JhdGNoID0gbmV3IEFycmF5KDQpO1xyXG4gICAgZnVuY3Rpb24gY3JlYXRlUGluKHVybCwgbGFiZWwsIGNvbG9yLCBzaXplLCBjYWNoZSkge1xyXG4gICAgICAgIC8vVXNlIHRoZSBwYXJhbWV0ZXJzIGFzIGEgdW5pcXVlIElEIGZvciBjYWNoaW5nLlxyXG4gICAgICAgIHN0cmluZ2lmeVNjcmF0Y2hbMF0gPSB1cmw7XHJcbiAgICAgICAgc3RyaW5naWZ5U2NyYXRjaFsxXSA9IGxhYmVsO1xyXG4gICAgICAgIHN0cmluZ2lmeVNjcmF0Y2hbMl0gPSBjb2xvcjtcclxuICAgICAgICBzdHJpbmdpZnlTY3JhdGNoWzNdID0gc2l6ZTtcclxuICAgICAgICB2YXIgaWQgPSBKU09OLnN0cmluZ2lmeShzdHJpbmdpZnlTY3JhdGNoKTtcclxuXHJcbiAgICAgICAgdmFyIGl0ZW0gPSBjYWNoZVtpZF07XHJcbiAgICAgICAgaWYgKGRlZmluZWQoaXRlbSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGl0ZW07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICAgICAgY2FudmFzLndpZHRoID0gc2l6ZTtcclxuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gc2l6ZTtcclxuXHJcbiAgICAgICAgdmFyIGNvbnRleHQyRCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgICAgIGRyYXdQaW4oY29udGV4dDJELCBjb2xvciwgc2l6ZSk7XHJcblxyXG4gICAgICAgIGlmIChkZWZpbmVkKHVybCkpIHtcclxuICAgICAgICAgICAgdmFyIHJlc291cmNlID0gUmVzb3VyY2UuY3JlYXRlSWZOZWVkZWQodXJsKTtcclxuXHJcbiAgICAgICAgICAgIC8vSWYgd2UgaGF2ZSBhbiBpbWFnZSB1cmwsIGxvYWQgaXQgYW5kIHRoZW4gc3RhbXAgdGhlIHBpbi5cclxuICAgICAgICAgICAgdmFyIHByb21pc2UgPSByZXNvdXJjZS5mZXRjaEltYWdlKCkudGhlbihmdW5jdGlvbihpbWFnZSkge1xyXG4gICAgICAgICAgICAgICAgZHJhd0ljb24oY29udGV4dDJELCBpbWFnZSwgc2l6ZSk7XHJcbiAgICAgICAgICAgICAgICBjYWNoZVtpZF0gPSBjYW52YXM7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FudmFzO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY2FjaGVbaWRdID0gcHJvbWlzZTtcclxuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XHJcbiAgICAgICAgfSBlbHNlIGlmIChkZWZpbmVkKGxhYmVsKSkge1xyXG4gICAgICAgICAgICAvL0lmIHdlIGhhdmUgYSBsYWJlbCwgd3JpdGUgaXQgdG8gYSBjYW52YXMgYW5kIHRoZW4gc3RhbXAgdGhlIHBpbi5cclxuICAgICAgICAgICAgdmFyIGltYWdlID0gd3JpdGVUZXh0VG9DYW52YXMobGFiZWwsIHtcclxuICAgICAgICAgICAgICAgIGZvbnQgOiAnYm9sZCAnICsgc2l6ZSArICdweCBzYW5zLXNlcmlmJ1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgZHJhd0ljb24oY29udGV4dDJELCBpbWFnZSwgc2l6ZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjYWNoZVtpZF0gPSBjYW52YXM7XHJcbiAgICAgICAgcmV0dXJuIGNhbnZhcztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gUGluQnVpbGRlcjtcclxufSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3RlcnJpYWpzLWNlc2l1bS9Tb3VyY2UvQ29yZS9QaW5CdWlsZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTk0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImRlZmluZShbXHJcbiAgICAgICAgJy4uL0NvcmUvZGVmYXVsdFZhbHVlJyxcclxuICAgICAgICAnLi4vQ29yZS9kZWZpbmVkJyxcclxuICAgICAgICAnLi4vQ29yZS9kZWZpbmVQcm9wZXJ0aWVzJyxcclxuICAgICAgICAnLi4vQ29yZS9EZXZlbG9wZXJFcnJvcicsXHJcbiAgICAgICAgJy4uL0NvcmUvRXZlbnQnLFxyXG4gICAgICAgICcuLi9Db3JlL1JlZmVyZW5jZUZyYW1lJyxcclxuICAgICAgICAnLi9Db21wb3NpdGVQcm9wZXJ0eScsXHJcbiAgICAgICAgJy4vUHJvcGVydHknXHJcbiAgICBdLCBmdW5jdGlvbihcclxuICAgICAgICBkZWZhdWx0VmFsdWUsXHJcbiAgICAgICAgZGVmaW5lZCxcclxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzLFxyXG4gICAgICAgIERldmVsb3BlckVycm9yLFxyXG4gICAgICAgIEV2ZW50LFxyXG4gICAgICAgIFJlZmVyZW5jZUZyYW1lLFxyXG4gICAgICAgIENvbXBvc2l0ZVByb3BlcnR5LFxyXG4gICAgICAgIFByb3BlcnR5KSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIHtAbGluayBDb21wb3NpdGVQcm9wZXJ0eX0gd2hpY2ggaXMgYWxzbyBhIHtAbGluayBQb3NpdGlvblByb3BlcnR5fS5cclxuICAgICAqXHJcbiAgICAgKiBAYWxpYXMgQ29tcG9zaXRlUG9zaXRpb25Qcm9wZXJ0eVxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtSZWZlcmVuY2VGcmFtZX0gW3JlZmVyZW5jZUZyYW1lPVJlZmVyZW5jZUZyYW1lLkZJWEVEXSBUaGUgcmVmZXJlbmNlIGZyYW1lIGluIHdoaWNoIHRoZSBwb3NpdGlvbiBpcyBkZWZpbmVkLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBDb21wb3NpdGVQb3NpdGlvblByb3BlcnR5KHJlZmVyZW5jZUZyYW1lKSB7XHJcbiAgICAgICAgdGhpcy5fcmVmZXJlbmNlRnJhbWUgPSBkZWZhdWx0VmFsdWUocmVmZXJlbmNlRnJhbWUsIFJlZmVyZW5jZUZyYW1lLkZJWEVEKTtcclxuICAgICAgICB0aGlzLl9kZWZpbml0aW9uQ2hhbmdlZCA9IG5ldyBFdmVudCgpO1xyXG4gICAgICAgIHRoaXMuX2NvbXBvc2l0ZSA9IG5ldyBDb21wb3NpdGVQcm9wZXJ0eSgpO1xyXG4gICAgICAgIHRoaXMuX2NvbXBvc2l0ZS5kZWZpbml0aW9uQ2hhbmdlZC5hZGRFdmVudExpc3RlbmVyKENvbXBvc2l0ZVBvc2l0aW9uUHJvcGVydHkucHJvdG90eXBlLl9yYWlzZURlZmluaXRpb25DaGFuZ2VkLCB0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICBkZWZpbmVQcm9wZXJ0aWVzKENvbXBvc2l0ZVBvc2l0aW9uUHJvcGVydHkucHJvdG90eXBlLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBhIHZhbHVlIGluZGljYXRpbmcgaWYgdGhpcyBwcm9wZXJ0eSBpcyBjb25zdGFudC4gIEEgcHJvcGVydHkgaXMgY29uc2lkZXJlZFxyXG4gICAgICAgICAqIGNvbnN0YW50IGlmIGdldFZhbHVlIGFsd2F5cyByZXR1cm5zIHRoZSBzYW1lIHJlc3VsdCBmb3IgdGhlIGN1cnJlbnQgZGVmaW5pdGlvbi5cclxuICAgICAgICAgKiBAbWVtYmVyb2YgQ29tcG9zaXRlUG9zaXRpb25Qcm9wZXJ0eS5wcm90b3R5cGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGlzQ29uc3RhbnQgOiB7XHJcbiAgICAgICAgICAgIGdldCA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbXBvc2l0ZS5pc0NvbnN0YW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSBldmVudCB0aGF0IGlzIHJhaXNlZCB3aGVuZXZlciB0aGUgZGVmaW5pdGlvbiBvZiB0aGlzIHByb3BlcnR5IGNoYW5nZXMuXHJcbiAgICAgICAgICogVGhlIGRlZmluaXRpb24gaXMgY2hhbmdlZCB3aGVuZXZlciBzZXRWYWx1ZSBpcyBjYWxsZWQgd2l0aCBkYXRhIGRpZmZlcmVudFxyXG4gICAgICAgICAqIHRoYW4gdGhlIGN1cnJlbnQgdmFsdWUuXHJcbiAgICAgICAgICogQG1lbWJlcm9mIENvbXBvc2l0ZVBvc2l0aW9uUHJvcGVydHkucHJvdG90eXBlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAdHlwZSB7RXZlbnR9XHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZGVmaW5pdGlvbkNoYW5nZWQgOiB7XHJcbiAgICAgICAgICAgIGdldCA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZmluaXRpb25DaGFuZ2VkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSBpbnRlcnZhbCBjb2xsZWN0aW9uLlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBDb21wb3NpdGVQb3NpdGlvblByb3BlcnR5LnByb3RvdHlwZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHR5cGUge1RpbWVJbnRlcnZhbENvbGxlY3Rpb259XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaW50ZXJ2YWxzIDoge1xyXG4gICAgICAgICAgICBnZXQgOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb21wb3NpdGUuaW50ZXJ2YWxzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIHJlZmVyZW5jZSBmcmFtZSB3aGljaCB0aGlzIHBvc2l0aW9uIHByZXNlbnRzIGl0c2VsZiBhcy5cclxuICAgICAgICAgKiBFYWNoIFBvc2l0aW9uUHJvcGVydHkgbWFraW5nIHVwIHRoaXMgb2JqZWN0IGhhcyBpdCdzIG93biByZWZlcmVuY2UgZnJhbWUsXHJcbiAgICAgICAgICogc28gdGhpcyBwcm9wZXJ0eSBtZXJlbHkgZXhwb3NlcyBhIFwicHJlZmVycmVkXCIgcmVmZXJlbmNlIGZyYW1lIGZvciBjbGllbnRzXHJcbiAgICAgICAgICogdG8gdXNlLlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBDb21wb3NpdGVQb3NpdGlvblByb3BlcnR5LnByb3RvdHlwZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHR5cGUge1JlZmVyZW5jZUZyYW1lfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHJlZmVyZW5jZUZyYW1lIDoge1xyXG4gICAgICAgICAgICBnZXQgOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWZlcmVuY2VGcmFtZTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2V0IDogZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlZmVyZW5jZUZyYW1lID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eSBhdCB0aGUgcHJvdmlkZWQgdGltZSBpbiB0aGUgZml4ZWQgZnJhbWUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtKdWxpYW5EYXRlfSB0aW1lIFRoZSB0aW1lIGZvciB3aGljaCB0byByZXRyaWV2ZSB0aGUgdmFsdWUuXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3Jlc3VsdF0gVGhlIG9iamVjdCB0byBzdG9yZSB0aGUgdmFsdWUgaW50bywgaWYgb21pdHRlZCwgYSBuZXcgaW5zdGFuY2UgaXMgY3JlYXRlZCBhbmQgcmV0dXJuZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgbW9kaWZpZWQgcmVzdWx0IHBhcmFtZXRlciBvciBhIG5ldyBpbnN0YW5jZSBpZiB0aGUgcmVzdWx0IHBhcmFtZXRlciB3YXMgbm90IHN1cHBsaWVkLlxyXG4gICAgICovXHJcbiAgICBDb21wb3NpdGVQb3NpdGlvblByb3BlcnR5LnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uKHRpbWUsIHJlc3VsdCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFZhbHVlSW5SZWZlcmVuY2VGcmFtZSh0aW1lLCBSZWZlcmVuY2VGcmFtZS5GSVhFRCwgcmVzdWx0KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgYXQgdGhlIHByb3ZpZGVkIHRpbWUgYW5kIGluIHRoZSBwcm92aWRlZCByZWZlcmVuY2UgZnJhbWUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtKdWxpYW5EYXRlfSB0aW1lIFRoZSB0aW1lIGZvciB3aGljaCB0byByZXRyaWV2ZSB0aGUgdmFsdWUuXHJcbiAgICAgKiBAcGFyYW0ge1JlZmVyZW5jZUZyYW1lfSByZWZlcmVuY2VGcmFtZSBUaGUgZGVzaXJlZCByZWZlcmVuY2VGcmFtZSBvZiB0aGUgcmVzdWx0LlxyXG4gICAgICogQHBhcmFtIHtDYXJ0ZXNpYW4zfSBbcmVzdWx0XSBUaGUgb2JqZWN0IHRvIHN0b3JlIHRoZSB2YWx1ZSBpbnRvLCBpZiBvbWl0dGVkLCBhIG5ldyBpbnN0YW5jZSBpcyBjcmVhdGVkIGFuZCByZXR1cm5lZC5cclxuICAgICAqIEByZXR1cm5zIHtDYXJ0ZXNpYW4zfSBUaGUgbW9kaWZpZWQgcmVzdWx0IHBhcmFtZXRlciBvciBhIG5ldyBpbnN0YW5jZSBpZiB0aGUgcmVzdWx0IHBhcmFtZXRlciB3YXMgbm90IHN1cHBsaWVkLlxyXG4gICAgICovXHJcbiAgICBDb21wb3NpdGVQb3NpdGlvblByb3BlcnR5LnByb3RvdHlwZS5nZXRWYWx1ZUluUmVmZXJlbmNlRnJhbWUgPSBmdW5jdGlvbih0aW1lLCByZWZlcmVuY2VGcmFtZSwgcmVzdWx0KSB7XHJcbiAgICAgICAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcclxuICAgICAgICBpZiAoIWRlZmluZWQodGltZSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKCd0aW1lIGlzIHJlcXVpcmVkLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWRlZmluZWQocmVmZXJlbmNlRnJhbWUpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcigncmVmZXJlbmNlRnJhbWUgaXMgcmVxdWlyZWQuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xyXG5cclxuICAgICAgICB2YXIgaW5uZXJQcm9wZXJ0eSA9IHRoaXMuX2NvbXBvc2l0ZS5faW50ZXJ2YWxzLmZpbmREYXRhRm9ySW50ZXJ2YWxDb250YWluaW5nRGF0ZSh0aW1lKTtcclxuICAgICAgICBpZiAoZGVmaW5lZChpbm5lclByb3BlcnR5KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaW5uZXJQcm9wZXJ0eS5nZXRWYWx1ZUluUmVmZXJlbmNlRnJhbWUodGltZSwgcmVmZXJlbmNlRnJhbWUsIHJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29tcGFyZXMgdGhpcyBwcm9wZXJ0eSB0byB0aGUgcHJvdmlkZWQgcHJvcGVydHkgYW5kIHJldHVybnNcclxuICAgICAqIDxjb2RlPnRydWU8L2NvZGU+IGlmIHRoZXkgYXJlIGVxdWFsLCA8Y29kZT5mYWxzZTwvY29kZT4gb3RoZXJ3aXNlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UHJvcGVydHl9IFtvdGhlcl0gVGhlIG90aGVyIHByb3BlcnR5LlxyXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IGlmIGxlZnQgYW5kIHJpZ2h0IGFyZSBlcXVhbCwgPGNvZGU+ZmFsc2U8L2NvZGU+IG90aGVyd2lzZS5cclxuICAgICAqL1xyXG4gICAgQ29tcG9zaXRlUG9zaXRpb25Qcm9wZXJ0eS5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24ob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gdGhpcyA9PT0gb3RoZXIgfHwgLy9cclxuICAgICAgICAgICAgICAgKG90aGVyIGluc3RhbmNlb2YgQ29tcG9zaXRlUG9zaXRpb25Qcm9wZXJ0eSAmJiAvL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVmZXJlbmNlRnJhbWUgPT09IG90aGVyLl9yZWZlcmVuY2VGcmFtZSAmJiAvL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY29tcG9zaXRlLmVxdWFscyhvdGhlci5fY29tcG9zaXRlLCBQcm9wZXJ0eS5lcXVhbHMpKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBDb21wb3NpdGVQb3NpdGlvblByb3BlcnR5LnByb3RvdHlwZS5fcmFpc2VEZWZpbml0aW9uQ2hhbmdlZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuX2RlZmluaXRpb25DaGFuZ2VkLnJhaXNlRXZlbnQodGhpcyk7XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBDb21wb3NpdGVQb3NpdGlvblByb3BlcnR5O1xyXG59KTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvdGVycmlhanMtY2VzaXVtL1NvdXJjZS9EYXRhU291cmNlcy9Db21wb3NpdGVQb3NpdGlvblByb3BlcnR5LmpzXG4vLyBtb2R1bGUgaWQgPSAxMTk1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImRlZmluZShbXHJcbiAgICAgICAgJy4uL0NvcmUvZGVmYXVsdFZhbHVlJyxcclxuICAgICAgICAnLi4vQ29yZS9kZWZpbmVkJyxcclxuICAgICAgICAnLi4vQ29yZS9kZWZpbmVQcm9wZXJ0aWVzJyxcclxuICAgICAgICAnLi4vQ29yZS9EZXZlbG9wZXJFcnJvcicsXHJcbiAgICAgICAgJy4uL0NvcmUvRXZlbnQnLFxyXG4gICAgICAgICcuLi9Db3JlL0V2ZW50SGVscGVyJyxcclxuICAgICAgICAnLi4vQ29yZS9SZWZlcmVuY2VGcmFtZScsXHJcbiAgICAgICAgJy4vUHJvcGVydHknXHJcbiAgICBdLCBmdW5jdGlvbihcclxuICAgICAgICBkZWZhdWx0VmFsdWUsXHJcbiAgICAgICAgZGVmaW5lZCxcclxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzLFxyXG4gICAgICAgIERldmVsb3BlckVycm9yLFxyXG4gICAgICAgIEV2ZW50LFxyXG4gICAgICAgIEV2ZW50SGVscGVyLFxyXG4gICAgICAgIFJlZmVyZW5jZUZyYW1lLFxyXG4gICAgICAgIFByb3BlcnR5KSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIHtAbGluayBQb3NpdGlvblByb3BlcnR5fSB3aG9zZSB2YWx1ZSBpcyBhbiBhcnJheSB3aG9zZSBpdGVtcyBhcmUgdGhlIGNvbXB1dGVkIHZhbHVlXHJcbiAgICAgKiBvZiBvdGhlciBQb3NpdGlvblByb3BlcnR5IGluc3RhbmNlcy5cclxuICAgICAqXHJcbiAgICAgKiBAYWxpYXMgUG9zaXRpb25Qcm9wZXJ0eUFycmF5XHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1Byb3BlcnR5W119IFt2YWx1ZV0gQW4gYXJyYXkgb2YgUHJvcGVydHkgaW5zdGFuY2VzLlxyXG4gICAgICogQHBhcmFtIHtSZWZlcmVuY2VGcmFtZX0gW3JlZmVyZW5jZUZyYW1lPVJlZmVyZW5jZUZyYW1lLkZJWEVEXSBUaGUgcmVmZXJlbmNlIGZyYW1lIGluIHdoaWNoIHRoZSBwb3NpdGlvbiBpcyBkZWZpbmVkLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBQb3NpdGlvblByb3BlcnR5QXJyYXkodmFsdWUsIHJlZmVyZW5jZUZyYW1lKSB7XHJcbiAgICAgICAgdGhpcy5fdmFsdWUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5fZGVmaW5pdGlvbkNoYW5nZWQgPSBuZXcgRXZlbnQoKTtcclxuICAgICAgICB0aGlzLl9ldmVudEhlbHBlciA9IG5ldyBFdmVudEhlbHBlcigpO1xyXG4gICAgICAgIHRoaXMuX3JlZmVyZW5jZUZyYW1lID0gZGVmYXVsdFZhbHVlKHJlZmVyZW5jZUZyYW1lLCBSZWZlcmVuY2VGcmFtZS5GSVhFRCk7XHJcbiAgICAgICAgdGhpcy5zZXRWYWx1ZSh2YWx1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgZGVmaW5lUHJvcGVydGllcyhQb3NpdGlvblByb3BlcnR5QXJyYXkucHJvdG90eXBlLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBhIHZhbHVlIGluZGljYXRpbmcgaWYgdGhpcyBwcm9wZXJ0eSBpcyBjb25zdGFudC4gIFRoaXMgcHJvcGVydHlcclxuICAgICAgICAgKiBpcyBjb25zaWRlcmVkIGNvbnN0YW50IGlmIGFsbCBwcm9wZXJ0eSBpdGVtcyBpbiB0aGUgYXJyYXkgYXJlIGNvbnN0YW50LlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBQb3NpdGlvblByb3BlcnR5QXJyYXkucHJvdG90eXBlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKi9cclxuICAgICAgICBpc0NvbnN0YW50IDoge1xyXG4gICAgICAgICAgICBnZXQgOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX3ZhbHVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFkZWZpbmVkKHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFQcm9wZXJ0eS5pc0NvbnN0YW50KHZhbHVlW2ldKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIGV2ZW50IHRoYXQgaXMgcmFpc2VkIHdoZW5ldmVyIHRoZSBkZWZpbml0aW9uIG9mIHRoaXMgcHJvcGVydHkgY2hhbmdlcy5cclxuICAgICAgICAgKiBUaGUgZGVmaW5pdGlvbiBpcyBjaGFuZ2VkIHdoZW5ldmVyIHNldFZhbHVlIGlzIGNhbGxlZCB3aXRoIGRhdGEgZGlmZmVyZW50XHJcbiAgICAgICAgICogdGhhbiB0aGUgY3VycmVudCB2YWx1ZSBvciBvbmUgb2YgdGhlIHByb3BlcnRpZXMgaW4gdGhlIGFycmF5IGFsc28gY2hhbmdlcy5cclxuICAgICAgICAgKiBAbWVtYmVyb2YgUG9zaXRpb25Qcm9wZXJ0eUFycmF5LnByb3RvdHlwZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHR5cGUge0V2ZW50fVxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGRlZmluaXRpb25DaGFuZ2VkIDoge1xyXG4gICAgICAgICAgICBnZXQgOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWZpbml0aW9uQ2hhbmdlZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgcmVmZXJlbmNlIGZyYW1lIGluIHdoaWNoIHRoZSBwb3NpdGlvbiBpcyBkZWZpbmVkLlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBQb3NpdGlvblByb3BlcnR5QXJyYXkucHJvdG90eXBlXHJcbiAgICAgICAgICogQHR5cGUge1JlZmVyZW5jZUZyYW1lfVxyXG4gICAgICAgICAqIEBkZWZhdWx0IFJlZmVyZW5jZUZyYW1lLkZJWEVEO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHJlZmVyZW5jZUZyYW1lIDoge1xyXG4gICAgICAgICAgICBnZXQgOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWZlcmVuY2VGcmFtZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgdmFsdWUgb2YgdGhlIHByb3BlcnR5LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7SnVsaWFuRGF0ZX0gW3RpbWVdIFRoZSB0aW1lIGZvciB3aGljaCB0byByZXRyaWV2ZSB0aGUgdmFsdWUuICBUaGlzIHBhcmFtZXRlciBpcyB1bnVzZWQgc2luY2UgdGhlIHZhbHVlIGRvZXMgbm90IGNoYW5nZSB3aXRoIHJlc3BlY3QgdG8gdGltZS5cclxuICAgICAqIEBwYXJhbSB7Q2FydGVzaWFuM1tdfSBbcmVzdWx0XSBUaGUgb2JqZWN0IHRvIHN0b3JlIHRoZSB2YWx1ZSBpbnRvLCBpZiBvbWl0dGVkLCBhIG5ldyBpbnN0YW5jZSBpcyBjcmVhdGVkIGFuZCByZXR1cm5lZC5cclxuICAgICAqIEByZXR1cm5zIHtDYXJ0ZXNpYW4zW119IFRoZSBtb2RpZmllZCByZXN1bHQgcGFyYW1ldGVyIG9yIGEgbmV3IGluc3RhbmNlIGlmIHRoZSByZXN1bHQgcGFyYW1ldGVyIHdhcyBub3Qgc3VwcGxpZWQuXHJcbiAgICAgKi9cclxuICAgIFBvc2l0aW9uUHJvcGVydHlBcnJheS5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbih0aW1lLCByZXN1bHQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZUluUmVmZXJlbmNlRnJhbWUodGltZSwgUmVmZXJlbmNlRnJhbWUuRklYRUQsIHJlc3VsdCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgdmFsdWUgb2YgdGhlIHByb3BlcnR5IGF0IHRoZSBwcm92aWRlZCB0aW1lIGFuZCBpbiB0aGUgcHJvdmlkZWQgcmVmZXJlbmNlIGZyYW1lLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7SnVsaWFuRGF0ZX0gdGltZSBUaGUgdGltZSBmb3Igd2hpY2ggdG8gcmV0cmlldmUgdGhlIHZhbHVlLlxyXG4gICAgICogQHBhcmFtIHtSZWZlcmVuY2VGcmFtZX0gcmVmZXJlbmNlRnJhbWUgVGhlIGRlc2lyZWQgcmVmZXJlbmNlRnJhbWUgb2YgdGhlIHJlc3VsdC5cclxuICAgICAqIEBwYXJhbSB7Q2FydGVzaWFuM30gW3Jlc3VsdF0gVGhlIG9iamVjdCB0byBzdG9yZSB0aGUgdmFsdWUgaW50bywgaWYgb21pdHRlZCwgYSBuZXcgaW5zdGFuY2UgaXMgY3JlYXRlZCBhbmQgcmV0dXJuZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7Q2FydGVzaWFuM30gVGhlIG1vZGlmaWVkIHJlc3VsdCBwYXJhbWV0ZXIgb3IgYSBuZXcgaW5zdGFuY2UgaWYgdGhlIHJlc3VsdCBwYXJhbWV0ZXIgd2FzIG5vdCBzdXBwbGllZC5cclxuICAgICAqL1xyXG4gICAgUG9zaXRpb25Qcm9wZXJ0eUFycmF5LnByb3RvdHlwZS5nZXRWYWx1ZUluUmVmZXJlbmNlRnJhbWUgPSBmdW5jdGlvbih0aW1lLCByZWZlcmVuY2VGcmFtZSwgcmVzdWx0KSB7XHJcbiAgICAgICAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcclxuICAgICAgICBpZiAoIWRlZmluZWQodGltZSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKCd0aW1lIGlzIHJlcXVpcmVkLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWRlZmluZWQocmVmZXJlbmNlRnJhbWUpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcigncmVmZXJlbmNlRnJhbWUgaXMgcmVxdWlyZWQuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xyXG5cclxuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl92YWx1ZTtcclxuICAgICAgICBpZiAoIWRlZmluZWQodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgbGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xyXG4gICAgICAgIGlmICghZGVmaW5lZChyZXN1bHQpKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBBcnJheShsZW5ndGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgdmFyIHggPSAwO1xyXG4gICAgICAgIHdoaWxlIChpIDwgbGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0eSA9IHZhbHVlW2ldO1xyXG4gICAgICAgICAgICB2YXIgaXRlbVZhbHVlID0gcHJvcGVydHkuZ2V0VmFsdWVJblJlZmVyZW5jZUZyYW1lKHRpbWUsIHJlZmVyZW5jZUZyYW1lLCByZXN1bHRbaV0pO1xyXG4gICAgICAgICAgICBpZiAoZGVmaW5lZChpdGVtVmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRbeF0gPSBpdGVtVmFsdWU7XHJcbiAgICAgICAgICAgICAgICB4Kys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXN1bHQubGVuZ3RoID0geDtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1Byb3BlcnR5W119IHZhbHVlIEFuIGFycmF5IG9mIFByb3BlcnR5IGluc3RhbmNlcy5cclxuICAgICAqL1xyXG4gICAgUG9zaXRpb25Qcm9wZXJ0eUFycmF5LnByb3RvdHlwZS5zZXRWYWx1ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIGV2ZW50SGVscGVyID0gdGhpcy5fZXZlbnRIZWxwZXI7XHJcbiAgICAgICAgZXZlbnRIZWxwZXIucmVtb3ZlQWxsKCk7XHJcblxyXG4gICAgICAgIGlmIChkZWZpbmVkKHZhbHVlKSkge1xyXG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlLnNsaWNlKCk7XHJcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eSA9IHZhbHVlW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRlZmluZWQocHJvcGVydHkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRIZWxwZXIuYWRkKHByb3BlcnR5LmRlZmluaXRpb25DaGFuZ2VkLCBQb3NpdGlvblByb3BlcnR5QXJyYXkucHJvdG90eXBlLl9yYWlzZURlZmluaXRpb25DaGFuZ2VkLCB0aGlzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9kZWZpbml0aW9uQ2hhbmdlZC5yYWlzZUV2ZW50KHRoaXMpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbXBhcmVzIHRoaXMgcHJvcGVydHkgdG8gdGhlIHByb3ZpZGVkIHByb3BlcnR5IGFuZCByZXR1cm5zXHJcbiAgICAgKiA8Y29kZT50cnVlPC9jb2RlPiBpZiB0aGV5IGFyZSBlcXVhbCwgPGNvZGU+ZmFsc2U8L2NvZGU+IG90aGVyd2lzZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1Byb3BlcnR5fSBbb3RoZXJdIFRoZSBvdGhlciBwcm9wZXJ0eS5cclxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiBpZiBsZWZ0IGFuZCByaWdodCBhcmUgZXF1YWwsIDxjb2RlPmZhbHNlPC9jb2RlPiBvdGhlcndpc2UuXHJcbiAgICAgKi9cclxuICAgIFBvc2l0aW9uUHJvcGVydHlBcnJheS5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24ob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gdGhpcyA9PT0gb3RoZXIgfHwgLy9cclxuICAgICAgICAgICAgICAgKG90aGVyIGluc3RhbmNlb2YgUG9zaXRpb25Qcm9wZXJ0eUFycmF5ICYmIC8vXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWZlcmVuY2VGcmFtZSA9PT0gb3RoZXIuX3JlZmVyZW5jZUZyYW1lICYmIC8vXHJcbiAgICAgICAgICAgICAgICBQcm9wZXJ0eS5hcnJheUVxdWFscyh0aGlzLl92YWx1ZSwgb3RoZXIuX3ZhbHVlKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIFBvc2l0aW9uUHJvcGVydHlBcnJheS5wcm90b3R5cGUuX3JhaXNlRGVmaW5pdGlvbkNoYW5nZWQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLl9kZWZpbml0aW9uQ2hhbmdlZC5yYWlzZUV2ZW50KHRoaXMpO1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gUG9zaXRpb25Qcm9wZXJ0eUFycmF5O1xyXG59KTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvdGVycmlhanMtY2VzaXVtL1NvdXJjZS9EYXRhU291cmNlcy9Qb3NpdGlvblByb3BlcnR5QXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDExOTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZGVmaW5lKFtcclxuICAgICAgICAnLi4vQ29yZS9kZWZpbmVkJyxcclxuICAgICAgICAnLi4vQ29yZS9kZWZpbmVQcm9wZXJ0aWVzJyxcclxuICAgICAgICAnLi4vQ29yZS9EZXZlbG9wZXJFcnJvcicsXHJcbiAgICAgICAgJy4uL0NvcmUvRXZlbnQnLFxyXG4gICAgICAgICcuLi9Db3JlL1J1bnRpbWVFcnJvcicsXHJcbiAgICAgICAgJy4vUHJvcGVydHknXHJcbiAgICBdLCBmdW5jdGlvbihcclxuICAgICAgICBkZWZpbmVkLFxyXG4gICAgICAgIGRlZmluZVByb3BlcnRpZXMsXHJcbiAgICAgICAgRGV2ZWxvcGVyRXJyb3IsXHJcbiAgICAgICAgRXZlbnQsXHJcbiAgICAgICAgUnVudGltZUVycm9yLFxyXG4gICAgICAgIFByb3BlcnR5KSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcblxyXG4gICAgZnVuY3Rpb24gcmVzb2x2ZUVudGl0eSh0aGF0KSB7XHJcbiAgICAgICAgdmFyIGVudGl0eUlzUmVzb2x2ZWQgPSB0cnVlO1xyXG4gICAgICAgIGlmICh0aGF0Ll9yZXNvbHZlRW50aXR5KSB7XHJcbiAgICAgICAgICAgIHZhciB0YXJnZXRFbnRpdHkgPSB0aGF0Ll90YXJnZXRDb2xsZWN0aW9uLmdldEJ5SWQodGhhdC5fdGFyZ2V0SWQpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGRlZmluZWQodGFyZ2V0RW50aXR5KSkge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0RW50aXR5LmRlZmluaXRpb25DaGFuZ2VkLmFkZEV2ZW50TGlzdGVuZXIoUmVmZXJlbmNlUHJvcGVydHkucHJvdG90eXBlLl9vblRhcmdldEVudGl0eURlZmluaXRpb25DaGFuZ2VkLCB0aGF0KTtcclxuICAgICAgICAgICAgICAgIHRoYXQuX3RhcmdldEVudGl0eSA9IHRhcmdldEVudGl0eTtcclxuICAgICAgICAgICAgICAgIHRoYXQuX3Jlc29sdmVFbnRpdHkgPSBmYWxzZTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vVGhlIHByb3BlcnR5IGhhcyBiZWNvbWUgZGV0YWNoZWQuICBJdCBoYXMgYSB2YWxpZCB2YWx1ZSBidXQgaXMgbm90IGN1cnJlbnRseSByZXNvbHZlZCB0byBhbiBlbnRpdHkgaW4gdGhlIGNvbGxlY3Rpb25cclxuICAgICAgICAgICAgICAgIHRhcmdldEVudGl0eSA9IHRoYXQuX3RhcmdldEVudGl0eTtcclxuICAgICAgICAgICAgICAgIGVudGl0eUlzUmVzb2x2ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCFkZWZpbmVkKHRhcmdldEVudGl0eSkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3IoJ3RhcmdldCBlbnRpdHkgXCInICsgdGhhdC5fdGFyZ2V0SWQgKyAnXCIgY291bGQgbm90IGJlIHJlc29sdmVkLicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBlbnRpdHlJc1Jlc29sdmVkO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJlc29sdmUodGhhdCkge1xyXG4gICAgICAgIHZhciB0YXJnZXRQcm9wZXJ0eSA9IHRoYXQuX3RhcmdldFByb3BlcnR5O1xyXG5cclxuICAgICAgICBpZiAodGhhdC5fcmVzb2x2ZVByb3BlcnR5KSB7XHJcbiAgICAgICAgICAgIHZhciBlbnRpdHlJc1Jlc29sdmVkID0gcmVzb2x2ZUVudGl0eSh0aGF0KTtcclxuXHJcbiAgICAgICAgICAgIHZhciBuYW1lcyA9IHRoYXQuX3RhcmdldFByb3BlcnR5TmFtZXM7XHJcbiAgICAgICAgICAgIHRhcmdldFByb3BlcnR5ID0gdGhhdC5fdGFyZ2V0RW50aXR5O1xyXG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gbmFtZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aCAmJiBkZWZpbmVkKHRhcmdldFByb3BlcnR5KTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXRQcm9wZXJ0eSA9IHRhcmdldFByb3BlcnR5W25hbWVzW2ldXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGRlZmluZWQodGFyZ2V0UHJvcGVydHkpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGF0Ll90YXJnZXRQcm9wZXJ0eSA9IHRhcmdldFByb3BlcnR5O1xyXG4gICAgICAgICAgICAgICAgdGhhdC5fcmVzb2x2ZVByb3BlcnR5ID0gIWVudGl0eUlzUmVzb2x2ZWQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWRlZmluZWQodGhhdC5fdGFyZ2V0UHJvcGVydHkpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUnVudGltZUVycm9yKCd0YXJnZXRQcm9wZXJ0eSBcIicgKyB0aGF0Ll90YXJnZXRJZCArICcuJyArIG5hbWVzLmpvaW4oJy4nKSArICdcIiBjb3VsZCBub3QgYmUgcmVzb2x2ZWQuJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0YXJnZXRQcm9wZXJ0eTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEEge0BsaW5rIFByb3BlcnR5fSB3aGljaCB0cmFuc3BhcmVudGx5IGxpbmtzIHRvIGFub3RoZXIgcHJvcGVydHkgb24gYSBwcm92aWRlZCBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQGFsaWFzIFJlZmVyZW5jZVByb3BlcnR5XHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0VudGl0eUNvbGxlY3Rpb259IHRhcmdldENvbGxlY3Rpb24gVGhlIGVudGl0eSBjb2xsZWN0aW9uIHdoaWNoIHdpbGwgYmUgdXNlZCB0byByZXNvbHZlIHRoZSByZWZlcmVuY2UuXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGFyZ2V0SWQgVGhlIGlkIG9mIHRoZSBlbnRpdHkgd2hpY2ggaXMgYmVpbmcgcmVmZXJlbmNlZC5cclxuICAgICAqIEBwYXJhbSB7U3RyaW5nW119IHRhcmdldFByb3BlcnR5TmFtZXMgVGhlIG5hbWVzIG9mIHRoZSBwcm9wZXJ0eSBvbiB0aGUgdGFyZ2V0IGVudGl0eSB3aGljaCB3ZSB3aWxsIHVzZS5cclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogdmFyIGNvbGxlY3Rpb24gPSBuZXcgQ2VzaXVtLkVudGl0eUNvbGxlY3Rpb24oKTtcclxuICAgICAqXHJcbiAgICAgKiAvL0NyZWF0ZSBhIG5ldyBlbnRpdHkgYW5kIGFzc2lnbiBhIGJpbGxib2FyZCBzY2FsZS5cclxuICAgICAqIHZhciBvYmplY3QxID0gbmV3IENlc2l1bS5FbnRpdHkoe2lkOidvYmplY3QxJ30pO1xyXG4gICAgICogb2JqZWN0MS5iaWxsYm9hcmQgPSBuZXcgQ2VzaXVtLkJpbGxib2FyZEdyYXBoaWNzKCk7XHJcbiAgICAgKiBvYmplY3QxLmJpbGxib2FyZC5zY2FsZSA9IG5ldyBDZXNpdW0uQ29uc3RhbnRQcm9wZXJ0eSgyLjApO1xyXG4gICAgICogY29sbGVjdGlvbi5hZGQob2JqZWN0MSk7XHJcbiAgICAgKlxyXG4gICAgICogLy9DcmVhdGUgYSBzZWNvbmQgZW50aXR5IGFuZCByZWZlcmVuY2UgdGhlIHNjYWxlIGZyb20gdGhlIGZpcnN0IG9uZS5cclxuICAgICAqIHZhciBvYmplY3QyID0gbmV3IENlc2l1bS5FbnRpdHkoe2lkOidvYmplY3QyJ30pO1xyXG4gICAgICogb2JqZWN0Mi5tb2RlbCA9IG5ldyBDZXNpdW0uTW9kZWxHcmFwaGljcygpO1xyXG4gICAgICogb2JqZWN0Mi5tb2RlbC5zY2FsZSA9IG5ldyBDZXNpdW0uUmVmZXJlbmNlUHJvcGVydHkoY29sbGVjdGlvbiwgJ29iamVjdDEnLCBbJ2JpbGxib2FyZCcsICdzY2FsZSddKTtcclxuICAgICAqIGNvbGxlY3Rpb24uYWRkKG9iamVjdDIpO1xyXG4gICAgICpcclxuICAgICAqIC8vQ3JlYXRlIGEgdGhpcmQgb2JqZWN0LCBidXQgdXNlIHRoZSBmcm9tU3RyaW5nIGhlbHBlciBmdW5jdGlvbi5cclxuICAgICAqIHZhciBvYmplY3QzID0gbmV3IENlc2l1bS5FbnRpdHkoe2lkOidvYmplY3QzJ30pO1xyXG4gICAgICogb2JqZWN0My5iaWxsYm9hcmQgPSBuZXcgQ2VzaXVtLkJpbGxib2FyZEdyYXBoaWNzKCk7XHJcbiAgICAgKiBvYmplY3QzLmJpbGxib2FyZC5zY2FsZSA9IENlc2l1bS5SZWZlcmVuY2VQcm9wZXJ0eS5mcm9tU3RyaW5nKGNvbGxlY3Rpb24sICdvYmplY3QxI2JpbGxib2FyZC5zY2FsZScpO1xyXG4gICAgICogY29sbGVjdGlvbi5hZGQob2JqZWN0Myk7XHJcbiAgICAgKlxyXG4gICAgICogLy9Zb3UgY2FuIHJlZmVyIHRvIGFuIGVudGl0eSB3aXRoIGEgIyBvciAuIGluIGlkIGFuZCBwcm9wZXJ0eSBuYW1lcyBieSBlc2NhcGluZyB0aGVtLlxyXG4gICAgICogdmFyIG9iamVjdDQgPSBuZXcgQ2VzaXVtLkVudGl0eSh7aWQ6JyNvYmplY3QuNCd9KTtcclxuICAgICAqIG9iamVjdDQuYmlsbGJvYXJkID0gbmV3IENlc2l1bS5CaWxsYm9hcmRHcmFwaGljcygpO1xyXG4gICAgICogb2JqZWN0NC5iaWxsYm9hcmQuc2NhbGUgPSBuZXcgQ2VzaXVtLkNvbnN0YW50UHJvcGVydHkoMi4wKTtcclxuICAgICAqIGNvbGxlY3Rpb24uYWRkKG9iamVjdDQpO1xyXG4gICAgICpcclxuICAgICAqIHZhciBvYmplY3Q1ID0gbmV3IENlc2l1bS5FbnRpdHkoe2lkOidvYmplY3Q1J30pO1xyXG4gICAgICogb2JqZWN0NS5iaWxsYm9hcmQgPSBuZXcgQ2VzaXVtLkJpbGxib2FyZEdyYXBoaWNzKCk7XHJcbiAgICAgKiBvYmplY3Q1LmJpbGxib2FyZC5zY2FsZSA9IENlc2l1bS5SZWZlcmVuY2VQcm9wZXJ0eS5mcm9tU3RyaW5nKGNvbGxlY3Rpb24sICdcXFxcI29iamVjdFxcXFwuNCNiaWxsYm9hcmQuc2NhbGUnKTtcclxuICAgICAqIGNvbGxlY3Rpb24uYWRkKG9iamVjdDUpO1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBSZWZlcmVuY2VQcm9wZXJ0eSh0YXJnZXRDb2xsZWN0aW9uLCB0YXJnZXRJZCwgdGFyZ2V0UHJvcGVydHlOYW1lcykge1xyXG4gICAgICAgIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XHJcbiAgICAgICAgaWYgKCFkZWZpbmVkKHRhcmdldENvbGxlY3Rpb24pKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcigndGFyZ2V0Q29sbGVjdGlvbiBpcyByZXF1aXJlZC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFkZWZpbmVkKHRhcmdldElkKSB8fCB0YXJnZXRJZCA9PT0gJycpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKCd0YXJnZXRJZCBpcyByZXF1aXJlZC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFkZWZpbmVkKHRhcmdldFByb3BlcnR5TmFtZXMpIHx8IHRhcmdldFByb3BlcnR5TmFtZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcigndGFyZ2V0UHJvcGVydHlOYW1lcyBpcyByZXF1aXJlZC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0YXJnZXRQcm9wZXJ0eU5hbWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBpdGVtID0gdGFyZ2V0UHJvcGVydHlOYW1lc1tpXTtcclxuICAgICAgICAgICAgaWYgKCFkZWZpbmVkKGl0ZW0pIHx8IGl0ZW0gPT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoJ3JlZmVyZW5jZSBjb250YWlucyBpbnZhbGlkIHByb3BlcnRpZXMuJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XHJcblxyXG4gICAgICAgIHRoaXMuX3RhcmdldENvbGxlY3Rpb24gPSB0YXJnZXRDb2xsZWN0aW9uO1xyXG4gICAgICAgIHRoaXMuX3RhcmdldElkID0gdGFyZ2V0SWQ7XHJcbiAgICAgICAgdGhpcy5fdGFyZ2V0UHJvcGVydHlOYW1lcyA9IHRhcmdldFByb3BlcnR5TmFtZXM7XHJcbiAgICAgICAgdGhpcy5fdGFyZ2V0UHJvcGVydHkgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5fdGFyZ2V0RW50aXR5ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuX2RlZmluaXRpb25DaGFuZ2VkID0gbmV3IEV2ZW50KCk7XHJcbiAgICAgICAgdGhpcy5fcmVzb2x2ZUVudGl0eSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5fcmVzb2x2ZVByb3BlcnR5ID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgdGFyZ2V0Q29sbGVjdGlvbi5jb2xsZWN0aW9uQ2hhbmdlZC5hZGRFdmVudExpc3RlbmVyKFJlZmVyZW5jZVByb3BlcnR5LnByb3RvdHlwZS5fb25Db2xsZWN0aW9uQ2hhbmdlZCwgdGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgZGVmaW5lUHJvcGVydGllcyhSZWZlcmVuY2VQcm9wZXJ0eS5wcm90b3R5cGUsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIGEgdmFsdWUgaW5kaWNhdGluZyBpZiB0aGlzIHByb3BlcnR5IGlzIGNvbnN0YW50LlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBSZWZlcmVuY2VQcm9wZXJ0eS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKi9cclxuICAgICAgICBpc0NvbnN0YW50IDoge1xyXG4gICAgICAgICAgICBnZXQgOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9wZXJ0eS5pc0NvbnN0YW50KHJlc29sdmUodGhpcykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSBldmVudCB0aGF0IGlzIHJhaXNlZCB3aGVuZXZlciB0aGUgZGVmaW5pdGlvbiBvZiB0aGlzIHByb3BlcnR5IGNoYW5nZXMuXHJcbiAgICAgICAgICogVGhlIGRlZmluaXRpb24gaXMgY2hhbmdlZCB3aGVuZXZlciB0aGUgcmVmZXJlbmNlZCBwcm9wZXJ0eSdzIGRlZmluaXRpb24gaXMgY2hhbmdlZC5cclxuICAgICAgICAgKiBAbWVtYmVyb2YgUmVmZXJlbmNlUHJvcGVydHkucHJvdG90eXBlXHJcbiAgICAgICAgICogQHR5cGUge0V2ZW50fVxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGRlZmluaXRpb25DaGFuZ2VkIDoge1xyXG4gICAgICAgICAgICBnZXQgOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWZpbml0aW9uQ2hhbmdlZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgcmVmZXJlbmNlIGZyYW1lIHRoYXQgdGhlIHBvc2l0aW9uIGlzIGRlZmluZWQgaW4uXHJcbiAgICAgICAgICogVGhpcyBwcm9wZXJ0eSBpcyBvbmx5IHZhbGlkIGlmIHRoZSByZWZlcmVuY2VkIHByb3BlcnR5IGlzIGEge0BsaW5rIFBvc2l0aW9uUHJvcGVydHl9LlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBSZWZlcmVuY2VQcm9wZXJ0eS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAdHlwZSB7UmVmZXJlbmNlRnJhbWV9XHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcmVmZXJlbmNlRnJhbWUgOiB7XHJcbiAgICAgICAgICAgIGdldCA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUodGhpcykucmVmZXJlbmNlRnJhbWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIGlkIG9mIHRoZSBlbnRpdHkgYmVpbmcgcmVmZXJlbmNlZC5cclxuICAgICAgICAgKiBAbWVtYmVyb2YgUmVmZXJlbmNlUHJvcGVydHkucHJvdG90eXBlXHJcbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKi9cclxuICAgICAgICB0YXJnZXRJZCA6IHtcclxuICAgICAgICAgICAgZ2V0IDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdGFyZ2V0SWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIGNvbGxlY3Rpb24gY29udGFpbmluZyB0aGUgZW50aXR5IGJlaW5nIHJlZmVyZW5jZWQuXHJcbiAgICAgICAgICogQG1lbWJlcm9mIFJlZmVyZW5jZVByb3BlcnR5LnByb3RvdHlwZVxyXG4gICAgICAgICAqIEB0eXBlIHtFbnRpdHlDb2xsZWN0aW9ufVxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRhcmdldENvbGxlY3Rpb24gOiB7XHJcbiAgICAgICAgICAgIGdldCA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RhcmdldENvbGxlY3Rpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIHVzZWQgdG8gcmV0cmlldmUgdGhlIHJlZmVyZW5jZWQgcHJvcGVydHkuXHJcbiAgICAgICAgICogQG1lbWJlcm9mIFJlZmVyZW5jZVByb3BlcnR5LnByb3RvdHlwZVxyXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmdbXX1cclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKi9cclxuICAgICAgICB0YXJnZXRQcm9wZXJ0eU5hbWVzIDoge1xyXG4gICAgICAgICAgICBnZXQgOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl90YXJnZXRQcm9wZXJ0eU5hbWVzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSByZXNvbHZlZCBpbnN0YW5jZSBvZiB0aGUgdW5kZXJseWluZyByZWZlcmVuY2VkIHByb3BlcnR5LlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBSZWZlcmVuY2VQcm9wZXJ0eS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAdHlwZSB7UHJvcGVydHl9XHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcmVzb2x2ZWRQcm9wZXJ0eSA6IHtcclxuICAgICAgICAgICAgZ2V0IDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBnaXZlbiB0aGUgZW50aXR5IGNvbGxlY3Rpb24gdGhhdCB3aWxsXHJcbiAgICAgKiBiZSB1c2VkIHRvIHJlc29sdmUgaXQgYW5kIGEgc3RyaW5nIGluZGljYXRpbmcgdGhlIHRhcmdldCBlbnRpdHkgaWQgYW5kIHByb3BlcnR5LlxyXG4gICAgICogVGhlIGZvcm1hdCBvZiB0aGUgc3RyaW5nIGlzIFwib2JqZWN0SWQjZm9vLmJhclwiLCB3aGVyZSAjIHNlcGFyYXRlcyB0aGUgaWQgZnJvbVxyXG4gICAgICogcHJvcGVydHkgcGF0aCBhbmQgLiBzZXBhcmF0ZXMgc3ViLXByb3BlcnRpZXMuICBJZiB0aGUgcmVmZXJlbmNlIGlkZW50aWZpZXIgb3JcclxuICAgICAqIG9yIGFueSBzdWItcHJvcGVydGllcyBjb250YWlucyBhICMgLiBvciBcXCB0aGV5IG11c3QgYmUgZXNjYXBlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0VudGl0eUNvbGxlY3Rpb259IHRhcmdldENvbGxlY3Rpb25cclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSByZWZlcmVuY2VTdHJpbmdcclxuICAgICAqIEByZXR1cm5zIHtSZWZlcmVuY2VQcm9wZXJ0eX0gQSBuZXcgaW5zdGFuY2Ugb2YgUmVmZXJlbmNlUHJvcGVydHkuXHJcbiAgICAgKlxyXG4gICAgICogQGV4Y2VwdGlvbiB7RGV2ZWxvcGVyRXJyb3J9IGludmFsaWQgcmVmZXJlbmNlU3RyaW5nLlxyXG4gICAgICovXHJcbiAgICBSZWZlcmVuY2VQcm9wZXJ0eS5mcm9tU3RyaW5nID0gZnVuY3Rpb24odGFyZ2V0Q29sbGVjdGlvbiwgcmVmZXJlbmNlU3RyaW5nKSB7XHJcbiAgICAgICAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcclxuICAgICAgICBpZiAoIWRlZmluZWQodGFyZ2V0Q29sbGVjdGlvbikpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKCd0YXJnZXRDb2xsZWN0aW9uIGlzIHJlcXVpcmVkLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWRlZmluZWQocmVmZXJlbmNlU3RyaW5nKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoJ3JlZmVyZW5jZVN0cmluZyBpcyByZXF1aXJlZC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XHJcblxyXG4gICAgICAgIHZhciBpZGVudGlmaWVyO1xyXG4gICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcclxuXHJcbiAgICAgICAgdmFyIGluSWRlbnRpZmllciA9IHRydWU7XHJcbiAgICAgICAgdmFyIGlzRXNjYXBlZCA9IGZhbHNlO1xyXG4gICAgICAgIHZhciB0b2tlbiA9ICcnO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVmZXJlbmNlU3RyaW5nLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIHZhciBjID0gcmVmZXJlbmNlU3RyaW5nLmNoYXJBdChpKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChpc0VzY2FwZWQpIHtcclxuICAgICAgICAgICAgICAgIHRva2VuICs9IGM7XHJcbiAgICAgICAgICAgICAgICBpc0VzY2FwZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChjID09PSAnXFxcXCcpIHtcclxuICAgICAgICAgICAgICAgIGlzRXNjYXBlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5JZGVudGlmaWVyICYmIGMgPT09ICcjJykge1xyXG4gICAgICAgICAgICAgICAgaWRlbnRpZmllciA9IHRva2VuO1xyXG4gICAgICAgICAgICAgICAgaW5JZGVudGlmaWVyID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB0b2tlbiA9ICcnO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFpbklkZW50aWZpZXIgJiYgYyA9PT0gJy4nKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaCh0b2tlbik7XHJcbiAgICAgICAgICAgICAgICB0b2tlbiA9ICcnO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdG9rZW4gKz0gYztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YWx1ZXMucHVzaCh0b2tlbik7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgUmVmZXJlbmNlUHJvcGVydHkodGFyZ2V0Q29sbGVjdGlvbiwgaWRlbnRpZmllciwgdmFsdWVzKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgYXQgdGhlIHByb3ZpZGVkIHRpbWUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtKdWxpYW5EYXRlfSB0aW1lIFRoZSB0aW1lIGZvciB3aGljaCB0byByZXRyaWV2ZSB0aGUgdmFsdWUuXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3Jlc3VsdF0gVGhlIG9iamVjdCB0byBzdG9yZSB0aGUgdmFsdWUgaW50bywgaWYgb21pdHRlZCwgYSBuZXcgaW5zdGFuY2UgaXMgY3JlYXRlZCBhbmQgcmV0dXJuZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgbW9kaWZpZWQgcmVzdWx0IHBhcmFtZXRlciBvciBhIG5ldyBpbnN0YW5jZSBpZiB0aGUgcmVzdWx0IHBhcmFtZXRlciB3YXMgbm90IHN1cHBsaWVkLlxyXG4gICAgICovXHJcbiAgICBSZWZlcmVuY2VQcm9wZXJ0eS5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbih0aW1lLCByZXN1bHQpIHtcclxuICAgICAgICByZXR1cm4gcmVzb2x2ZSh0aGlzKS5nZXRWYWx1ZSh0aW1lLCByZXN1bHQpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eSBhdCB0aGUgcHJvdmlkZWQgdGltZSBhbmQgaW4gdGhlIHByb3ZpZGVkIHJlZmVyZW5jZSBmcmFtZS5cclxuICAgICAqIFRoaXMgbWV0aG9kIGlzIG9ubHkgdmFsaWQgaWYgdGhlIHByb3BlcnR5IGJlaW5nIHJlZmVyZW5jZWQgaXMgYSB7QGxpbmsgUG9zaXRpb25Qcm9wZXJ0eX0uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtKdWxpYW5EYXRlfSB0aW1lIFRoZSB0aW1lIGZvciB3aGljaCB0byByZXRyaWV2ZSB0aGUgdmFsdWUuXHJcbiAgICAgKiBAcGFyYW0ge1JlZmVyZW5jZUZyYW1lfSByZWZlcmVuY2VGcmFtZSBUaGUgZGVzaXJlZCByZWZlcmVuY2VGcmFtZSBvZiB0aGUgcmVzdWx0LlxyXG4gICAgICogQHBhcmFtIHtDYXJ0ZXNpYW4zfSBbcmVzdWx0XSBUaGUgb2JqZWN0IHRvIHN0b3JlIHRoZSB2YWx1ZSBpbnRvLCBpZiBvbWl0dGVkLCBhIG5ldyBpbnN0YW5jZSBpcyBjcmVhdGVkIGFuZCByZXR1cm5lZC5cclxuICAgICAqIEByZXR1cm5zIHtDYXJ0ZXNpYW4zfSBUaGUgbW9kaWZpZWQgcmVzdWx0IHBhcmFtZXRlciBvciBhIG5ldyBpbnN0YW5jZSBpZiB0aGUgcmVzdWx0IHBhcmFtZXRlciB3YXMgbm90IHN1cHBsaWVkLlxyXG4gICAgICovXHJcbiAgICBSZWZlcmVuY2VQcm9wZXJ0eS5wcm90b3R5cGUuZ2V0VmFsdWVJblJlZmVyZW5jZUZyYW1lID0gZnVuY3Rpb24odGltZSwgcmVmZXJlbmNlRnJhbWUsIHJlc3VsdCkge1xyXG4gICAgICAgIHJldHVybiByZXNvbHZlKHRoaXMpLmdldFZhbHVlSW5SZWZlcmVuY2VGcmFtZSh0aW1lLCByZWZlcmVuY2VGcmFtZSwgcmVzdWx0KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSB7QGxpbmsgTWF0ZXJpYWx9IHR5cGUgYXQgdGhlIHByb3ZpZGVkIHRpbWUuXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBvbmx5IHZhbGlkIGlmIHRoZSBwcm9wZXJ0eSBiZWluZyByZWZlcmVuY2VkIGlzIGEge0BsaW5rIE1hdGVyaWFsUHJvcGVydHl9LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7SnVsaWFuRGF0ZX0gdGltZSBUaGUgdGltZSBmb3Igd2hpY2ggdG8gcmV0cmlldmUgdGhlIHR5cGUuXHJcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgdHlwZSBvZiBtYXRlcmlhbC5cclxuICAgICAqL1xyXG4gICAgUmVmZXJlbmNlUHJvcGVydHkucHJvdG90eXBlLmdldFR5cGUgPSBmdW5jdGlvbih0aW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlc29sdmUodGhpcykuZ2V0VHlwZSh0aW1lKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wYXJlcyB0aGlzIHByb3BlcnR5IHRvIHRoZSBwcm92aWRlZCBwcm9wZXJ0eSBhbmQgcmV0dXJuc1xyXG4gICAgICogPGNvZGU+dHJ1ZTwvY29kZT4gaWYgdGhleSBhcmUgZXF1YWwsIDxjb2RlPmZhbHNlPC9jb2RlPiBvdGhlcndpc2UuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtQcm9wZXJ0eX0gW290aGVyXSBUaGUgb3RoZXIgcHJvcGVydHkuXHJcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgbGVmdCBhbmQgcmlnaHQgYXJlIGVxdWFsLCA8Y29kZT5mYWxzZTwvY29kZT4gb3RoZXJ3aXNlLlxyXG4gICAgICovXHJcbiAgICBSZWZlcmVuY2VQcm9wZXJ0eS5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24ob3RoZXIpIHtcclxuICAgICAgICBpZiAodGhpcyA9PT0gb3RoZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgbmFtZXMgPSB0aGlzLl90YXJnZXRQcm9wZXJ0eU5hbWVzO1xyXG4gICAgICAgIHZhciBvdGhlck5hbWVzID0gb3RoZXIuX3RhcmdldFByb3BlcnR5TmFtZXM7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLl90YXJnZXRDb2xsZWN0aW9uICE9PSBvdGhlci5fdGFyZ2V0Q29sbGVjdGlvbiB8fCAvL1xyXG4gICAgICAgICAgICB0aGlzLl90YXJnZXRJZCAhPT0gb3RoZXIuX3RhcmdldElkIHx8IC8vXHJcbiAgICAgICAgICAgIG5hbWVzLmxlbmd0aCAhPT0gb3RoZXJOYW1lcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMuX3RhcmdldFByb3BlcnR5TmFtZXMubGVuZ3RoO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKG5hbWVzW2ldICE9PSBvdGhlck5hbWVzW2ldKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxuXHJcbiAgICBSZWZlcmVuY2VQcm9wZXJ0eS5wcm90b3R5cGUuX29uVGFyZ2V0RW50aXR5RGVmaW5pdGlvbkNoYW5nZWQgPSBmdW5jdGlvbih0YXJnZXRFbnRpdHksIG5hbWUsIHZhbHVlLCBvbGRWYWx1ZSkge1xyXG4gICAgICAgIGlmICh0aGlzLl90YXJnZXRQcm9wZXJ0eU5hbWVzWzBdID09PSBuYW1lKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmVQcm9wZXJ0eSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuX2RlZmluaXRpb25DaGFuZ2VkLnJhaXNlRXZlbnQodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBSZWZlcmVuY2VQcm9wZXJ0eS5wcm90b3R5cGUuX29uQ29sbGVjdGlvbkNoYW5nZWQgPSBmdW5jdGlvbihjb2xsZWN0aW9uLCBhZGRlZCwgcmVtb3ZlZCkge1xyXG4gICAgICAgIHZhciB0YXJnZXRFbnRpdHkgPSB0aGlzLl90YXJnZXRFbnRpdHk7XHJcbiAgICAgICAgaWYgKGRlZmluZWQodGFyZ2V0RW50aXR5KSkge1xyXG4gICAgICAgICAgICBpZiAocmVtb3ZlZC5pbmRleE9mKHRhcmdldEVudGl0eSkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXRFbnRpdHkuZGVmaW5pdGlvbkNoYW5nZWQucmVtb3ZlRXZlbnRMaXN0ZW5lcihSZWZlcmVuY2VQcm9wZXJ0eS5wcm90b3R5cGUuX29uVGFyZ2V0RW50aXR5RGVmaW5pdGlvbkNoYW5nZWQsIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZUVudGl0eSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNvbHZlUHJvcGVydHkgPSB0cnVlO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX3Jlc29sdmVFbnRpdHkpIHtcclxuICAgICAgICAgICAgICAgIC8vSWYgdGFyZ2V0RW50aXR5IGlzIGRlZmluZWQgYnV0IHJlc29sdmVFbnRpdHkgaXMgdHJ1ZSwgdGhlbiB0aGUgZW50aXR5IGlzIGRldGFjaGVkXHJcbiAgICAgICAgICAgICAgICAvL2FuZCBhbnkgY2hhbmdlIHRvIHRoZSBjb2xsZWN0aW9uIG5lZWRzIHRvIGluY3VyIGFuIGF0dGVtcHQgdG8gcmVzb2x2ZSBpbiBvcmRlciB0byByZS1hdHRhY2guXHJcbiAgICAgICAgICAgICAgICAvL3dpdGhvdXQgdGhpcyBpZiBibG9jaywgYSByZWZlcmVuY2UgdGhhdCBiZWNvbWVzIHJlLWF0dGFjaGVkIHdpbGwgbm90IHNpZ25hbCBkZWZpbml0aW9uQ2hhbmdlZFxyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzKTtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fcmVzb2x2ZUVudGl0eSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RlZmluaXRpb25DaGFuZ2VkLnJhaXNlRXZlbnQodGhpcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBSZWZlcmVuY2VQcm9wZXJ0eTtcclxufSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3RlcnJpYWpzLWNlc2l1bS9Tb3VyY2UvRGF0YVNvdXJjZXMvUmVmZXJlbmNlUHJvcGVydHkuanNcbi8vIG1vZHVsZSBpZCA9IDExOTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZGVmaW5lKFtcclxuICAgICAgICAnLi4vQ29yZS9mcmVlemVPYmplY3QnXHJcbiAgICBdLCBmdW5jdGlvbihcclxuICAgICAgICBmcmVlemVPYmplY3QpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlZmluZWQgdGhlIG9yaWVudGF0aW9uIG9mIHN0cmlwZXMgaW4ge0BsaW5rIFN0cmlwZU1hdGVyaWFsUHJvcGVydHl9LlxyXG4gICAgICpcclxuICAgICAqIEBleHBvcnRzIFN0cmlwZU9yaWVudGF0aW9uXHJcbiAgICAgKi9cclxuICAgIHZhciBTdHJpcGVPcmllbnRhdGlvbiA9IHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBIb3Jpem9udGFsIG9yaWVudGF0aW9uLlxyXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgSE9SSVpPTlRBTCA6IDAsXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFZlcnRpY2FsIG9yaWVudGF0aW9uLlxyXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVkVSVElDQUwgOiAxXHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBmcmVlemVPYmplY3QoU3RyaXBlT3JpZW50YXRpb24pO1xyXG59KTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvdGVycmlhanMtY2VzaXVtL1NvdXJjZS9EYXRhU291cmNlcy9TdHJpcGVPcmllbnRhdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gMTE5OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJkZWZpbmUoW1xyXG4gICAgICAgICcuLi9Db3JlL0NhcnRlc2lhbjMnLFxyXG4gICAgICAgICcuLi9Db3JlL2RlZmF1bHRWYWx1ZScsXHJcbiAgICAgICAgJy4uL0NvcmUvZGVmaW5lZCcsXHJcbiAgICAgICAgJy4uL0NvcmUvZGVmaW5lUHJvcGVydGllcycsXHJcbiAgICAgICAgJy4uL0NvcmUvRGV2ZWxvcGVyRXJyb3InLFxyXG4gICAgICAgICcuLi9Db3JlL0V2ZW50JyxcclxuICAgICAgICAnLi4vQ29yZS9KdWxpYW5EYXRlJyxcclxuICAgICAgICAnLi9Qcm9wZXJ0eSdcclxuICAgIF0sIGZ1bmN0aW9uKFxyXG4gICAgICAgIENhcnRlc2lhbjMsXHJcbiAgICAgICAgZGVmYXVsdFZhbHVlLFxyXG4gICAgICAgIGRlZmluZWQsXHJcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyxcclxuICAgICAgICBEZXZlbG9wZXJFcnJvcixcclxuICAgICAgICBFdmVudCxcclxuICAgICAgICBKdWxpYW5EYXRlLFxyXG4gICAgICAgIFByb3BlcnR5KSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIHtAbGluayBQcm9wZXJ0eX0gd2hpY2ggZXZhbHVhdGVzIHRvIGEge0BsaW5rIENhcnRlc2lhbjN9IHZlY3RvclxyXG4gICAgICogYmFzZWQgb24gdGhlIHZlbG9jaXR5IG9mIHRoZSBwcm92aWRlZCB7QGxpbmsgUG9zaXRpb25Qcm9wZXJ0eX0uXHJcbiAgICAgKlxyXG4gICAgICogQGFsaWFzIFZlbG9jaXR5VmVjdG9yUHJvcGVydHlcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UHJvcGVydHl9IFtwb3NpdGlvbl0gVGhlIHBvc2l0aW9uIHByb3BlcnR5IHVzZWQgdG8gY29tcHV0ZSB0aGUgdmVsb2NpdHkuXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtub3JtYWxpemU9dHJ1ZV0gV2hldGhlciB0byBub3JtYWxpemUgdGhlIGNvbXB1dGVkIHZlbG9jaXR5IHZlY3Rvci5cclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogLy9DcmVhdGUgYW4gZW50aXR5IHdpdGggYSBiaWxsYm9hcmQgcm90YXRlZCB0byBtYXRjaCBpdHMgdmVsb2NpdHkuXHJcbiAgICAgKiB2YXIgcG9zaXRpb24gPSBuZXcgQ2VzaXVtLlNhbXBsZWRQcm9wZXJ0eSgpO1xyXG4gICAgICogcG9zaXRpb24uYWRkU2FtcGxlcyguLi4pO1xyXG4gICAgICogdmFyIGVudGl0eSA9IHZpZXdlci5lbnRpdGllcy5hZGQoe1xyXG4gICAgICogICBwb3NpdGlvbiA6IHBvc2l0aW9uLFxyXG4gICAgICogICBiaWxsYm9hcmQgOiB7XHJcbiAgICAgKiAgICAgaW1hZ2UgOiAnaW1hZ2UucG5nJyxcclxuICAgICAqICAgICBhbGlnbmVkQXhpcyA6IG5ldyBDZXNpdW0uVmVsb2NpdHlWZWN0b3JQcm9wZXJ0eShwb3NpdGlvbiwgdHJ1ZSkgLy8gYWxpZ25lZEF4aXMgbXVzdCBiZSBhIHVuaXQgdmVjdG9yXHJcbiAgICAgKiAgIH1cclxuICAgICAqIH0pKTtcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gVmVsb2NpdHlWZWN0b3JQcm9wZXJ0eShwb3NpdGlvbiwgbm9ybWFsaXplKSB7XHJcbiAgICAgICAgdGhpcy5fcG9zaXRpb24gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuX2RlZmluaXRpb25DaGFuZ2VkID0gbmV3IEV2ZW50KCk7XHJcbiAgICAgICAgdGhpcy5fbm9ybWFsaXplID0gZGVmYXVsdFZhbHVlKG5vcm1hbGl6ZSwgdHJ1ZSk7XHJcblxyXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBkZWZpbmVQcm9wZXJ0aWVzKFZlbG9jaXR5VmVjdG9yUHJvcGVydHkucHJvdG90eXBlLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBhIHZhbHVlIGluZGljYXRpbmcgaWYgdGhpcyBwcm9wZXJ0eSBpcyBjb25zdGFudC5cclxuICAgICAgICAgKiBAbWVtYmVyb2YgVmVsb2NpdHlWZWN0b3JQcm9wZXJ0eS5wcm90b3R5cGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGlzQ29uc3RhbnQgOiB7XHJcbiAgICAgICAgICAgIGdldCA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb3BlcnR5LmlzQ29uc3RhbnQodGhpcy5fcG9zaXRpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSBldmVudCB0aGF0IGlzIHJhaXNlZCB3aGVuZXZlciB0aGUgZGVmaW5pdGlvbiBvZiB0aGlzIHByb3BlcnR5IGNoYW5nZXMuXHJcbiAgICAgICAgICogQG1lbWJlcm9mIFZlbG9jaXR5VmVjdG9yUHJvcGVydHkucHJvdG90eXBlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAdHlwZSB7RXZlbnR9XHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZGVmaW5pdGlvbkNoYW5nZWQgOiB7XHJcbiAgICAgICAgICAgIGdldCA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZmluaXRpb25DaGFuZ2VkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIHBvc2l0aW9uIHByb3BlcnR5IHVzZWQgdG8gY29tcHV0ZSB0aGUgdmVsb2NpdHkgdmVjdG9yLlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBWZWxvY2l0eVZlY3RvclByb3BlcnR5LnByb3RvdHlwZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHR5cGUge1Byb3BlcnR5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHBvc2l0aW9uIDoge1xyXG4gICAgICAgICAgICBnZXQgOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wb3NpdGlvbjtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2V0IDogZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMuX3Bvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgaWYgKG9sZFZhbHVlICE9PSB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWZpbmVkKG9sZFZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24oKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Bvc2l0aW9uID0gdmFsdWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWZpbmVkKHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24gPSB2YWx1ZS5fZGVmaW5pdGlvbkNoYW5nZWQuYWRkRXZlbnRMaXN0ZW5lcihmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RlZmluaXRpb25DaGFuZ2VkLnJhaXNlRXZlbnQodGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGVmaW5pdGlvbkNoYW5nZWQucmFpc2VFdmVudCh0aGlzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBvciBzZXRzIHdoZXRoZXIgdGhlIHZlY3RvciBwcm9kdWNlZCBieSB0aGlzIHByb3BlcnR5XHJcbiAgICAgICAgICogd2lsbCBiZSBub3JtYWxpemVkIG9yIG5vdC5cclxuICAgICAgICAgKiBAbWVtYmVyb2YgVmVsb2NpdHlWZWN0b3JQcm9wZXJ0eS5wcm90b3R5cGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIG5vcm1hbGl6ZSA6IHtcclxuICAgICAgICAgICAgZ2V0IDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbm9ybWFsaXplO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzZXQgOiBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX25vcm1hbGl6ZSA9PT0gdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5fbm9ybWFsaXplID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWZpbml0aW9uQ2hhbmdlZC5yYWlzZUV2ZW50KHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgdmFyIHBvc2l0aW9uMVNjcmF0Y2ggPSBuZXcgQ2FydGVzaWFuMygpO1xyXG4gICAgdmFyIHBvc2l0aW9uMlNjcmF0Y2ggPSBuZXcgQ2FydGVzaWFuMygpO1xyXG4gICAgdmFyIHRpbWVTY3JhdGNoID0gbmV3IEp1bGlhbkRhdGUoKTtcclxuICAgIHZhciBzdGVwID0gMS4wIC8gNjAuMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eSBhdCB0aGUgcHJvdmlkZWQgdGltZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0p1bGlhbkRhdGV9IFt0aW1lXSBUaGUgdGltZSBmb3Igd2hpY2ggdG8gcmV0cmlldmUgdGhlIHZhbHVlLlxyXG4gICAgICogQHBhcmFtIHtDYXJ0ZXNpYW4zfSBbcmVzdWx0XSBUaGUgb2JqZWN0IHRvIHN0b3JlIHRoZSB2YWx1ZSBpbnRvLCBpZiBvbWl0dGVkLCBhIG5ldyBpbnN0YW5jZSBpcyBjcmVhdGVkIGFuZCByZXR1cm5lZC5cclxuICAgICAqIEByZXR1cm5zIHtDYXJ0ZXNpYW4zfSBUaGUgbW9kaWZpZWQgcmVzdWx0IHBhcmFtZXRlciBvciBhIG5ldyBpbnN0YW5jZSBpZiB0aGUgcmVzdWx0IHBhcmFtZXRlciB3YXMgbm90IHN1cHBsaWVkLlxyXG4gICAgICovXHJcbiAgICBWZWxvY2l0eVZlY3RvclByb3BlcnR5LnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uKHRpbWUsIHJlc3VsdCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRWYWx1ZSh0aW1lLCByZXN1bHQpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIFZlbG9jaXR5VmVjdG9yUHJvcGVydHkucHJvdG90eXBlLl9nZXRWYWx1ZSA9IGZ1bmN0aW9uKHRpbWUsIHZlbG9jaXR5UmVzdWx0LCBwb3NpdGlvblJlc3VsdCkge1xyXG4gICAgICAgIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XHJcbiAgICAgICAgaWYgKCFkZWZpbmVkKHRpbWUpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcigndGltZSBpcyByZXF1aXJlZCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcclxuXHJcbiAgICAgICAgaWYgKCFkZWZpbmVkKHZlbG9jaXR5UmVzdWx0KSkge1xyXG4gICAgICAgICAgICB2ZWxvY2l0eVJlc3VsdCA9IG5ldyBDYXJ0ZXNpYW4zKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgcHJvcGVydHkgPSB0aGlzLl9wb3NpdGlvbjtcclxuICAgICAgICBpZiAoUHJvcGVydHkuaXNDb25zdGFudChwcm9wZXJ0eSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25vcm1hbGl6ZSA/IHVuZGVmaW5lZCA6IENhcnRlc2lhbjMuY2xvbmUoQ2FydGVzaWFuMy5aRVJPLCB2ZWxvY2l0eVJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgcG9zaXRpb24xID0gcHJvcGVydHkuZ2V0VmFsdWUodGltZSwgcG9zaXRpb24xU2NyYXRjaCk7XHJcbiAgICAgICAgdmFyIHBvc2l0aW9uMiA9IHByb3BlcnR5LmdldFZhbHVlKEp1bGlhbkRhdGUuYWRkU2Vjb25kcyh0aW1lLCBzdGVwLCB0aW1lU2NyYXRjaCksIHBvc2l0aW9uMlNjcmF0Y2gpO1xyXG5cclxuICAgICAgICAvL0lmIHdlIGRvbid0IGhhdmUgYSBwb3NpdGlvbiBmb3Igbm93LCByZXR1cm4gdW5kZWZpbmVkLlxyXG4gICAgICAgIGlmICghZGVmaW5lZChwb3NpdGlvbjEpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL0lmIHdlIGRvbid0IGhhdmUgYSBwb3NpdGlvbiBmb3Igbm93ICsgc3RlcCwgc2VlIGlmIHdlIGhhdmUgYSBwb3NpdGlvbiBmb3Igbm93IC0gc3RlcC5cclxuICAgICAgICBpZiAoIWRlZmluZWQocG9zaXRpb24yKSkge1xyXG4gICAgICAgICAgICBwb3NpdGlvbjIgPSBwb3NpdGlvbjE7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uMSA9IHByb3BlcnR5LmdldFZhbHVlKEp1bGlhbkRhdGUuYWRkU2Vjb25kcyh0aW1lLCAtc3RlcCwgdGltZVNjcmF0Y2gpLCBwb3NpdGlvbjJTY3JhdGNoKTtcclxuXHJcbiAgICAgICAgICAgIGlmICghZGVmaW5lZChwb3NpdGlvbjEpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoQ2FydGVzaWFuMy5lcXVhbHMocG9zaXRpb24xLCBwb3NpdGlvbjIpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ub3JtYWxpemUgPyB1bmRlZmluZWQgOiBDYXJ0ZXNpYW4zLmNsb25lKENhcnRlc2lhbjMuWkVSTywgdmVsb2NpdHlSZXN1bHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGRlZmluZWQocG9zaXRpb25SZXN1bHQpKSB7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uMS5jbG9uZShwb3NpdGlvblJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgdmVsb2NpdHkgPSBDYXJ0ZXNpYW4zLnN1YnRyYWN0KHBvc2l0aW9uMiwgcG9zaXRpb24xLCB2ZWxvY2l0eVJlc3VsdCk7XHJcbiAgICAgICAgaWYgKHRoaXMuX25vcm1hbGl6ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gQ2FydGVzaWFuMy5ub3JtYWxpemUodmVsb2NpdHksIHZlbG9jaXR5UmVzdWx0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBDYXJ0ZXNpYW4zLmRpdmlkZUJ5U2NhbGFyKHZlbG9jaXR5LCBzdGVwLCB2ZWxvY2l0eVJlc3VsdCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29tcGFyZXMgdGhpcyBwcm9wZXJ0eSB0byB0aGUgcHJvdmlkZWQgcHJvcGVydHkgYW5kIHJldHVybnNcclxuICAgICAqIDxjb2RlPnRydWU8L2NvZGU+IGlmIHRoZXkgYXJlIGVxdWFsLCA8Y29kZT5mYWxzZTwvY29kZT4gb3RoZXJ3aXNlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UHJvcGVydHl9IFtvdGhlcl0gVGhlIG90aGVyIHByb3BlcnR5LlxyXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IGlmIGxlZnQgYW5kIHJpZ2h0IGFyZSBlcXVhbCwgPGNvZGU+ZmFsc2U8L2NvZGU+IG90aGVyd2lzZS5cclxuICAgICAqL1xyXG4gICAgVmVsb2NpdHlWZWN0b3JQcm9wZXJ0eS5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24ob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gdGhpcyA9PT0gb3RoZXIgfHwvL1xyXG4gICAgICAgICAgICAgICAob3RoZXIgaW5zdGFuY2VvZiBWZWxvY2l0eVZlY3RvclByb3BlcnR5ICYmXHJcbiAgICAgICAgICAgICAgICBQcm9wZXJ0eS5lcXVhbHModGhpcy5fcG9zaXRpb24sIG90aGVyLl9wb3NpdGlvbikpO1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gVmVsb2NpdHlWZWN0b3JQcm9wZXJ0eTtcclxufSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3RlcnJpYWpzLWNlc2l1bS9Tb3VyY2UvRGF0YVNvdXJjZXMvVmVsb2NpdHlWZWN0b3JQcm9wZXJ0eS5qc1xuLy8gbW9kdWxlIGlkID0gMTE5OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJkZWZpbmUoW1xyXG4gICAgICAgICcuL2ZyZWV6ZU9iamVjdCdcclxuICAgIF0sIGZ1bmN0aW9uKFxyXG4gICAgICAgIGZyZWV6ZU9iamVjdCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3R5bGUgb3B0aW9ucyBmb3IgY29ybmVycy5cclxuICAgICAqXHJcbiAgICAgKiBAZGVtbyBUaGUge0BsaW5rIGh0dHBzOi8vY2VzaXVtanMub3JnL0Nlc2l1bS9BcHBzL1NhbmRjYXN0bGUvaW5kZXguaHRtbD9zcmM9Q29ycmlkb3IuaHRtbCZsYWJlbD1HZW9tZXRyaWVzfENvcnJpZG9yIERlbW99XHJcbiAgICAgKiBkZW1vbnN0cmF0ZXMgdGhlIHRocmVlIGNvcm5lciB0eXBlcywgYXMgdXNlZCBieSB7QGxpbmsgQ29ycmlkb3JHcmFwaGljc30uXHJcbiAgICAgKlxyXG4gICAgICogQGV4cG9ydHMgQ29ybmVyVHlwZVxyXG4gICAgICovXHJcbiAgICB2YXIgQ29ybmVyVHlwZSA9IHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiA8aW1nIHNyYz1cIkltYWdlcy9Db3JuZXJUeXBlUm91bmRlZC5wbmdcIiBzdHlsZT1cInZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XCIgd2lkdGg9XCIxODZcIiBoZWlnaHQ9XCIxODlcIiAvPlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQ29ybmVyIGhhcyBhIHNtb290aCBlZGdlLlxyXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgICAgICogQGNvbnN0YW50XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUk9VTkRFRCA6IDAsXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIDxpbWcgc3JjPVwiSW1hZ2VzL0Nvcm5lclR5cGVNaXRlcmVkLnBuZ1wiIHN0eWxlPVwidmVydGljYWwtYWxpZ246IG1pZGRsZTtcIiB3aWR0aD1cIjE4NlwiIGhlaWdodD1cIjE4OVwiIC8+XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBDb3JuZXIgcG9pbnQgaXMgdGhlIGludGVyc2VjdGlvbiBvZiBhZGphY2VudCBlZGdlcy5cclxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICAgICAqIEBjb25zdGFudFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE1JVEVSRUQgOiAxLFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiA8aW1nIHNyYz1cIkltYWdlcy9Db3JuZXJUeXBlQmV2ZWxlZC5wbmdcIiBzdHlsZT1cInZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XCIgd2lkdGg9XCIxODZcIiBoZWlnaHQ9XCIxODlcIiAvPlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQ29ybmVyIGlzIGNsaXBwZWQuXHJcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAgICAgKiBAY29uc3RhbnRcclxuICAgICAgICAgKi9cclxuICAgICAgICBCRVZFTEVEIDogMlxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gZnJlZXplT2JqZWN0KENvcm5lclR5cGUpO1xyXG59KTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvdGVycmlhanMtY2VzaXVtL1NvdXJjZS9Db3JlL0Nvcm5lclR5cGUuanNcbi8vIG1vZHVsZSBpZCA9IDEyMDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZGVmaW5lKFtcclxuICAgICAgICAnLi9kZWZhdWx0VmFsdWUnLFxyXG4gICAgICAgICcuL2RlZmluZWQnLFxyXG4gICAgICAgICcuL0RldmVsb3BlckVycm9yJyxcclxuICAgICAgICAnLi9NYXRoJ1xyXG4gICAgXSwgZnVuY3Rpb24oXHJcbiAgICAgICAgZGVmYXVsdFZhbHVlLFxyXG4gICAgICAgIGRlZmluZWQsXHJcbiAgICAgICAgRGV2ZWxvcGVyRXJyb3IsXHJcbiAgICAgICAgQ2VzaXVtTWF0aCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICAgIHZhciBmYWN0b3JpYWwgPSBDZXNpdW1NYXRoLmZhY3RvcmlhbDtcclxuXHJcbiAgICBmdW5jdGlvbiBjYWxjdWxhdGVDb2VmZmljaWVudFRlcm0oeCwgekluZGljZXMsIHhUYWJsZSwgZGVyaXZPcmRlciwgdGVybU9yZGVyLCByZXNlcnZlZEluZGljZXMpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gMDtcclxuICAgICAgICB2YXIgcmVzZXJ2ZWQ7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIGo7XHJcblxyXG4gICAgICAgIGlmIChkZXJpdk9yZGVyID4gMCkge1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGVybU9yZGVyOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHJlc2VydmVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgcmVzZXJ2ZWRJbmRpY2VzLmxlbmd0aCAmJiAhcmVzZXJ2ZWQ7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09PSByZXNlcnZlZEluZGljZXNbal0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzZXJ2ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIXJlc2VydmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzZXJ2ZWRJbmRpY2VzLnB1c2goaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IGNhbGN1bGF0ZUNvZWZmaWNpZW50VGVybSh4LCB6SW5kaWNlcywgeFRhYmxlLCBkZXJpdk9yZGVyIC0gMSwgdGVybU9yZGVyLCByZXNlcnZlZEluZGljZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc2VydmVkSW5kaWNlcy5zcGxpY2UocmVzZXJ2ZWRJbmRpY2VzLmxlbmd0aCAtIDEsIDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmVzdWx0ID0gMTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGVybU9yZGVyOyBpKyspIHtcclxuICAgICAgICAgICAgcmVzZXJ2ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IHJlc2VydmVkSW5kaWNlcy5sZW5ndGggJiYgIXJlc2VydmVkOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChpID09PSByZXNlcnZlZEluZGljZXNbal0pIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNlcnZlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICghcmVzZXJ2ZWQpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCAqPSB4IC0geFRhYmxlW3pJbmRpY2VzW2ldXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFuIHtAbGluayBJbnRlcnBvbGF0aW9uQWxnb3JpdGhtfSBmb3IgcGVyZm9ybWluZyBIZXJtaXRlIGludGVycG9sYXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQGV4cG9ydHMgSGVybWl0ZVBvbHlub21pYWxBcHByb3hpbWF0aW9uXHJcbiAgICAgKi9cclxuICAgIHZhciBIZXJtaXRlUG9seW5vbWlhbEFwcHJveGltYXRpb24gPSB7XHJcbiAgICAgICAgdHlwZSA6ICdIZXJtaXRlJ1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdpdmVuIHRoZSBkZXNpcmVkIGRlZ3JlZSwgcmV0dXJucyB0aGUgbnVtYmVyIG9mIGRhdGEgcG9pbnRzIHJlcXVpcmVkIGZvciBpbnRlcnBvbGF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkZWdyZWUgVGhlIGRlc2lyZWQgZGVncmVlIG9mIGludGVycG9sYXRpb24uXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2lucHV0T3JkZXI9MF0gIFRoZSBvcmRlciBvZiB0aGUgaW5wdXRzICgwIG1lYW5zIGp1c3QgdGhlIGRhdGEsIDEgbWVhbnMgdGhlIGRhdGEgYW5kIGl0cyBkZXJpdmF0aXZlLCBldGMpLlxyXG4gICAgICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWJlciBvZiByZXF1aXJlZCBkYXRhIHBvaW50cyBuZWVkZWQgZm9yIHRoZSBkZXNpcmVkIGRlZ3JlZSBvZiBpbnRlcnBvbGF0aW9uLlxyXG4gICAgICogQGV4Y2VwdGlvbiB7RGV2ZWxvcGVyRXJyb3J9IGRlZ3JlZSBtdXN0IGJlIDAgb3IgZ3JlYXRlci5cclxuICAgICAqIEBleGNlcHRpb24ge0RldmVsb3BlckVycm9yfSBpbnB1dE9yZGVyIG11c3QgYmUgMCBvciBncmVhdGVyLlxyXG4gICAgICovXHJcbiAgICBIZXJtaXRlUG9seW5vbWlhbEFwcHJveGltYXRpb24uZ2V0UmVxdWlyZWREYXRhUG9pbnRzID0gZnVuY3Rpb24oZGVncmVlLCBpbnB1dE9yZGVyKSB7XHJcbiAgICAgICAgaW5wdXRPcmRlciA9IGRlZmF1bHRWYWx1ZShpbnB1dE9yZGVyLCAwKTtcclxuXHJcbiAgICAgICAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcclxuICAgICAgICBpZiAoIWRlZmluZWQoZGVncmVlKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoJ2RlZ3JlZSBpcyByZXF1aXJlZC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRlZ3JlZSA8IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKCdkZWdyZWUgbXVzdCBiZSAwIG9yIGdyZWF0ZXIuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpbnB1dE9yZGVyIDwgMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoJ2lucHV0T3JkZXIgbXVzdCBiZSAwIG9yIGdyZWF0ZXIuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xyXG5cclxuICAgICAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5mbG9vcigoZGVncmVlICsgMSkgLyAoaW5wdXRPcmRlciArIDEpKSwgMik7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW50ZXJwb2xhdGVzIHZhbHVlcyB1c2luZyBIZXJtaXRlIFBvbHlub21pYWwgQXBwcm94aW1hdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgaW5kZXBlbmRlbnQgdmFyaWFibGUgZm9yIHdoaWNoIHRoZSBkZXBlbmRlbnQgdmFyaWFibGVzIHdpbGwgYmUgaW50ZXJwb2xhdGVkLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJbXX0geFRhYmxlIFRoZSBhcnJheSBvZiBpbmRlcGVuZGVudCB2YXJpYWJsZXMgdG8gdXNlIHRvIGludGVycG9sYXRlLiAgVGhlIHZhbHVlc1xyXG4gICAgICogaW4gdGhpcyBhcnJheSBtdXN0IGJlIGluIGluY3JlYXNpbmcgb3JkZXIgYW5kIHRoZSBzYW1lIHZhbHVlIG11c3Qgbm90IG9jY3VyIHR3aWNlIGluIHRoZSBhcnJheS5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyW119IHlUYWJsZSBUaGUgYXJyYXkgb2YgZGVwZW5kZW50IHZhcmlhYmxlcyB0byB1c2UgdG8gaW50ZXJwb2xhdGUuICBGb3IgYSBzZXQgb2YgdGhyZWVcclxuICAgICAqIGRlcGVuZGVudCB2YWx1ZXMgKHAscSx3KSBhdCB0aW1lIDEgYW5kIHRpbWUgMiB0aGlzIHNob3VsZCBiZSBhcyBmb2xsb3dzOiB7cDEsIHExLCB3MSwgcDIsIHEyLCB3Mn0uXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVN0cmlkZSBUaGUgbnVtYmVyIG9mIGRlcGVuZGVudCB2YXJpYWJsZSB2YWx1ZXMgaW4geVRhYmxlIGNvcnJlc3BvbmRpbmcgdG9cclxuICAgICAqIGVhY2ggaW5kZXBlbmRlbnQgdmFyaWFibGUgdmFsdWUgaW4geFRhYmxlLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJbXX0gW3Jlc3VsdF0gQW4gZXhpc3RpbmcgYXJyYXkgaW50byB3aGljaCB0byBzdG9yZSB0aGUgcmVzdWx0LlxyXG4gICAgICogQHJldHVybnMge051bWJlcltdfSBUaGUgYXJyYXkgb2YgaW50ZXJwb2xhdGVkIHZhbHVlcywgb3IgdGhlIHJlc3VsdCBwYXJhbWV0ZXIgaWYgb25lIHdhcyBwcm92aWRlZC5cclxuICAgICAqL1xyXG4gICAgSGVybWl0ZVBvbHlub21pYWxBcHByb3hpbWF0aW9uLmludGVycG9sYXRlT3JkZXJaZXJvID0gZnVuY3Rpb24oeCwgeFRhYmxlLCB5VGFibGUsIHlTdHJpZGUsIHJlc3VsdCkge1xyXG4gICAgICAgIGlmICghZGVmaW5lZChyZXN1bHQpKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBBcnJheSh5U3RyaWRlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHZhciBqO1xyXG4gICAgICAgIHZhciBkO1xyXG4gICAgICAgIHZhciBzO1xyXG4gICAgICAgIHZhciBsZW47XHJcbiAgICAgICAgdmFyIGluZGV4O1xyXG4gICAgICAgIHZhciBsZW5ndGggPSB4VGFibGUubGVuZ3RoO1xyXG4gICAgICAgIHZhciBjb2VmZmljaWVudHMgPSBuZXcgQXJyYXkoeVN0cmlkZSk7XHJcblxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB5U3RyaWRlOyBpKyspIHtcclxuICAgICAgICAgICAgcmVzdWx0W2ldID0gMDtcclxuXHJcbiAgICAgICAgICAgIHZhciBsID0gbmV3IEFycmF5KGxlbmd0aCk7XHJcbiAgICAgICAgICAgIGNvZWZmaWNpZW50c1tpXSA9IGw7XHJcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBsZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgbFtqXSA9IFtdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgekluZGljZXNMZW5ndGggPSBsZW5ndGgsIHpJbmRpY2VzID0gbmV3IEFycmF5KHpJbmRpY2VzTGVuZ3RoKTtcclxuXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHpJbmRpY2VzTGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgekluZGljZXNbaV0gPSBpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGhpZ2hlc3ROb25aZXJvQ29lZiA9IGxlbmd0aCAtIDE7XHJcbiAgICAgICAgZm9yIChzID0gMDsgcyA8IHlTdHJpZGU7IHMrKykge1xyXG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgekluZGljZXNMZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgaW5kZXggPSB6SW5kaWNlc1tqXSAqIHlTdHJpZGUgKyBzO1xyXG4gICAgICAgICAgICAgICAgY29lZmZpY2llbnRzW3NdWzBdLnB1c2goeVRhYmxlW2luZGV4XSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPCB6SW5kaWNlc0xlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbm9uWmVyb0NvZWZmaWNpZW50cyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IHpJbmRpY2VzTGVuZ3RoIC0gaTsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHpqID0geFRhYmxlW3pJbmRpY2VzW2pdXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgem4gPSB4VGFibGVbekluZGljZXNbaiArIGldXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG51bWVyYXRvcjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoem4gLSB6aiA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gekluZGljZXNbal0gKiB5U3RyaWRlICsgeVN0cmlkZSAqIGkgKyBzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBudW1lcmF0b3IgPSB5VGFibGVbaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2VmZmljaWVudHNbc11baV0ucHVzaChudW1lcmF0b3IgLyBmYWN0b3JpYWwoaSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bWVyYXRvciA9IChjb2VmZmljaWVudHNbc11baSAtIDFdW2ogKyAxXSAtIGNvZWZmaWNpZW50c1tzXVtpIC0gMV1bal0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2VmZmljaWVudHNbc11baV0ucHVzaChudW1lcmF0b3IgLyAoem4gLSB6aikpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBub25aZXJvQ29lZmZpY2llbnRzID0gbm9uWmVyb0NvZWZmaWNpZW50cyB8fCAobnVtZXJhdG9yICE9PSAwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIW5vblplcm9Db2VmZmljaWVudHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBoaWdoZXN0Tm9uWmVyb0NvZWYgPSBpIC0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yIChkID0gMCwgbGVuID0gMDsgZCA8PSBsZW47IGQrKykge1xyXG4gICAgICAgICAgICBmb3IgKGkgPSBkOyBpIDw9IGhpZ2hlc3ROb25aZXJvQ29lZjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGVtcFRlcm0gPSBjYWxjdWxhdGVDb2VmZmljaWVudFRlcm0oeCwgekluZGljZXMsIHhUYWJsZSwgZCwgaSwgW10pO1xyXG4gICAgICAgICAgICAgICAgZm9yIChzID0gMDsgcyA8IHlTdHJpZGU7IHMrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2VmZiA9IGNvZWZmaWNpZW50c1tzXVtpXVswXTtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRbcyArIGQgKiB5U3RyaWRlXSArPSBjb2VmZiAqIHRlbXBUZXJtO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgYXJyYXlTY3JhdGNoID0gW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnRlcnBvbGF0ZXMgdmFsdWVzIHVzaW5nIEhlcm1pdGUgUG9seW5vbWlhbCBBcHByb3hpbWF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSBpbmRlcGVuZGVudCB2YXJpYWJsZSBmb3Igd2hpY2ggdGhlIGRlcGVuZGVudCB2YXJpYWJsZXMgd2lsbCBiZSBpbnRlcnBvbGF0ZWQuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcltdfSB4VGFibGUgVGhlIGFycmF5IG9mIGluZGVwZW5kZW50IHZhcmlhYmxlcyB0byB1c2UgdG8gaW50ZXJwb2xhdGUuICBUaGUgdmFsdWVzXHJcbiAgICAgKiBpbiB0aGlzIGFycmF5IG11c3QgYmUgaW4gaW5jcmVhc2luZyBvcmRlciBhbmQgdGhlIHNhbWUgdmFsdWUgbXVzdCBub3Qgb2NjdXIgdHdpY2UgaW4gdGhlIGFycmF5LlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJbXX0geVRhYmxlIFRoZSBhcnJheSBvZiBkZXBlbmRlbnQgdmFyaWFibGVzIHRvIHVzZSB0byBpbnRlcnBvbGF0ZS4gIEZvciBhIHNldCBvZiB0aHJlZVxyXG4gICAgICogZGVwZW5kZW50IHZhbHVlcyAocCxxLHcpIGF0IHRpbWUgMSBhbmQgdGltZSAyIHRoaXMgc2hvdWxkIGJlIGFzIGZvbGxvd3M6IHtwMSwgcTEsIHcxLCBwMiwgcTIsIHcyfS5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5U3RyaWRlIFRoZSBudW1iZXIgb2YgZGVwZW5kZW50IHZhcmlhYmxlIHZhbHVlcyBpbiB5VGFibGUgY29ycmVzcG9uZGluZyB0b1xyXG4gICAgICogZWFjaCBpbmRlcGVuZGVudCB2YXJpYWJsZSB2YWx1ZSBpbiB4VGFibGUuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5wdXRPcmRlciBUaGUgbnVtYmVyIG9mIGRlcml2YXRpdmVzIHN1cHBsaWVkIGZvciBpbnB1dC5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvdXRwdXRPcmRlciBUaGUgbnVtYmVyIG9mIGRlcml2YXRpdmVzIGRlc2lyZWQgZm9yIG91dHB1dC5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyW119IFtyZXN1bHRdIEFuIGV4aXN0aW5nIGFycmF5IGludG8gd2hpY2ggdG8gc3RvcmUgdGhlIHJlc3VsdC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyW119IFRoZSBhcnJheSBvZiBpbnRlcnBvbGF0ZWQgdmFsdWVzLCBvciB0aGUgcmVzdWx0IHBhcmFtZXRlciBpZiBvbmUgd2FzIHByb3ZpZGVkLlxyXG4gICAgICovXHJcbiAgICBIZXJtaXRlUG9seW5vbWlhbEFwcHJveGltYXRpb24uaW50ZXJwb2xhdGUgPSBmdW5jdGlvbih4LCB4VGFibGUsIHlUYWJsZSwgeVN0cmlkZSwgaW5wdXRPcmRlciwgb3V0cHV0T3JkZXIsIHJlc3VsdCkge1xyXG4gICAgICAgIHZhciByZXN1bHRMZW5ndGggPSB5U3RyaWRlICogKG91dHB1dE9yZGVyICsgMSk7XHJcbiAgICAgICAgaWYgKCFkZWZpbmVkKHJlc3VsdCkpIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEFycmF5KHJlc3VsdExlbmd0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgcmVzdWx0TGVuZ3RoOyByKyspIHtcclxuICAgICAgICAgICAgcmVzdWx0W3JdID0gMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBsZW5ndGggPSB4VGFibGUubGVuZ3RoO1xyXG4gICAgICAgIC8vIFRoZSB6SW5kaWNlcyBhcnJheSBob2xkcyBjb3BpZXMgb2YgdGhlIGFkZHJlc3NlcyBvZiB0aGUgeFRhYmxlIHZhbHVlc1xyXG4gICAgICAgIC8vIGluIHRoZSByYW5nZSB3ZSdyZSBsb29raW5nIGF0LiBFdmVuIHRob3VnaCB0aGlzIGp1c3QgaG9sZHMgaW5mb3JtYXRpb24gYWxyZWFkeVxyXG4gICAgICAgIC8vIGF2YWlsYWJsZSBpbiB4VGFibGUgdGhpcyBpcyBhIG11Y2ggbW9yZSBjb252ZW5pZW50IGZvcm1hdC5cclxuICAgICAgICB2YXIgekluZGljZXMgPSBuZXcgQXJyYXkobGVuZ3RoICogKGlucHV0T3JkZXIgKyAxKSk7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgKGlucHV0T3JkZXIgKyAxKTsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICB6SW5kaWNlc1tpICogKGlucHV0T3JkZXIgKyAxKSArIGpdID0gaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHpJbmRpY2VzbGVuZ3RoID0gekluZGljZXMubGVuZ3RoO1xyXG4gICAgICAgIHZhciBjb2VmZmljaWVudHMgPSBhcnJheVNjcmF0Y2g7XHJcbiAgICAgICAgdmFyIGhpZ2hlc3ROb25aZXJvQ29lZiA9IGZpbGxDb2VmZmljaWVudExpc3QoY29lZmZpY2llbnRzLCB6SW5kaWNlcywgeFRhYmxlLCB5VGFibGUsIHlTdHJpZGUsIGlucHV0T3JkZXIpO1xyXG4gICAgICAgIHZhciByZXNlcnZlZEluZGljZXMgPSBbXTtcclxuXHJcbiAgICAgICAgdmFyIHRtcCA9IHpJbmRpY2VzbGVuZ3RoICogKHpJbmRpY2VzbGVuZ3RoICsgMSkgLyAyO1xyXG4gICAgICAgIHZhciBsb29wU3RvcCA9IE1hdGgubWluKGhpZ2hlc3ROb25aZXJvQ29lZiwgb3V0cHV0T3JkZXIpO1xyXG4gICAgICAgIGZvciAodmFyIGQgPSAwOyBkIDw9IGxvb3BTdG9wOyBkKyspIHtcclxuICAgICAgICAgICAgZm9yIChpID0gZDsgaSA8PSBoaWdoZXN0Tm9uWmVyb0NvZWY7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgcmVzZXJ2ZWRJbmRpY2VzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGVtcFRlcm0gPSBjYWxjdWxhdGVDb2VmZmljaWVudFRlcm0oeCwgekluZGljZXMsIHhUYWJsZSwgZCwgaSwgcmVzZXJ2ZWRJbmRpY2VzKTtcclxuICAgICAgICAgICAgICAgIHZhciBkaW1Ud28gPSBNYXRoLmZsb29yKGkgKiAoMSAtIGkpIC8gMikgKyAoekluZGljZXNsZW5ndGggKiBpKTtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBzID0gMDsgcyA8IHlTdHJpZGU7IHMrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkaW1PbmUgPSBNYXRoLmZsb29yKHMgKiB0bXApO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2VmID0gY29lZmZpY2llbnRzW2RpbU9uZSArIGRpbVR3b107XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3MgKyBkICogeVN0cmlkZV0gKz0gY29lZiAqIHRlbXBUZXJtO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBmaWxsQ29lZmZpY2llbnRMaXN0KGNvZWZmaWNpZW50cywgekluZGljZXMsIHhUYWJsZSwgeVRhYmxlLCB5U3RyaWRlLCBpbnB1dE9yZGVyKSB7XHJcbiAgICAgICAgdmFyIGo7XHJcbiAgICAgICAgdmFyIGluZGV4O1xyXG4gICAgICAgIHZhciBoaWdoZXN0Tm9uWmVybyA9IC0xO1xyXG4gICAgICAgIHZhciB6SW5kaWNlc2xlbmd0aCA9IHpJbmRpY2VzLmxlbmd0aDtcclxuICAgICAgICB2YXIgdG1wID0gekluZGljZXNsZW5ndGggKiAoekluZGljZXNsZW5ndGggKyAxKSAvIDI7XHJcblxyXG4gICAgICAgIGZvciAodmFyIHMgPSAwOyBzIDwgeVN0cmlkZTsgcysrKSB7XHJcbiAgICAgICAgICAgIHZhciBkaW1PbmUgPSBNYXRoLmZsb29yKHMgKiB0bXApO1xyXG5cclxuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IHpJbmRpY2VzbGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIGluZGV4ID0gekluZGljZXNbal0gKiB5U3RyaWRlICogKGlucHV0T3JkZXIgKyAxKSArIHM7XHJcbiAgICAgICAgICAgICAgICBjb2VmZmljaWVudHNbZGltT25lICsgal0gPSB5VGFibGVbaW5kZXhdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHpJbmRpY2VzbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBjb2VmSW5kZXggPSAwO1xyXG4gICAgICAgICAgICAgICAgdmFyIGRpbVR3byA9IE1hdGguZmxvb3IoaSAqICgxIC0gaSkgLyAyKSArICh6SW5kaWNlc2xlbmd0aCAqIGkpO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5vblplcm9Db2VmZmljaWVudHMgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgekluZGljZXNsZW5ndGggLSBpOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgemogPSB4VGFibGVbekluZGljZXNbal1dO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB6biA9IHhUYWJsZVt6SW5kaWNlc1tqICsgaV1dO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgbnVtZXJhdG9yO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2VmZmljaWVudDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoem4gLSB6aiA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gekluZGljZXNbal0gKiB5U3RyaWRlICogKGlucHV0T3JkZXIgKyAxKSArIHlTdHJpZGUgKiBpICsgcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgbnVtZXJhdG9yID0geVRhYmxlW2luZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29lZmZpY2llbnQgPSAobnVtZXJhdG9yIC8gQ2VzaXVtTWF0aC5mYWN0b3JpYWwoaSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2VmZmljaWVudHNbZGltT25lICsgZGltVHdvICsgY29lZkluZGV4XSA9IGNvZWZmaWNpZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2VmSW5kZXgrKztcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGltVHdvTWludXNPbmUgPSBNYXRoLmZsb29yKChpIC0gMSkgKiAoMiAtIGkpIC8gMikgKyAoekluZGljZXNsZW5ndGggKiAoaSAtIDEpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbnVtZXJhdG9yID0gY29lZmZpY2llbnRzW2RpbU9uZSArIGRpbVR3b01pbnVzT25lICsgaiArIDFdIC0gY29lZmZpY2llbnRzW2RpbU9uZSArIGRpbVR3b01pbnVzT25lICsgal07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZWZmaWNpZW50ID0gKG51bWVyYXRvciAvICh6biAtIHpqKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZWZmaWNpZW50c1tkaW1PbmUgKyBkaW1Ud28gKyBjb2VmSW5kZXhdID0gY29lZmZpY2llbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZWZJbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBub25aZXJvQ29lZmZpY2llbnRzID0gbm9uWmVyb0NvZWZmaWNpZW50cyB8fCAobnVtZXJhdG9yICE9PSAwLjApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChub25aZXJvQ29lZmZpY2llbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGlnaGVzdE5vblplcm8gPSBNYXRoLm1heChoaWdoZXN0Tm9uWmVybywgaSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBoaWdoZXN0Tm9uWmVybztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gSGVybWl0ZVBvbHlub21pYWxBcHByb3hpbWF0aW9uO1xyXG59KTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvdGVycmlhanMtY2VzaXVtL1NvdXJjZS9Db3JlL0hlcm1pdGVQb2x5bm9taWFsQXBwcm94aW1hdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gMTIwMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJkZWZpbmUoW1xyXG4gICAgICAgICcuL2RlZmluZWQnXHJcbiAgICBdLCBmdW5jdGlvbihcclxuICAgICAgICBkZWZpbmVkKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbiB7QGxpbmsgSW50ZXJwb2xhdGlvbkFsZ29yaXRobX0gZm9yIHBlcmZvcm1pbmcgTGFncmFuZ2UgaW50ZXJwb2xhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAZXhwb3J0cyBMYWdyYW5nZVBvbHlub21pYWxBcHByb3hpbWF0aW9uXHJcbiAgICAgKi9cclxuICAgIHZhciBMYWdyYW5nZVBvbHlub21pYWxBcHByb3hpbWF0aW9uID0ge1xyXG4gICAgICAgIHR5cGUgOiAnTGFncmFuZ2UnXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2l2ZW4gdGhlIGRlc2lyZWQgZGVncmVlLCByZXR1cm5zIHRoZSBudW1iZXIgb2YgZGF0YSBwb2ludHMgcmVxdWlyZWQgZm9yIGludGVycG9sYXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRlZ3JlZSBUaGUgZGVzaXJlZCBkZWdyZWUgb2YgaW50ZXJwb2xhdGlvbi5cclxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1iZXIgb2YgcmVxdWlyZWQgZGF0YSBwb2ludHMgbmVlZGVkIGZvciB0aGUgZGVzaXJlZCBkZWdyZWUgb2YgaW50ZXJwb2xhdGlvbi5cclxuICAgICAqL1xyXG4gICAgTGFncmFuZ2VQb2x5bm9taWFsQXBwcm94aW1hdGlvbi5nZXRSZXF1aXJlZERhdGFQb2ludHMgPSBmdW5jdGlvbihkZWdyZWUpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5tYXgoZGVncmVlICsgMS4wLCAyKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnRlcnBvbGF0ZXMgdmFsdWVzIHVzaW5nIExhZ3JhbmdlIFBvbHlub21pYWwgQXBwcm94aW1hdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgaW5kZXBlbmRlbnQgdmFyaWFibGUgZm9yIHdoaWNoIHRoZSBkZXBlbmRlbnQgdmFyaWFibGVzIHdpbGwgYmUgaW50ZXJwb2xhdGVkLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJbXX0geFRhYmxlIFRoZSBhcnJheSBvZiBpbmRlcGVuZGVudCB2YXJpYWJsZXMgdG8gdXNlIHRvIGludGVycG9sYXRlLiAgVGhlIHZhbHVlc1xyXG4gICAgICogaW4gdGhpcyBhcnJheSBtdXN0IGJlIGluIGluY3JlYXNpbmcgb3JkZXIgYW5kIHRoZSBzYW1lIHZhbHVlIG11c3Qgbm90IG9jY3VyIHR3aWNlIGluIHRoZSBhcnJheS5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyW119IHlUYWJsZSBUaGUgYXJyYXkgb2YgZGVwZW5kZW50IHZhcmlhYmxlcyB0byB1c2UgdG8gaW50ZXJwb2xhdGUuICBGb3IgYSBzZXQgb2YgdGhyZWVcclxuICAgICAqIGRlcGVuZGVudCB2YWx1ZXMgKHAscSx3KSBhdCB0aW1lIDEgYW5kIHRpbWUgMiB0aGlzIHNob3VsZCBiZSBhcyBmb2xsb3dzOiB7cDEsIHExLCB3MSwgcDIsIHEyLCB3Mn0uXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVN0cmlkZSBUaGUgbnVtYmVyIG9mIGRlcGVuZGVudCB2YXJpYWJsZSB2YWx1ZXMgaW4geVRhYmxlIGNvcnJlc3BvbmRpbmcgdG9cclxuICAgICAqIGVhY2ggaW5kZXBlbmRlbnQgdmFyaWFibGUgdmFsdWUgaW4geFRhYmxlLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJbXX0gW3Jlc3VsdF0gQW4gZXhpc3RpbmcgYXJyYXkgaW50byB3aGljaCB0byBzdG9yZSB0aGUgcmVzdWx0LlxyXG4gICAgICogQHJldHVybnMge051bWJlcltdfSBUaGUgYXJyYXkgb2YgaW50ZXJwb2xhdGVkIHZhbHVlcywgb3IgdGhlIHJlc3VsdCBwYXJhbWV0ZXIgaWYgb25lIHdhcyBwcm92aWRlZC5cclxuICAgICAqL1xyXG4gICAgTGFncmFuZ2VQb2x5bm9taWFsQXBwcm94aW1hdGlvbi5pbnRlcnBvbGF0ZU9yZGVyWmVybyA9IGZ1bmN0aW9uKHgsIHhUYWJsZSwgeVRhYmxlLCB5U3RyaWRlLCByZXN1bHQpIHtcclxuICAgICAgICBpZiAoIWRlZmluZWQocmVzdWx0KSkge1xyXG4gICAgICAgICAgICByZXN1bHQgPSBuZXcgQXJyYXkoeVN0cmlkZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgajtcclxuICAgICAgICB2YXIgbGVuZ3RoID0geFRhYmxlLmxlbmd0aDtcclxuXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHlTdHJpZGU7IGkrKykge1xyXG4gICAgICAgICAgICByZXN1bHRbaV0gPSAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBjb2VmZmljaWVudCA9IDE7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChqICE9PSBpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpZmZYID0geFRhYmxlW2ldIC0geFRhYmxlW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvZWZmaWNpZW50ICo9ICh4IC0geFRhYmxlW2pdKSAvIGRpZmZYO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgeVN0cmlkZTsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRbal0gKz0gY29lZmZpY2llbnQgKiB5VGFibGVbaSAqIHlTdHJpZGUgKyBqXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIExhZ3JhbmdlUG9seW5vbWlhbEFwcHJveGltYXRpb247XHJcbn0pO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy90ZXJyaWFqcy1jZXNpdW0vU291cmNlL0NvcmUvTGFncmFuZ2VQb2x5bm9taWFsQXBwcm94aW1hdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gMTIwMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJkZWZpbmUoW1xyXG4gICAgICAgICcuL0NoZWNrJyxcclxuICAgICAgICAnLi9kZWZhdWx0VmFsdWUnLFxyXG4gICAgICAgICcuL2RlZmluZWQnXHJcbiAgICBdLCBmdW5jdGlvbihcclxuICAgICAgICBDaGVjayxcclxuICAgICAgICBkZWZhdWx0VmFsdWUsXHJcbiAgICAgICAgZGVmaW5lZCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBzZXQgb2YgY3VydmlsaW5lYXIgMy1kaW1lbnNpb25hbCBjb29yZGluYXRlcy5cclxuICAgICAqXHJcbiAgICAgKiBAYWxpYXMgU3BoZXJpY2FsXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2Nsb2NrPTAuMF0gVGhlIGFuZ3VsYXIgY29vcmRpbmF0ZSBseWluZyBpbiB0aGUgeHktcGxhbmUgbWVhc3VyZWQgZnJvbSB0aGUgcG9zaXRpdmUgeC1heGlzIGFuZCB0b3dhcmQgdGhlIHBvc2l0aXZlIHktYXhpcy5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZT0wLjBdIFRoZSBhbmd1bGFyIGNvb3JkaW5hdGUgbWVhc3VyZWQgZnJvbSB0aGUgcG9zaXRpdmUgei1heGlzIGFuZCB0b3dhcmQgdGhlIG5lZ2F0aXZlIHotYXhpcy5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbbWFnbml0dWRlPTEuMF0gVGhlIGxpbmVhciBjb29yZGluYXRlIG1lYXN1cmVkIGZyb20gdGhlIG9yaWdpbi5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gU3BoZXJpY2FsKGNsb2NrLCBjb25lLCBtYWduaXR1ZGUpIHtcclxuICAgICAgICB0aGlzLmNsb2NrID0gZGVmYXVsdFZhbHVlKGNsb2NrLCAwLjApO1xyXG4gICAgICAgIHRoaXMuY29uZSA9IGRlZmF1bHRWYWx1ZShjb25lLCAwLjApO1xyXG4gICAgICAgIHRoaXMubWFnbml0dWRlID0gZGVmYXVsdFZhbHVlKG1hZ25pdHVkZSwgMS4wKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIHRoZSBwcm92aWRlZCBDYXJ0ZXNpYW4zIGludG8gU3BoZXJpY2FsIGNvb3JkaW5hdGVzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Q2FydGVzaWFuM30gY2FydGVzaWFuMyBUaGUgQ2FydGVzaWFuMyB0byBiZSBjb252ZXJ0ZWQgdG8gU3BoZXJpY2FsLlxyXG4gICAgICogQHBhcmFtIHtTcGhlcmljYWx9IFtyZXN1bHRdIFRoZSBvYmplY3QgaW4gd2hpY2ggdGhlIHJlc3VsdCB3aWxsIGJlIHN0b3JlZCwgaWYgdW5kZWZpbmVkIGEgbmV3IGluc3RhbmNlIHdpbGwgYmUgY3JlYXRlZC5cclxuICAgICAqIEByZXR1cm5zIHtTcGhlcmljYWx9IFRoZSBtb2RpZmllZCByZXN1bHQgcGFyYW1ldGVyLCBvciBhIG5ldyBpbnN0YW5jZSBpZiBvbmUgd2FzIG5vdCBwcm92aWRlZC5cclxuICAgICAqL1xyXG4gICAgU3BoZXJpY2FsLmZyb21DYXJ0ZXNpYW4zID0gZnVuY3Rpb24oY2FydGVzaWFuMywgcmVzdWx0KSB7XHJcbiAgICAgICAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcclxuICAgICAgICBDaGVjay50eXBlT2Yub2JqZWN0KCdjYXJ0ZXNpYW4zJywgY2FydGVzaWFuMyk7XHJcbiAgICAgICAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XHJcblxyXG4gICAgICAgIHZhciB4ID0gY2FydGVzaWFuMy54O1xyXG4gICAgICAgIHZhciB5ID0gY2FydGVzaWFuMy55O1xyXG4gICAgICAgIHZhciB6ID0gY2FydGVzaWFuMy56O1xyXG4gICAgICAgIHZhciByYWRpYWxTcXVhcmVkID0geCAqIHggKyB5ICogeTtcclxuXHJcbiAgICAgICAgaWYgKCFkZWZpbmVkKHJlc3VsdCkpIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gbmV3IFNwaGVyaWNhbCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmVzdWx0LmNsb2NrID0gTWF0aC5hdGFuMih5LCB4KTtcclxuICAgICAgICByZXN1bHQuY29uZSA9IE1hdGguYXRhbjIoTWF0aC5zcXJ0KHJhZGlhbFNxdWFyZWQpLCB6KTtcclxuICAgICAgICByZXN1bHQubWFnbml0dWRlID0gTWF0aC5zcXJ0KHJhZGlhbFNxdWFyZWQgKyB6ICogeik7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgZHVwbGljYXRlIG9mIGEgU3BoZXJpY2FsLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7U3BoZXJpY2FsfSBzcGhlcmljYWwgVGhlIHNwaGVyaWNhbCB0byBjbG9uZS5cclxuICAgICAqIEBwYXJhbSB7U3BoZXJpY2FsfSBbcmVzdWx0XSBUaGUgb2JqZWN0IHRvIHN0b3JlIHRoZSByZXN1bHQgaW50bywgaWYgdW5kZWZpbmVkIGEgbmV3IGluc3RhbmNlIHdpbGwgYmUgY3JlYXRlZC5cclxuICAgICAqIEByZXR1cm5zIHtTcGhlcmljYWx9IFRoZSBtb2RpZmllZCByZXN1bHQgcGFyYW1ldGVyIG9yIGEgbmV3IGluc3RhbmNlIGlmIHJlc3VsdCB3YXMgdW5kZWZpbmVkLiAoUmV0dXJucyB1bmRlZmluZWQgaWYgc3BoZXJpY2FsIGlzIHVuZGVmaW5lZClcclxuICAgICAqL1xyXG4gICAgU3BoZXJpY2FsLmNsb25lID0gZnVuY3Rpb24oc3BoZXJpY2FsLCByZXN1bHQpIHtcclxuICAgICAgICBpZiAoIWRlZmluZWQoc3BoZXJpY2FsKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFkZWZpbmVkKHJlc3VsdCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTcGhlcmljYWwoc3BoZXJpY2FsLmNsb2NrLCBzcGhlcmljYWwuY29uZSwgc3BoZXJpY2FsLm1hZ25pdHVkZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXN1bHQuY2xvY2sgPSBzcGhlcmljYWwuY2xvY2s7XHJcbiAgICAgICAgcmVzdWx0LmNvbmUgPSBzcGhlcmljYWwuY29uZTtcclxuICAgICAgICByZXN1bHQubWFnbml0dWRlID0gc3BoZXJpY2FsLm1hZ25pdHVkZTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbXB1dGVzIHRoZSBub3JtYWxpemVkIHZlcnNpb24gb2YgdGhlIHByb3ZpZGVkIHNwaGVyaWNhbC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1NwaGVyaWNhbH0gc3BoZXJpY2FsIFRoZSBzcGhlcmljYWwgdG8gYmUgbm9ybWFsaXplZC5cclxuICAgICAqIEBwYXJhbSB7U3BoZXJpY2FsfSBbcmVzdWx0XSBUaGUgb2JqZWN0IHRvIHN0b3JlIHRoZSByZXN1bHQgaW50bywgaWYgdW5kZWZpbmVkIGEgbmV3IGluc3RhbmNlIHdpbGwgYmUgY3JlYXRlZC5cclxuICAgICAqIEByZXR1cm5zIHtTcGhlcmljYWx9IFRoZSBtb2RpZmllZCByZXN1bHQgcGFyYW1ldGVyIG9yIGEgbmV3IGluc3RhbmNlIGlmIHJlc3VsdCB3YXMgdW5kZWZpbmVkLlxyXG4gICAgICovXHJcbiAgICBTcGhlcmljYWwubm9ybWFsaXplID0gZnVuY3Rpb24oc3BoZXJpY2FsLCByZXN1bHQpIHtcclxuICAgICAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcclxuICAgICAgICBDaGVjay50eXBlT2Yub2JqZWN0KCdzcGhlcmljYWwnLCBzcGhlcmljYWwpO1xyXG4gICAgICAgIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xyXG5cclxuICAgICAgICBpZiAoIWRlZmluZWQocmVzdWx0KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFNwaGVyaWNhbChzcGhlcmljYWwuY2xvY2ssIHNwaGVyaWNhbC5jb25lLCAxLjApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmVzdWx0LmNsb2NrID0gc3BoZXJpY2FsLmNsb2NrO1xyXG4gICAgICAgIHJlc3VsdC5jb25lID0gc3BoZXJpY2FsLmNvbmU7XHJcbiAgICAgICAgcmVzdWx0Lm1hZ25pdHVkZSA9IDEuMDtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZmlyc3Qgc3BoZXJpY2FsIGlzIGVxdWFsIHRvIHRoZSBzZWNvbmQgc3BoZXJpY2FsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtTcGhlcmljYWx9IGxlZnQgVGhlIGZpcnN0IFNwaGVyaWNhbCB0byBiZSBjb21wYXJlZC5cclxuICAgICAqIEBwYXJhbSB7U3BoZXJpY2FsfSByaWdodCBUaGUgc2Vjb25kIFNwaGVyaWNhbCB0byBiZSBjb21wYXJlZC5cclxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGlmIHRoZSBmaXJzdCBzcGhlcmljYWwgaXMgZXF1YWwgdG8gdGhlIHNlY29uZCBzcGhlcmljYWwsIGZhbHNlIG90aGVyd2lzZS5cclxuICAgICAqL1xyXG4gICAgU3BoZXJpY2FsLmVxdWFscyA9IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XHJcbiAgICAgICAgcmV0dXJuIChsZWZ0ID09PSByaWdodCkgfHxcclxuICAgICAgICAgICAgICAgKChkZWZpbmVkKGxlZnQpKSAmJlxyXG4gICAgICAgICAgICAgICAgKGRlZmluZWQocmlnaHQpKSAmJlxyXG4gICAgICAgICAgICAgICAgKGxlZnQuY2xvY2sgPT09IHJpZ2h0LmNsb2NrKSAmJlxyXG4gICAgICAgICAgICAgICAgKGxlZnQuY29uZSA9PT0gcmlnaHQuY29uZSkgJiZcclxuICAgICAgICAgICAgICAgIChsZWZ0Lm1hZ25pdHVkZSA9PT0gcmlnaHQubWFnbml0dWRlKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBmaXJzdCBzcGhlcmljYWwgaXMgd2l0aGluIHRoZSBwcm92aWRlZCBlcHNpbG9uIG9mIHRoZSBzZWNvbmQgc3BoZXJpY2FsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtTcGhlcmljYWx9IGxlZnQgVGhlIGZpcnN0IFNwaGVyaWNhbCB0byBiZSBjb21wYXJlZC5cclxuICAgICAqIEBwYXJhbSB7U3BoZXJpY2FsfSByaWdodCBUaGUgc2Vjb25kIFNwaGVyaWNhbCB0byBiZSBjb21wYXJlZC5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbZXBzaWxvbj0wLjBdIFRoZSBlcHNpbG9uIHRvIGNvbXBhcmUgYWdhaW5zdC5cclxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGlmIHRoZSBmaXJzdCBzcGhlcmljYWwgaXMgd2l0aGluIHRoZSBwcm92aWRlZCBlcHNpbG9uIG9mIHRoZSBzZWNvbmQgc3BoZXJpY2FsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgKi9cclxuICAgIFNwaGVyaWNhbC5lcXVhbHNFcHNpbG9uID0gZnVuY3Rpb24obGVmdCwgcmlnaHQsIGVwc2lsb24pIHtcclxuICAgICAgICBlcHNpbG9uID0gZGVmYXVsdFZhbHVlKGVwc2lsb24sIDAuMCk7XHJcbiAgICAgICAgcmV0dXJuIChsZWZ0ID09PSByaWdodCkgfHxcclxuICAgICAgICAgICAgICAgKChkZWZpbmVkKGxlZnQpKSAmJlxyXG4gICAgICAgICAgICAgICAgKGRlZmluZWQocmlnaHQpKSAmJlxyXG4gICAgICAgICAgICAgICAgKE1hdGguYWJzKGxlZnQuY2xvY2sgLSByaWdodC5jbG9jaykgPD0gZXBzaWxvbikgJiZcclxuICAgICAgICAgICAgICAgIChNYXRoLmFicyhsZWZ0LmNvbmUgLSByaWdodC5jb25lKSA8PSBlcHNpbG9uKSAmJlxyXG4gICAgICAgICAgICAgICAgKE1hdGguYWJzKGxlZnQubWFnbml0dWRlIC0gcmlnaHQubWFnbml0dWRlKSA8PSBlcHNpbG9uKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgc3BoZXJpY2FsIGlzIGVxdWFsIHRvIHRoZSBwcm92aWRlZCBzcGhlcmljYWwsIGZhbHNlIG90aGVyd2lzZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1NwaGVyaWNhbH0gb3RoZXIgVGhlIFNwaGVyaWNhbCB0byBiZSBjb21wYXJlZC5cclxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGlmIHRoaXMgc3BoZXJpY2FsIGlzIGVxdWFsIHRvIHRoZSBwcm92aWRlZCBzcGhlcmljYWwsIGZhbHNlIG90aGVyd2lzZS5cclxuICAgICAqL1xyXG4gICAgU3BoZXJpY2FsLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbihvdGhlcikge1xyXG4gICAgICAgIHJldHVybiBTcGhlcmljYWwuZXF1YWxzKHRoaXMsIG90aGVyKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgZHVwbGljYXRlIG9mIHRoaXMgU3BoZXJpY2FsLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7U3BoZXJpY2FsfSBbcmVzdWx0XSBUaGUgb2JqZWN0IHRvIHN0b3JlIHRoZSByZXN1bHQgaW50bywgaWYgdW5kZWZpbmVkIGEgbmV3IGluc3RhbmNlIHdpbGwgYmUgY3JlYXRlZC5cclxuICAgICAqIEByZXR1cm5zIHtTcGhlcmljYWx9IFRoZSBtb2RpZmllZCByZXN1bHQgcGFyYW1ldGVyIG9yIGEgbmV3IGluc3RhbmNlIGlmIHJlc3VsdCB3YXMgdW5kZWZpbmVkLlxyXG4gICAgICovXHJcbiAgICBTcGhlcmljYWwucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24ocmVzdWx0KSB7XHJcbiAgICAgICAgcmV0dXJuIFNwaGVyaWNhbC5jbG9uZSh0aGlzLCByZXN1bHQpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgc3BoZXJpY2FsIGlzIHdpdGhpbiB0aGUgcHJvdmlkZWQgZXBzaWxvbiBvZiB0aGUgcHJvdmlkZWQgc3BoZXJpY2FsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAqXHJcbiAgICAqIEBwYXJhbSB7U3BoZXJpY2FsfSBvdGhlciBUaGUgU3BoZXJpY2FsIHRvIGJlIGNvbXBhcmVkLlxyXG4gICAgKiBAcGFyYW0ge051bWJlcn0gZXBzaWxvbiBUaGUgZXBzaWxvbiB0byBjb21wYXJlIGFnYWluc3QuXHJcbiAgICAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGlmIHRoaXMgc3BoZXJpY2FsIGlzIHdpdGhpbiB0aGUgcHJvdmlkZWQgZXBzaWxvbiBvZiB0aGUgcHJvdmlkZWQgc3BoZXJpY2FsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAqL1xyXG4gICAgU3BoZXJpY2FsLnByb3RvdHlwZS5lcXVhbHNFcHNpbG9uID0gZnVuY3Rpb24ob3RoZXIsIGVwc2lsb24pIHtcclxuICAgICAgICByZXR1cm4gU3BoZXJpY2FsLmVxdWFsc0Vwc2lsb24odGhpcywgb3RoZXIsIGVwc2lsb24pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhpcyBpbnN0YW5jZSBpbiB0aGUgZm9ybWF0IChjbG9jaywgY29uZSwgbWFnbml0dWRlKS5cclxuICAgICpcclxuICAgICogQHJldHVybnMge1N0cmluZ30gQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoaXMgaW5zdGFuY2UuXHJcbiAgICAqL1xyXG4gICAgU3BoZXJpY2FsLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiAnKCcgKyB0aGlzLmNsb2NrICsgJywgJyArIHRoaXMuY29uZSArICcsICcgKyB0aGlzLm1hZ25pdHVkZSArICcpJztcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIFNwaGVyaWNhbDtcclxufSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3RlcnJpYWpzLWNlc2l1bS9Tb3VyY2UvQ29yZS9TcGhlcmljYWwuanNcbi8vIG1vZHVsZSBpZCA9IDEyMDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZGVmaW5lKFtcclxuICAgICAgICAnLi4vQ29yZS9kZWZpbmVkJyxcclxuICAgICAgICAnLi4vQ29yZS9kZWZpbmVQcm9wZXJ0aWVzJyxcclxuICAgICAgICAnLi4vQ29yZS9EZXZlbG9wZXJFcnJvcicsXHJcbiAgICAgICAgJy4uL0NvcmUvRXZlbnQnLFxyXG4gICAgICAgICcuL0NvbXBvc2l0ZVByb3BlcnR5JyxcclxuICAgICAgICAnLi9Qcm9wZXJ0eSdcclxuICAgIF0sIGZ1bmN0aW9uKFxyXG4gICAgICAgIGRlZmluZWQsXHJcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyxcclxuICAgICAgICBEZXZlbG9wZXJFcnJvcixcclxuICAgICAgICBFdmVudCxcclxuICAgICAgICBDb21wb3NpdGVQcm9wZXJ0eSxcclxuICAgICAgICBQcm9wZXJ0eSkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSB7QGxpbmsgQ29tcG9zaXRlUHJvcGVydHl9IHdoaWNoIGlzIGFsc28gYSB7QGxpbmsgTWF0ZXJpYWxQcm9wZXJ0eX0uXHJcbiAgICAgKlxyXG4gICAgICogQGFsaWFzIENvbXBvc2l0ZU1hdGVyaWFsUHJvcGVydHlcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBDb21wb3NpdGVNYXRlcmlhbFByb3BlcnR5KCkge1xyXG4gICAgICAgIHRoaXMuX2RlZmluaXRpb25DaGFuZ2VkID0gbmV3IEV2ZW50KCk7XHJcbiAgICAgICAgdGhpcy5fY29tcG9zaXRlID0gbmV3IENvbXBvc2l0ZVByb3BlcnR5KCk7XHJcbiAgICAgICAgdGhpcy5fY29tcG9zaXRlLmRlZmluaXRpb25DaGFuZ2VkLmFkZEV2ZW50TGlzdGVuZXIoQ29tcG9zaXRlTWF0ZXJpYWxQcm9wZXJ0eS5wcm90b3R5cGUuX3JhaXNlRGVmaW5pdGlvbkNoYW5nZWQsIHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIGRlZmluZVByb3BlcnRpZXMoQ29tcG9zaXRlTWF0ZXJpYWxQcm9wZXJ0eS5wcm90b3R5cGUsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIGEgdmFsdWUgaW5kaWNhdGluZyBpZiB0aGlzIHByb3BlcnR5IGlzIGNvbnN0YW50LiAgQSBwcm9wZXJ0eSBpcyBjb25zaWRlcmVkXHJcbiAgICAgICAgICogY29uc3RhbnQgaWYgZ2V0VmFsdWUgYWx3YXlzIHJldHVybnMgdGhlIHNhbWUgcmVzdWx0IGZvciB0aGUgY3VycmVudCBkZWZpbml0aW9uLlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBDb21wb3NpdGVNYXRlcmlhbFByb3BlcnR5LnByb3RvdHlwZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaXNDb25zdGFudCA6IHtcclxuICAgICAgICAgICAgZ2V0IDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY29tcG9zaXRlLmlzQ29uc3RhbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIGV2ZW50IHRoYXQgaXMgcmFpc2VkIHdoZW5ldmVyIHRoZSBkZWZpbml0aW9uIG9mIHRoaXMgcHJvcGVydHkgY2hhbmdlcy5cclxuICAgICAgICAgKiBUaGUgZGVmaW5pdGlvbiBpcyBjaGFuZ2VkIHdoZW5ldmVyIHNldFZhbHVlIGlzIGNhbGxlZCB3aXRoIGRhdGEgZGlmZmVyZW50XHJcbiAgICAgICAgICogdGhhbiB0aGUgY3VycmVudCB2YWx1ZS5cclxuICAgICAgICAgKiBAbWVtYmVyb2YgQ29tcG9zaXRlTWF0ZXJpYWxQcm9wZXJ0eS5wcm90b3R5cGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEB0eXBlIHtFdmVudH1cclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKi9cclxuICAgICAgICBkZWZpbml0aW9uQ2hhbmdlZCA6IHtcclxuICAgICAgICAgICAgZ2V0IDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmaW5pdGlvbkNoYW5nZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIGludGVydmFsIGNvbGxlY3Rpb24uXHJcbiAgICAgICAgICogQG1lbWJlcm9mIENvbXBvc2l0ZU1hdGVyaWFsUHJvcGVydHkucHJvdG90eXBlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAdHlwZSB7VGltZUludGVydmFsQ29sbGVjdGlvbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBpbnRlcnZhbHMgOiB7XHJcbiAgICAgICAgICAgIGdldCA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbXBvc2l0ZS5faW50ZXJ2YWxzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSB7QGxpbmsgTWF0ZXJpYWx9IHR5cGUgYXQgdGhlIHByb3ZpZGVkIHRpbWUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtKdWxpYW5EYXRlfSB0aW1lIFRoZSB0aW1lIGZvciB3aGljaCB0byByZXRyaWV2ZSB0aGUgdHlwZS5cclxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSB0eXBlIG9mIG1hdGVyaWFsLlxyXG4gICAgICovXHJcbiAgICBDb21wb3NpdGVNYXRlcmlhbFByb3BlcnR5LnByb3RvdHlwZS5nZXRUeXBlID0gZnVuY3Rpb24odGltZSkge1xyXG4gICAgICAgIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XHJcbiAgICAgICAgaWYgKCFkZWZpbmVkKHRpbWUpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcigndGltZSBpcyByZXF1aXJlZCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcclxuXHJcbiAgICAgICAgdmFyIGlubmVyUHJvcGVydHkgPSB0aGlzLl9jb21wb3NpdGUuX2ludGVydmFscy5maW5kRGF0YUZvckludGVydmFsQ29udGFpbmluZ0RhdGUodGltZSk7XHJcbiAgICAgICAgaWYgKGRlZmluZWQoaW5uZXJQcm9wZXJ0eSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlubmVyUHJvcGVydHkuZ2V0VHlwZSh0aW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgYXQgdGhlIHByb3ZpZGVkIHRpbWUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtKdWxpYW5EYXRlfSB0aW1lIFRoZSB0aW1lIGZvciB3aGljaCB0byByZXRyaWV2ZSB0aGUgdmFsdWUuXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3Jlc3VsdF0gVGhlIG9iamVjdCB0byBzdG9yZSB0aGUgdmFsdWUgaW50bywgaWYgb21pdHRlZCwgYSBuZXcgaW5zdGFuY2UgaXMgY3JlYXRlZCBhbmQgcmV0dXJuZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgbW9kaWZpZWQgcmVzdWx0IHBhcmFtZXRlciBvciBhIG5ldyBpbnN0YW5jZSBpZiB0aGUgcmVzdWx0IHBhcmFtZXRlciB3YXMgbm90IHN1cHBsaWVkLlxyXG4gICAgICovXHJcbiAgICBDb21wb3NpdGVNYXRlcmlhbFByb3BlcnR5LnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uKHRpbWUsIHJlc3VsdCkge1xyXG4gICAgICAgIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XHJcbiAgICAgICAgaWYgKCFkZWZpbmVkKHRpbWUpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcigndGltZSBpcyByZXF1aXJlZCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcclxuXHJcbiAgICAgICAgdmFyIGlubmVyUHJvcGVydHkgPSB0aGlzLl9jb21wb3NpdGUuX2ludGVydmFscy5maW5kRGF0YUZvckludGVydmFsQ29udGFpbmluZ0RhdGUodGltZSk7XHJcbiAgICAgICAgaWYgKGRlZmluZWQoaW5uZXJQcm9wZXJ0eSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlubmVyUHJvcGVydHkuZ2V0VmFsdWUodGltZSwgcmVzdWx0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wYXJlcyB0aGlzIHByb3BlcnR5IHRvIHRoZSBwcm92aWRlZCBwcm9wZXJ0eSBhbmQgcmV0dXJuc1xyXG4gICAgICogPGNvZGU+dHJ1ZTwvY29kZT4gaWYgdGhleSBhcmUgZXF1YWwsIDxjb2RlPmZhbHNlPC9jb2RlPiBvdGhlcndpc2UuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtQcm9wZXJ0eX0gW290aGVyXSBUaGUgb3RoZXIgcHJvcGVydHkuXHJcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgbGVmdCBhbmQgcmlnaHQgYXJlIGVxdWFsLCA8Y29kZT5mYWxzZTwvY29kZT4gb3RoZXJ3aXNlLlxyXG4gICAgICovXHJcbiAgICBDb21wb3NpdGVNYXRlcmlhbFByb3BlcnR5LnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbihvdGhlcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzID09PSBvdGhlciB8fCAvL1xyXG4gICAgICAgICAgICAgICAob3RoZXIgaW5zdGFuY2VvZiBDb21wb3NpdGVNYXRlcmlhbFByb3BlcnR5ICYmIC8vXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jb21wb3NpdGUuZXF1YWxzKG90aGVyLl9jb21wb3NpdGUsIFByb3BlcnR5LmVxdWFscykpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIENvbXBvc2l0ZU1hdGVyaWFsUHJvcGVydHkucHJvdG90eXBlLl9yYWlzZURlZmluaXRpb25DaGFuZ2VkID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5fZGVmaW5pdGlvbkNoYW5nZWQucmFpc2VFdmVudCh0aGlzKTtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIENvbXBvc2l0ZU1hdGVyaWFsUHJvcGVydHk7XHJcbn0pO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy90ZXJyaWFqcy1jZXNpdW0vU291cmNlL0RhdGFTb3VyY2VzL0NvbXBvc2l0ZU1hdGVyaWFsUHJvcGVydHkuanNcbi8vIG1vZHVsZSBpZCA9IDEyMDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZGVmaW5lKFtcclxuICAgICAgICAnLi4vQ29yZS9DYXJ0ZXNpYW4yJyxcclxuICAgICAgICAnLi4vQ29yZS9Db2xvcicsXHJcbiAgICAgICAgJy4uL0NvcmUvZGVmYXVsdFZhbHVlJyxcclxuICAgICAgICAnLi4vQ29yZS9kZWZpbmVkJyxcclxuICAgICAgICAnLi4vQ29yZS9kZWZpbmVQcm9wZXJ0aWVzJyxcclxuICAgICAgICAnLi4vQ29yZS9FdmVudCcsXHJcbiAgICAgICAgJy4vY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJyxcclxuICAgICAgICAnLi9Qcm9wZXJ0eSdcclxuICAgIF0sIGZ1bmN0aW9uKFxyXG4gICAgICAgIENhcnRlc2lhbjIsXHJcbiAgICAgICAgQ29sb3IsXHJcbiAgICAgICAgZGVmYXVsdFZhbHVlLFxyXG4gICAgICAgIGRlZmluZWQsXHJcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyxcclxuICAgICAgICBFdmVudCxcclxuICAgICAgICBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IsXHJcbiAgICAgICAgUHJvcGVydHkpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgICB2YXIgZGVmYXVsdENvbG9yID0gQ29sb3IuV0hJVEU7XHJcbiAgICB2YXIgZGVmYXVsdENlbGxBbHBoYSA9IDAuMTtcclxuICAgIHZhciBkZWZhdWx0TGluZUNvdW50ID0gbmV3IENhcnRlc2lhbjIoOCwgOCk7XHJcbiAgICB2YXIgZGVmYXVsdExpbmVPZmZzZXQgPSBuZXcgQ2FydGVzaWFuMigwLCAwKTtcclxuICAgIHZhciBkZWZhdWx0TGluZVRoaWNrbmVzcyA9IG5ldyBDYXJ0ZXNpYW4yKDEsIDEpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSB7QGxpbmsgTWF0ZXJpYWxQcm9wZXJ0eX0gdGhhdCBtYXBzIHRvIGdyaWQge0BsaW5rIE1hdGVyaWFsfSB1bmlmb3Jtcy5cclxuICAgICAqIEBhbGlhcyBHcmlkTWF0ZXJpYWxQcm9wZXJ0eVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxyXG4gICAgICogQHBhcmFtIHtQcm9wZXJ0eX0gW29wdGlvbnMuY29sb3I9Q29sb3IuV0hJVEVdIEEgUHJvcGVydHkgc3BlY2lmeWluZyB0aGUgZ3JpZCB7QGxpbmsgQ29sb3J9LlxyXG4gICAgICogQHBhcmFtIHtQcm9wZXJ0eX0gW29wdGlvbnMuY2VsbEFscGhhPTAuMV0gQSBudW1lcmljIFByb3BlcnR5IHNwZWNpZnlpbmcgY2VsbCBhbHBoYSB2YWx1ZXMuXHJcbiAgICAgKiBAcGFyYW0ge1Byb3BlcnR5fSBbb3B0aW9ucy5saW5lQ291bnQ9bmV3IENhcnRlc2lhbjIoOCwgOCldIEEge0BsaW5rIENhcnRlc2lhbjJ9IFByb3BlcnR5IHNwZWNpZnlpbmcgdGhlIG51bWJlciBvZiBncmlkIGxpbmVzIGFsb25nIGVhY2ggYXhpcy5cclxuICAgICAqIEBwYXJhbSB7UHJvcGVydHl9IFtvcHRpb25zLmxpbmVUaGlja25lc3M9bmV3IENhcnRlc2lhbjIoMS4wLCAxLjApXSBBIHtAbGluayBDYXJ0ZXNpYW4yfSBQcm9wZXJ0eSBzcGVjaWZ5aW5nIHRoZSB0aGlja25lc3Mgb2YgZ3JpZCBsaW5lcyBhbG9uZyBlYWNoIGF4aXMuXHJcbiAgICAgKiBAcGFyYW0ge1Byb3BlcnR5fSBbb3B0aW9ucy5saW5lT2Zmc2V0PW5ldyBDYXJ0ZXNpYW4yKDAuMCwgMC4wKV0gQSB7QGxpbmsgQ2FydGVzaWFuMn0gUHJvcGVydHkgc3BlY2lmeWluZyBzdGFydGluZyBvZmZzZXQgb2YgZ3JpZCBsaW5lcyBhbG9uZyBlYWNoIGF4aXMuXHJcbiAgICAgKlxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIEdyaWRNYXRlcmlhbFByb3BlcnR5KG9wdGlvbnMpIHtcclxuICAgICAgICBvcHRpb25zID0gZGVmYXVsdFZhbHVlKG9wdGlvbnMsIGRlZmF1bHRWYWx1ZS5FTVBUWV9PQkpFQ1QpO1xyXG5cclxuICAgICAgICB0aGlzLl9kZWZpbml0aW9uQ2hhbmdlZCA9IG5ldyBFdmVudCgpO1xyXG4gICAgICAgIHRoaXMuX2NvbG9yID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuX2NvbG9yU3Vic2NyaXB0aW9uID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuX2NlbGxBbHBoYSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLl9jZWxsQWxwaGFTdWJzY3JpcHRpb24gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5fbGluZUNvdW50ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuX2xpbmVDb3VudFN1YnNjcmlwdGlvbiA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLl9saW5lVGhpY2tuZXNzID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuX2xpbmVUaGlja25lc3NTdWJzY3JpcHRpb24gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5fbGluZU9mZnNldCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLl9saW5lT2Zmc2V0U3Vic2NyaXB0aW9uID0gdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICB0aGlzLmNvbG9yID0gb3B0aW9ucy5jb2xvcjtcclxuICAgICAgICB0aGlzLmNlbGxBbHBoYSA9IG9wdGlvbnMuY2VsbEFscGhhO1xyXG4gICAgICAgIHRoaXMubGluZUNvdW50ID0gb3B0aW9ucy5saW5lQ291bnQ7XHJcbiAgICAgICAgdGhpcy5saW5lVGhpY2tuZXNzID0gb3B0aW9ucy5saW5lVGhpY2tuZXNzO1xyXG4gICAgICAgIHRoaXMubGluZU9mZnNldCA9IG9wdGlvbnMubGluZU9mZnNldDtcclxuICAgIH1cclxuXHJcbiAgICBkZWZpbmVQcm9wZXJ0aWVzKEdyaWRNYXRlcmlhbFByb3BlcnR5LnByb3RvdHlwZSwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgYSB2YWx1ZSBpbmRpY2F0aW5nIGlmIHRoaXMgcHJvcGVydHkgaXMgY29uc3RhbnQuICBBIHByb3BlcnR5IGlzIGNvbnNpZGVyZWRcclxuICAgICAgICAgKiBjb25zdGFudCBpZiBnZXRWYWx1ZSBhbHdheXMgcmV0dXJucyB0aGUgc2FtZSByZXN1bHQgZm9yIHRoZSBjdXJyZW50IGRlZmluaXRpb24uXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEdyaWRNYXRlcmlhbFByb3BlcnR5LnByb3RvdHlwZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaXNDb25zdGFudCA6IHtcclxuICAgICAgICAgICAgZ2V0IDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvcGVydHkuaXNDb25zdGFudCh0aGlzLl9jb2xvcikgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICBQcm9wZXJ0eS5pc0NvbnN0YW50KHRoaXMuX2NlbGxBbHBoYSkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICBQcm9wZXJ0eS5pc0NvbnN0YW50KHRoaXMuX2xpbmVDb3VudCkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICBQcm9wZXJ0eS5pc0NvbnN0YW50KHRoaXMuX2xpbmVUaGlja25lc3MpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgUHJvcGVydHkuaXNDb25zdGFudCh0aGlzLl9saW5lT2Zmc2V0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgZXZlbnQgdGhhdCBpcyByYWlzZWQgd2hlbmV2ZXIgdGhlIGRlZmluaXRpb24gb2YgdGhpcyBwcm9wZXJ0eSBjaGFuZ2VzLlxyXG4gICAgICAgICAqIFRoZSBkZWZpbml0aW9uIGlzIGNvbnNpZGVyZWQgdG8gaGF2ZSBjaGFuZ2VkIGlmIGEgY2FsbCB0byBnZXRWYWx1ZSB3b3VsZCByZXR1cm5cclxuICAgICAgICAgKiBhIGRpZmZlcmVudCByZXN1bHQgZm9yIHRoZSBzYW1lIHRpbWUuXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEdyaWRNYXRlcmlhbFByb3BlcnR5LnByb3RvdHlwZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHR5cGUge0V2ZW50fVxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGRlZmluaXRpb25DaGFuZ2VkIDoge1xyXG4gICAgICAgICAgICBnZXQgOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWZpbml0aW9uQ2hhbmdlZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBQcm9wZXJ0eSBzcGVjaWZ5aW5nIHRoZSBncmlkIHtAbGluayBDb2xvcn0uXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEdyaWRNYXRlcmlhbFByb3BlcnR5LnByb3RvdHlwZVxyXG4gICAgICAgICAqIEB0eXBlIHtQcm9wZXJ0eX1cclxuICAgICAgICAgKiBAZGVmYXVsdCBDb2xvci5XSElURVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNvbG9yIDogY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKCdjb2xvcicpLFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgbnVtZXJpYyBQcm9wZXJ0eSBzcGVjaWZ5aW5nIGNlbGwgYWxwaGEgdmFsdWVzLlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBHcmlkTWF0ZXJpYWxQcm9wZXJ0eS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAdHlwZSB7UHJvcGVydHl9XHJcbiAgICAgICAgICogQGRlZmF1bHQgMC4xXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2VsbEFscGhhIDogY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKCdjZWxsQWxwaGEnKSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIHtAbGluayBDYXJ0ZXNpYW4yfSBQcm9wZXJ0eSBzcGVjaWZ5aW5nIHRoZSBudW1iZXIgb2YgZ3JpZCBsaW5lcyBhbG9uZyBlYWNoIGF4aXMuXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEdyaWRNYXRlcmlhbFByb3BlcnR5LnByb3RvdHlwZVxyXG4gICAgICAgICAqIEB0eXBlIHtQcm9wZXJ0eX1cclxuICAgICAgICAgKiBAZGVmYXVsdCBuZXcgQ2FydGVzaWFuMig4LjAsIDguMClcclxuICAgICAgICAgKi9cclxuICAgICAgICBsaW5lQ291bnQgOiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoJ2xpbmVDb3VudCcpLFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUge0BsaW5rIENhcnRlc2lhbjJ9IFByb3BlcnR5IHNwZWNpZnlpbmcgdGhlIHRoaWNrbmVzcyBvZiBncmlkIGxpbmVzIGFsb25nIGVhY2ggYXhpcy5cclxuICAgICAgICAgKiBAbWVtYmVyb2YgR3JpZE1hdGVyaWFsUHJvcGVydHkucHJvdG90eXBlXHJcbiAgICAgICAgICogQHR5cGUge1Byb3BlcnR5fVxyXG4gICAgICAgICAqIEBkZWZhdWx0IG5ldyBDYXJ0ZXNpYW4yKDEuMCwgMS4wKVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGxpbmVUaGlja25lc3MgOiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoJ2xpbmVUaGlja25lc3MnKSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIHtAbGluayBDYXJ0ZXNpYW4yfSBQcm9wZXJ0eSBzcGVjaWZ5aW5nIHRoZSBzdGFydGluZyBvZmZzZXQgb2YgZ3JpZCBsaW5lcyBhbG9uZyBlYWNoIGF4aXMuXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEdyaWRNYXRlcmlhbFByb3BlcnR5LnByb3RvdHlwZVxyXG4gICAgICAgICAqIEB0eXBlIHtQcm9wZXJ0eX1cclxuICAgICAgICAgKiBAZGVmYXVsdCBuZXcgQ2FydGVzaWFuMigwLjAsIDAuMClcclxuICAgICAgICAgKi9cclxuICAgICAgICBsaW5lT2Zmc2V0IDogY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKCdsaW5lT2Zmc2V0JylcclxuICAgIH0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUge0BsaW5rIE1hdGVyaWFsfSB0eXBlIGF0IHRoZSBwcm92aWRlZCB0aW1lLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7SnVsaWFuRGF0ZX0gdGltZSBUaGUgdGltZSBmb3Igd2hpY2ggdG8gcmV0cmlldmUgdGhlIHR5cGUuXHJcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgdHlwZSBvZiBtYXRlcmlhbC5cclxuICAgICAqL1xyXG4gICAgR3JpZE1hdGVyaWFsUHJvcGVydHkucHJvdG90eXBlLmdldFR5cGUgPSBmdW5jdGlvbih0aW1lKSB7XHJcbiAgICAgICAgcmV0dXJuICdHcmlkJztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgYXQgdGhlIHByb3ZpZGVkIHRpbWUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtKdWxpYW5EYXRlfSB0aW1lIFRoZSB0aW1lIGZvciB3aGljaCB0byByZXRyaWV2ZSB0aGUgdmFsdWUuXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3Jlc3VsdF0gVGhlIG9iamVjdCB0byBzdG9yZSB0aGUgdmFsdWUgaW50bywgaWYgb21pdHRlZCwgYSBuZXcgaW5zdGFuY2UgaXMgY3JlYXRlZCBhbmQgcmV0dXJuZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgbW9kaWZpZWQgcmVzdWx0IHBhcmFtZXRlciBvciBhIG5ldyBpbnN0YW5jZSBpZiB0aGUgcmVzdWx0IHBhcmFtZXRlciB3YXMgbm90IHN1cHBsaWVkLlxyXG4gICAgICovXHJcbiAgICBHcmlkTWF0ZXJpYWxQcm9wZXJ0eS5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbih0aW1lLCByZXN1bHQpIHtcclxuICAgICAgICBpZiAoIWRlZmluZWQocmVzdWx0KSkge1xyXG4gICAgICAgICAgICByZXN1bHQgPSB7fTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzdWx0LmNvbG9yID0gUHJvcGVydHkuZ2V0VmFsdWVPckNsb25lZERlZmF1bHQodGhpcy5fY29sb3IsIHRpbWUsIGRlZmF1bHRDb2xvciwgcmVzdWx0LmNvbG9yKTtcclxuICAgICAgICByZXN1bHQuY2VsbEFscGhhID0gUHJvcGVydHkuZ2V0VmFsdWVPckRlZmF1bHQodGhpcy5fY2VsbEFscGhhLCB0aW1lLCBkZWZhdWx0Q2VsbEFscGhhKTtcclxuICAgICAgICByZXN1bHQubGluZUNvdW50ID0gUHJvcGVydHkuZ2V0VmFsdWVPckNsb25lZERlZmF1bHQodGhpcy5fbGluZUNvdW50LCB0aW1lLCBkZWZhdWx0TGluZUNvdW50LCByZXN1bHQubGluZUNvdW50KTtcclxuICAgICAgICByZXN1bHQubGluZVRoaWNrbmVzcyA9IFByb3BlcnR5LmdldFZhbHVlT3JDbG9uZWREZWZhdWx0KHRoaXMuX2xpbmVUaGlja25lc3MsIHRpbWUsIGRlZmF1bHRMaW5lVGhpY2tuZXNzLCByZXN1bHQubGluZVRoaWNrbmVzcyk7XHJcbiAgICAgICAgcmVzdWx0LmxpbmVPZmZzZXQgPSBQcm9wZXJ0eS5nZXRWYWx1ZU9yQ2xvbmVkRGVmYXVsdCh0aGlzLl9saW5lT2Zmc2V0LCB0aW1lLCBkZWZhdWx0TGluZU9mZnNldCwgcmVzdWx0LmxpbmVPZmZzZXQpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29tcGFyZXMgdGhpcyBwcm9wZXJ0eSB0byB0aGUgcHJvdmlkZWQgcHJvcGVydHkgYW5kIHJldHVybnNcclxuICAgICAqIDxjb2RlPnRydWU8L2NvZGU+IGlmIHRoZXkgYXJlIGVxdWFsLCA8Y29kZT5mYWxzZTwvY29kZT4gb3RoZXJ3aXNlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UHJvcGVydHl9IFtvdGhlcl0gVGhlIG90aGVyIHByb3BlcnR5LlxyXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IGlmIGxlZnQgYW5kIHJpZ2h0IGFyZSBlcXVhbCwgPGNvZGU+ZmFsc2U8L2NvZGU+IG90aGVyd2lzZS5cclxuICAgICAqL1xyXG4gICAgR3JpZE1hdGVyaWFsUHJvcGVydHkucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMgPT09IG90aGVyIHx8IC8vXHJcbiAgICAgICAgKG90aGVyIGluc3RhbmNlb2YgR3JpZE1hdGVyaWFsUHJvcGVydHkgJiYgLy9cclxuICAgICAgICBQcm9wZXJ0eS5lcXVhbHModGhpcy5fY29sb3IsIG90aGVyLl9jb2xvcikgJiYgLy9cclxuICAgICAgICBQcm9wZXJ0eS5lcXVhbHModGhpcy5fY2VsbEFscGhhLCBvdGhlci5fY2VsbEFscGhhKSAmJiAvL1xyXG4gICAgICAgIFByb3BlcnR5LmVxdWFscyh0aGlzLl9saW5lQ291bnQsIG90aGVyLl9saW5lQ291bnQpICYmIC8vXHJcbiAgICAgICAgUHJvcGVydHkuZXF1YWxzKHRoaXMuX2xpbmVUaGlja25lc3MsIG90aGVyLl9saW5lVGhpY2tuZXNzKSAmJiAvL1xyXG4gICAgICAgIFByb3BlcnR5LmVxdWFscyh0aGlzLl9saW5lT2Zmc2V0LCBvdGhlci5fbGluZU9mZnNldCkpO1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gR3JpZE1hdGVyaWFsUHJvcGVydHk7XHJcbn0pO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy90ZXJyaWFqcy1jZXNpdW0vU291cmNlL0RhdGFTb3VyY2VzL0dyaWRNYXRlcmlhbFByb3BlcnR5LmpzXG4vLyBtb2R1bGUgaWQgPSAxMjA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImRlZmluZShbXHJcbiAgICAgICAgJy4uL0NvcmUvQ29sb3InLFxyXG4gICAgICAgICcuLi9Db3JlL2RlZmluZWQnLFxyXG4gICAgICAgICcuLi9Db3JlL2RlZmluZVByb3BlcnRpZXMnLFxyXG4gICAgICAgICcuLi9Db3JlL0V2ZW50JyxcclxuICAgICAgICAnLi9jcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3InLFxyXG4gICAgICAgICcuL1Byb3BlcnR5J1xyXG4gICAgXSwgZnVuY3Rpb24oXHJcbiAgICAgICAgQ29sb3IsXHJcbiAgICAgICAgZGVmaW5lZCxcclxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzLFxyXG4gICAgICAgIEV2ZW50LFxyXG4gICAgICAgIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcixcclxuICAgICAgICBQcm9wZXJ0eSkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSB7QGxpbmsgTWF0ZXJpYWxQcm9wZXJ0eX0gdGhhdCBtYXBzIHRvIFBvbHlsaW5lQXJyb3cge0BsaW5rIE1hdGVyaWFsfSB1bmlmb3Jtcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1Byb3BlcnR5fSBbY29sb3I9Q29sb3IuV0hJVEVdIFRoZSB7QGxpbmsgQ29sb3J9IFByb3BlcnR5IHRvIGJlIHVzZWQuXHJcbiAgICAgKlxyXG4gICAgICogQGFsaWFzIFBvbHlsaW5lQXJyb3dNYXRlcmlhbFByb3BlcnR5XHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gUG9seWxpbmVBcnJvd01hdGVyaWFsUHJvcGVydHkoY29sb3IpIHtcclxuICAgICAgICB0aGlzLl9kZWZpbml0aW9uQ2hhbmdlZCA9IG5ldyBFdmVudCgpO1xyXG4gICAgICAgIHRoaXMuX2NvbG9yID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuX2NvbG9yU3Vic2NyaXB0aW9uID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuY29sb3IgPSBjb2xvcjtcclxuICAgIH1cclxuXHJcbiAgICBkZWZpbmVQcm9wZXJ0aWVzKFBvbHlsaW5lQXJyb3dNYXRlcmlhbFByb3BlcnR5LnByb3RvdHlwZSwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgYSB2YWx1ZSBpbmRpY2F0aW5nIGlmIHRoaXMgcHJvcGVydHkgaXMgY29uc3RhbnQuICBBIHByb3BlcnR5IGlzIGNvbnNpZGVyZWRcclxuICAgICAgICAgKiBjb25zdGFudCBpZiBnZXRWYWx1ZSBhbHdheXMgcmV0dXJucyB0aGUgc2FtZSByZXN1bHQgZm9yIHRoZSBjdXJyZW50IGRlZmluaXRpb24uXHJcbiAgICAgICAgICogQG1lbWJlcm9mIFBvbHlsaW5lQXJyb3dNYXRlcmlhbFByb3BlcnR5LnByb3RvdHlwZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaXNDb25zdGFudCA6IHtcclxuICAgICAgICAgICAgZ2V0IDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvcGVydHkuaXNDb25zdGFudCh0aGlzLl9jb2xvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIGV2ZW50IHRoYXQgaXMgcmFpc2VkIHdoZW5ldmVyIHRoZSBkZWZpbml0aW9uIG9mIHRoaXMgcHJvcGVydHkgY2hhbmdlcy5cclxuICAgICAgICAgKiBUaGUgZGVmaW5pdGlvbiBpcyBjb25zaWRlcmVkIHRvIGhhdmUgY2hhbmdlZCBpZiBhIGNhbGwgdG8gZ2V0VmFsdWUgd291bGQgcmV0dXJuXHJcbiAgICAgICAgICogYSBkaWZmZXJlbnQgcmVzdWx0IGZvciB0aGUgc2FtZSB0aW1lLlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBQb2x5bGluZUFycm93TWF0ZXJpYWxQcm9wZXJ0eS5wcm90b3R5cGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEB0eXBlIHtFdmVudH1cclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKi9cclxuICAgICAgICBkZWZpbml0aW9uQ2hhbmdlZCA6IHtcclxuICAgICAgICAgICAgZ2V0IDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmaW5pdGlvbkNoYW5nZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUge0BsaW5rIENvbG9yfSB7QGxpbmsgUHJvcGVydHl9LlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBQb2x5bGluZUFycm93TWF0ZXJpYWxQcm9wZXJ0eS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAdHlwZSB7UHJvcGVydHl9XHJcbiAgICAgICAgICogQGRlZmF1bHQgQ29sb3IuV0hJVEVcclxuICAgICAgICAgKi9cclxuICAgICAgICBjb2xvciA6IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcignY29sb3InKVxyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSB7QGxpbmsgTWF0ZXJpYWx9IHR5cGUgYXQgdGhlIHByb3ZpZGVkIHRpbWUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtKdWxpYW5EYXRlfSB0aW1lIFRoZSB0aW1lIGZvciB3aGljaCB0byByZXRyaWV2ZSB0aGUgdHlwZS5cclxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSB0eXBlIG9mIG1hdGVyaWFsLlxyXG4gICAgICovXHJcbiAgICBQb2x5bGluZUFycm93TWF0ZXJpYWxQcm9wZXJ0eS5wcm90b3R5cGUuZ2V0VHlwZSA9IGZ1bmN0aW9uKHRpbWUpIHtcclxuICAgICAgICByZXR1cm4gJ1BvbHlsaW5lQXJyb3cnO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eSBhdCB0aGUgcHJvdmlkZWQgdGltZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0p1bGlhbkRhdGV9IHRpbWUgVGhlIHRpbWUgZm9yIHdoaWNoIHRvIHJldHJpZXZlIHRoZSB2YWx1ZS5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcmVzdWx0XSBUaGUgb2JqZWN0IHRvIHN0b3JlIHRoZSB2YWx1ZSBpbnRvLCBpZiBvbWl0dGVkLCBhIG5ldyBpbnN0YW5jZSBpcyBjcmVhdGVkIGFuZCByZXR1cm5lZC5cclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBtb2RpZmllZCByZXN1bHQgcGFyYW1ldGVyIG9yIGEgbmV3IGluc3RhbmNlIGlmIHRoZSByZXN1bHQgcGFyYW1ldGVyIHdhcyBub3Qgc3VwcGxpZWQuXHJcbiAgICAgKi9cclxuICAgIFBvbHlsaW5lQXJyb3dNYXRlcmlhbFByb3BlcnR5LnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uKHRpbWUsIHJlc3VsdCkge1xyXG4gICAgICAgIGlmICghZGVmaW5lZChyZXN1bHQpKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHt9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXN1bHQuY29sb3IgPSBQcm9wZXJ0eS5nZXRWYWx1ZU9yQ2xvbmVkRGVmYXVsdCh0aGlzLl9jb2xvciwgdGltZSwgQ29sb3IuV0hJVEUsIHJlc3VsdC5jb2xvcik7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wYXJlcyB0aGlzIHByb3BlcnR5IHRvIHRoZSBwcm92aWRlZCBwcm9wZXJ0eSBhbmQgcmV0dXJuc1xyXG4gICAgICogPGNvZGU+dHJ1ZTwvY29kZT4gaWYgdGhleSBhcmUgZXF1YWwsIDxjb2RlPmZhbHNlPC9jb2RlPiBvdGhlcndpc2UuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtQcm9wZXJ0eX0gW290aGVyXSBUaGUgb3RoZXIgcHJvcGVydHkuXHJcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgbGVmdCBhbmQgcmlnaHQgYXJlIGVxdWFsLCA8Y29kZT5mYWxzZTwvY29kZT4gb3RoZXJ3aXNlLlxyXG4gICAgICovXHJcbiAgICBQb2x5bGluZUFycm93TWF0ZXJpYWxQcm9wZXJ0eS5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24ob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gdGhpcyA9PT0gb3RoZXIgfHwgLy9cclxuICAgICAgICAgICAgICAgKG90aGVyIGluc3RhbmNlb2YgUG9seWxpbmVBcnJvd01hdGVyaWFsUHJvcGVydHkgJiYgLy9cclxuICAgICAgICAgICAgICAgIFByb3BlcnR5LmVxdWFscyh0aGlzLl9jb2xvciwgb3RoZXIuX2NvbG9yKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBQb2x5bGluZUFycm93TWF0ZXJpYWxQcm9wZXJ0eTtcclxufSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3RlcnJpYWpzLWNlc2l1bS9Tb3VyY2UvRGF0YVNvdXJjZXMvUG9seWxpbmVBcnJvd01hdGVyaWFsUHJvcGVydHkuanNcbi8vIG1vZHVsZSBpZCA9IDEyMDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZGVmaW5lKFtcclxuICAgICAgICAnLi4vQ29yZS9Db2xvcicsXHJcbiAgICAgICAgJy4uL0NvcmUvZGVmYXVsdFZhbHVlJyxcclxuICAgICAgICAnLi4vQ29yZS9kZWZpbmVkJyxcclxuICAgICAgICAnLi4vQ29yZS9kZWZpbmVQcm9wZXJ0aWVzJyxcclxuICAgICAgICAnLi4vQ29yZS9FdmVudCcsXHJcbiAgICAgICAgJy4vY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJyxcclxuICAgICAgICAnLi9Qcm9wZXJ0eSdcclxuICAgIF0sIGZ1bmN0aW9uKFxyXG4gICAgICAgIENvbG9yLFxyXG4gICAgICAgIGRlZmF1bHRWYWx1ZSxcclxuICAgICAgICBkZWZpbmVkLFxyXG4gICAgICAgIGRlZmluZVByb3BlcnRpZXMsXHJcbiAgICAgICAgRXZlbnQsXHJcbiAgICAgICAgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yLFxyXG4gICAgICAgIFByb3BlcnR5KSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcblxyXG4gICAgdmFyIGRlZmF1bHRDb2xvciA9IENvbG9yLldISVRFO1xyXG4gICAgdmFyIGRlZmF1bHRHYXBDb2xvciA9IENvbG9yLlRSQU5TUEFSRU5UO1xyXG4gICAgdmFyIGRlZmF1bHREYXNoTGVuZ3RoID0gMTYuMDtcclxuICAgIHZhciBkZWZhdWx0RGFzaFBhdHRlcm4gPSAyNTUuMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEEge0BsaW5rIE1hdGVyaWFsUHJvcGVydHl9IHRoYXQgbWFwcyB0byBwb2x5bGluZSBkYXNoIHtAbGluayBNYXRlcmlhbH0gdW5pZm9ybXMuXHJcbiAgICAgKiBAYWxpYXMgUG9seWxpbmVEYXNoTWF0ZXJpYWxQcm9wZXJ0eVxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XHJcbiAgICAgKiBAcGFyYW0ge1Byb3BlcnR5fSBbb3B0aW9ucy5jb2xvcj1Db2xvci5XSElURV0gQSBQcm9wZXJ0eSBzcGVjaWZ5aW5nIHRoZSB7QGxpbmsgQ29sb3J9IG9mIHRoZSBsaW5lLlxyXG4gICAgICogQHBhcmFtIHtQcm9wZXJ0eX0gW29wdGlvbnMuZ2FwQ29sb3I9Q29sb3IuVFJBTlNQQVJFTlRdIEEgUHJvcGVydHkgc3BlY2lmeWluZyB0aGUge0BsaW5rIENvbG9yfSBvZiB0aGUgZ2FwcyBpbiB0aGUgbGluZS5cclxuICAgICAqIEBwYXJhbSB7UHJvcGVydHl9IFtvcHRpb25zLmRhc2hMZW5ndGg9MTYuMF0gQSBudW1lcmljIFByb3BlcnR5IHNwZWNpZnlpbmcgdGhlIGxlbmd0aCBvZiB0aGUgZGFzaCBwYXR0ZXJuIGluIHBpeGVsLnNcclxuICAgICAqIEBwYXJhbSB7UHJvcGVydHl9IFtvcHRpb25zLmRhc2hQYXR0ZXJuPTI1NS4wXSBBIG51bWVyaWMgUHJvcGVydHkgc3BlY2lmeWluZyBhIDE2IGJpdCBwYXR0ZXJuIGZvciB0aGUgZGFzaFxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBQb2x5bGluZURhc2hNYXRlcmlhbFByb3BlcnR5KG9wdGlvbnMpIHtcclxuICAgICAgICBvcHRpb25zID0gZGVmYXVsdFZhbHVlKG9wdGlvbnMsIGRlZmF1bHRWYWx1ZS5FTVBUWV9PQkpFQ1QpO1xyXG5cclxuICAgICAgICB0aGlzLl9kZWZpbml0aW9uQ2hhbmdlZCA9IG5ldyBFdmVudCgpO1xyXG4gICAgICAgIHRoaXMuX2NvbG9yID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuX2NvbG9yU3Vic2NyaXB0aW9uID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuX2dhcENvbG9yID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuX2dhcENvbG9yU3Vic2NyaXB0aW9uID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuX2Rhc2hMZW5ndGggPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5fZGFzaExlbmd0aFN1YnNjcmlwdGlvbiA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLl9kYXNoUGF0dGVybiA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLl9kYXNoUGF0dGVyblN1YnNjcmlwdGlvbiA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgdGhpcy5jb2xvciA9IG9wdGlvbnMuY29sb3I7XHJcbiAgICAgICAgdGhpcy5nYXBDb2xvciA9IG9wdGlvbnMuZ2FwQ29sb3I7XHJcbiAgICAgICAgdGhpcy5kYXNoTGVuZ3RoID0gb3B0aW9ucy5kYXNoTGVuZ3RoO1xyXG4gICAgICAgIHRoaXMuZGFzaFBhdHRlcm4gPSBvcHRpb25zLmRhc2hQYXR0ZXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGRlZmluZVByb3BlcnRpZXMoUG9seWxpbmVEYXNoTWF0ZXJpYWxQcm9wZXJ0eS5wcm90b3R5cGUsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIGEgdmFsdWUgaW5kaWNhdGluZyBpZiB0aGlzIHByb3BlcnR5IGlzIGNvbnN0YW50LiAgQSBwcm9wZXJ0eSBpcyBjb25zaWRlcmVkXHJcbiAgICAgICAgICogY29uc3RhbnQgaWYgZ2V0VmFsdWUgYWx3YXlzIHJldHVybnMgdGhlIHNhbWUgcmVzdWx0IGZvciB0aGUgY3VycmVudCBkZWZpbml0aW9uLlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBQb2x5bGluZURhc2hNYXRlcmlhbFByb3BlcnR5LnByb3RvdHlwZVxyXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGlzQ29uc3RhbnQgOiB7XHJcbiAgICAgICAgICAgIGdldCA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChQcm9wZXJ0eS5pc0NvbnN0YW50KHRoaXMuX2NvbG9yKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBQcm9wZXJ0eS5pc0NvbnN0YW50KHRoaXMuX2dhcENvbG9yKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBQcm9wZXJ0eS5pc0NvbnN0YW50KHRoaXMuX2Rhc2hMZW5ndGgpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFByb3BlcnR5LmlzQ29uc3RhbnQodGhpcy5fZGFzaFBhdHRlcm4pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgZXZlbnQgdGhhdCBpcyByYWlzZWQgd2hlbmV2ZXIgdGhlIGRlZmluaXRpb24gb2YgdGhpcyBwcm9wZXJ0eSBjaGFuZ2VzLlxyXG4gICAgICAgICAqIFRoZSBkZWZpbml0aW9uIGlzIGNvbnNpZGVyZWQgdG8gaGF2ZSBjaGFuZ2VkIGlmIGEgY2FsbCB0byBnZXRWYWx1ZSB3b3VsZCByZXR1cm5cclxuICAgICAgICAgKiBhIGRpZmZlcmVudCByZXN1bHQgZm9yIHRoZSBzYW1lIHRpbWUuXHJcbiAgICAgICAgICogQG1lbWJlcm9mIFBvbHlsaW5lRGFzaE1hdGVyaWFsUHJvcGVydHkucHJvdG90eXBlXHJcbiAgICAgICAgICogQHR5cGUge0V2ZW50fVxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGRlZmluaXRpb25DaGFuZ2VkIDoge1xyXG4gICAgICAgICAgICBnZXQgOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWZpbml0aW9uQ2hhbmdlZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBQcm9wZXJ0eSBzcGVjaWZ5aW5nIHRoZSB7QGxpbmsgQ29sb3J9IG9mIHRoZSBsaW5lLlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBQb2x5bGluZURhc2hNYXRlcmlhbFByb3BlcnR5LnByb3RvdHlwZVxyXG4gICAgICAgICAqIEB0eXBlIHtQcm9wZXJ0eX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBjb2xvciA6IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcignY29sb3InKSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIFByb3BlcnR5IHNwZWNpZnlpbmcgdGhlIHtAbGluayBDb2xvcn0gb2YgdGhlIGdhcHMgaW4gdGhlIGxpbmUuXHJcbiAgICAgICAgICogQG1lbWJlcm9mIFBvbHlsaW5lRGFzaE1hdGVyaWFsUHJvcGVydHkucHJvdG90eXBlXHJcbiAgICAgICAgICogQHR5cGUge1Byb3BlcnR5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdhcENvbG9yIDogY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKCdnYXBDb2xvcicpLFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgbnVtZXJpYyBQcm9wZXJ0eSBzcGVjaWZ5aW5nIHRoZSBsZW5ndGggb2YgYSBkYXNoIGN5Y2xlXHJcbiAgICAgICAgICogQG1lbWJlcm9mIFBvbHlsaW5lRGFzaE1hdGVyaWFsUHJvcGVydHkucHJvdG90eXBlXHJcbiAgICAgICAgICogQHR5cGUge1Byb3BlcnR5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGRhc2hMZW5ndGggOiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoJ2Rhc2hMZW5ndGgnKSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIG51bWVyaWMgUHJvcGVydHkgc3BlY2lmeWluZyBhIGRhc2ggcGF0dGVyblxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBQb2x5bGluZURhc2hNYXRlcmlhbFByb3BlcnR5LnByb3RvdHlwZVxyXG4gICAgICAgICAqIEB0eXBlIHtQcm9wZXJ0eX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBkYXNoUGF0dGVybiA6IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcignZGFzaFBhdHRlcm4nKVxyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSB7QGxpbmsgTWF0ZXJpYWx9IHR5cGUgYXQgdGhlIHByb3ZpZGVkIHRpbWUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtKdWxpYW5EYXRlfSB0aW1lIFRoZSB0aW1lIGZvciB3aGljaCB0byByZXRyaWV2ZSB0aGUgdHlwZS5cclxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSB0eXBlIG9mIG1hdGVyaWFsLlxyXG4gICAgICovXHJcbiAgICBQb2x5bGluZURhc2hNYXRlcmlhbFByb3BlcnR5LnByb3RvdHlwZS5nZXRUeXBlID0gZnVuY3Rpb24odGltZSkge1xyXG4gICAgICAgIHJldHVybiAnUG9seWxpbmVEYXNoJztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgYXQgdGhlIHByb3ZpZGVkIHRpbWUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtKdWxpYW5EYXRlfSB0aW1lIFRoZSB0aW1lIGZvciB3aGljaCB0byByZXRyaWV2ZSB0aGUgdmFsdWUuXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3Jlc3VsdF0gVGhlIG9iamVjdCB0byBzdG9yZSB0aGUgdmFsdWUgaW50bywgaWYgb21pdHRlZCwgYSBuZXcgaW5zdGFuY2UgaXMgY3JlYXRlZCBhbmQgcmV0dXJuZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgbW9kaWZpZWQgcmVzdWx0IHBhcmFtZXRlciBvciBhIG5ldyBpbnN0YW5jZSBpZiB0aGUgcmVzdWx0IHBhcmFtZXRlciB3YXMgbm90IHN1cHBsaWVkLlxyXG4gICAgICovXHJcbiAgICBQb2x5bGluZURhc2hNYXRlcmlhbFByb3BlcnR5LnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uKHRpbWUsIHJlc3VsdCkge1xyXG4gICAgICAgIGlmICghZGVmaW5lZChyZXN1bHQpKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHt9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXN1bHQuY29sb3IgPSBQcm9wZXJ0eS5nZXRWYWx1ZU9yQ2xvbmVkRGVmYXVsdCh0aGlzLl9jb2xvciwgdGltZSwgZGVmYXVsdENvbG9yLCByZXN1bHQuY29sb3IpO1xyXG4gICAgICAgIHJlc3VsdC5nYXBDb2xvciA9IFByb3BlcnR5LmdldFZhbHVlT3JDbG9uZWREZWZhdWx0KHRoaXMuX2dhcENvbG9yLCB0aW1lLCBkZWZhdWx0R2FwQ29sb3IsIHJlc3VsdC5nYXBDb2xvcik7XHJcbiAgICAgICAgcmVzdWx0LmRhc2hMZW5ndGggPSBQcm9wZXJ0eS5nZXRWYWx1ZU9yRGVmYXVsdCh0aGlzLl9kYXNoTGVuZ3RoLCB0aW1lLCBkZWZhdWx0RGFzaExlbmd0aCwgcmVzdWx0LmRhc2hMZW5ndGgpO1xyXG4gICAgICAgIHJlc3VsdC5kYXNoUGF0dGVybiA9IFByb3BlcnR5LmdldFZhbHVlT3JEZWZhdWx0KHRoaXMuX2Rhc2hQYXR0ZXJuLCB0aW1lLCBkZWZhdWx0RGFzaFBhdHRlcm4sIHJlc3VsdC5kYXNoUGF0dGVybik7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wYXJlcyB0aGlzIHByb3BlcnR5IHRvIHRoZSBwcm92aWRlZCBwcm9wZXJ0eSBhbmQgcmV0dXJuc1xyXG4gICAgICogPGNvZGU+dHJ1ZTwvY29kZT4gaWYgdGhleSBhcmUgZXF1YWwsIDxjb2RlPmZhbHNlPC9jb2RlPiBvdGhlcndpc2UuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtQcm9wZXJ0eX0gW290aGVyXSBUaGUgb3RoZXIgcHJvcGVydHkuXHJcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgbGVmdCBhbmQgcmlnaHQgYXJlIGVxdWFsLCA8Y29kZT5mYWxzZTwvY29kZT4gb3RoZXJ3aXNlLlxyXG4gICAgICovXHJcbiAgICBQb2x5bGluZURhc2hNYXRlcmlhbFByb3BlcnR5LnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbihvdGhlcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzID09PSBvdGhlciB8fCAvL1xyXG4gICAgICAgICAgICAgICAob3RoZXIgaW5zdGFuY2VvZiBQb2x5bGluZURhc2hNYXRlcmlhbFByb3BlcnR5ICYmXHJcbiAgICAgICAgICAgICAgICBQcm9wZXJ0eS5lcXVhbHModGhpcy5fY29sb3IsIG90aGVyLl9jb2xvcikgJiZcclxuICAgICAgICAgICAgICAgIFByb3BlcnR5LmVxdWFscyh0aGlzLl9nYXBDb2xvciwgb3RoZXIuX2dhcENvbG9yKSAmJlxyXG4gICAgICAgICAgICAgICAgUHJvcGVydHkuZXF1YWxzKHRoaXMuX2Rhc2hMZW5ndGgsIG90aGVyLl9kYXNoTGVuZ3RoKSAmJlxyXG4gICAgICAgICAgICAgICAgUHJvcGVydHkuZXF1YWxzKHRoaXMuX2Rhc2hQYXR0ZXJuLCBvdGhlci5fZGFzaFBhdHRlcm4pXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gUG9seWxpbmVEYXNoTWF0ZXJpYWxQcm9wZXJ0eTtcclxufSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3RlcnJpYWpzLWNlc2l1bS9Tb3VyY2UvRGF0YVNvdXJjZXMvUG9seWxpbmVEYXNoTWF0ZXJpYWxQcm9wZXJ0eS5qc1xuLy8gbW9kdWxlIGlkID0gMTIwN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJkZWZpbmUoW1xyXG4gICAgICAgICcuLi9Db3JlL0NvbG9yJyxcclxuICAgICAgICAnLi4vQ29yZS9kZWZhdWx0VmFsdWUnLFxyXG4gICAgICAgICcuLi9Db3JlL2RlZmluZWQnLFxyXG4gICAgICAgICcuLi9Db3JlL2RlZmluZVByb3BlcnRpZXMnLFxyXG4gICAgICAgICcuLi9Db3JlL0V2ZW50JyxcclxuICAgICAgICAnLi9jcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3InLFxyXG4gICAgICAgICcuL1Byb3BlcnR5J1xyXG4gICAgXSwgZnVuY3Rpb24oXHJcbiAgICAgICAgQ29sb3IsXHJcbiAgICAgICAgZGVmYXVsdFZhbHVlLFxyXG4gICAgICAgIGRlZmluZWQsXHJcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyxcclxuICAgICAgICBFdmVudCxcclxuICAgICAgICBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IsXHJcbiAgICAgICAgUHJvcGVydHkpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgICB2YXIgZGVmYXVsdENvbG9yID0gQ29sb3IuV0hJVEU7XHJcbiAgICB2YXIgZGVmYXVsdEdsb3dQb3dlciA9IDAuMjU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIHtAbGluayBNYXRlcmlhbFByb3BlcnR5fSB0aGF0IG1hcHMgdG8gcG9seWxpbmUgZ2xvdyB7QGxpbmsgTWF0ZXJpYWx9IHVuaWZvcm1zLlxyXG4gICAgICogQGFsaWFzIFBvbHlsaW5lR2xvd01hdGVyaWFsUHJvcGVydHlcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxyXG4gICAgICogQHBhcmFtIHtQcm9wZXJ0eX0gW29wdGlvbnMuY29sb3I9Q29sb3IuV0hJVEVdIEEgUHJvcGVydHkgc3BlY2lmeWluZyB0aGUge0BsaW5rIENvbG9yfSBvZiB0aGUgbGluZS5cclxuICAgICAqIEBwYXJhbSB7UHJvcGVydHl9IFtvcHRpb25zLmdsb3dQb3dlcj0wLjI1XSBBIG51bWVyaWMgUHJvcGVydHkgc3BlY2lmeWluZyB0aGUgc3RyZW5ndGggb2YgdGhlIGdsb3csIGFzIGEgcGVyY2VudGFnZSBvZiB0aGUgdG90YWwgbGluZSB3aWR0aC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gUG9seWxpbmVHbG93TWF0ZXJpYWxQcm9wZXJ0eShvcHRpb25zKSB7XHJcbiAgICAgICAgb3B0aW9ucyA9IGRlZmF1bHRWYWx1ZShvcHRpb25zLCBkZWZhdWx0VmFsdWUuRU1QVFlfT0JKRUNUKTtcclxuXHJcbiAgICAgICAgdGhpcy5fZGVmaW5pdGlvbkNoYW5nZWQgPSBuZXcgRXZlbnQoKTtcclxuICAgICAgICB0aGlzLl9jb2xvciA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLl9jb2xvclN1YnNjcmlwdGlvbiA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLl9nbG93UG93ZXIgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5fZ2xvd1Bvd2VyU3Vic2NyaXB0aW9uID0gdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICB0aGlzLmNvbG9yID0gb3B0aW9ucy5jb2xvcjtcclxuICAgICAgICB0aGlzLmdsb3dQb3dlciA9IG9wdGlvbnMuZ2xvd1Bvd2VyO1xyXG4gICAgfVxyXG5cclxuICAgIGRlZmluZVByb3BlcnRpZXMoUG9seWxpbmVHbG93TWF0ZXJpYWxQcm9wZXJ0eS5wcm90b3R5cGUsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIGEgdmFsdWUgaW5kaWNhdGluZyBpZiB0aGlzIHByb3BlcnR5IGlzIGNvbnN0YW50LiAgQSBwcm9wZXJ0eSBpcyBjb25zaWRlcmVkXHJcbiAgICAgICAgICogY29uc3RhbnQgaWYgZ2V0VmFsdWUgYWx3YXlzIHJldHVybnMgdGhlIHNhbWUgcmVzdWx0IGZvciB0aGUgY3VycmVudCBkZWZpbml0aW9uLlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBQb2x5bGluZUdsb3dNYXRlcmlhbFByb3BlcnR5LnByb3RvdHlwZVxyXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGlzQ29uc3RhbnQgOiB7XHJcbiAgICAgICAgICAgIGdldCA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb3BlcnR5LmlzQ29uc3RhbnQodGhpcy5fY29sb3IpICYmIFByb3BlcnR5LmlzQ29uc3RhbnQodGhpcy5fZ2xvdyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIGV2ZW50IHRoYXQgaXMgcmFpc2VkIHdoZW5ldmVyIHRoZSBkZWZpbml0aW9uIG9mIHRoaXMgcHJvcGVydHkgY2hhbmdlcy5cclxuICAgICAgICAgKiBUaGUgZGVmaW5pdGlvbiBpcyBjb25zaWRlcmVkIHRvIGhhdmUgY2hhbmdlZCBpZiBhIGNhbGwgdG8gZ2V0VmFsdWUgd291bGQgcmV0dXJuXHJcbiAgICAgICAgICogYSBkaWZmZXJlbnQgcmVzdWx0IGZvciB0aGUgc2FtZSB0aW1lLlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBQb2x5bGluZUdsb3dNYXRlcmlhbFByb3BlcnR5LnByb3RvdHlwZVxyXG4gICAgICAgICAqIEB0eXBlIHtFdmVudH1cclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKi9cclxuICAgICAgICBkZWZpbml0aW9uQ2hhbmdlZCA6IHtcclxuICAgICAgICAgICAgZ2V0IDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmaW5pdGlvbkNoYW5nZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgUHJvcGVydHkgc3BlY2lmeWluZyB0aGUge0BsaW5rIENvbG9yfSBvZiB0aGUgbGluZS5cclxuICAgICAgICAgKiBAbWVtYmVyb2YgUG9seWxpbmVHbG93TWF0ZXJpYWxQcm9wZXJ0eS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAdHlwZSB7UHJvcGVydHl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY29sb3IgOiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoJ2NvbG9yJyksXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBudW1lcmljIFByb3BlcnR5IHNwZWNpZnlpbmcgdGhlIHN0cmVuZ3RoIG9mIHRoZSBnbG93LCBhcyBhIHBlcmNlbnRhZ2Ugb2YgdGhlIHRvdGFsIGxpbmUgd2lkdGggKGxlc3MgdGhhbiAxLjApLlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBQb2x5bGluZUdsb3dNYXRlcmlhbFByb3BlcnR5LnByb3RvdHlwZVxyXG4gICAgICAgICAqIEB0eXBlIHtQcm9wZXJ0eX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBnbG93UG93ZXIgOiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoJ2dsb3dQb3dlcicpXHJcbiAgICB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHtAbGluayBNYXRlcmlhbH0gdHlwZSBhdCB0aGUgcHJvdmlkZWQgdGltZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0p1bGlhbkRhdGV9IHRpbWUgVGhlIHRpbWUgZm9yIHdoaWNoIHRvIHJldHJpZXZlIHRoZSB0eXBlLlxyXG4gICAgICogQHJldHVybnMge1N0cmluZ30gVGhlIHR5cGUgb2YgbWF0ZXJpYWwuXHJcbiAgICAgKi9cclxuICAgIFBvbHlsaW5lR2xvd01hdGVyaWFsUHJvcGVydHkucHJvdG90eXBlLmdldFR5cGUgPSBmdW5jdGlvbih0aW1lKSB7XHJcbiAgICAgICAgcmV0dXJuICdQb2x5bGluZUdsb3cnO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eSBhdCB0aGUgcHJvdmlkZWQgdGltZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0p1bGlhbkRhdGV9IHRpbWUgVGhlIHRpbWUgZm9yIHdoaWNoIHRvIHJldHJpZXZlIHRoZSB2YWx1ZS5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcmVzdWx0XSBUaGUgb2JqZWN0IHRvIHN0b3JlIHRoZSB2YWx1ZSBpbnRvLCBpZiBvbWl0dGVkLCBhIG5ldyBpbnN0YW5jZSBpcyBjcmVhdGVkIGFuZCByZXR1cm5lZC5cclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBtb2RpZmllZCByZXN1bHQgcGFyYW1ldGVyIG9yIGEgbmV3IGluc3RhbmNlIGlmIHRoZSByZXN1bHQgcGFyYW1ldGVyIHdhcyBub3Qgc3VwcGxpZWQuXHJcbiAgICAgKi9cclxuICAgIFBvbHlsaW5lR2xvd01hdGVyaWFsUHJvcGVydHkucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24odGltZSwgcmVzdWx0KSB7XHJcbiAgICAgICAgaWYgKCFkZWZpbmVkKHJlc3VsdCkpIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0ge307XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc3VsdC5jb2xvciA9IFByb3BlcnR5LmdldFZhbHVlT3JDbG9uZWREZWZhdWx0KHRoaXMuX2NvbG9yLCB0aW1lLCBkZWZhdWx0Q29sb3IsIHJlc3VsdC5jb2xvcik7XHJcbiAgICAgICAgcmVzdWx0Lmdsb3dQb3dlciA9IFByb3BlcnR5LmdldFZhbHVlT3JEZWZhdWx0KHRoaXMuX2dsb3dQb3dlciwgdGltZSwgZGVmYXVsdEdsb3dQb3dlciwgcmVzdWx0Lmdsb3dQb3dlcik7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wYXJlcyB0aGlzIHByb3BlcnR5IHRvIHRoZSBwcm92aWRlZCBwcm9wZXJ0eSBhbmQgcmV0dXJuc1xyXG4gICAgICogPGNvZGU+dHJ1ZTwvY29kZT4gaWYgdGhleSBhcmUgZXF1YWwsIDxjb2RlPmZhbHNlPC9jb2RlPiBvdGhlcndpc2UuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtQcm9wZXJ0eX0gW290aGVyXSBUaGUgb3RoZXIgcHJvcGVydHkuXHJcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgbGVmdCBhbmQgcmlnaHQgYXJlIGVxdWFsLCA8Y29kZT5mYWxzZTwvY29kZT4gb3RoZXJ3aXNlLlxyXG4gICAgICovXHJcbiAgICBQb2x5bGluZUdsb3dNYXRlcmlhbFByb3BlcnR5LnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbihvdGhlcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzID09PSBvdGhlciB8fCAvL1xyXG4gICAgICAgICAgICAgICAob3RoZXIgaW5zdGFuY2VvZiBQb2x5bGluZUdsb3dNYXRlcmlhbFByb3BlcnR5ICYmIC8vXHJcbiAgICAgICAgICAgICAgICBQcm9wZXJ0eS5lcXVhbHModGhpcy5fY29sb3IsIG90aGVyLl9jb2xvcikgJiZcclxuICAgICAgICAgICAgICAgIFByb3BlcnR5LmVxdWFscyh0aGlzLl9nbG93UG93ZXIsIG90aGVyLl9nbG93UG93ZXIpKTtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIFBvbHlsaW5lR2xvd01hdGVyaWFsUHJvcGVydHk7XHJcbn0pO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy90ZXJyaWFqcy1jZXNpdW0vU291cmNlL0RhdGFTb3VyY2VzL1BvbHlsaW5lR2xvd01hdGVyaWFsUHJvcGVydHkuanNcbi8vIG1vZHVsZSBpZCA9IDEyMDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZGVmaW5lKFtcclxuICAgICAgICAnLi4vQ29yZS9Db2xvcicsXHJcbiAgICAgICAgJy4uL0NvcmUvZGVmYXVsdFZhbHVlJyxcclxuICAgICAgICAnLi4vQ29yZS9kZWZpbmVkJyxcclxuICAgICAgICAnLi4vQ29yZS9kZWZpbmVQcm9wZXJ0aWVzJyxcclxuICAgICAgICAnLi4vQ29yZS9FdmVudCcsXHJcbiAgICAgICAgJy4vY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJyxcclxuICAgICAgICAnLi9Qcm9wZXJ0eSdcclxuICAgIF0sIGZ1bmN0aW9uKFxyXG4gICAgICAgIENvbG9yLFxyXG4gICAgICAgIGRlZmF1bHRWYWx1ZSxcclxuICAgICAgICBkZWZpbmVkLFxyXG4gICAgICAgIGRlZmluZVByb3BlcnRpZXMsXHJcbiAgICAgICAgRXZlbnQsXHJcbiAgICAgICAgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yLFxyXG4gICAgICAgIFByb3BlcnR5KSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcblxyXG4gICAgdmFyIGRlZmF1bHRDb2xvciA9IENvbG9yLldISVRFO1xyXG4gICAgdmFyIGRlZmF1bHRPdXRsaW5lQ29sb3IgPSBDb2xvci5CTEFDSztcclxuICAgIHZhciBkZWZhdWx0T3V0bGluZVdpZHRoID0gMS4wO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSB7QGxpbmsgTWF0ZXJpYWxQcm9wZXJ0eX0gdGhhdCBtYXBzIHRvIHBvbHlsaW5lIG91dGxpbmUge0BsaW5rIE1hdGVyaWFsfSB1bmlmb3Jtcy5cclxuICAgICAqIEBhbGlhcyBQb2x5bGluZU91dGxpbmVNYXRlcmlhbFByb3BlcnR5XHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcclxuICAgICAqIEBwYXJhbSB7UHJvcGVydHl9IFtvcHRpb25zLmNvbG9yPUNvbG9yLldISVRFXSBBIFByb3BlcnR5IHNwZWNpZnlpbmcgdGhlIHtAbGluayBDb2xvcn0gb2YgdGhlIGxpbmUuXHJcbiAgICAgKiBAcGFyYW0ge1Byb3BlcnR5fSBbb3B0aW9ucy5vdXRsaW5lQ29sb3I9Q29sb3IuQkxBQ0tdIEEgUHJvcGVydHkgc3BlY2lmeWluZyB0aGUge0BsaW5rIENvbG9yfSBvZiB0aGUgb3V0bGluZS5cclxuICAgICAqIEBwYXJhbSB7UHJvcGVydHl9IFtvcHRpb25zLm91dGxpbmVXaWR0aD0xLjBdIEEgbnVtZXJpYyBQcm9wZXJ0eSBzcGVjaWZ5aW5nIHRoZSB3aWR0aCBvZiB0aGUgb3V0bGluZSwgaW4gcGl4ZWxzLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBQb2x5bGluZU91dGxpbmVNYXRlcmlhbFByb3BlcnR5KG9wdGlvbnMpIHtcclxuICAgICAgICBvcHRpb25zID0gZGVmYXVsdFZhbHVlKG9wdGlvbnMsIGRlZmF1bHRWYWx1ZS5FTVBUWV9PQkpFQ1QpO1xyXG5cclxuICAgICAgICB0aGlzLl9kZWZpbml0aW9uQ2hhbmdlZCA9IG5ldyBFdmVudCgpO1xyXG4gICAgICAgIHRoaXMuX2NvbG9yID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuX2NvbG9yU3Vic2NyaXB0aW9uID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuX291dGxpbmVDb2xvciA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLl9vdXRsaW5lQ29sb3JTdWJzY3JpcHRpb24gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5fb3V0bGluZVdpZHRoID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuX291dGxpbmVXaWR0aFN1YnNjcmlwdGlvbiA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgdGhpcy5jb2xvciA9IG9wdGlvbnMuY29sb3I7XHJcbiAgICAgICAgdGhpcy5vdXRsaW5lQ29sb3IgPSBvcHRpb25zLm91dGxpbmVDb2xvcjtcclxuICAgICAgICB0aGlzLm91dGxpbmVXaWR0aCA9IG9wdGlvbnMub3V0bGluZVdpZHRoO1xyXG4gICAgfVxyXG5cclxuICAgIGRlZmluZVByb3BlcnRpZXMoUG9seWxpbmVPdXRsaW5lTWF0ZXJpYWxQcm9wZXJ0eS5wcm90b3R5cGUsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIGEgdmFsdWUgaW5kaWNhdGluZyBpZiB0aGlzIHByb3BlcnR5IGlzIGNvbnN0YW50LiAgQSBwcm9wZXJ0eSBpcyBjb25zaWRlcmVkXHJcbiAgICAgICAgICogY29uc3RhbnQgaWYgZ2V0VmFsdWUgYWx3YXlzIHJldHVybnMgdGhlIHNhbWUgcmVzdWx0IGZvciB0aGUgY3VycmVudCBkZWZpbml0aW9uLlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBQb2x5bGluZU91dGxpbmVNYXRlcmlhbFByb3BlcnR5LnByb3RvdHlwZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaXNDb25zdGFudCA6IHtcclxuICAgICAgICAgICAgZ2V0IDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvcGVydHkuaXNDb25zdGFudCh0aGlzLl9jb2xvcikgJiYgUHJvcGVydHkuaXNDb25zdGFudCh0aGlzLl9vdXRsaW5lQ29sb3IpICYmIFByb3BlcnR5LmlzQ29uc3RhbnQodGhpcy5fb3V0bGluZVdpZHRoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgZXZlbnQgdGhhdCBpcyByYWlzZWQgd2hlbmV2ZXIgdGhlIGRlZmluaXRpb24gb2YgdGhpcyBwcm9wZXJ0eSBjaGFuZ2VzLlxyXG4gICAgICAgICAqIFRoZSBkZWZpbml0aW9uIGlzIGNvbnNpZGVyZWQgdG8gaGF2ZSBjaGFuZ2VkIGlmIGEgY2FsbCB0byBnZXRWYWx1ZSB3b3VsZCByZXR1cm5cclxuICAgICAgICAgKiBhIGRpZmZlcmVudCByZXN1bHQgZm9yIHRoZSBzYW1lIHRpbWUuXHJcbiAgICAgICAgICogQG1lbWJlcm9mIFBvbHlsaW5lT3V0bGluZU1hdGVyaWFsUHJvcGVydHkucHJvdG90eXBlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAdHlwZSB7RXZlbnR9XHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZGVmaW5pdGlvbkNoYW5nZWQgOiB7XHJcbiAgICAgICAgICAgIGdldCA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZmluaXRpb25DaGFuZ2VkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIFByb3BlcnR5IHNwZWNpZnlpbmcgdGhlIHtAbGluayBDb2xvcn0gb2YgdGhlIGxpbmUuXHJcbiAgICAgICAgICogQG1lbWJlcm9mIFBvbHlsaW5lT3V0bGluZU1hdGVyaWFsUHJvcGVydHkucHJvdG90eXBlXHJcbiAgICAgICAgICogQHR5cGUge1Byb3BlcnR5fVxyXG4gICAgICAgICAqIEBkZWZhdWx0IENvbG9yLldISVRFXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY29sb3IgOiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoJ2NvbG9yJyksXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBQcm9wZXJ0eSBzcGVjaWZ5aW5nIHRoZSB7QGxpbmsgQ29sb3J9IG9mIHRoZSBvdXRsaW5lLlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBQb2x5bGluZU91dGxpbmVNYXRlcmlhbFByb3BlcnR5LnByb3RvdHlwZVxyXG4gICAgICAgICAqIEB0eXBlIHtQcm9wZXJ0eX1cclxuICAgICAgICAgKiBAZGVmYXVsdCBDb2xvci5CTEFDS1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIG91dGxpbmVDb2xvciA6IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcignb3V0bGluZUNvbG9yJyksXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBudW1lcmljIFByb3BlcnR5IHNwZWNpZnlpbmcgdGhlIHdpZHRoIG9mIHRoZSBvdXRsaW5lLlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBQb2x5bGluZU91dGxpbmVNYXRlcmlhbFByb3BlcnR5LnByb3RvdHlwZVxyXG4gICAgICAgICAqIEB0eXBlIHtQcm9wZXJ0eX1cclxuICAgICAgICAgKiBAZGVmYXVsdCAxLjBcclxuICAgICAgICAgKi9cclxuICAgICAgICBvdXRsaW5lV2lkdGggOiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoJ291dGxpbmVXaWR0aCcpXHJcbiAgICB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHtAbGluayBNYXRlcmlhbH0gdHlwZSBhdCB0aGUgcHJvdmlkZWQgdGltZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0p1bGlhbkRhdGV9IHRpbWUgVGhlIHRpbWUgZm9yIHdoaWNoIHRvIHJldHJpZXZlIHRoZSB0eXBlLlxyXG4gICAgICogQHJldHVybnMge1N0cmluZ30gVGhlIHR5cGUgb2YgbWF0ZXJpYWwuXHJcbiAgICAgKi9cclxuICAgIFBvbHlsaW5lT3V0bGluZU1hdGVyaWFsUHJvcGVydHkucHJvdG90eXBlLmdldFR5cGUgPSBmdW5jdGlvbih0aW1lKSB7XHJcbiAgICAgICAgcmV0dXJuICdQb2x5bGluZU91dGxpbmUnO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eSBhdCB0aGUgcHJvdmlkZWQgdGltZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0p1bGlhbkRhdGV9IHRpbWUgVGhlIHRpbWUgZm9yIHdoaWNoIHRvIHJldHJpZXZlIHRoZSB2YWx1ZS5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcmVzdWx0XSBUaGUgb2JqZWN0IHRvIHN0b3JlIHRoZSB2YWx1ZSBpbnRvLCBpZiBvbWl0dGVkLCBhIG5ldyBpbnN0YW5jZSBpcyBjcmVhdGVkIGFuZCByZXR1cm5lZC5cclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBtb2RpZmllZCByZXN1bHQgcGFyYW1ldGVyIG9yIGEgbmV3IGluc3RhbmNlIGlmIHRoZSByZXN1bHQgcGFyYW1ldGVyIHdhcyBub3Qgc3VwcGxpZWQuXHJcbiAgICAgKi9cclxuICAgIFBvbHlsaW5lT3V0bGluZU1hdGVyaWFsUHJvcGVydHkucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24odGltZSwgcmVzdWx0KSB7XHJcbiAgICAgICAgaWYgKCFkZWZpbmVkKHJlc3VsdCkpIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0ge307XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc3VsdC5jb2xvciA9IFByb3BlcnR5LmdldFZhbHVlT3JDbG9uZWREZWZhdWx0KHRoaXMuX2NvbG9yLCB0aW1lLCBkZWZhdWx0Q29sb3IsIHJlc3VsdC5jb2xvcik7XHJcbiAgICAgICAgcmVzdWx0Lm91dGxpbmVDb2xvciA9IFByb3BlcnR5LmdldFZhbHVlT3JDbG9uZWREZWZhdWx0KHRoaXMuX291dGxpbmVDb2xvciwgdGltZSwgZGVmYXVsdE91dGxpbmVDb2xvciwgcmVzdWx0Lm91dGxpbmVDb2xvcik7XHJcbiAgICAgICAgcmVzdWx0Lm91dGxpbmVXaWR0aCA9IFByb3BlcnR5LmdldFZhbHVlT3JEZWZhdWx0KHRoaXMuX291dGxpbmVXaWR0aCwgdGltZSwgZGVmYXVsdE91dGxpbmVXaWR0aCk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wYXJlcyB0aGlzIHByb3BlcnR5IHRvIHRoZSBwcm92aWRlZCBwcm9wZXJ0eSBhbmQgcmV0dXJuc1xyXG4gICAgICogPGNvZGU+dHJ1ZTwvY29kZT4gaWYgdGhleSBhcmUgZXF1YWwsIDxjb2RlPmZhbHNlPC9jb2RlPiBvdGhlcndpc2UuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtQcm9wZXJ0eX0gW290aGVyXSBUaGUgb3RoZXIgcHJvcGVydHkuXHJcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgbGVmdCBhbmQgcmlnaHQgYXJlIGVxdWFsLCA8Y29kZT5mYWxzZTwvY29kZT4gb3RoZXJ3aXNlLlxyXG4gICAgICovXHJcbiAgICBQb2x5bGluZU91dGxpbmVNYXRlcmlhbFByb3BlcnR5LnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbihvdGhlcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzID09PSBvdGhlciB8fCAvL1xyXG4gICAgICAgICAgICAgICAob3RoZXIgaW5zdGFuY2VvZiBQb2x5bGluZU91dGxpbmVNYXRlcmlhbFByb3BlcnR5ICYmIC8vXHJcbiAgICAgICAgICAgICAgICBQcm9wZXJ0eS5lcXVhbHModGhpcy5fY29sb3IsIG90aGVyLl9jb2xvcikgJiYgLy9cclxuICAgICAgICAgICAgICAgIFByb3BlcnR5LmVxdWFscyh0aGlzLl9vdXRsaW5lQ29sb3IsIG90aGVyLl9vdXRsaW5lQ29sb3IpICYmIC8vXHJcbiAgICAgICAgICAgICAgICBQcm9wZXJ0eS5lcXVhbHModGhpcy5fb3V0bGluZVdpZHRoLCBvdGhlci5fb3V0bGluZVdpZHRoKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBQb2x5bGluZU91dGxpbmVNYXRlcmlhbFByb3BlcnR5O1xyXG59KTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvdGVycmlhanMtY2VzaXVtL1NvdXJjZS9EYXRhU291cmNlcy9Qb2x5bGluZU91dGxpbmVNYXRlcmlhbFByb3BlcnR5LmpzXG4vLyBtb2R1bGUgaWQgPSAxMjA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImRlZmluZShbXHJcbiAgICAgICAgJy4uL0NvcmUvZGVmaW5lZCcsXHJcbiAgICAgICAgJy4uL0NvcmUvZGVmaW5lUHJvcGVydGllcycsXHJcbiAgICAgICAgJy4uL0NvcmUvRGV2ZWxvcGVyRXJyb3InLFxyXG4gICAgICAgICcuLi9Db3JlL0V2ZW50JyxcclxuICAgICAgICAnLi4vQ29yZS9FdmVudEhlbHBlcicsXHJcbiAgICAgICAgJy4vUHJvcGVydHknXHJcbiAgICBdLCBmdW5jdGlvbihcclxuICAgICAgICBkZWZpbmVkLFxyXG4gICAgICAgIGRlZmluZVByb3BlcnRpZXMsXHJcbiAgICAgICAgRGV2ZWxvcGVyRXJyb3IsXHJcbiAgICAgICAgRXZlbnQsXHJcbiAgICAgICAgRXZlbnRIZWxwZXIsXHJcbiAgICAgICAgUHJvcGVydHkpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgICAvKipcclxuICAgICAqIEEge0BsaW5rIFByb3BlcnR5fSB3aG9zZSB2YWx1ZSBpcyBhbiBhcnJheSB3aG9zZSBpdGVtcyBhcmUgdGhlIGNvbXB1dGVkIHZhbHVlXHJcbiAgICAgKiBvZiBvdGhlciBwcm9wZXJ0eSBpbnN0YW5jZXMuXHJcbiAgICAgKlxyXG4gICAgICogQGFsaWFzIFByb3BlcnR5QXJyYXlcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UHJvcGVydHlbXX0gW3ZhbHVlXSBBbiBhcnJheSBvZiBQcm9wZXJ0eSBpbnN0YW5jZXMuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFByb3BlcnR5QXJyYXkodmFsdWUpIHtcclxuICAgICAgICB0aGlzLl92YWx1ZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLl9kZWZpbml0aW9uQ2hhbmdlZCA9IG5ldyBFdmVudCgpO1xyXG4gICAgICAgIHRoaXMuX2V2ZW50SGVscGVyID0gbmV3IEV2ZW50SGVscGVyKCk7XHJcbiAgICAgICAgdGhpcy5zZXRWYWx1ZSh2YWx1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgZGVmaW5lUHJvcGVydGllcyhQcm9wZXJ0eUFycmF5LnByb3RvdHlwZSwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgYSB2YWx1ZSBpbmRpY2F0aW5nIGlmIHRoaXMgcHJvcGVydHkgaXMgY29uc3RhbnQuICBUaGlzIHByb3BlcnR5XHJcbiAgICAgICAgICogaXMgY29uc2lkZXJlZCBjb25zdGFudCBpZiBhbGwgcHJvcGVydHkgaXRlbXMgaW4gdGhlIGFycmF5IGFyZSBjb25zdGFudC5cclxuICAgICAgICAgKiBAbWVtYmVyb2YgUHJvcGVydHlBcnJheS5wcm90b3R5cGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGlzQ29uc3RhbnQgOiB7XHJcbiAgICAgICAgICAgIGdldCA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5fdmFsdWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWRlZmluZWQodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghUHJvcGVydHkuaXNDb25zdGFudCh2YWx1ZVtpXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSBldmVudCB0aGF0IGlzIHJhaXNlZCB3aGVuZXZlciB0aGUgZGVmaW5pdGlvbiBvZiB0aGlzIHByb3BlcnR5IGNoYW5nZXMuXHJcbiAgICAgICAgICogVGhlIGRlZmluaXRpb24gaXMgY2hhbmdlZCB3aGVuZXZlciBzZXRWYWx1ZSBpcyBjYWxsZWQgd2l0aCBkYXRhIGRpZmZlcmVudFxyXG4gICAgICAgICAqIHRoYW4gdGhlIGN1cnJlbnQgdmFsdWUgb3Igb25lIG9mIHRoZSBwcm9wZXJ0aWVzIGluIHRoZSBhcnJheSBhbHNvIGNoYW5nZXMuXHJcbiAgICAgICAgICogQG1lbWJlcm9mIFByb3BlcnR5QXJyYXkucHJvdG90eXBlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAdHlwZSB7RXZlbnR9XHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZGVmaW5pdGlvbkNoYW5nZWQgOiB7XHJcbiAgICAgICAgICAgIGdldCA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZmluaXRpb25DaGFuZ2VkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtKdWxpYW5EYXRlfSB0aW1lIFRoZSB0aW1lIGZvciB3aGljaCB0byByZXRyaWV2ZSB0aGUgdmFsdWUuXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBbcmVzdWx0XSBUaGUgb2JqZWN0IHRvIHN0b3JlIHRoZSB2YWx1ZSBpbnRvLCBpZiBvbWl0dGVkLCBhIG5ldyBpbnN0YW5jZSBpcyBjcmVhdGVkIGFuZCByZXR1cm5lZC5cclxuICAgICAqIEByZXR1cm5zIHtPYmplY3RbXX0gVGhlIG1vZGlmaWVkIHJlc3VsdCBwYXJhbWV0ZXIsIHdoaWNoIGlzIGFuIGFycmF5IG9mIHZhbHVlcyBwcm9kdWNlZCBieSBldmFsdWF0aW5nIGVhY2ggb2YgdGhlIGNvbnRhaW5lZCBwcm9wZXJ0aWVzIGF0IHRoZSBnaXZlbiB0aW1lIG9yIGEgbmV3IGluc3RhbmNlIGlmIHRoZSByZXN1bHQgcGFyYW1ldGVyIHdhcyBub3Qgc3VwcGxpZWQuXHJcbiAgICAgKi9cclxuICAgIFByb3BlcnR5QXJyYXkucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24odGltZSwgcmVzdWx0KSB7XHJcbiAgICAgICAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcclxuICAgICAgICBpZiAoIWRlZmluZWQodGltZSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKCd0aW1lIGlzIHJlcXVpcmVkLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcclxuXHJcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5fdmFsdWU7XHJcbiAgICAgICAgaWYgKCFkZWZpbmVkKHZhbHVlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcclxuICAgICAgICBpZiAoIWRlZmluZWQocmVzdWx0KSkge1xyXG4gICAgICAgICAgICByZXN1bHQgPSBuZXcgQXJyYXkobGVuZ3RoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgIHZhciB4ID0gMDtcclxuICAgICAgICB3aGlsZSAoaSA8IGxlbmd0aCkge1xyXG4gICAgICAgICAgICB2YXIgcHJvcGVydHkgPSB0aGlzLl92YWx1ZVtpXTtcclxuICAgICAgICAgICAgdmFyIGl0ZW1WYWx1ZSA9IHByb3BlcnR5LmdldFZhbHVlKHRpbWUsIHJlc3VsdFtpXSk7XHJcbiAgICAgICAgICAgIGlmIChkZWZpbmVkKGl0ZW1WYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdFt4XSA9IGl0ZW1WYWx1ZTtcclxuICAgICAgICAgICAgICAgIHgrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc3VsdC5sZW5ndGggPSB4O1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgdmFsdWUgb2YgdGhlIHByb3BlcnR5LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UHJvcGVydHlbXX0gdmFsdWUgQW4gYXJyYXkgb2YgUHJvcGVydHkgaW5zdGFuY2VzLlxyXG4gICAgICovXHJcbiAgICBQcm9wZXJ0eUFycmF5LnByb3RvdHlwZS5zZXRWYWx1ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIGV2ZW50SGVscGVyID0gdGhpcy5fZXZlbnRIZWxwZXI7XHJcbiAgICAgICAgZXZlbnRIZWxwZXIucmVtb3ZlQWxsKCk7XHJcblxyXG4gICAgICAgIGlmIChkZWZpbmVkKHZhbHVlKSkge1xyXG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlLnNsaWNlKCk7XHJcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eSA9IHZhbHVlW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRlZmluZWQocHJvcGVydHkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRIZWxwZXIuYWRkKHByb3BlcnR5LmRlZmluaXRpb25DaGFuZ2VkLCBQcm9wZXJ0eUFycmF5LnByb3RvdHlwZS5fcmFpc2VEZWZpbml0aW9uQ2hhbmdlZCwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fZGVmaW5pdGlvbkNoYW5nZWQucmFpc2VFdmVudCh0aGlzKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wYXJlcyB0aGlzIHByb3BlcnR5IHRvIHRoZSBwcm92aWRlZCBwcm9wZXJ0eSBhbmQgcmV0dXJuc1xyXG4gICAgICogPGNvZGU+dHJ1ZTwvY29kZT4gaWYgdGhleSBhcmUgZXF1YWwsIDxjb2RlPmZhbHNlPC9jb2RlPiBvdGhlcndpc2UuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtQcm9wZXJ0eX0gW290aGVyXSBUaGUgb3RoZXIgcHJvcGVydHkuXHJcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgbGVmdCBhbmQgcmlnaHQgYXJlIGVxdWFsLCA8Y29kZT5mYWxzZTwvY29kZT4gb3RoZXJ3aXNlLlxyXG4gICAgICovXHJcbiAgICBQcm9wZXJ0eUFycmF5LnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbihvdGhlcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzID09PSBvdGhlciB8fCAvL1xyXG4gICAgICAgICAgICAgICAob3RoZXIgaW5zdGFuY2VvZiBQcm9wZXJ0eUFycmF5ICYmIC8vXHJcbiAgICAgICAgICAgICAgICBQcm9wZXJ0eS5hcnJheUVxdWFscyh0aGlzLl92YWx1ZSwgb3RoZXIuX3ZhbHVlKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIFByb3BlcnR5QXJyYXkucHJvdG90eXBlLl9yYWlzZURlZmluaXRpb25DaGFuZ2VkID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5fZGVmaW5pdGlvbkNoYW5nZWQucmFpc2VFdmVudCh0aGlzKTtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIFByb3BlcnR5QXJyYXk7XHJcbn0pO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy90ZXJyaWFqcy1jZXNpdW0vU291cmNlL0RhdGFTb3VyY2VzL1Byb3BlcnR5QXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDEyMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZGVmaW5lKFtcclxuICAgICAgICAnLi4vQ29yZS9kZWZhdWx0VmFsdWUnLFxyXG4gICAgICAgICcuLi9Db3JlL2RlZmluZWQnLFxyXG4gICAgICAgICcuLi9Db3JlL0RldmVsb3BlckVycm9yJyxcclxuICAgICAgICAnLi4vQ29yZS9NYXRoJ1xyXG4gICAgXSwgZnVuY3Rpb24oXHJcbiAgICAgICAgZGVmYXVsdFZhbHVlLFxyXG4gICAgICAgIGRlZmluZWQsXHJcbiAgICAgICAgRGV2ZWxvcGVyRXJyb3IsXHJcbiAgICAgICAgQ2VzaXVtTWF0aCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVwcmVzZW50cyBhIHtAbGluayBQYWNrYWJsZX0gbnVtYmVyIHRoYXQgYWx3YXlzIGludGVycG9sYXRlcyB2YWx1ZXNcclxuICAgICAqIHRvd2FyZHMgdGhlIHNob3J0ZXN0IGFuZ2xlIG9mIHJvdGF0aW9uLiBUaGlzIG9iamVjdCBpcyBuZXZlciB1c2VkIGRpcmVjdGx5XHJcbiAgICAgKiBidXQgaXMgaW5zdGVhZCBwYXNzZWQgdG8gdGhlIGNvbnN0cnVjdG9yIG9mIHtAbGluayBTYW1wbGVkUHJvcGVydHl9XHJcbiAgICAgKiBpbiBvcmRlciB0byByZXByZXNlbnQgYSB0d28tZGltZW5zaW9uYWwgYW5nbGUgb2Ygcm90YXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQGV4cG9ydHMgUm90YXRpb25cclxuICAgICAqXHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIHZhciB0aW1lMSA9IENlc2l1bS5KdWxpYW5EYXRlLmZyb21Jc284NjAxKCcyMDEwLTA1LTA3VDAwOjAwOjAwJyk7XHJcbiAgICAgKiB2YXIgdGltZTIgPSBDZXNpdW0uSnVsaWFuRGF0ZS5mcm9tSXNvODYwMSgnMjAxMC0wNS0wN1QwMDowMTowMCcpO1xyXG4gICAgICogdmFyIHRpbWUzID0gQ2VzaXVtLkp1bGlhbkRhdGUuZnJvbUlzbzg2MDEoJzIwMTAtMDUtMDdUMDA6MDI6MDAnKTtcclxuICAgICAqXHJcbiAgICAgKiB2YXIgcHJvcGVydHkgPSBuZXcgQ2VzaXVtLlNhbXBsZWRQcm9wZXJ0eShDZXNpdW0uUm90YXRpb24pO1xyXG4gICAgICogcHJvcGVydHkuYWRkU2FtcGxlKHRpbWUxLCAwKTtcclxuICAgICAqIHByb3BlcnR5LmFkZFNhbXBsZSh0aW1lMywgQ2VzaXVtLk1hdGgudG9SYWRpYW5zKDM1MCkpO1xyXG4gICAgICpcclxuICAgICAqIC8vR2V0dGluZyB0aGUgdmFsdWUgYXQgdGltZTIgd2lsbCBlcXVhbCAzNTUgZGVncmVlcyBpbnN0ZWFkXHJcbiAgICAgKiAvL29mIDE3NSBkZWdyZWVzICh3aGljaCBpcyB3aGF0IHlvdSBnZXQgaWYgeW91IGNvbnN0cnVjdFxyXG4gICAgICogLy9hIFNhbXBsZWRQcm9wZXJ0eShOdW1iZXIpIGluc3RlYWQuICBOb3RlLCB0aGUgYWN0dWFsXHJcbiAgICAgKiAvL3JldHVybiB2YWx1ZSBpcyBpbiByYWRpYW5zLCBub3QgZGVncmVlcy5cclxuICAgICAqIHByb3BlcnR5LmdldFZhbHVlKHRpbWUyKTtcclxuICAgICAqXHJcbiAgICAgKiBAc2VlIFBhY2thYmxlRm9ySW50ZXJwb2xhdGlvblxyXG4gICAgICovXHJcbiAgICB2YXIgUm90YXRpb24gPSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIG51bWJlciBvZiBlbGVtZW50cyB1c2VkIHRvIHBhY2sgdGhlIG9iamVjdCBpbnRvIGFuIGFycmF5LlxyXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcGFja2VkTGVuZ3RoIDogMSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU3RvcmVzIHRoZSBwcm92aWRlZCBpbnN0YW5jZSBpbnRvIHRoZSBwcm92aWRlZCBhcnJheS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7Um90YXRpb259IHZhbHVlIFRoZSB2YWx1ZSB0byBwYWNrLlxyXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyW119IGFycmF5IFRoZSBhcnJheSB0byBwYWNrIGludG8uXHJcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtzdGFydGluZ0luZGV4PTBdIFRoZSBpbmRleCBpbnRvIHRoZSBhcnJheSBhdCB3aGljaCB0byBzdGFydCBwYWNraW5nIHRoZSBlbGVtZW50cy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtOdW1iZXJbXX0gVGhlIGFycmF5IHRoYXQgd2FzIHBhY2tlZCBpbnRvXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcGFjayA6IGZ1bmN0aW9uKHZhbHVlLCBhcnJheSwgc3RhcnRpbmdJbmRleCkge1xyXG4gICAgICAgICAgICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xyXG4gICAgICAgICAgICBpZiAoIWRlZmluZWQodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoJ3ZhbHVlIGlzIHJlcXVpcmVkJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICghZGVmaW5lZChhcnJheSkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcignYXJyYXkgaXMgcmVxdWlyZWQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcclxuXHJcbiAgICAgICAgICAgIHN0YXJ0aW5nSW5kZXggPSBkZWZhdWx0VmFsdWUoc3RhcnRpbmdJbmRleCwgMCk7XHJcbiAgICAgICAgICAgIGFycmF5W3N0YXJ0aW5nSW5kZXhdID0gdmFsdWU7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYXJyYXk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0cmlldmVzIGFuIGluc3RhbmNlIGZyb20gYSBwYWNrZWQgYXJyYXkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcltdfSBhcnJheSBUaGUgcGFja2VkIGFycmF5LlxyXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbc3RhcnRpbmdJbmRleD0wXSBUaGUgc3RhcnRpbmcgaW5kZXggb2YgdGhlIGVsZW1lbnQgdG8gYmUgdW5wYWNrZWQuXHJcbiAgICAgICAgICogQHBhcmFtIHtSb3RhdGlvbn0gW3Jlc3VsdF0gVGhlIG9iamVjdCBpbnRvIHdoaWNoIHRvIHN0b3JlIHRoZSByZXN1bHQuXHJcbiAgICAgICAgICogQHJldHVybnMge1JvdGF0aW9ufSBUaGUgbW9kaWZpZWQgcmVzdWx0IHBhcmFtZXRlciBvciBhIG5ldyBSb3RhdGlvbiBpbnN0YW5jZSBpZiBvbmUgd2FzIG5vdCBwcm92aWRlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB1bnBhY2sgOiBmdW5jdGlvbihhcnJheSwgc3RhcnRpbmdJbmRleCwgcmVzdWx0KSB7XHJcbiAgICAgICAgICAgIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XHJcbiAgICAgICAgICAgIGlmICghZGVmaW5lZChhcnJheSkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcignYXJyYXkgaXMgcmVxdWlyZWQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcclxuXHJcbiAgICAgICAgICAgIHN0YXJ0aW5nSW5kZXggPSBkZWZhdWx0VmFsdWUoc3RhcnRpbmdJbmRleCwgMCk7XHJcbiAgICAgICAgICAgIHJldHVybiBhcnJheVtzdGFydGluZ0luZGV4XTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb252ZXJ0cyBhIHBhY2tlZCBhcnJheSBpbnRvIGEgZm9ybSBzdWl0YWJsZSBmb3IgaW50ZXJwb2xhdGlvbi5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyW119IHBhY2tlZEFycmF5IFRoZSBwYWNrZWQgYXJyYXkuXHJcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtzdGFydGluZ0luZGV4PTBdIFRoZSBpbmRleCBvZiB0aGUgZmlyc3QgZWxlbWVudCB0byBiZSBjb252ZXJ0ZWQuXHJcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtsYXN0SW5kZXg9cGFja2VkQXJyYXkubGVuZ3RoXSBUaGUgaW5kZXggb2YgdGhlIGxhc3QgZWxlbWVudCB0byBiZSBjb252ZXJ0ZWQuXHJcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJbXX0gcmVzdWx0IFRoZSBvYmplY3QgaW50byB3aGljaCB0byBzdG9yZSB0aGUgcmVzdWx0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNvbnZlcnRQYWNrZWRBcnJheUZvckludGVycG9sYXRpb24gOiBmdW5jdGlvbihwYWNrZWRBcnJheSwgc3RhcnRpbmdJbmRleCwgbGFzdEluZGV4LCByZXN1bHQpIHtcclxuICAgICAgICAgICAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcclxuICAgICAgICAgICAgaWYgKCFkZWZpbmVkKHBhY2tlZEFycmF5KSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKCdwYWNrZWRBcnJheSBpcyByZXF1aXJlZCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xyXG5cclxuICAgICAgICAgICAgc3RhcnRpbmdJbmRleCA9IGRlZmF1bHRWYWx1ZShzdGFydGluZ0luZGV4LCAwKTtcclxuICAgICAgICAgICAgbGFzdEluZGV4ID0gZGVmYXVsdFZhbHVlKGxhc3RJbmRleCwgcGFja2VkQXJyYXkubGVuZ3RoKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBwcmV2aW91c1ZhbHVlO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbGFzdEluZGV4IC0gc3RhcnRpbmdJbmRleCArIDE7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gcGFja2VkQXJyYXlbc3RhcnRpbmdJbmRleCArIGldO1xyXG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IDAgfHwgTWF0aC5hYnMocHJldmlvdXNWYWx1ZSAtIHZhbHVlKSA8IE1hdGguUEkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2ldID0gdmFsdWUgLSBDZXNpdW1NYXRoLlRXT19QSTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHByZXZpb3VzVmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHJpZXZlcyBhbiBpbnN0YW5jZSBmcm9tIGEgcGFja2VkIGFycmF5IGNvbnZlcnRlZCB3aXRoIHtAbGluayBSb3RhdGlvbi5jb252ZXJ0UGFja2VkQXJyYXlGb3JJbnRlcnBvbGF0aW9ufS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyW119IGFycmF5IFRoZSBhcnJheSBwcmV2aW91c2x5IHBhY2tlZCBmb3IgaW50ZXJwb2xhdGlvbi5cclxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcltdfSBzb3VyY2VBcnJheSBUaGUgb3JpZ2luYWwgcGFja2VkIGFycmF5LlxyXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbZmlyc3RJbmRleD0wXSBUaGUgZmlyc3RJbmRleCB1c2VkIHRvIGNvbnZlcnQgdGhlIGFycmF5LlxyXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbbGFzdEluZGV4PXBhY2tlZEFycmF5Lmxlbmd0aF0gVGhlIGxhc3RJbmRleCB1c2VkIHRvIGNvbnZlcnQgdGhlIGFycmF5LlxyXG4gICAgICAgICAqIEBwYXJhbSB7Um90YXRpb259IFtyZXN1bHRdIFRoZSBvYmplY3QgaW50byB3aGljaCB0byBzdG9yZSB0aGUgcmVzdWx0LlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtSb3RhdGlvbn0gVGhlIG1vZGlmaWVkIHJlc3VsdCBwYXJhbWV0ZXIgb3IgYSBuZXcgUm90YXRpb24gaW5zdGFuY2UgaWYgb25lIHdhcyBub3QgcHJvdmlkZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdW5wYWNrSW50ZXJwb2xhdGlvblJlc3VsdCA6IGZ1bmN0aW9uKGFycmF5LCBzb3VyY2VBcnJheSwgZmlyc3RJbmRleCwgbGFzdEluZGV4LCByZXN1bHQpIHtcclxuICAgICAgICAgICAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcclxuICAgICAgICAgICAgaWYgKCFkZWZpbmVkKGFycmF5KSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKCdhcnJheSBpcyByZXF1aXJlZCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghZGVmaW5lZChzb3VyY2VBcnJheSkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcignc291cmNlQXJyYXkgaXMgcmVxdWlyZWQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcclxuXHJcbiAgICAgICAgICAgIHJlc3VsdCA9IGFycmF5WzBdO1xyXG4gICAgICAgICAgICBpZiAocmVzdWx0IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArIENlc2l1bU1hdGguVFdPX1BJO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gUm90YXRpb247XHJcbn0pO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy90ZXJyaWFqcy1jZXNpdW0vU291cmNlL0RhdGFTb3VyY2VzL1JvdGF0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImRlZmluZShbXHJcbiAgICAgICAgJy4uL0NvcmUvQ29sb3InLFxyXG4gICAgICAgICcuLi9Db3JlL2RlZmF1bHRWYWx1ZScsXHJcbiAgICAgICAgJy4uL0NvcmUvZGVmaW5lZCcsXHJcbiAgICAgICAgJy4uL0NvcmUvZGVmaW5lUHJvcGVydGllcycsXHJcbiAgICAgICAgJy4uL0NvcmUvRXZlbnQnLFxyXG4gICAgICAgICcuL2NyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcicsXHJcbiAgICAgICAgJy4vUHJvcGVydHknLFxyXG4gICAgICAgICcuL1N0cmlwZU9yaWVudGF0aW9uJ1xyXG4gICAgXSwgZnVuY3Rpb24oXHJcbiAgICAgICAgQ29sb3IsXHJcbiAgICAgICAgZGVmYXVsdFZhbHVlLFxyXG4gICAgICAgIGRlZmluZWQsXHJcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyxcclxuICAgICAgICBFdmVudCxcclxuICAgICAgICBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IsXHJcbiAgICAgICAgUHJvcGVydHksXHJcbiAgICAgICAgU3RyaXBlT3JpZW50YXRpb24pIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgICB2YXIgZGVmYXVsdE9yaWVudGF0aW9uID0gU3RyaXBlT3JpZW50YXRpb24uSE9SSVpPTlRBTDtcclxuICAgIHZhciBkZWZhdWx0RXZlbkNvbG9yID0gQ29sb3IuV0hJVEU7XHJcbiAgICB2YXIgZGVmYXVsdE9kZENvbG9yID0gQ29sb3IuQkxBQ0s7XHJcbiAgICB2YXIgZGVmYXVsdE9mZnNldCA9IDA7XHJcbiAgICB2YXIgZGVmYXVsdFJlcGVhdCA9IDE7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIHtAbGluayBNYXRlcmlhbFByb3BlcnR5fSB0aGF0IG1hcHMgdG8gc3RyaXBlIHtAbGluayBNYXRlcmlhbH0gdW5pZm9ybXMuXHJcbiAgICAgKiBAYWxpYXMgU3RyaXBlTWF0ZXJpYWxQcm9wZXJ0eVxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XHJcbiAgICAgKiBAcGFyYW0ge1Byb3BlcnR5fSBbb3B0aW9ucy5ldmVuQ29sb3I9Q29sb3IuV0hJVEVdIEEgUHJvcGVydHkgc3BlY2lmeWluZyB0aGUgZmlyc3Qge0BsaW5rIENvbG9yfS5cclxuICAgICAqIEBwYXJhbSB7UHJvcGVydHl9IFtvcHRpb25zLm9kZENvbG9yPUNvbG9yLkJMQUNLXSBBIFByb3BlcnR5IHNwZWNpZnlpbmcgdGhlIHNlY29uZCB7QGxpbmsgQ29sb3J9LlxyXG4gICAgICogQHBhcmFtIHtQcm9wZXJ0eX0gW29wdGlvbnMucmVwZWF0PTFdIEEgbnVtZXJpYyBQcm9wZXJ0eSBzcGVjaWZ5aW5nIGhvdyBtYW55IHRpbWVzIHRoZSBzdHJpcGVzIHJlcGVhdC5cclxuICAgICAqIEBwYXJhbSB7UHJvcGVydHl9IFtvcHRpb25zLm9mZnNldD0wXSBBIG51bWVyaWMgUHJvcGVydHkgc3BlY2lmeWluZyBob3cgZmFyIGludG8gdGhlIHBhdHRlcm4gdG8gc3RhcnQgdGhlIG1hdGVyaWFsLlxyXG4gICAgICogQHBhcmFtIHtQcm9wZXJ0eX0gW29wdGlvbnMub3JpZW50YXRpb249U3RyaXBlT3JpZW50YXRpb24uSE9SSVpPTlRBTF0gQSBQcm9wZXJ0eSBzcGVjaWZ5aW5nIHRoZSB7QGxpbmsgU3RyaXBlT3JpZW50YXRpb259LlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBTdHJpcGVNYXRlcmlhbFByb3BlcnR5KG9wdGlvbnMpIHtcclxuICAgICAgICBvcHRpb25zID0gZGVmYXVsdFZhbHVlKG9wdGlvbnMsIGRlZmF1bHRWYWx1ZS5FTVBUWV9PQkpFQ1QpO1xyXG5cclxuICAgICAgICB0aGlzLl9kZWZpbml0aW9uQ2hhbmdlZCA9IG5ldyBFdmVudCgpO1xyXG5cclxuICAgICAgICB0aGlzLl9vcmllbnRhdGlvbiA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLl9vcmllbnRhdGlvblN1YnNjcmlwdGlvbiA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgdGhpcy5fZXZlbkNvbG9yID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuX2V2ZW5Db2xvclN1YnNjcmlwdGlvbiA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgdGhpcy5fb2RkQ29sb3IgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5fb2RkQ29sb3JTdWJzY3JpcHRpb24gPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgIHRoaXMuX29mZnNldCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLl9vZmZzZXRTdWJzY3JpcHRpb24gPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgIHRoaXMuX3JlcGVhdCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLl9yZXBlYXRTdWJzY3JpcHRpb24gPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgIHRoaXMub3JpZW50YXRpb24gPSBvcHRpb25zLm9yaWVudGF0aW9uO1xyXG4gICAgICAgIHRoaXMuZXZlbkNvbG9yID0gb3B0aW9ucy5ldmVuQ29sb3I7XHJcbiAgICAgICAgdGhpcy5vZGRDb2xvciA9IG9wdGlvbnMub2RkQ29sb3I7XHJcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBvcHRpb25zLm9mZnNldDtcclxuICAgICAgICB0aGlzLnJlcGVhdCA9IG9wdGlvbnMucmVwZWF0O1xyXG4gICAgfVxyXG5cclxuICAgIGRlZmluZVByb3BlcnRpZXMoU3RyaXBlTWF0ZXJpYWxQcm9wZXJ0eS5wcm90b3R5cGUsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIGEgdmFsdWUgaW5kaWNhdGluZyBpZiB0aGlzIHByb3BlcnR5IGlzIGNvbnN0YW50LiAgQSBwcm9wZXJ0eSBpcyBjb25zaWRlcmVkXHJcbiAgICAgICAgICogY29uc3RhbnQgaWYgZ2V0VmFsdWUgYWx3YXlzIHJldHVybnMgdGhlIHNhbWUgcmVzdWx0IGZvciB0aGUgY3VycmVudCBkZWZpbml0aW9uLlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBTdHJpcGVNYXRlcmlhbFByb3BlcnR5LnByb3RvdHlwZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaXNDb25zdGFudCA6IHtcclxuICAgICAgICAgICAgZ2V0IDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvcGVydHkuaXNDb25zdGFudCh0aGlzLl9vcmllbnRhdGlvbikgJiYgLy9cclxuICAgICAgICAgICAgICAgICAgICAgICBQcm9wZXJ0eS5pc0NvbnN0YW50KHRoaXMuX2V2ZW5Db2xvcikgJiYgLy9cclxuICAgICAgICAgICAgICAgICAgICAgICBQcm9wZXJ0eS5pc0NvbnN0YW50KHRoaXMuX29kZENvbG9yKSAmJiAvL1xyXG4gICAgICAgICAgICAgICAgICAgICAgIFByb3BlcnR5LmlzQ29uc3RhbnQodGhpcy5fb2Zmc2V0KSAmJiAvL1xyXG4gICAgICAgICAgICAgICAgICAgICAgIFByb3BlcnR5LmlzQ29uc3RhbnQodGhpcy5fcmVwZWF0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgZXZlbnQgdGhhdCBpcyByYWlzZWQgd2hlbmV2ZXIgdGhlIGRlZmluaXRpb24gb2YgdGhpcyBwcm9wZXJ0eSBjaGFuZ2VzLlxyXG4gICAgICAgICAqIFRoZSBkZWZpbml0aW9uIGlzIGNvbnNpZGVyZWQgdG8gaGF2ZSBjaGFuZ2VkIGlmIGEgY2FsbCB0byBnZXRWYWx1ZSB3b3VsZCByZXR1cm5cclxuICAgICAgICAgKiBhIGRpZmZlcmVudCByZXN1bHQgZm9yIHRoZSBzYW1lIHRpbWUuXHJcbiAgICAgICAgICogQG1lbWJlcm9mIFN0cmlwZU1hdGVyaWFsUHJvcGVydHkucHJvdG90eXBlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAdHlwZSB7RXZlbnR9XHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZGVmaW5pdGlvbkNoYW5nZWQgOiB7XHJcbiAgICAgICAgICAgIGdldCA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZmluaXRpb25DaGFuZ2VkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIFByb3BlcnR5IHNwZWNpZnlpbmcgdGhlIHtAbGluayBTdHJpcGVPcmllbnRhdGlvbn0vXHJcbiAgICAgICAgICogQG1lbWJlcm9mIFN0cmlwZU1hdGVyaWFsUHJvcGVydHkucHJvdG90eXBlXHJcbiAgICAgICAgICogQHR5cGUge1Byb3BlcnR5fVxyXG4gICAgICAgICAqIEBkZWZhdWx0IFN0cmlwZU9yaWVudGF0aW9uLkhPUklaT05UQUxcclxuICAgICAgICAgKi9cclxuICAgICAgICBvcmllbnRhdGlvbiA6IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcignb3JpZW50YXRpb24nKSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIFByb3BlcnR5IHNwZWNpZnlpbmcgdGhlIGZpcnN0IHtAbGluayBDb2xvcn0uXHJcbiAgICAgICAgICogQG1lbWJlcm9mIFN0cmlwZU1hdGVyaWFsUHJvcGVydHkucHJvdG90eXBlXHJcbiAgICAgICAgICogQHR5cGUge1Byb3BlcnR5fVxyXG4gICAgICAgICAqIEBkZWZhdWx0IENvbG9yLldISVRFXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZXZlbkNvbG9yIDogY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKCdldmVuQ29sb3InKSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIFByb3BlcnR5IHNwZWNpZnlpbmcgdGhlIHNlY29uZCB7QGxpbmsgQ29sb3J9LlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBTdHJpcGVNYXRlcmlhbFByb3BlcnR5LnByb3RvdHlwZVxyXG4gICAgICAgICAqIEB0eXBlIHtQcm9wZXJ0eX1cclxuICAgICAgICAgKiBAZGVmYXVsdCBDb2xvci5CTEFDS1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIG9kZENvbG9yIDogY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKCdvZGRDb2xvcicpLFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgbnVtZXJpYyBQcm9wZXJ0eSBzcGVjaWZ5aW5nIHRoZSBwb2ludCBpbnRvIHRoZSBwYXR0ZXJuXHJcbiAgICAgICAgICogdG8gYmVnaW4gZHJhd2luZzsgd2l0aCAwLjAgYmVpbmcgdGhlIGJlZ2lubmluZyBvZiB0aGUgZXZlbiBjb2xvciwgMS4wIHRoZSBiZWdpbm5pbmdcclxuICAgICAgICAgKiBvZiB0aGUgb2RkIGNvbG9yLCAyLjAgYmVpbmcgdGhlIGV2ZW4gY29sb3IgYWdhaW4sIGFuZCBhbnkgbXVsdGlwbGUgb3IgZnJhY3Rpb25hbCB2YWx1ZXNcclxuICAgICAgICAgKiBiZWluZyBpbiBiZXR3ZWVuLlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBTdHJpcGVNYXRlcmlhbFByb3BlcnR5LnByb3RvdHlwZVxyXG4gICAgICAgICAqIEB0eXBlIHtQcm9wZXJ0eX1cclxuICAgICAgICAgKiBAZGVmYXVsdCAwLjBcclxuICAgICAgICAgKi9cclxuICAgICAgICBvZmZzZXQgOiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoJ29mZnNldCcpLFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgbnVtZXJpYyBQcm9wZXJ0eSBzcGVjaWZ5aW5nIGhvdyBtYW55IHRpbWVzIHRoZSBzdHJpcGVzIHJlcGVhdC5cclxuICAgICAgICAgKiBAbWVtYmVyb2YgU3RyaXBlTWF0ZXJpYWxQcm9wZXJ0eS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAdHlwZSB7UHJvcGVydHl9XHJcbiAgICAgICAgICogQGRlZmF1bHQgMS4wXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcmVwZWF0IDogY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKCdyZXBlYXQnKVxyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSB7QGxpbmsgTWF0ZXJpYWx9IHR5cGUgYXQgdGhlIHByb3ZpZGVkIHRpbWUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtKdWxpYW5EYXRlfSB0aW1lIFRoZSB0aW1lIGZvciB3aGljaCB0byByZXRyaWV2ZSB0aGUgdHlwZS5cclxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSB0eXBlIG9mIG1hdGVyaWFsLlxyXG4gICAgICovXHJcbiAgICBTdHJpcGVNYXRlcmlhbFByb3BlcnR5LnByb3RvdHlwZS5nZXRUeXBlID0gZnVuY3Rpb24odGltZSkge1xyXG4gICAgICAgIHJldHVybiAnU3RyaXBlJztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgYXQgdGhlIHByb3ZpZGVkIHRpbWUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtKdWxpYW5EYXRlfSB0aW1lIFRoZSB0aW1lIGZvciB3aGljaCB0byByZXRyaWV2ZSB0aGUgdmFsdWUuXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3Jlc3VsdF0gVGhlIG9iamVjdCB0byBzdG9yZSB0aGUgdmFsdWUgaW50bywgaWYgb21pdHRlZCwgYSBuZXcgaW5zdGFuY2UgaXMgY3JlYXRlZCBhbmQgcmV0dXJuZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgbW9kaWZpZWQgcmVzdWx0IHBhcmFtZXRlciBvciBhIG5ldyBpbnN0YW5jZSBpZiB0aGUgcmVzdWx0IHBhcmFtZXRlciB3YXMgbm90IHN1cHBsaWVkLlxyXG4gICAgICovXHJcbiAgICBTdHJpcGVNYXRlcmlhbFByb3BlcnR5LnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uKHRpbWUsIHJlc3VsdCkge1xyXG4gICAgICAgIGlmICghZGVmaW5lZChyZXN1bHQpKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHt9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXN1bHQuaG9yaXpvbnRhbCA9IFByb3BlcnR5LmdldFZhbHVlT3JEZWZhdWx0KHRoaXMuX29yaWVudGF0aW9uLCB0aW1lLCBkZWZhdWx0T3JpZW50YXRpb24pID09PSBTdHJpcGVPcmllbnRhdGlvbi5IT1JJWk9OVEFMO1xyXG4gICAgICAgIHJlc3VsdC5ldmVuQ29sb3IgPSBQcm9wZXJ0eS5nZXRWYWx1ZU9yQ2xvbmVkRGVmYXVsdCh0aGlzLl9ldmVuQ29sb3IsIHRpbWUsIGRlZmF1bHRFdmVuQ29sb3IsIHJlc3VsdC5ldmVuQ29sb3IpO1xyXG4gICAgICAgIHJlc3VsdC5vZGRDb2xvciA9IFByb3BlcnR5LmdldFZhbHVlT3JDbG9uZWREZWZhdWx0KHRoaXMuX29kZENvbG9yLCB0aW1lLCBkZWZhdWx0T2RkQ29sb3IsIHJlc3VsdC5vZGRDb2xvcik7XHJcbiAgICAgICAgcmVzdWx0Lm9mZnNldCA9IFByb3BlcnR5LmdldFZhbHVlT3JEZWZhdWx0KHRoaXMuX29mZnNldCwgdGltZSwgZGVmYXVsdE9mZnNldCk7XHJcbiAgICAgICAgcmVzdWx0LnJlcGVhdCA9IFByb3BlcnR5LmdldFZhbHVlT3JEZWZhdWx0KHRoaXMuX3JlcGVhdCwgdGltZSwgZGVmYXVsdFJlcGVhdCk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wYXJlcyB0aGlzIHByb3BlcnR5IHRvIHRoZSBwcm92aWRlZCBwcm9wZXJ0eSBhbmQgcmV0dXJuc1xyXG4gICAgICogPGNvZGU+dHJ1ZTwvY29kZT4gaWYgdGhleSBhcmUgZXF1YWwsIDxjb2RlPmZhbHNlPC9jb2RlPiBvdGhlcndpc2UuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtQcm9wZXJ0eX0gW290aGVyXSBUaGUgb3RoZXIgcHJvcGVydHkuXHJcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgbGVmdCBhbmQgcmlnaHQgYXJlIGVxdWFsLCA8Y29kZT5mYWxzZTwvY29kZT4gb3RoZXJ3aXNlLlxyXG4gICAgICovXHJcbiAgICBTdHJpcGVNYXRlcmlhbFByb3BlcnR5LnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbihvdGhlcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzID09PSBvdGhlciB8fCAvL1xyXG4gICAgICAgICAgICAgICAob3RoZXIgaW5zdGFuY2VvZiBTdHJpcGVNYXRlcmlhbFByb3BlcnR5ICYmIC8vXHJcbiAgICAgICAgICAgICAgICAgICAgICAgUHJvcGVydHkuZXF1YWxzKHRoaXMuX29yaWVudGF0aW9uLCBvdGhlci5fb3JpZW50YXRpb24pICYmIC8vXHJcbiAgICAgICAgICAgICAgICAgICAgICAgUHJvcGVydHkuZXF1YWxzKHRoaXMuX2V2ZW5Db2xvciwgb3RoZXIuX2V2ZW5Db2xvcikgJiYgLy9cclxuICAgICAgICAgICAgICAgICAgICAgICBQcm9wZXJ0eS5lcXVhbHModGhpcy5fb2RkQ29sb3IsIG90aGVyLl9vZGRDb2xvcikgJiYgLy9cclxuICAgICAgICAgICAgICAgICAgICAgICBQcm9wZXJ0eS5lcXVhbHModGhpcy5fb2Zmc2V0LCBvdGhlci5fb2Zmc2V0KSAmJiAvL1xyXG4gICAgICAgICAgICAgICAgICAgICAgIFByb3BlcnR5LmVxdWFscyh0aGlzLl9yZXBlYXQsIG90aGVyLl9yZXBlYXQpKTtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIFN0cmlwZU1hdGVyaWFsUHJvcGVydHk7XHJcbn0pO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy90ZXJyaWFqcy1jZXNpdW0vU291cmNlL0RhdGFTb3VyY2VzL1N0cmlwZU1hdGVyaWFsUHJvcGVydHkuanNcbi8vIG1vZHVsZSBpZCA9IDEyMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZGVmaW5lKFtcclxuICAgICAgICAnLi4vQ29yZS9DYXJ0ZXNpYW4zJyxcclxuICAgICAgICAnLi4vQ29yZS9kZWZhdWx0VmFsdWUnLFxyXG4gICAgICAgICcuLi9Db3JlL2RlZmluZWQnLFxyXG4gICAgICAgICcuLi9Db3JlL2RlZmluZVByb3BlcnRpZXMnLFxyXG4gICAgICAgICcuLi9Db3JlL0VsbGlwc29pZCcsXHJcbiAgICAgICAgJy4uL0NvcmUvRXZlbnQnLFxyXG4gICAgICAgICcuLi9Db3JlL01hdHJpeDMnLFxyXG4gICAgICAgICcuLi9Db3JlL1F1YXRlcm5pb24nLFxyXG4gICAgICAgICcuLi9Db3JlL1RyYW5zZm9ybXMnLFxyXG4gICAgICAgICcuL1Byb3BlcnR5JyxcclxuICAgICAgICAnLi9WZWxvY2l0eVZlY3RvclByb3BlcnR5J1xyXG4gICAgXSwgZnVuY3Rpb24oXHJcbiAgICAgICAgQ2FydGVzaWFuMyxcclxuICAgICAgICBkZWZhdWx0VmFsdWUsXHJcbiAgICAgICAgZGVmaW5lZCxcclxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzLFxyXG4gICAgICAgIEVsbGlwc29pZCxcclxuICAgICAgICBFdmVudCxcclxuICAgICAgICBNYXRyaXgzLFxyXG4gICAgICAgIFF1YXRlcm5pb24sXHJcbiAgICAgICAgVHJhbnNmb3JtcyxcclxuICAgICAgICBQcm9wZXJ0eSxcclxuICAgICAgICBWZWxvY2l0eVZlY3RvclByb3BlcnR5KSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIHtAbGluayBQcm9wZXJ0eX0gd2hpY2ggZXZhbHVhdGVzIHRvIGEge0BsaW5rIFF1YXRlcm5pb259IHJvdGF0aW9uXHJcbiAgICAgKiBiYXNlZCBvbiB0aGUgdmVsb2NpdHkgb2YgdGhlIHByb3ZpZGVkIHtAbGluayBQb3NpdGlvblByb3BlcnR5fS5cclxuICAgICAqXHJcbiAgICAgKiBAYWxpYXMgVmVsb2NpdHlPcmllbnRhdGlvblByb3BlcnR5XHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1Byb3BlcnR5fSBbcG9zaXRpb25dIFRoZSBwb3NpdGlvbiBwcm9wZXJ0eSB1c2VkIHRvIGNvbXB1dGUgdGhlIG9yaWVudGF0aW9uLlxyXG4gICAgICogQHBhcmFtIHtFbGxpcHNvaWR9IFtlbGxpcHNvaWQ9RWxsaXBzb2lkLldHUzg0XSBUaGUgZWxsaXBzb2lkIHVzZWQgdG8gZGV0ZXJtaW5lIHdoaWNoIHdheSBpcyB1cC5cclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogLy9DcmVhdGUgYW4gZW50aXR5IHdpdGggcG9zaXRpb24gYW5kIG9yaWVudGF0aW9uLlxyXG4gICAgICogdmFyIHBvc2l0aW9uID0gbmV3IENlc2l1bS5TYW1wbGVkUHJvcGVydHkoKTtcclxuICAgICAqIHBvc2l0aW9uLmFkZFNhbXBsZXMoLi4uKTtcclxuICAgICAqIHZhciBlbnRpdHkgPSB2aWV3ZXIuZW50aXRpZXMuYWRkKHtcclxuICAgICAqICAgcG9zaXRpb24gOiBwb3NpdGlvbixcclxuICAgICAqICAgb3JpZW50YXRpb24gOiBuZXcgQ2VzaXVtLlZlbG9jaXR5T3JpZW50YXRpb25Qcm9wZXJ0eShwb3NpdGlvbilcclxuICAgICAqIH0pKTtcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gVmVsb2NpdHlPcmllbnRhdGlvblByb3BlcnR5KHBvc2l0aW9uLCBlbGxpcHNvaWQpIHtcclxuICAgICAgICB0aGlzLl92ZWxvY2l0eVZlY3RvclByb3BlcnR5ID0gbmV3IFZlbG9jaXR5VmVjdG9yUHJvcGVydHkocG9zaXRpb24sIHRydWUpO1xyXG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbiA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLl9lbGxpcHNvaWQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5fZGVmaW5pdGlvbkNoYW5nZWQgPSBuZXcgRXZlbnQoKTtcclxuXHJcbiAgICAgICAgdGhpcy5lbGxpcHNvaWQgPSBkZWZhdWx0VmFsdWUoZWxsaXBzb2lkLCBFbGxpcHNvaWQuV0dTODQpO1xyXG5cclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5fdmVsb2NpdHlWZWN0b3JQcm9wZXJ0eS5kZWZpbml0aW9uQ2hhbmdlZC5hZGRFdmVudExpc3RlbmVyKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGF0Ll9kZWZpbml0aW9uQ2hhbmdlZC5yYWlzZUV2ZW50KHRoYXQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGRlZmluZVByb3BlcnRpZXMoVmVsb2NpdHlPcmllbnRhdGlvblByb3BlcnR5LnByb3RvdHlwZSwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgYSB2YWx1ZSBpbmRpY2F0aW5nIGlmIHRoaXMgcHJvcGVydHkgaXMgY29uc3RhbnQuXHJcbiAgICAgICAgICogQG1lbWJlcm9mIFZlbG9jaXR5T3JpZW50YXRpb25Qcm9wZXJ0eS5wcm90b3R5cGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGlzQ29uc3RhbnQgOiB7XHJcbiAgICAgICAgICAgIGdldCA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb3BlcnR5LmlzQ29uc3RhbnQodGhpcy5fdmVsb2NpdHlWZWN0b3JQcm9wZXJ0eSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIGV2ZW50IHRoYXQgaXMgcmFpc2VkIHdoZW5ldmVyIHRoZSBkZWZpbml0aW9uIG9mIHRoaXMgcHJvcGVydHkgY2hhbmdlcy5cclxuICAgICAgICAgKiBAbWVtYmVyb2YgVmVsb2NpdHlPcmllbnRhdGlvblByb3BlcnR5LnByb3RvdHlwZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHR5cGUge0V2ZW50fVxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGRlZmluaXRpb25DaGFuZ2VkIDoge1xyXG4gICAgICAgICAgICBnZXQgOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWZpbml0aW9uQ2hhbmdlZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBwb3NpdGlvbiBwcm9wZXJ0eSB1c2VkIHRvIGNvbXB1dGUgb3JpZW50YXRpb24uXHJcbiAgICAgICAgICogQG1lbWJlcm9mIFZlbG9jaXR5T3JpZW50YXRpb25Qcm9wZXJ0eS5wcm90b3R5cGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEB0eXBlIHtQcm9wZXJ0eX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBwb3NpdGlvbiA6IHtcclxuICAgICAgICAgICAgZ2V0IDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdmVsb2NpdHlWZWN0b3JQcm9wZXJ0eS5wb3NpdGlvbjtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2V0IDogZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3ZlbG9jaXR5VmVjdG9yUHJvcGVydHkucG9zaXRpb24gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBlbGxpcHNvaWQgdXNlZCB0byBkZXRlcm1pbmUgd2hpY2ggd2F5IGlzIHVwLlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBWZWxvY2l0eU9yaWVudGF0aW9uUHJvcGVydHkucHJvdG90eXBlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAdHlwZSB7UHJvcGVydHl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZWxsaXBzb2lkIDoge1xyXG4gICAgICAgICAgICBnZXQgOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9lbGxpcHNvaWQ7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNldCA6IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLl9lbGxpcHNvaWQ7XHJcbiAgICAgICAgICAgICAgICBpZiAob2xkVmFsdWUgIT09IHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZWxsaXBzb2lkID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGVmaW5pdGlvbkNoYW5nZWQucmFpc2VFdmVudCh0aGlzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHZhciBwb3NpdGlvblNjcmF0Y2ggPSBuZXcgQ2FydGVzaWFuMygpO1xyXG4gICAgdmFyIHZlbG9jaXR5U2NyYXRjaCA9IG5ldyBDYXJ0ZXNpYW4zKCk7XHJcbiAgICB2YXIgcm90YXRpb25TY3JhdGNoID0gbmV3IE1hdHJpeDMoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eSBhdCB0aGUgcHJvdmlkZWQgdGltZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0p1bGlhbkRhdGV9IFt0aW1lXSBUaGUgdGltZSBmb3Igd2hpY2ggdG8gcmV0cmlldmUgdGhlIHZhbHVlLlxyXG4gICAgICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBbcmVzdWx0XSBUaGUgb2JqZWN0IHRvIHN0b3JlIHRoZSB2YWx1ZSBpbnRvLCBpZiBvbWl0dGVkLCBhIG5ldyBpbnN0YW5jZSBpcyBjcmVhdGVkIGFuZCByZXR1cm5lZC5cclxuICAgICAqIEByZXR1cm5zIHtRdWF0ZXJuaW9ufSBUaGUgbW9kaWZpZWQgcmVzdWx0IHBhcmFtZXRlciBvciBhIG5ldyBpbnN0YW5jZSBpZiB0aGUgcmVzdWx0IHBhcmFtZXRlciB3YXMgbm90IHN1cHBsaWVkLlxyXG4gICAgICovXHJcbiAgICBWZWxvY2l0eU9yaWVudGF0aW9uUHJvcGVydHkucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24odGltZSwgcmVzdWx0KSB7XHJcbiAgICAgICAgdmFyIHZlbG9jaXR5ID0gdGhpcy5fdmVsb2NpdHlWZWN0b3JQcm9wZXJ0eS5fZ2V0VmFsdWUodGltZSwgdmVsb2NpdHlTY3JhdGNoLCBwb3NpdGlvblNjcmF0Y2gpO1xyXG5cclxuICAgICAgICBpZiAoIWRlZmluZWQodmVsb2NpdHkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBUcmFuc2Zvcm1zLnJvdGF0aW9uTWF0cml4RnJvbVBvc2l0aW9uVmVsb2NpdHkocG9zaXRpb25TY3JhdGNoLCB2ZWxvY2l0eSwgdGhpcy5fZWxsaXBzb2lkLCByb3RhdGlvblNjcmF0Y2gpO1xyXG4gICAgICAgIHJldHVybiBRdWF0ZXJuaW9uLmZyb21Sb3RhdGlvbk1hdHJpeChyb3RhdGlvblNjcmF0Y2gsIHJlc3VsdCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29tcGFyZXMgdGhpcyBwcm9wZXJ0eSB0byB0aGUgcHJvdmlkZWQgcHJvcGVydHkgYW5kIHJldHVybnNcclxuICAgICAqIDxjb2RlPnRydWU8L2NvZGU+IGlmIHRoZXkgYXJlIGVxdWFsLCA8Y29kZT5mYWxzZTwvY29kZT4gb3RoZXJ3aXNlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UHJvcGVydHl9IFtvdGhlcl0gVGhlIG90aGVyIHByb3BlcnR5LlxyXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IGlmIGxlZnQgYW5kIHJpZ2h0IGFyZSBlcXVhbCwgPGNvZGU+ZmFsc2U8L2NvZGU+IG90aGVyd2lzZS5cclxuICAgICAqL1xyXG4gICAgVmVsb2NpdHlPcmllbnRhdGlvblByb3BlcnR5LnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbihvdGhlcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzID09PSBvdGhlciB8fC8vXHJcbiAgICAgICAgICAgICAgIChvdGhlciBpbnN0YW5jZW9mIFZlbG9jaXR5T3JpZW50YXRpb25Qcm9wZXJ0eSAmJlxyXG4gICAgICAgICAgICAgICAgUHJvcGVydHkuZXF1YWxzKHRoaXMuX3ZlbG9jaXR5VmVjdG9yUHJvcGVydHksIG90aGVyLl92ZWxvY2l0eVZlY3RvclByb3BlcnR5KSAmJlxyXG4gICAgICAgICAgICAgICAgKHRoaXMuX2VsbGlwc29pZCA9PT0gb3RoZXIuX2VsbGlwc29pZCB8fFxyXG4gICAgICAgICAgICAgICAgIHRoaXMuX2VsbGlwc29pZC5lcXVhbHMob3RoZXIuX2VsbGlwc29pZCkpKTtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIFZlbG9jaXR5T3JpZW50YXRpb25Qcm9wZXJ0eTtcclxufSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3RlcnJpYWpzLWNlc2l1bS9Tb3VyY2UvRGF0YVNvdXJjZXMvVmVsb2NpdHlPcmllbnRhdGlvblByb3BlcnR5LmpzXG4vLyBtb2R1bGUgaWQgPSAxMjEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xyXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcclxuICAgIC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZSB1bmxlc3MgYW1kTW9kdWxlSWQgaXMgc2V0XHJcbiAgICBkZWZpbmUoW10sIGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIChyb290WydBdXRvbGlua2VyJ10gPSBmYWN0b3J5KCkpO1xyXG4gICAgfSk7XHJcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcclxuICAgIC8vIE5vZGUuIERvZXMgbm90IHdvcmsgd2l0aCBzdHJpY3QgQ29tbW9uSlMsIGJ1dFxyXG4gICAgLy8gb25seSBDb21tb25KUy1saWtlIGVudmlyb25tZW50cyB0aGF0IHN1cHBvcnQgbW9kdWxlLmV4cG9ydHMsXHJcbiAgICAvLyBsaWtlIE5vZGUuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcclxuICB9IGVsc2Uge1xyXG4gICAgcm9vdFsnQXV0b2xpbmtlciddID0gZmFjdG9yeSgpO1xyXG4gIH1cclxufSh0aGlzLCBmdW5jdGlvbiAoKSB7XHJcblxyXG4vKiFcclxuICogQXV0b2xpbmtlci5qc1xyXG4gKiAwLjE3LjFcclxuICpcclxuICogQ29weXJpZ2h0KGMpIDIwMTUgR3JlZ29yeSBKYWNvYnMgPGdyZWdAZ3JlZy1qYWNvYnMuY29tPlxyXG4gKiBNSVQgTGljZW5zZWQuIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcbiAqXHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ncmVnamFjb2JzL0F1dG9saW5rZXIuanNcclxuICovXHJcbi8qKlxyXG4gKiBAY2xhc3MgQXV0b2xpbmtlclxyXG4gKiBAZXh0ZW5kcyBPYmplY3RcclxuICpcclxuICogVXRpbGl0eSBjbGFzcyB1c2VkIHRvIHByb2Nlc3MgYSBnaXZlbiBzdHJpbmcgb2YgdGV4dCwgYW5kIHdyYXAgdGhlIG1hdGNoZXMgaW5cclxuICogdGhlIGFwcHJvcHJpYXRlIGFuY2hvciAoJmx0O2EmZ3Q7KSB0YWdzIHRvIHR1cm4gdGhlbSBpbnRvIGxpbmtzLlxyXG4gKlxyXG4gKiBBbnkgb2YgdGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBtYXkgYmUgcHJvdmlkZWQgaW4gYW4gT2JqZWN0IChtYXApIHByb3ZpZGVkXHJcbiAqIHRvIHRoZSBBdXRvbGlua2VyIGNvbnN0cnVjdG9yLCB3aGljaCB3aWxsIGNvbmZpZ3VyZSBob3cgdGhlIHtAbGluayAjbGluayBsaW5rKCl9XHJcbiAqIG1ldGhvZCB3aWxsIHByb2Nlc3MgdGhlIGxpbmtzLlxyXG4gKlxyXG4gKiBGb3IgZXhhbXBsZTpcclxuICpcclxuICogICAgIHZhciBhdXRvbGlua2VyID0gbmV3IEF1dG9saW5rZXIoIHtcclxuICogICAgICAgICBuZXdXaW5kb3cgOiBmYWxzZSxcclxuICogICAgICAgICB0cnVuY2F0ZSAgOiAzMFxyXG4gKiAgICAgfSApO1xyXG4gKlxyXG4gKiAgICAgdmFyIGh0bWwgPSBhdXRvbGlua2VyLmxpbmsoIFwiSm9lIHdlbnQgdG8gd3d3LnlhaG9vLmNvbVwiICk7XHJcbiAqICAgICAvLyBwcm9kdWNlczogJ0pvZSB3ZW50IHRvIDxhIGhyZWY9XCJodHRwOi8vd3d3LnlhaG9vLmNvbVwiPnlhaG9vLmNvbTwvYT4nXHJcbiAqXHJcbiAqXHJcbiAqIFRoZSB7QGxpbmsgI3N0YXRpYy1saW5rIHN0YXRpYyBsaW5rKCl9IG1ldGhvZCBtYXkgYWxzbyBiZSB1c2VkIHRvIGlubGluZSBvcHRpb25zIGludG8gYSBzaW5nbGUgY2FsbCwgd2hpY2ggbWF5XHJcbiAqIGJlIG1vcmUgY29udmVuaWVudCBmb3Igb25lLW9mZiB1c2VzLiBGb3IgZXhhbXBsZTpcclxuICpcclxuICogICAgIHZhciBodG1sID0gQXV0b2xpbmtlci5saW5rKCBcIkpvZSB3ZW50IHRvIHd3dy55YWhvby5jb21cIiwge1xyXG4gKiAgICAgICAgIG5ld1dpbmRvdyA6IGZhbHNlLFxyXG4gKiAgICAgICAgIHRydW5jYXRlICA6IDMwXHJcbiAqICAgICB9ICk7XHJcbiAqICAgICAvLyBwcm9kdWNlczogJ0pvZSB3ZW50IHRvIDxhIGhyZWY9XCJodHRwOi8vd3d3LnlhaG9vLmNvbVwiPnlhaG9vLmNvbTwvYT4nXHJcbiAqXHJcbiAqXHJcbiAqICMjIEN1c3RvbSBSZXBsYWNlbWVudHMgb2YgTGlua3NcclxuICpcclxuICogSWYgdGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBkbyBub3QgcHJvdmlkZSBlbm91Z2ggZmxleGliaWxpdHksIGEge0BsaW5rICNyZXBsYWNlRm59XHJcbiAqIG1heSBiZSBwcm92aWRlZCB0byBmdWxseSBjdXN0b21pemUgdGhlIG91dHB1dCBvZiBBdXRvbGlua2VyLiBUaGlzIGZ1bmN0aW9uIGlzXHJcbiAqIGNhbGxlZCBvbmNlIGZvciBlYWNoIFVSTC9FbWFpbC9QaG9uZSMvVHdpdHRlciBIYW5kbGUvSGFzaHRhZyBtYXRjaCB0aGF0IGlzXHJcbiAqIGVuY291bnRlcmVkLlxyXG4gKlxyXG4gKiBGb3IgZXhhbXBsZTpcclxuICpcclxuICogICAgIHZhciBpbnB1dCA9IFwiLi4uXCI7ICAvLyBzdHJpbmcgd2l0aCBVUkxzLCBFbWFpbCBBZGRyZXNzZXMsIFBob25lICNzLCBUd2l0dGVyIEhhbmRsZXMsIGFuZCBIYXNodGFnc1xyXG4gKlxyXG4gKiAgICAgdmFyIGxpbmtlZFRleHQgPSBBdXRvbGlua2VyLmxpbmsoIGlucHV0LCB7XHJcbiAqICAgICAgICAgcmVwbGFjZUZuIDogZnVuY3Rpb24oIGF1dG9saW5rZXIsIG1hdGNoICkge1xyXG4gKiAgICAgICAgICAgICBjb25zb2xlLmxvZyggXCJocmVmID0gXCIsIG1hdGNoLmdldEFuY2hvckhyZWYoKSApO1xyXG4gKiAgICAgICAgICAgICBjb25zb2xlLmxvZyggXCJ0ZXh0ID0gXCIsIG1hdGNoLmdldEFuY2hvclRleHQoKSApO1xyXG4gKlxyXG4gKiAgICAgICAgICAgICBzd2l0Y2goIG1hdGNoLmdldFR5cGUoKSApIHtcclxuICogICAgICAgICAgICAgICAgIGNhc2UgJ3VybCcgOlxyXG4gKiAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCBcInVybDogXCIsIG1hdGNoLmdldFVybCgpICk7XHJcbiAqXHJcbiAqICAgICAgICAgICAgICAgICAgICAgaWYoIG1hdGNoLmdldFVybCgpLmluZGV4T2YoICdteXNpdGUuY29tJyApID09PSAtMSApIHtcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRhZyA9IGF1dG9saW5rZXIuZ2V0VGFnQnVpbGRlcigpLmJ1aWxkKCBtYXRjaCApOyAgLy8gcmV0dXJucyBhbiBgQXV0b2xpbmtlci5IdG1sVGFnYCBpbnN0YW5jZSwgd2hpY2ggcHJvdmlkZXMgbXV0YXRvciBtZXRob2RzIGZvciBlYXN5IGNoYW5nZXNcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgdGFnLnNldEF0dHIoICdyZWwnLCAnbm9mb2xsb3cnICk7XHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgIHRhZy5hZGRDbGFzcyggJ2V4dGVybmFsLWxpbmsnICk7XHJcbiAqXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YWc7XHJcbiAqXHJcbiAqICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7ICAvLyBsZXQgQXV0b2xpbmtlciBwZXJmb3JtIGl0cyBub3JtYWwgYW5jaG9yIHRhZyByZXBsYWNlbWVudFxyXG4gKiAgICAgICAgICAgICAgICAgICAgIH1cclxuICpcclxuICogICAgICAgICAgICAgICAgIGNhc2UgJ2VtYWlsJyA6XHJcbiAqICAgICAgICAgICAgICAgICAgICAgdmFyIGVtYWlsID0gbWF0Y2guZ2V0RW1haWwoKTtcclxuICogICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyggXCJlbWFpbDogXCIsIGVtYWlsICk7XHJcbiAqXHJcbiAqICAgICAgICAgICAgICAgICAgICAgaWYoIGVtYWlsID09PSBcIm15QG93bi5hZGRyZXNzXCIgKSB7XHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgIC8vIGRvbid0IGF1dG8tbGluayB0aGlzIHBhcnRpY3VsYXIgZW1haWwgYWRkcmVzczsgbGVhdmUgYXMtaXNcclxuICogICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47ICAvLyBubyByZXR1cm4gdmFsdWUgd2lsbCBoYXZlIEF1dG9saW5rZXIgcGVyZm9ybSBpdHMgbm9ybWFsIGFuY2hvciB0YWcgcmVwbGFjZW1lbnQgKHNhbWUgYXMgcmV0dXJuaW5nIGB0cnVlYClcclxuICogICAgICAgICAgICAgICAgICAgICB9XHJcbiAqXHJcbiAqICAgICAgICAgICAgICAgICBjYXNlICdwaG9uZScgOlxyXG4gKiAgICAgICAgICAgICAgICAgICAgIHZhciBwaG9uZU51bWJlciA9IG1hdGNoLmdldFBob25lTnVtYmVyKCk7XHJcbiAqICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coIHBob25lTnVtYmVyICk7XHJcbiAqXHJcbiAqICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICc8YSBocmVmPVwiaHR0cDovL25ld3BsYWNlLnRvLmxpbmsucGhvbmUubnVtYmVycy50by9cIj4nICsgcGhvbmVOdW1iZXIgKyAnPC9hPic7XHJcbiAqXHJcbiAqICAgICAgICAgICAgICAgICBjYXNlICd0d2l0dGVyJyA6XHJcbiAqICAgICAgICAgICAgICAgICAgICAgdmFyIHR3aXR0ZXJIYW5kbGUgPSBtYXRjaC5nZXRUd2l0dGVySGFuZGxlKCk7XHJcbiAqICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coIHR3aXR0ZXJIYW5kbGUgKTtcclxuICpcclxuICogICAgICAgICAgICAgICAgICAgICByZXR1cm4gJzxhIGhyZWY9XCJodHRwOi8vbmV3cGxhY2UudG8ubGluay50d2l0dGVyLmhhbmRsZXMudG8vXCI+JyArIHR3aXR0ZXJIYW5kbGUgKyAnPC9hPic7XHJcbiAqXHJcbiAqICAgICAgICAgICAgICAgICBjYXNlICdoYXNodGFnJyA6XHJcbiAqICAgICAgICAgICAgICAgICAgICAgdmFyIGhhc2h0YWcgPSBtYXRjaC5nZXRIYXNodGFnKCk7XHJcbiAqICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coIGhhc2h0YWcgKTtcclxuICpcclxuICogICAgICAgICAgICAgICAgICAgICByZXR1cm4gJzxhIGhyZWY9XCJodHRwOi8vbmV3cGxhY2UudG8ubGluay5oYXNodGFnLmhhbmRsZXMudG8vXCI+JyArIGhhc2h0YWcgKyAnPC9hPic7XHJcbiAqICAgICAgICAgICAgIH1cclxuICogICAgICAgICB9XHJcbiAqICAgICB9ICk7XHJcbiAqXHJcbiAqXHJcbiAqIFRoZSBmdW5jdGlvbiBtYXkgcmV0dXJuIHRoZSBmb2xsb3dpbmcgdmFsdWVzOlxyXG4gKlxyXG4gKiAtIGB0cnVlYCAoQm9vbGVhbik6IEFsbG93IEF1dG9saW5rZXIgdG8gcmVwbGFjZSB0aGUgbWF0Y2ggYXMgaXQgbm9ybWFsbHkgd291bGQuXHJcbiAqIC0gYGZhbHNlYCAoQm9vbGVhbik6IERvIG5vdCByZXBsYWNlIHRoZSBjdXJyZW50IG1hdGNoIGF0IGFsbCAtIGxlYXZlIGFzLWlzLlxyXG4gKiAtIEFueSBTdHJpbmc6IElmIGEgc3RyaW5nIGlzIHJldHVybmVkIGZyb20gdGhlIGZ1bmN0aW9uLCB0aGUgc3RyaW5nIHdpbGwgYmUgdXNlZCBkaXJlY3RseSBhcyB0aGUgcmVwbGFjZW1lbnQgSFRNTCBmb3JcclxuICogICB0aGUgbWF0Y2guXHJcbiAqIC0gQW4ge0BsaW5rIEF1dG9saW5rZXIuSHRtbFRhZ30gaW5zdGFuY2UsIHdoaWNoIGNhbiBiZSB1c2VkIHRvIGJ1aWxkL21vZGlmeSBhbiBIVE1MIHRhZyBiZWZvcmUgd3JpdGluZyBvdXQgaXRzIEhUTUwgdGV4dC5cclxuICpcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgQXV0b2xpbmtlciBpbnN0YW5jZSwgc3BlY2lmaWVkIGluIGFuIE9iamVjdCAobWFwKS5cclxuICovXHJcbnZhciBBdXRvbGlua2VyID0gZnVuY3Rpb24oIGNmZyApIHtcclxuXHRBdXRvbGlua2VyLlV0aWwuYXNzaWduKCB0aGlzLCBjZmcgKTsgIC8vIGFzc2lnbiB0aGUgcHJvcGVydGllcyBvZiBgY2ZnYCBvbnRvIHRoZSBBdXRvbGlua2VyIGluc3RhbmNlLiBQcm90b3R5cGUgcHJvcGVydGllcyB3aWxsIGJlIHVzZWQgZm9yIG1pc3NpbmcgY29uZmlncy5cclxuXHJcblx0Ly8gVmFsaWRhdGUgdGhlIHZhbHVlIG9mIHRoZSBgaGFzaHRhZ2AgY2ZnLlxyXG5cdHZhciBoYXNodGFnID0gdGhpcy5oYXNodGFnO1xyXG5cdGlmKCBoYXNodGFnICE9PSBmYWxzZSAmJiBoYXNodGFnICE9PSAndHdpdHRlcicgJiYgaGFzaHRhZyAhPT0gJ2ZhY2Vib29rJyApIHtcclxuXHRcdHRocm93IG5ldyBFcnJvciggXCJpbnZhbGlkIGBoYXNodGFnYCBjZmcgLSBzZWUgZG9jc1wiICk7XHJcblx0fVxyXG59O1xyXG5cclxuQXV0b2xpbmtlci5wcm90b3R5cGUgPSB7XHJcblx0Y29uc3RydWN0b3IgOiBBdXRvbGlua2VyLCAgLy8gZml4IGNvbnN0cnVjdG9yIHByb3BlcnR5XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBjZmcge0Jvb2xlYW59IHVybHNcclxuXHQgKlxyXG5cdCAqIGB0cnVlYCBpZiBtaXNjZWxsYW5lb3VzIFVSTHMgc2hvdWxkIGJlIGF1dG9tYXRpY2FsbHkgbGlua2VkLCBgZmFsc2VgIGlmIHRoZXkgc2hvdWxkIG5vdCBiZS5cclxuXHQgKi9cclxuXHR1cmxzIDogdHJ1ZSxcclxuXHJcblx0LyoqXHJcblx0ICogQGNmZyB7Qm9vbGVhbn0gZW1haWxcclxuXHQgKlxyXG5cdCAqIGB0cnVlYCBpZiBlbWFpbCBhZGRyZXNzZXMgc2hvdWxkIGJlIGF1dG9tYXRpY2FsbHkgbGlua2VkLCBgZmFsc2VgIGlmIHRoZXkgc2hvdWxkIG5vdCBiZS5cclxuXHQgKi9cclxuXHRlbWFpbCA6IHRydWUsXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBjZmcge0Jvb2xlYW59IHR3aXR0ZXJcclxuXHQgKlxyXG5cdCAqIGB0cnVlYCBpZiBUd2l0dGVyIGhhbmRsZXMgKFwiQGV4YW1wbGVcIikgc2hvdWxkIGJlIGF1dG9tYXRpY2FsbHkgbGlua2VkLCBgZmFsc2VgIGlmIHRoZXkgc2hvdWxkIG5vdCBiZS5cclxuXHQgKi9cclxuXHR0d2l0dGVyIDogdHJ1ZSxcclxuXHJcblx0LyoqXHJcblx0ICogQGNmZyB7Qm9vbGVhbn0gcGhvbmVcclxuXHQgKlxyXG5cdCAqIGB0cnVlYCBpZiBQaG9uZSBudW1iZXJzIChcIig1NTUpNTU1LTU1NTVcIikgc2hvdWxkIGJlIGF1dG9tYXRpY2FsbHkgbGlua2VkLCBgZmFsc2VgIGlmIHRoZXkgc2hvdWxkIG5vdCBiZS5cclxuXHQgKi9cclxuXHRwaG9uZTogdHJ1ZSxcclxuXHJcblx0LyoqXHJcblx0ICogQGNmZyB7Qm9vbGVhbi9TdHJpbmd9IGhhc2h0YWdcclxuXHQgKlxyXG5cdCAqIEEgc3RyaW5nIGZvciB0aGUgc2VydmljZSBuYW1lIHRvIGhhdmUgaGFzaHRhZ3MgKGV4OiBcIiNteUhhc2h0YWdcIilcclxuXHQgKiBhdXRvLWxpbmtlZCB0by4gVGhlIGN1cnJlbnRseS1zdXBwb3J0ZWQgdmFsdWVzIGFyZTpcclxuXHQgKlxyXG5cdCAqIC0gJ3R3aXR0ZXInXHJcblx0ICogLSAnZmFjZWJvb2snXHJcblx0ICpcclxuXHQgKiBQYXNzIGBmYWxzZWAgdG8gc2tpcCBhdXRvLWxpbmtpbmcgb2YgaGFzaHRhZ3MuXHJcblx0ICovXHJcblx0aGFzaHRhZyA6IGZhbHNlLFxyXG5cclxuXHQvKipcclxuXHQgKiBAY2ZnIHtCb29sZWFufSBuZXdXaW5kb3dcclxuXHQgKlxyXG5cdCAqIGB0cnVlYCBpZiB0aGUgbGlua3Mgc2hvdWxkIG9wZW4gaW4gYSBuZXcgd2luZG93LCBgZmFsc2VgIG90aGVyd2lzZS5cclxuXHQgKi9cclxuXHRuZXdXaW5kb3cgOiB0cnVlLFxyXG5cclxuXHQvKipcclxuXHQgKiBAY2ZnIHtCb29sZWFufSBzdHJpcFByZWZpeFxyXG5cdCAqXHJcblx0ICogYHRydWVgIGlmICdodHRwOi8vJyBvciAnaHR0cHM6Ly8nIGFuZC9vciB0aGUgJ3d3dy4nIHNob3VsZCBiZSBzdHJpcHBlZFxyXG5cdCAqIGZyb20gdGhlIGJlZ2lubmluZyBvZiBVUkwgbGlua3MnIHRleHQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxyXG5cdCAqL1xyXG5cdHN0cmlwUHJlZml4IDogdHJ1ZSxcclxuXHJcblx0LyoqXHJcblx0ICogQGNmZyB7TnVtYmVyfSB0cnVuY2F0ZVxyXG5cdCAqXHJcblx0ICogQSBudW1iZXIgZm9yIGhvdyBtYW55IGNoYXJhY3RlcnMgbG9uZyBtYXRjaGVkIHRleHQgc2hvdWxkIGJlIHRydW5jYXRlZCB0byBpbnNpZGUgdGhlIHRleHQgb2ZcclxuXHQgKiBhIGxpbmsuIElmIHRoZSBtYXRjaGVkIHRleHQgaXMgb3ZlciB0aGlzIG51bWJlciBvZiBjaGFyYWN0ZXJzLCBpdCB3aWxsIGJlIHRydW5jYXRlZCB0byB0aGlzIGxlbmd0aCBieVxyXG5cdCAqIGFkZGluZyBhIHR3byBwZXJpb2QgZWxsaXBzaXMgKCcuLicpIHRvIHRoZSBlbmQgb2YgdGhlIHN0cmluZy5cclxuXHQgKlxyXG5cdCAqIEZvciBleGFtcGxlOiBBIHVybCBsaWtlICdodHRwOi8vd3d3LnlhaG9vLmNvbS9zb21lL2xvbmcvcGF0aC90by9hL2ZpbGUnIHRydW5jYXRlZCB0byAyNSBjaGFyYWN0ZXJzIG1pZ2h0IGxvb2tcclxuXHQgKiBzb21ldGhpbmcgbGlrZSB0aGlzOiAneWFob28uY29tL3NvbWUvbG9uZy9wYXQuLidcclxuXHQgKi9cclxuXHR0cnVuY2F0ZSA6IHVuZGVmaW5lZCxcclxuXHJcblx0LyoqXHJcblx0ICogQGNmZyB7U3RyaW5nfSBjbGFzc05hbWVcclxuXHQgKlxyXG5cdCAqIEEgQ1NTIGNsYXNzIG5hbWUgdG8gYWRkIHRvIHRoZSBnZW5lcmF0ZWQgbGlua3MuIFRoaXMgY2xhc3Mgd2lsbCBiZSBhZGRlZCB0byBhbGwgbGlua3MsIGFzIHdlbGwgYXMgdGhpcyBjbGFzc1xyXG5cdCAqIHBsdXMgbWF0Y2ggc3VmZml4ZXMgZm9yIHN0eWxpbmcgdXJsL2VtYWlsL3Bob25lL3R3aXR0ZXIvaGFzaHRhZyBsaW5rcyBkaWZmZXJlbnRseS5cclxuXHQgKlxyXG5cdCAqIEZvciBleGFtcGxlLCBpZiB0aGlzIGNvbmZpZyBpcyBwcm92aWRlZCBhcyBcIm15TGlua1wiLCB0aGVuOlxyXG5cdCAqXHJcblx0ICogLSBVUkwgbGlua3Mgd2lsbCBoYXZlIHRoZSBDU1MgY2xhc3NlczogXCJteUxpbmsgbXlMaW5rLXVybFwiXHJcblx0ICogLSBFbWFpbCBsaW5rcyB3aWxsIGhhdmUgdGhlIENTUyBjbGFzc2VzOiBcIm15TGluayBteUxpbmstZW1haWxcIiwgYW5kXHJcblx0ICogLSBUd2l0dGVyIGxpbmtzIHdpbGwgaGF2ZSB0aGUgQ1NTIGNsYXNzZXM6IFwibXlMaW5rIG15TGluay10d2l0dGVyXCJcclxuXHQgKiAtIFBob25lIGxpbmtzIHdpbGwgaGF2ZSB0aGUgQ1NTIGNsYXNzZXM6IFwibXlMaW5rIG15TGluay1waG9uZVwiXHJcblx0ICogLSBIYXNodGFnIGxpbmtzIHdpbGwgaGF2ZSB0aGUgQ1NTIGNsYXNzZXM6IFwibXlMaW5rIG15TGluay1oYXNodGFnXCJcclxuXHQgKi9cclxuXHRjbGFzc05hbWUgOiBcIlwiLFxyXG5cclxuXHQvKipcclxuXHQgKiBAY2ZnIHtGdW5jdGlvbn0gcmVwbGFjZUZuXHJcblx0ICpcclxuXHQgKiBBIGZ1bmN0aW9uIHRvIGluZGl2aWR1YWxseSBwcm9jZXNzIGVhY2ggbWF0Y2ggZm91bmQgaW4gdGhlIGlucHV0IHN0cmluZy5cclxuXHQgKlxyXG5cdCAqIFNlZSB0aGUgY2xhc3MncyBkZXNjcmlwdGlvbiBmb3IgdXNhZ2UuXHJcblx0ICpcclxuXHQgKiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIHRoZSBmb2xsb3dpbmcgcGFyYW1ldGVyczpcclxuXHQgKlxyXG5cdCAqIEBjZmcge0F1dG9saW5rZXJ9IHJlcGxhY2VGbi5hdXRvbGlua2VyIFRoZSBBdXRvbGlua2VyIGluc3RhbmNlLCB3aGljaCBtYXkgYmUgdXNlZCB0byByZXRyaWV2ZSBjaGlsZCBvYmplY3RzIGZyb20gKHN1Y2hcclxuXHQgKiAgIGFzIHRoZSBpbnN0YW5jZSdzIHtAbGluayAjZ2V0VGFnQnVpbGRlciB0YWcgYnVpbGRlcn0pLlxyXG5cdCAqIEBjZmcge0F1dG9saW5rZXIubWF0Y2guTWF0Y2h9IHJlcGxhY2VGbi5tYXRjaCBUaGUgTWF0Y2ggaW5zdGFuY2Ugd2hpY2ggY2FuIGJlIHVzZWQgdG8gcmV0cmlldmUgaW5mb3JtYXRpb24gYWJvdXQgdGhlXHJcblx0ICogICBtYXRjaCB0aGF0IHRoZSBgcmVwbGFjZUZuYCBpcyBjdXJyZW50bHkgcHJvY2Vzc2luZy4gU2VlIHtAbGluayBBdXRvbGlua2VyLm1hdGNoLk1hdGNofSBzdWJjbGFzc2VzIGZvciBkZXRhaWxzLlxyXG5cdCAqL1xyXG5cclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcHJvcGVydHkge0F1dG9saW5rZXIuaHRtbFBhcnNlci5IdG1sUGFyc2VyfSBodG1sUGFyc2VyXHJcblx0ICpcclxuXHQgKiBUaGUgSHRtbFBhcnNlciBpbnN0YW5jZSB1c2VkIHRvIHNraXAgb3ZlciBIVE1MIHRhZ3MsIHdoaWxlIGZpbmRpbmcgdGV4dCBub2RlcyB0byBwcm9jZXNzLiBUaGlzIGlzIGxhemlseSBpbnN0YW50aWF0ZWRcclxuXHQgKiBpbiB0aGUge0BsaW5rICNnZXRIdG1sUGFyc2VyfSBtZXRob2QuXHJcblx0ICovXHJcblx0aHRtbFBhcnNlciA6IHVuZGVmaW5lZCxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcHJvcGVydHkge0F1dG9saW5rZXIubWF0Y2hQYXJzZXIuTWF0Y2hQYXJzZXJ9IG1hdGNoUGFyc2VyXHJcblx0ICpcclxuXHQgKiBUaGUgTWF0Y2hQYXJzZXIgaW5zdGFuY2UgdXNlZCB0byBmaW5kIG1hdGNoZXMgaW4gdGhlIHRleHQgbm9kZXMgb2YgYW4gaW5wdXQgc3RyaW5nIHBhc3NlZCB0b1xyXG5cdCAqIHtAbGluayAjbGlua30uIFRoaXMgaXMgbGF6aWx5IGluc3RhbnRpYXRlZCBpbiB0aGUge0BsaW5rICNnZXRNYXRjaFBhcnNlcn0gbWV0aG9kLlxyXG5cdCAqL1xyXG5cdG1hdGNoUGFyc2VyIDogdW5kZWZpbmVkLFxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwcm9wZXJ0eSB7QXV0b2xpbmtlci5BbmNob3JUYWdCdWlsZGVyfSB0YWdCdWlsZGVyXHJcblx0ICpcclxuXHQgKiBUaGUgQW5jaG9yVGFnQnVpbGRlciBpbnN0YW5jZSB1c2VkIHRvIGJ1aWxkIG1hdGNoIHJlcGxhY2VtZW50IGFuY2hvciB0YWdzLiBOb3RlOiB0aGlzIGlzIGxhemlseSBpbnN0YW50aWF0ZWRcclxuXHQgKiBpbiB0aGUge0BsaW5rICNnZXRUYWdCdWlsZGVyfSBtZXRob2QuXHJcblx0ICovXHJcblx0dGFnQnVpbGRlciA6IHVuZGVmaW5lZCxcclxuXHJcblx0LyoqXHJcblx0ICogQXV0b21hdGljYWxseSBsaW5rcyBVUkxzLCBFbWFpbCBhZGRyZXNzZXMsIFBob25lIG51bWJlcnMsIFR3aXR0ZXJcclxuXHQgKiBoYW5kbGVzLCBhbmQgSGFzaHRhZ3MgZm91bmQgaW4gdGhlIGdpdmVuIGNodW5rIG9mIEhUTUwuIERvZXMgbm90IGxpbmtcclxuXHQgKiBVUkxzIGZvdW5kIHdpdGhpbiBIVE1MIHRhZ3MuXHJcblx0ICpcclxuXHQgKiBGb3IgaW5zdGFuY2UsIGlmIGdpdmVuIHRoZSB0ZXh0OiBgWW91IHNob3VsZCBnbyB0byBodHRwOi8vd3d3LnlhaG9vLmNvbWAsXHJcblx0ICogdGhlbiB0aGUgcmVzdWx0IHdpbGwgYmUgYFlvdSBzaG91bGQgZ28gdG9cclxuXHQgKiAmbHQ7YSBocmVmPVwiaHR0cDovL3d3dy55YWhvby5jb21cIiZndDtodHRwOi8vd3d3LnlhaG9vLmNvbSZsdDsvYSZndDtgXHJcblx0ICpcclxuXHQgKiBUaGlzIG1ldGhvZCBmaW5kcyB0aGUgdGV4dCBhcm91bmQgYW55IEhUTUwgZWxlbWVudHMgaW4gdGhlIGlucHV0XHJcblx0ICogYHRleHRPckh0bWxgLCB3aGljaCB3aWxsIGJlIHRoZSB0ZXh0IHRoYXQgaXMgcHJvY2Vzc2VkLiBBbnkgb3JpZ2luYWwgSFRNTFxyXG5cdCAqIGVsZW1lbnRzIHdpbGwgYmUgbGVmdCBhcy1pcywgYXMgd2VsbCBhcyB0aGUgdGV4dCB0aGF0IGlzIGFscmVhZHkgd3JhcHBlZFxyXG5cdCAqIGluIGFuY2hvciAoJmx0O2EmZ3Q7KSB0YWdzLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHRleHRPckh0bWwgVGhlIEhUTUwgb3IgdGV4dCB0byBhdXRvbGluayBtYXRjaGVzIHdpdGhpblxyXG5cdCAqICAgKGRlcGVuZGluZyBvbiBpZiB0aGUge0BsaW5rICN1cmxzfSwge0BsaW5rICNlbWFpbH0sIHtAbGluayAjcGhvbmV9LFxyXG5cdCAqICAge0BsaW5rICN0d2l0dGVyfSwgYW5kIHtAbGluayAjaGFzaHRhZ30gb3B0aW9ucyBhcmUgZW5hYmxlZCkuXHJcblx0ICogQHJldHVybiB7U3RyaW5nfSBUaGUgSFRNTCwgd2l0aCBtYXRjaGVzIGF1dG9tYXRpY2FsbHkgbGlua2VkLlxyXG5cdCAqL1xyXG5cdGxpbmsgOiBmdW5jdGlvbiggdGV4dE9ySHRtbCApIHtcclxuXHRcdHZhciBodG1sUGFyc2VyID0gdGhpcy5nZXRIdG1sUGFyc2VyKCksXHJcblx0XHQgICAgaHRtbE5vZGVzID0gaHRtbFBhcnNlci5wYXJzZSggdGV4dE9ySHRtbCApLFxyXG5cdFx0ICAgIGFuY2hvclRhZ1N0YWNrQ291bnQgPSAwLCAgLy8gdXNlZCB0byBvbmx5IHByb2Nlc3MgdGV4dCBhcm91bmQgYW5jaG9yIHRhZ3MsIGFuZCBhbnkgaW5uZXIgdGV4dC9odG1sIHRoZXkgbWF5IGhhdmVcclxuXHRcdCAgICByZXN1bHRIdG1sID0gW107XHJcblxyXG5cdFx0Zm9yKCB2YXIgaSA9IDAsIGxlbiA9IGh0bWxOb2Rlcy5sZW5ndGg7IGkgPCBsZW47IGkrKyApIHtcclxuXHRcdFx0dmFyIG5vZGUgPSBodG1sTm9kZXNbIGkgXSxcclxuXHRcdFx0ICAgIG5vZGVUeXBlID0gbm9kZS5nZXRUeXBlKCksXHJcblx0XHRcdCAgICBub2RlVGV4dCA9IG5vZGUuZ2V0VGV4dCgpO1xyXG5cclxuXHRcdFx0aWYoIG5vZGVUeXBlID09PSAnZWxlbWVudCcgKSB7XHJcblx0XHRcdFx0Ly8gUHJvY2VzcyBIVE1MIG5vZGVzIGluIHRoZSBpbnB1dCBgdGV4dE9ySHRtbGBcclxuXHRcdFx0XHRpZiggbm9kZS5nZXRUYWdOYW1lKCkgPT09ICdhJyApIHtcclxuXHRcdFx0XHRcdGlmKCAhbm9kZS5pc0Nsb3NpbmcoKSApIHsgIC8vIGl0J3MgdGhlIHN0YXJ0IDxhPiB0YWdcclxuXHRcdFx0XHRcdFx0YW5jaG9yVGFnU3RhY2tDb3VudCsrO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHsgICAvLyBpdCdzIHRoZSBlbmQgPC9hPiB0YWdcclxuXHRcdFx0XHRcdFx0YW5jaG9yVGFnU3RhY2tDb3VudCA9IE1hdGgubWF4KCBhbmNob3JUYWdTdGFja0NvdW50IC0gMSwgMCApOyAgLy8gYXR0ZW1wdCB0byBoYW5kbGUgZXh0cmFuZW91cyA8L2E+IHRhZ3MgYnkgbWFraW5nIHN1cmUgdGhlIHN0YWNrIGNvdW50IG5ldmVyIGdvZXMgYmVsb3cgMFxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXN1bHRIdG1sLnB1c2goIG5vZGVUZXh0ICk7ICAvLyBub3cgYWRkIHRoZSB0ZXh0IG9mIHRoZSB0YWcgaXRzZWxmIHZlcmJhdGltXHJcblxyXG5cdFx0XHR9IGVsc2UgaWYoIG5vZGVUeXBlID09PSAnZW50aXR5JyB8fCBub2RlVHlwZSA9PT0gJ2NvbW1lbnQnICkge1xyXG5cdFx0XHRcdHJlc3VsdEh0bWwucHVzaCggbm9kZVRleHQgKTsgIC8vIGFwcGVuZCBIVE1MIGVudGl0eSBub2RlcyAoc3VjaCBhcyAnJm5ic3A7Jykgb3IgSFRNTCBjb21tZW50cyAoc3VjaCBhcyAnPCEtLSBDb21tZW50IC0tPicpIHZlcmJhdGltXHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdC8vIFByb2Nlc3MgdGV4dCBub2RlcyBpbiB0aGUgaW5wdXQgYHRleHRPckh0bWxgXHJcblx0XHRcdFx0aWYoIGFuY2hvclRhZ1N0YWNrQ291bnQgPT09IDAgKSB7XHJcblx0XHRcdFx0XHQvLyBJZiB3ZSdyZSBub3Qgd2l0aGluIGFuIDxhPiB0YWcsIHByb2Nlc3MgdGhlIHRleHQgbm9kZSB0byBsaW5raWZ5XHJcblx0XHRcdFx0XHR2YXIgbGlua2lmaWVkU3RyID0gdGhpcy5saW5raWZ5U3RyKCBub2RlVGV4dCApO1xyXG5cdFx0XHRcdFx0cmVzdWx0SHRtbC5wdXNoKCBsaW5raWZpZWRTdHIgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdC8vIGB0ZXh0YCBpcyB3aXRoaW4gYW4gPGE+IHRhZywgc2ltcGx5IGFwcGVuZCB0aGUgdGV4dCAtIHdlIGRvIG5vdCB3YW50IHRvIGF1dG9saW5rIGFueXRoaW5nXHJcblx0XHRcdFx0XHQvLyBhbHJlYWR5IHdpdGhpbiBhbiA8YT4uLi48L2E+IHRhZ1xyXG5cdFx0XHRcdFx0cmVzdWx0SHRtbC5wdXNoKCBub2RlVGV4dCApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByZXN1bHRIdG1sLmpvaW4oIFwiXCIgKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBQcm9jZXNzIHRoZSB0ZXh0IHRoYXQgbGllcyBpbiBiZXR3ZWVuIEhUTUwgdGFncywgcGVyZm9ybWluZyB0aGUgYW5jaG9yXHJcblx0ICogdGFnIHJlcGxhY2VtZW50cyBmb3IgdGhlIG1hdGNoZXMsIGFuZCByZXR1cm5zIHRoZSBzdHJpbmcgd2l0aCB0aGVcclxuXHQgKiByZXBsYWNlbWVudHMgbWFkZS5cclxuXHQgKlxyXG5cdCAqIFRoaXMgbWV0aG9kIGRvZXMgdGhlIGFjdHVhbCB3cmFwcGluZyBvZiBtYXRjaGVzIHdpdGggYW5jaG9yIHRhZ3MuXHJcblx0ICpcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN0cmluZyBvZiB0ZXh0IHRvIGF1dG8tbGluay5cclxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSB0ZXh0IHdpdGggYW5jaG9yIHRhZ3MgYXV0by1maWxsZWQuXHJcblx0ICovXHJcblx0bGlua2lmeVN0ciA6IGZ1bmN0aW9uKCBzdHIgKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5nZXRNYXRjaFBhcnNlcigpLnJlcGxhY2UoIHN0ciwgdGhpcy5jcmVhdGVNYXRjaFJldHVyblZhbCwgdGhpcyApO1xyXG5cdH0sXHJcblxyXG5cclxuXHQvKipcclxuXHQgKiBDcmVhdGVzIHRoZSByZXR1cm4gc3RyaW5nIHZhbHVlIGZvciBhIGdpdmVuIG1hdGNoIGluIHRoZSBpbnB1dCBzdHJpbmcsXHJcblx0ICogZm9yIHRoZSB7QGxpbmsgI2xpbmtpZnlTdHJ9IG1ldGhvZC5cclxuXHQgKlxyXG5cdCAqIFRoaXMgbWV0aG9kIGhhbmRsZXMgdGhlIHtAbGluayAjcmVwbGFjZUZufSwgaWYgb25lIHdhcyBwcm92aWRlZC5cclxuXHQgKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtBdXRvbGlua2VyLm1hdGNoLk1hdGNofSBtYXRjaCBUaGUgTWF0Y2ggb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgbWF0Y2guXHJcblx0ICogQHJldHVybiB7U3RyaW5nfSBUaGUgc3RyaW5nIHRoYXQgdGhlIGBtYXRjaGAgc2hvdWxkIGJlIHJlcGxhY2VkIHdpdGguIFRoaXMgaXMgdXN1YWxseSB0aGUgYW5jaG9yIHRhZyBzdHJpbmcsIGJ1dFxyXG5cdCAqICAgbWF5IGJlIHRoZSBgbWF0Y2hTdHJgIGl0c2VsZiBpZiB0aGUgbWF0Y2ggaXMgbm90IHRvIGJlIHJlcGxhY2VkLlxyXG5cdCAqL1xyXG5cdGNyZWF0ZU1hdGNoUmV0dXJuVmFsIDogZnVuY3Rpb24oIG1hdGNoICkge1xyXG5cdFx0Ly8gSGFuZGxlIGEgY3VzdG9tIGByZXBsYWNlRm5gIGJlaW5nIHByb3ZpZGVkXHJcblx0XHR2YXIgcmVwbGFjZUZuUmVzdWx0O1xyXG5cdFx0aWYoIHRoaXMucmVwbGFjZUZuICkge1xyXG5cdFx0XHRyZXBsYWNlRm5SZXN1bHQgPSB0aGlzLnJlcGxhY2VGbi5jYWxsKCB0aGlzLCB0aGlzLCBtYXRjaCApOyAgLy8gQXV0b2xpbmtlciBpbnN0YW5jZSBpcyB0aGUgY29udGV4dCwgYW5kIHRoZSBmaXJzdCBhcmdcclxuXHRcdH1cclxuXHJcblx0XHRpZiggdHlwZW9mIHJlcGxhY2VGblJlc3VsdCA9PT0gJ3N0cmluZycgKSB7XHJcblx0XHRcdHJldHVybiByZXBsYWNlRm5SZXN1bHQ7ICAvLyBgcmVwbGFjZUZuYCByZXR1cm5lZCBhIHN0cmluZywgdXNlIHRoYXRcclxuXHJcblx0XHR9IGVsc2UgaWYoIHJlcGxhY2VGblJlc3VsdCA9PT0gZmFsc2UgKSB7XHJcblx0XHRcdHJldHVybiBtYXRjaC5nZXRNYXRjaGVkVGV4dCgpOyAgLy8gbm8gcmVwbGFjZW1lbnQgZm9yIHRoZSBtYXRjaFxyXG5cclxuXHRcdH0gZWxzZSBpZiggcmVwbGFjZUZuUmVzdWx0IGluc3RhbmNlb2YgQXV0b2xpbmtlci5IdG1sVGFnICkge1xyXG5cdFx0XHRyZXR1cm4gcmVwbGFjZUZuUmVzdWx0LnRvQW5jaG9yU3RyaW5nKCk7XHJcblxyXG5cdFx0fSBlbHNlIHsgIC8vIHJlcGxhY2VGblJlc3VsdCA9PT0gdHJ1ZSwgb3Igbm8vdW5rbm93biByZXR1cm4gdmFsdWUgZnJvbSBmdW5jdGlvblxyXG5cdFx0XHQvLyBQZXJmb3JtIEF1dG9saW5rZXIncyBkZWZhdWx0IGFuY2hvciB0YWcgZ2VuZXJhdGlvblxyXG5cdFx0XHR2YXIgdGFnQnVpbGRlciA9IHRoaXMuZ2V0VGFnQnVpbGRlcigpLFxyXG5cdFx0XHQgICAgYW5jaG9yVGFnID0gdGFnQnVpbGRlci5idWlsZCggbWF0Y2ggKTsgIC8vIHJldHVybnMgYW4gQXV0b2xpbmtlci5IdG1sVGFnIGluc3RhbmNlXHJcblxyXG5cdFx0XHRyZXR1cm4gYW5jaG9yVGFnLnRvQW5jaG9yU3RyaW5nKCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblxyXG5cdC8qKlxyXG5cdCAqIExhemlseSBpbnN0YW50aWF0ZXMgYW5kIHJldHVybnMgdGhlIHtAbGluayAjaHRtbFBhcnNlcn0gaW5zdGFuY2UgZm9yIHRoaXMgQXV0b2xpbmtlciBpbnN0YW5jZS5cclxuXHQgKlxyXG5cdCAqIEBwcm90ZWN0ZWRcclxuXHQgKiBAcmV0dXJuIHtBdXRvbGlua2VyLmh0bWxQYXJzZXIuSHRtbFBhcnNlcn1cclxuXHQgKi9cclxuXHRnZXRIdG1sUGFyc2VyIDogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgaHRtbFBhcnNlciA9IHRoaXMuaHRtbFBhcnNlcjtcclxuXHJcblx0XHRpZiggIWh0bWxQYXJzZXIgKSB7XHJcblx0XHRcdGh0bWxQYXJzZXIgPSB0aGlzLmh0bWxQYXJzZXIgPSBuZXcgQXV0b2xpbmtlci5odG1sUGFyc2VyLkh0bWxQYXJzZXIoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gaHRtbFBhcnNlcjtcclxuXHR9LFxyXG5cclxuXHJcblx0LyoqXHJcblx0ICogTGF6aWx5IGluc3RhbnRpYXRlcyBhbmQgcmV0dXJucyB0aGUge0BsaW5rICNtYXRjaFBhcnNlcn0gaW5zdGFuY2UgZm9yIHRoaXMgQXV0b2xpbmtlciBpbnN0YW5jZS5cclxuXHQgKlxyXG5cdCAqIEBwcm90ZWN0ZWRcclxuXHQgKiBAcmV0dXJuIHtBdXRvbGlua2VyLm1hdGNoUGFyc2VyLk1hdGNoUGFyc2VyfVxyXG5cdCAqL1xyXG5cdGdldE1hdGNoUGFyc2VyIDogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWF0Y2hQYXJzZXIgPSB0aGlzLm1hdGNoUGFyc2VyO1xyXG5cclxuXHRcdGlmKCAhbWF0Y2hQYXJzZXIgKSB7XHJcblx0XHRcdG1hdGNoUGFyc2VyID0gdGhpcy5tYXRjaFBhcnNlciA9IG5ldyBBdXRvbGlua2VyLm1hdGNoUGFyc2VyLk1hdGNoUGFyc2VyKCB7XHJcblx0XHRcdFx0dXJscyAgICAgICAgOiB0aGlzLnVybHMsXHJcblx0XHRcdFx0ZW1haWwgICAgICAgOiB0aGlzLmVtYWlsLFxyXG5cdFx0XHRcdHR3aXR0ZXIgICAgIDogdGhpcy50d2l0dGVyLFxyXG5cdFx0XHRcdHBob25lICAgICAgIDogdGhpcy5waG9uZSxcclxuXHRcdFx0XHRoYXNodGFnICAgICA6IHRoaXMuaGFzaHRhZyxcclxuXHRcdFx0XHRzdHJpcFByZWZpeCA6IHRoaXMuc3RyaXBQcmVmaXhcclxuXHRcdFx0fSApO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBtYXRjaFBhcnNlcjtcclxuXHR9LFxyXG5cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUge0BsaW5rICN0YWdCdWlsZGVyfSBpbnN0YW5jZSBmb3IgdGhpcyBBdXRvbGlua2VyIGluc3RhbmNlLCBsYXppbHkgaW5zdGFudGlhdGluZyBpdFxyXG5cdCAqIGlmIGl0IGRvZXMgbm90IHlldCBleGlzdC5cclxuXHQgKlxyXG5cdCAqIFRoaXMgbWV0aG9kIG1heSBiZSB1c2VkIGluIGEge0BsaW5rICNyZXBsYWNlRm59IHRvIGdlbmVyYXRlIHRoZSB7QGxpbmsgQXV0b2xpbmtlci5IdG1sVGFnIEh0bWxUYWd9IGluc3RhbmNlIHRoYXRcclxuXHQgKiBBdXRvbGlua2VyIHdvdWxkIG5vcm1hbGx5IGdlbmVyYXRlLCBhbmQgdGhlbiBhbGxvdyBmb3IgbW9kaWZpY2F0aW9ucyBiZWZvcmUgcmV0dXJuaW5nIGl0LiBGb3IgZXhhbXBsZTpcclxuXHQgKlxyXG5cdCAqICAgICB2YXIgaHRtbCA9IEF1dG9saW5rZXIubGluayggXCJUZXN0IGdvb2dsZS5jb21cIiwge1xyXG5cdCAqICAgICAgICAgcmVwbGFjZUZuIDogZnVuY3Rpb24oIGF1dG9saW5rZXIsIG1hdGNoICkge1xyXG5cdCAqICAgICAgICAgICAgIHZhciB0YWcgPSBhdXRvbGlua2VyLmdldFRhZ0J1aWxkZXIoKS5idWlsZCggbWF0Y2ggKTsgIC8vIHJldHVybnMgYW4ge0BsaW5rIEF1dG9saW5rZXIuSHRtbFRhZ30gaW5zdGFuY2VcclxuXHQgKiAgICAgICAgICAgICB0YWcuc2V0QXR0ciggJ3JlbCcsICdub2ZvbGxvdycgKTtcclxuXHQgKlxyXG5cdCAqICAgICAgICAgICAgIHJldHVybiB0YWc7XHJcblx0ICogICAgICAgICB9XHJcblx0ICogICAgIH0gKTtcclxuXHQgKlxyXG5cdCAqICAgICAvLyBnZW5lcmF0ZWQgaHRtbDpcclxuXHQgKiAgICAgLy8gICBUZXN0IDxhIGhyZWY9XCJodHRwOi8vZ29vZ2xlLmNvbVwiIHRhcmdldD1cIl9ibGFua1wiIHJlbD1cIm5vZm9sbG93XCI+Z29vZ2xlLmNvbTwvYT5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm4ge0F1dG9saW5rZXIuQW5jaG9yVGFnQnVpbGRlcn1cclxuXHQgKi9cclxuXHRnZXRUYWdCdWlsZGVyIDogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgdGFnQnVpbGRlciA9IHRoaXMudGFnQnVpbGRlcjtcclxuXHJcblx0XHRpZiggIXRhZ0J1aWxkZXIgKSB7XHJcblx0XHRcdHRhZ0J1aWxkZXIgPSB0aGlzLnRhZ0J1aWxkZXIgPSBuZXcgQXV0b2xpbmtlci5BbmNob3JUYWdCdWlsZGVyKCB7XHJcblx0XHRcdFx0bmV3V2luZG93ICAgOiB0aGlzLm5ld1dpbmRvdyxcclxuXHRcdFx0XHR0cnVuY2F0ZSAgICA6IHRoaXMudHJ1bmNhdGUsXHJcblx0XHRcdFx0Y2xhc3NOYW1lICAgOiB0aGlzLmNsYXNzTmFtZVxyXG5cdFx0XHR9ICk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRhZ0J1aWxkZXI7XHJcblx0fVxyXG5cclxufTtcclxuXHJcblxyXG4vKipcclxuICogQXV0b21hdGljYWxseSBsaW5rcyBVUkxzLCBFbWFpbCBhZGRyZXNzZXMsIFBob25lIE51bWJlcnMsIFR3aXR0ZXIgaGFuZGxlcyxcclxuICogYW5kIEhhc2h0YWdzIGZvdW5kIGluIHRoZSBnaXZlbiBjaHVuayBvZiBIVE1MLiBEb2VzIG5vdCBsaW5rIFVSTHMgZm91bmRcclxuICogd2l0aGluIEhUTUwgdGFncy5cclxuICpcclxuICogRm9yIGluc3RhbmNlLCBpZiBnaXZlbiB0aGUgdGV4dDogYFlvdSBzaG91bGQgZ28gdG8gaHR0cDovL3d3dy55YWhvby5jb21gLFxyXG4gKiB0aGVuIHRoZSByZXN1bHQgd2lsbCBiZSBgWW91IHNob3VsZCBnbyB0byAmbHQ7YSBocmVmPVwiaHR0cDovL3d3dy55YWhvby5jb21cIiZndDtodHRwOi8vd3d3LnlhaG9vLmNvbSZsdDsvYSZndDtgXHJcbiAqXHJcbiAqIEV4YW1wbGU6XHJcbiAqXHJcbiAqICAgICB2YXIgbGlua2VkVGV4dCA9IEF1dG9saW5rZXIubGluayggXCJHbyB0byBnb29nbGUuY29tXCIsIHsgbmV3V2luZG93OiBmYWxzZSB9ICk7XHJcbiAqICAgICAvLyBQcm9kdWNlczogXCJHbyB0byA8YSBocmVmPVwiaHR0cDovL2dvb2dsZS5jb21cIj5nb29nbGUuY29tPC9hPlwiXHJcbiAqXHJcbiAqIEBzdGF0aWNcclxuICogQHBhcmFtIHtTdHJpbmd9IHRleHRPckh0bWwgVGhlIEhUTUwgb3IgdGV4dCB0byBmaW5kIG1hdGNoZXMgd2l0aGluIChkZXBlbmRpbmdcclxuICogICBvbiBpZiB0aGUge0BsaW5rICN1cmxzfSwge0BsaW5rICNlbWFpbH0sIHtAbGluayAjcGhvbmV9LCB7QGxpbmsgI3R3aXR0ZXJ9LFxyXG4gKiAgIGFuZCB7QGxpbmsgI2hhc2h0YWd9IG9wdGlvbnMgYXJlIGVuYWJsZWQpLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEFueSBvZiB0aGUgY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgQXV0b2xpbmtlclxyXG4gKiAgIGNsYXNzLCBzcGVjaWZpZWQgaW4gYW4gT2JqZWN0IChtYXApLiBTZWUgdGhlIGNsYXNzIGRlc2NyaXB0aW9uIGZvciBhblxyXG4gKiAgIGV4YW1wbGUgY2FsbC5cclxuICogQHJldHVybiB7U3RyaW5nfSBUaGUgSFRNTCB0ZXh0LCB3aXRoIG1hdGNoZXMgYXV0b21hdGljYWxseSBsaW5rZWQuXHJcbiAqL1xyXG5BdXRvbGlua2VyLmxpbmsgPSBmdW5jdGlvbiggdGV4dE9ySHRtbCwgb3B0aW9ucyApIHtcclxuXHR2YXIgYXV0b2xpbmtlciA9IG5ldyBBdXRvbGlua2VyKCBvcHRpb25zICk7XHJcblx0cmV0dXJuIGF1dG9saW5rZXIubGluayggdGV4dE9ySHRtbCApO1xyXG59O1xyXG5cclxuXHJcbi8vIEF1dG9saW5rZXIgTmFtZXNwYWNlc1xyXG5BdXRvbGlua2VyLm1hdGNoID0ge307XHJcbkF1dG9saW5rZXIuaHRtbFBhcnNlciA9IHt9O1xyXG5BdXRvbGlua2VyLm1hdGNoUGFyc2VyID0ge307XHJcblxyXG4vKmdsb2JhbCBBdXRvbGlua2VyICovXHJcbi8qanNoaW50IGVxbnVsbDp0cnVlLCBib3NzOnRydWUgKi9cclxuLyoqXHJcbiAqIEBjbGFzcyBBdXRvbGlua2VyLlV0aWxcclxuICogQHNpbmdsZXRvblxyXG4gKlxyXG4gKiBBIGZldyB1dGlsaXR5IG1ldGhvZHMgZm9yIEF1dG9saW5rZXIuXHJcbiAqL1xyXG5BdXRvbGlua2VyLlV0aWwgPSB7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGFic3RyYWN0TWV0aG9kXHJcblx0ICpcclxuXHQgKiBBIGZ1bmN0aW9uIG9iamVjdCB3aGljaCByZXByZXNlbnRzIGFuIGFic3RyYWN0IG1ldGhvZC5cclxuXHQgKi9cclxuXHRhYnN0cmFjdE1ldGhvZCA6IGZ1bmN0aW9uKCkgeyB0aHJvdyBcImFic3RyYWN0XCI7IH0sXHJcblxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwcm9wZXJ0eSB7UmVnRXhwfSB0cmltUmVnZXhcclxuXHQgKlxyXG5cdCAqIFRoZSByZWd1bGFyIGV4cHJlc3Npb24gdXNlZCB0byB0cmltIHRoZSBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlXHJcblx0ICogZnJvbSBhIHN0cmluZy5cclxuXHQgKi9cclxuXHR0cmltUmVnZXggOiAvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2csXHJcblxyXG5cclxuXHQvKipcclxuXHQgKiBBc3NpZ25zIChzaGFsbG93IGNvcGllcykgdGhlIHByb3BlcnRpZXMgb2YgYHNyY2Agb250byBgZGVzdGAuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGVzdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBzcmMgVGhlIHNvdXJjZSBvYmplY3QuXHJcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgZGVzdGluYXRpb24gb2JqZWN0IChgZGVzdGApXHJcblx0ICovXHJcblx0YXNzaWduIDogZnVuY3Rpb24oIGRlc3QsIHNyYyApIHtcclxuXHRcdGZvciggdmFyIHByb3AgaW4gc3JjICkge1xyXG5cdFx0XHRpZiggc3JjLmhhc093blByb3BlcnR5KCBwcm9wICkgKSB7XHJcblx0XHRcdFx0ZGVzdFsgcHJvcCBdID0gc3JjWyBwcm9wIF07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZGVzdDtcclxuXHR9LFxyXG5cclxuXHJcblx0LyoqXHJcblx0ICogRXh0ZW5kcyBgc3VwZXJjbGFzc2AgdG8gY3JlYXRlIGEgbmV3IHN1YmNsYXNzLCBhZGRpbmcgdGhlIGBwcm90b1Byb3BzYCB0byB0aGUgbmV3IHN1YmNsYXNzJ3MgcHJvdG90eXBlLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gc3VwZXJjbGFzcyBUaGUgY29uc3RydWN0b3IgZnVuY3Rpb24gZm9yIHRoZSBzdXBlcmNsYXNzLlxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b1Byb3BzIFRoZSBtZXRob2RzL3Byb3BlcnRpZXMgdG8gYWRkIHRvIHRoZSBzdWJjbGFzcydzIHByb3RvdHlwZS4gVGhpcyBtYXkgY29udGFpbiB0aGVcclxuXHQgKiAgIHNwZWNpYWwgcHJvcGVydHkgYGNvbnN0cnVjdG9yYCwgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIHRoZSBuZXcgc3ViY2xhc3MncyBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cclxuXHQgKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIG5ldyBzdWJjbGFzcyBmdW5jdGlvbi5cclxuXHQgKi9cclxuXHRleHRlbmQgOiBmdW5jdGlvbiggc3VwZXJjbGFzcywgcHJvdG9Qcm9wcyApIHtcclxuXHRcdHZhciBzdXBlcmNsYXNzUHJvdG8gPSBzdXBlcmNsYXNzLnByb3RvdHlwZTtcclxuXHJcblx0XHR2YXIgRiA9IGZ1bmN0aW9uKCkge307XHJcblx0XHRGLnByb3RvdHlwZSA9IHN1cGVyY2xhc3NQcm90bztcclxuXHJcblx0XHR2YXIgc3ViY2xhc3M7XHJcblx0XHRpZiggcHJvdG9Qcm9wcy5oYXNPd25Qcm9wZXJ0eSggJ2NvbnN0cnVjdG9yJyApICkge1xyXG5cdFx0XHRzdWJjbGFzcyA9IHByb3RvUHJvcHMuY29uc3RydWN0b3I7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRzdWJjbGFzcyA9IGZ1bmN0aW9uKCkgeyBzdXBlcmNsYXNzUHJvdG8uY29uc3RydWN0b3IuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApOyB9O1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBzdWJjbGFzc1Byb3RvID0gc3ViY2xhc3MucHJvdG90eXBlID0gbmV3IEYoKTsgIC8vIHNldCB1cCBwcm90b3R5cGUgY2hhaW5cclxuXHRcdHN1YmNsYXNzUHJvdG8uY29uc3RydWN0b3IgPSBzdWJjbGFzczsgIC8vIGZpeCBjb25zdHJ1Y3RvciBwcm9wZXJ0eVxyXG5cdFx0c3ViY2xhc3NQcm90by5zdXBlcmNsYXNzID0gc3VwZXJjbGFzc1Byb3RvO1xyXG5cclxuXHRcdGRlbGV0ZSBwcm90b1Byb3BzLmNvbnN0cnVjdG9yOyAgLy8gZG9uJ3QgcmUtYXNzaWduIGNvbnN0cnVjdG9yIHByb3BlcnR5IHRvIHRoZSBwcm90b3R5cGUsIHNpbmNlIGEgbmV3IGZ1bmN0aW9uIG1heSBoYXZlIGJlZW4gY3JlYXRlZCAoYHN1YmNsYXNzYCksIHdoaWNoIGlzIG5vdyBhbHJlYWR5IHRoZXJlXHJcblx0XHRBdXRvbGlua2VyLlV0aWwuYXNzaWduKCBzdWJjbGFzc1Byb3RvLCBwcm90b1Byb3BzICk7XHJcblxyXG5cdFx0cmV0dXJuIHN1YmNsYXNzO1xyXG5cdH0sXHJcblxyXG5cclxuXHQvKipcclxuXHQgKiBUcnVuY2F0ZXMgdGhlIGBzdHJgIGF0IGBsZW4gLSBlbGxpcHNpc0NoYXJzLmxlbmd0aGAsIGFuZCBhZGRzIHRoZSBgZWxsaXBzaXNDaGFyc2AgdG8gdGhlXHJcblx0ICogZW5kIG9mIHRoZSBzdHJpbmcgKGJ5IGRlZmF1bHQsIHR3byBwZXJpb2RzOiAnLi4nKS4gSWYgdGhlIGBzdHJgIGxlbmd0aCBkb2VzIG5vdCBleGNlZWRcclxuXHQgKiBgbGVuYCwgdGhlIHN0cmluZyB3aWxsIGJlIHJldHVybmVkIHVuY2hhbmdlZC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0byB0cnVuY2F0ZSBhbmQgYWRkIGFuIGVsbGlwc2lzIHRvLlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0cnVuY2F0ZUxlbiBUaGUgbGVuZ3RoIHRvIHRydW5jYXRlIHRoZSBzdHJpbmcgYXQuXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IFtlbGxpcHNpc0NoYXJzPS4uXSBUaGUgZWxsaXBzaXMgY2hhcmFjdGVyKHMpIHRvIGFkZCB0byB0aGUgZW5kIG9mIGBzdHJgXHJcblx0ICogICB3aGVuIHRydW5jYXRlZC4gRGVmYXVsdHMgdG8gJy4uJ1xyXG5cdCAqL1xyXG5cdGVsbGlwc2lzIDogZnVuY3Rpb24oIHN0ciwgdHJ1bmNhdGVMZW4sIGVsbGlwc2lzQ2hhcnMgKSB7XHJcblx0XHRpZiggc3RyLmxlbmd0aCA+IHRydW5jYXRlTGVuICkge1xyXG5cdFx0XHRlbGxpcHNpc0NoYXJzID0gKCBlbGxpcHNpc0NoYXJzID09IG51bGwgKSA/ICcuLicgOiBlbGxpcHNpc0NoYXJzO1xyXG5cdFx0XHRzdHIgPSBzdHIuc3Vic3RyaW5nKCAwLCB0cnVuY2F0ZUxlbiAtIGVsbGlwc2lzQ2hhcnMubGVuZ3RoICkgKyBlbGxpcHNpc0NoYXJzO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHN0cjtcclxuXHR9LFxyXG5cclxuXHJcblx0LyoqXHJcblx0ICogU3VwcG9ydHMgYEFycmF5LnByb3RvdHlwZS5pbmRleE9mKClgIGZ1bmN0aW9uYWxpdHkgZm9yIG9sZCBJRSAoSUU4IGFuZCBiZWxvdykuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge0FycmF5fSBhcnIgVGhlIGFycmF5IHRvIGZpbmQgYW4gZWxlbWVudCBvZi5cclxuXHQgKiBAcGFyYW0geyp9IGVsZW1lbnQgVGhlIGVsZW1lbnQgdG8gZmluZCBpbiB0aGUgYXJyYXksIGFuZCByZXR1cm4gdGhlIGluZGV4IG9mLlxyXG5cdCAqIEByZXR1cm4ge051bWJlcn0gVGhlIGluZGV4IG9mIHRoZSBgZWxlbWVudGAsIG9yIC0xIGlmIGl0IHdhcyBub3QgZm91bmQuXHJcblx0ICovXHJcblx0aW5kZXhPZiA6IGZ1bmN0aW9uKCBhcnIsIGVsZW1lbnQgKSB7XHJcblx0XHRpZiggQXJyYXkucHJvdG90eXBlLmluZGV4T2YgKSB7XHJcblx0XHRcdHJldHVybiBhcnIuaW5kZXhPZiggZWxlbWVudCApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGZvciggdmFyIGkgPSAwLCBsZW4gPSBhcnIubGVuZ3RoOyBpIDwgbGVuOyBpKysgKSB7XHJcblx0XHRcdFx0aWYoIGFyclsgaSBdID09PSBlbGVtZW50ICkgcmV0dXJuIGk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIC0xO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cclxuXHJcblx0LyoqXHJcblx0ICogUGVyZm9ybXMgdGhlIGZ1bmN0aW9uYWxpdHkgb2Ygd2hhdCBtb2Rlcm4gYnJvd3NlcnMgZG8gd2hlbiBgU3RyaW5nLnByb3RvdHlwZS5zcGxpdCgpYCBpcyBjYWxsZWRcclxuXHQgKiB3aXRoIGEgcmVndWxhciBleHByZXNzaW9uIHRoYXQgY29udGFpbnMgY2FwdHVyaW5nIHBhcmVudGhlc2lzLlxyXG5cdCAqXHJcblx0ICogRm9yIGV4YW1wbGU6XHJcblx0ICpcclxuXHQgKiAgICAgLy8gTW9kZXJuIGJyb3dzZXJzOlxyXG5cdCAqICAgICBcImEsYixjXCIuc3BsaXQoIC8oLCkvICk7ICAvLyAtLT4gWyAnYScsICcsJywgJ2InLCAnLCcsICdjJyBdXHJcblx0ICpcclxuXHQgKiAgICAgLy8gT2xkIElFIChpbmNsdWRpbmcgSUU4KTpcclxuXHQgKiAgICAgXCJhLGIsY1wiLnNwbGl0KCAvKCwpLyApOyAgLy8gLS0+IFsgJ2EnLCAnYicsICdjJyBdXHJcblx0ICpcclxuXHQgKiBUaGlzIG1ldGhvZCBlbXVsYXRlcyB0aGUgZnVuY3Rpb25hbGl0eSBvZiBtb2Rlcm4gYnJvd3NlcnMgZm9yIHRoZSBvbGQgSUUgY2FzZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0byBzcGxpdC5cclxuXHQgKiBAcGFyYW0ge1JlZ0V4cH0gc3BsaXRSZWdleCBUaGUgcmVndWxhciBleHByZXNzaW9uIHRvIHNwbGl0IHRoZSBpbnB1dCBgc3RyYCBvbi4gVGhlIHNwbGl0dGluZ1xyXG5cdCAqICAgY2hhcmFjdGVyKHMpIHdpbGwgYmUgc3BsaWNlZCBpbnRvIHRoZSBhcnJheSwgYXMgaW4gdGhlIFwibW9kZXJuIGJyb3dzZXJzXCIgZXhhbXBsZSBpbiB0aGVcclxuXHQgKiAgIGRlc2NyaXB0aW9uIG9mIHRoaXMgbWV0aG9kLlxyXG5cdCAqICAgTm90ZSAjMTogdGhlIHN1cHBsaWVkIHJlZ3VsYXIgZXhwcmVzc2lvbiAqKm11c3QqKiBoYXZlIHRoZSAnZycgZmxhZyBzcGVjaWZpZWQuXHJcblx0ICogICBOb3RlICMyOiBmb3Igc2ltcGxpY2l0eSdzIHNha2UsIHRoZSByZWd1bGFyIGV4cHJlc3Npb24gZG9lcyBub3QgbmVlZFxyXG5cdCAqICAgdG8gY29udGFpbiBjYXB0dXJpbmcgcGFyZW50aGVzaXMgLSBpdCB3aWxsIGJlIGFzc3VtZWQgdGhhdCBhbnkgbWF0Y2ggaGFzIHRoZW0uXHJcblx0ICogQHJldHVybiB7U3RyaW5nW119IFRoZSBzcGxpdCBhcnJheSBvZiBzdHJpbmdzLCB3aXRoIHRoZSBzcGxpdHRpbmcgY2hhcmFjdGVyKHMpIGluY2x1ZGVkLlxyXG5cdCAqL1xyXG5cdHNwbGl0QW5kQ2FwdHVyZSA6IGZ1bmN0aW9uKCBzdHIsIHNwbGl0UmVnZXggKSB7XHJcblx0XHRpZiggIXNwbGl0UmVnZXguZ2xvYmFsICkgdGhyb3cgbmV3IEVycm9yKCBcImBzcGxpdFJlZ2V4YCBtdXN0IGhhdmUgdGhlICdnJyBmbGFnIHNldFwiICk7XHJcblxyXG5cdFx0dmFyIHJlc3VsdCA9IFtdLFxyXG5cdFx0ICAgIGxhc3RJZHggPSAwLFxyXG5cdFx0ICAgIG1hdGNoO1xyXG5cclxuXHRcdHdoaWxlKCBtYXRjaCA9IHNwbGl0UmVnZXguZXhlYyggc3RyICkgKSB7XHJcblx0XHRcdHJlc3VsdC5wdXNoKCBzdHIuc3Vic3RyaW5nKCBsYXN0SWR4LCBtYXRjaC5pbmRleCApICk7XHJcblx0XHRcdHJlc3VsdC5wdXNoKCBtYXRjaFsgMCBdICk7ICAvLyBwdXNoIHRoZSBzcGxpdHRpbmcgY2hhcihzKVxyXG5cclxuXHRcdFx0bGFzdElkeCA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbIDAgXS5sZW5ndGg7XHJcblx0XHR9XHJcblx0XHRyZXN1bHQucHVzaCggc3RyLnN1YnN0cmluZyggbGFzdElkeCApICk7XHJcblxyXG5cdFx0cmV0dXJuIHJlc3VsdDtcclxuXHR9LFxyXG5cclxuXHJcblx0LyoqXHJcblx0ICogVHJpbXMgdGhlIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UgZnJvbSBhIHN0cmluZy5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0byB0cmltLlxyXG5cdCAqIEByZXR1cm4ge1N0cmluZ31cclxuXHQgKi9cclxuXHR0cmltIDogZnVuY3Rpb24oIHN0ciApIHtcclxuXHRcdHJldHVybiBzdHIucmVwbGFjZSggdGhpcy50cmltUmVnZXgsICcnICk7XHJcblx0fVxyXG5cclxufTtcclxuLypnbG9iYWwgQXV0b2xpbmtlciAqL1xyXG4vKmpzaGludCBib3NzOnRydWUgKi9cclxuLyoqXHJcbiAqIEBjbGFzcyBBdXRvbGlua2VyLkh0bWxUYWdcclxuICogQGV4dGVuZHMgT2JqZWN0XHJcbiAqXHJcbiAqIFJlcHJlc2VudHMgYW4gSFRNTCB0YWcsIHdoaWNoIGNhbiBiZSB1c2VkIHRvIGVhc2lseSBidWlsZC9tb2RpZnkgSFRNTCB0YWdzIHByb2dyYW1tYXRpY2FsbHkuXHJcbiAqXHJcbiAqIEF1dG9saW5rZXIgdXNlcyB0aGlzIGFic3RyYWN0aW9uIHRvIGNyZWF0ZSBIVE1MIHRhZ3MsIGFuZCB0aGVuIHdyaXRlIHRoZW0gb3V0IGFzIHN0cmluZ3MuIFlvdSBtYXkgYWxzbyB1c2VcclxuICogdGhpcyBjbGFzcyBpbiB5b3VyIGNvZGUsIGVzcGVjaWFsbHkgd2l0aGluIGEge0BsaW5rIEF1dG9saW5rZXIjcmVwbGFjZUZuIHJlcGxhY2VGbn0uXHJcbiAqXHJcbiAqICMjIEV4YW1wbGVzXHJcbiAqXHJcbiAqIEV4YW1wbGUgaW5zdGFudGlhdGlvbjpcclxuICpcclxuICogICAgIHZhciB0YWcgPSBuZXcgQXV0b2xpbmtlci5IdG1sVGFnKCB7XHJcbiAqICAgICAgICAgdGFnTmFtZSA6ICdhJyxcclxuICogICAgICAgICBhdHRycyAgIDogeyAnaHJlZic6ICdodHRwOi8vZ29vZ2xlLmNvbScsICdjbGFzcyc6ICdleHRlcm5hbC1saW5rJyB9LFxyXG4gKiAgICAgICAgIGlubmVySHRtbCA6ICdHb29nbGUnXHJcbiAqICAgICB9ICk7XHJcbiAqXHJcbiAqICAgICB0YWcudG9BbmNob3JTdHJpbmcoKTsgIC8vIDxhIGhyZWY9XCJodHRwOi8vZ29vZ2xlLmNvbVwiIGNsYXNzPVwiZXh0ZXJuYWwtbGlua1wiPkdvb2dsZTwvYT5cclxuICpcclxuICogICAgIC8vIEluZGl2aWR1YWwgYWNjZXNzb3IgbWV0aG9kc1xyXG4gKiAgICAgdGFnLmdldFRhZ05hbWUoKTsgICAgICAgICAgICAgICAgIC8vICdhJ1xyXG4gKiAgICAgdGFnLmdldEF0dHIoICdocmVmJyApOyAgICAgICAgICAgIC8vICdodHRwOi8vZ29vZ2xlLmNvbSdcclxuICogICAgIHRhZy5oYXNDbGFzcyggJ2V4dGVybmFsLWxpbmsnICk7ICAvLyB0cnVlXHJcbiAqXHJcbiAqXHJcbiAqIFVzaW5nIG11dGF0b3IgbWV0aG9kcyAod2hpY2ggbWF5IGJlIHVzZWQgaW4gY29tYmluYXRpb24gd2l0aCBpbnN0YW50aWF0aW9uIGNvbmZpZyBwcm9wZXJ0aWVzKTpcclxuICpcclxuICogICAgIHZhciB0YWcgPSBuZXcgQXV0b2xpbmtlci5IdG1sVGFnKCk7XHJcbiAqICAgICB0YWcuc2V0VGFnTmFtZSggJ2EnICk7XHJcbiAqICAgICB0YWcuc2V0QXR0ciggJ2hyZWYnLCAnaHR0cDovL2dvb2dsZS5jb20nICk7XHJcbiAqICAgICB0YWcuYWRkQ2xhc3MoICdleHRlcm5hbC1saW5rJyApO1xyXG4gKiAgICAgdGFnLnNldElubmVySHRtbCggJ0dvb2dsZScgKTtcclxuICpcclxuICogICAgIHRhZy5nZXRUYWdOYW1lKCk7ICAgICAgICAgICAgICAgICAvLyAnYSdcclxuICogICAgIHRhZy5nZXRBdHRyKCAnaHJlZicgKTsgICAgICAgICAgICAvLyAnaHR0cDovL2dvb2dsZS5jb20nXHJcbiAqICAgICB0YWcuaGFzQ2xhc3MoICdleHRlcm5hbC1saW5rJyApOyAgLy8gdHJ1ZVxyXG4gKlxyXG4gKiAgICAgdGFnLnRvQW5jaG9yU3RyaW5nKCk7ICAvLyA8YSBocmVmPVwiaHR0cDovL2dvb2dsZS5jb21cIiBjbGFzcz1cImV4dGVybmFsLWxpbmtcIj5Hb29nbGU8L2E+XHJcbiAqXHJcbiAqXHJcbiAqICMjIEV4YW1wbGUgdXNlIHdpdGhpbiBhIHtAbGluayBBdXRvbGlua2VyI3JlcGxhY2VGbiByZXBsYWNlRm59XHJcbiAqXHJcbiAqICAgICB2YXIgaHRtbCA9IEF1dG9saW5rZXIubGluayggXCJUZXN0IGdvb2dsZS5jb21cIiwge1xyXG4gKiAgICAgICAgIHJlcGxhY2VGbiA6IGZ1bmN0aW9uKCBhdXRvbGlua2VyLCBtYXRjaCApIHtcclxuICogICAgICAgICAgICAgdmFyIHRhZyA9IGF1dG9saW5rZXIuZ2V0VGFnQnVpbGRlcigpLmJ1aWxkKCBtYXRjaCApOyAgLy8gcmV0dXJucyBhbiB7QGxpbmsgQXV0b2xpbmtlci5IdG1sVGFnfSBpbnN0YW5jZSwgY29uZmlndXJlZCB3aXRoIHRoZSBNYXRjaCdzIGhyZWYgYW5kIGFuY2hvciB0ZXh0XHJcbiAqICAgICAgICAgICAgIHRhZy5zZXRBdHRyKCAncmVsJywgJ25vZm9sbG93JyApO1xyXG4gKlxyXG4gKiAgICAgICAgICAgICByZXR1cm4gdGFnO1xyXG4gKiAgICAgICAgIH1cclxuICogICAgIH0gKTtcclxuICpcclxuICogICAgIC8vIGdlbmVyYXRlZCBodG1sOlxyXG4gKiAgICAgLy8gICBUZXN0IDxhIGhyZWY9XCJodHRwOi8vZ29vZ2xlLmNvbVwiIHRhcmdldD1cIl9ibGFua1wiIHJlbD1cIm5vZm9sbG93XCI+Z29vZ2xlLmNvbTwvYT5cclxuICpcclxuICpcclxuICogIyMgRXhhbXBsZSB1c2Ugd2l0aCBhIG5ldyB0YWcgZm9yIHRoZSByZXBsYWNlbWVudFxyXG4gKlxyXG4gKiAgICAgdmFyIGh0bWwgPSBBdXRvbGlua2VyLmxpbmsoIFwiVGVzdCBnb29nbGUuY29tXCIsIHtcclxuICogICAgICAgICByZXBsYWNlRm4gOiBmdW5jdGlvbiggYXV0b2xpbmtlciwgbWF0Y2ggKSB7XHJcbiAqICAgICAgICAgICAgIHZhciB0YWcgPSBuZXcgQXV0b2xpbmtlci5IdG1sVGFnKCB7XHJcbiAqICAgICAgICAgICAgICAgICB0YWdOYW1lIDogJ2J1dHRvbicsXHJcbiAqICAgICAgICAgICAgICAgICBhdHRycyAgIDogeyAndGl0bGUnOiAnTG9hZCBVUkw6ICcgKyBtYXRjaC5nZXRBbmNob3JIcmVmKCkgfSxcclxuICogICAgICAgICAgICAgICAgIGlubmVySHRtbCA6ICdMb2FkIFVSTDogJyArIG1hdGNoLmdldEFuY2hvclRleHQoKVxyXG4gKiAgICAgICAgICAgICB9ICk7XHJcbiAqXHJcbiAqICAgICAgICAgICAgIHJldHVybiB0YWc7XHJcbiAqICAgICAgICAgfVxyXG4gKiAgICAgfSApO1xyXG4gKlxyXG4gKiAgICAgLy8gZ2VuZXJhdGVkIGh0bWw6XHJcbiAqICAgICAvLyAgIFRlc3QgPGJ1dHRvbiB0aXRsZT1cIkxvYWQgVVJMOiBodHRwOi8vZ29vZ2xlLmNvbVwiPkxvYWQgVVJMOiBnb29nbGUuY29tPC9idXR0b24+XHJcbiAqL1xyXG5BdXRvbGlua2VyLkh0bWxUYWcgPSBBdXRvbGlua2VyLlV0aWwuZXh0ZW5kKCBPYmplY3QsIHtcclxuXHJcblx0LyoqXHJcblx0ICogQGNmZyB7U3RyaW5nfSB0YWdOYW1lXHJcblx0ICpcclxuXHQgKiBUaGUgdGFnIG5hbWUuIEV4OiAnYScsICdidXR0b24nLCBldGMuXHJcblx0ICpcclxuXHQgKiBOb3QgcmVxdWlyZWQgYXQgaW5zdGFudGlhdGlvbiB0aW1lLCBidXQgc2hvdWxkIGJlIHNldCB1c2luZyB7QGxpbmsgI3NldFRhZ05hbWV9IGJlZm9yZSB7QGxpbmsgI3RvQW5jaG9yU3RyaW5nfVxyXG5cdCAqIGlzIGV4ZWN1dGVkLlxyXG5cdCAqL1xyXG5cclxuXHQvKipcclxuXHQgKiBAY2ZnIHtPYmplY3QuPFN0cmluZywgU3RyaW5nPn0gYXR0cnNcclxuXHQgKlxyXG5cdCAqIEFuIGtleS92YWx1ZSBPYmplY3QgKG1hcCkgb2YgYXR0cmlidXRlcyB0byBjcmVhdGUgdGhlIHRhZyB3aXRoLiBUaGUga2V5cyBhcmUgdGhlIGF0dHJpYnV0ZSBuYW1lcywgYW5kIHRoZVxyXG5cdCAqIHZhbHVlcyBhcmUgdGhlIGF0dHJpYnV0ZSB2YWx1ZXMuXHJcblx0ICovXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBjZmcge1N0cmluZ30gaW5uZXJIdG1sXHJcblx0ICpcclxuXHQgKiBUaGUgaW5uZXIgSFRNTCBmb3IgdGhlIHRhZy5cclxuXHQgKlxyXG5cdCAqIE5vdGUgdGhlIGNhbWVsIGNhc2UgbmFtZSBvbiBgaW5uZXJIdG1sYC4gQWNyb255bXMgYXJlIGNhbWVsQ2FzZWQgaW4gdGhpcyB1dGlsaXR5IChzdWNoIGFzIG5vdCB0byBydW4gaW50byB0aGUgYWNyb255bVxyXG5cdCAqIG5hbWluZyBpbmNvbnNpc3RlbmN5IHRoYXQgdGhlIERPTSBkZXZlbG9wZXJzIGNyZWF0ZWQgd2l0aCBgWE1MSHR0cFJlcXVlc3RgKS4gWW91IG1heSBhbHRlcm5hdGl2ZWx5IHVzZSB7QGxpbmsgI2lubmVySFRNTH1cclxuXHQgKiBpZiB5b3UgcHJlZmVyLCBidXQgdGhpcyBvbmUgaXMgcmVjb21tZW5kZWQuXHJcblx0ICovXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBjZmcge1N0cmluZ30gaW5uZXJIVE1MXHJcblx0ICpcclxuXHQgKiBBbGlhcyBvZiB7QGxpbmsgI2lubmVySHRtbH0sIGFjY2VwdGVkIGZvciBjb25zaXN0ZW5jeSB3aXRoIHRoZSBicm93c2VyIERPTSBhcGksIGJ1dCBwcmVmZXIgdGhlIGNhbWVsQ2FzZWQgdmVyc2lvblxyXG5cdCAqIGZvciBhY3JvbnltIG5hbWVzLlxyXG5cdCAqL1xyXG5cclxuXHJcblx0LyoqXHJcblx0ICogQHByb3RlY3RlZFxyXG5cdCAqIEBwcm9wZXJ0eSB7UmVnRXhwfSB3aGl0ZXNwYWNlUmVnZXhcclxuXHQgKlxyXG5cdCAqIFJlZ3VsYXIgZXhwcmVzc2lvbiB1c2VkIHRvIG1hdGNoIHdoaXRlc3BhY2UgaW4gYSBzdHJpbmcgb2YgQ1NTIGNsYXNzZXMuXHJcblx0ICovXHJcblx0d2hpdGVzcGFjZVJlZ2V4IDogL1xccysvLFxyXG5cclxuXHJcblx0LyoqXHJcblx0ICogQGNvbnN0cnVjdG9yXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IFtjZmddIFRoZSBjb25maWd1cmF0aW9uIHByb3BlcnRpZXMgZm9yIHRoaXMgY2xhc3MsIGluIGFuIE9iamVjdCAobWFwKVxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yIDogZnVuY3Rpb24oIGNmZyApIHtcclxuXHRcdEF1dG9saW5rZXIuVXRpbC5hc3NpZ24oIHRoaXMsIGNmZyApO1xyXG5cclxuXHRcdHRoaXMuaW5uZXJIdG1sID0gdGhpcy5pbm5lckh0bWwgfHwgdGhpcy5pbm5lckhUTUw7ICAvLyBhY2NlcHQgZWl0aGVyIHRoZSBjYW1lbENhc2VkIGZvcm0gb3IgdGhlIGZ1bGx5IGNhcGl0YWxpemVkIGFjcm9ueW1cclxuXHR9LFxyXG5cclxuXHJcblx0LyoqXHJcblx0ICogU2V0cyB0aGUgdGFnIG5hbWUgdGhhdCB3aWxsIGJlIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIHRhZyB3aXRoLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHRhZ05hbWVcclxuXHQgKiBAcmV0dXJuIHtBdXRvbGlua2VyLkh0bWxUYWd9IFRoaXMgSHRtbFRhZyBpbnN0YW5jZSwgc28gdGhhdCBtZXRob2QgY2FsbHMgbWF5IGJlIGNoYWluZWQuXHJcblx0ICovXHJcblx0c2V0VGFnTmFtZSA6IGZ1bmN0aW9uKCB0YWdOYW1lICkge1xyXG5cdFx0dGhpcy50YWdOYW1lID0gdGFnTmFtZTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cclxuXHQvKipcclxuXHQgKiBSZXRyaWV2ZXMgdGhlIHRhZyBuYW1lLlxyXG5cdCAqXHJcblx0ICogQHJldHVybiB7U3RyaW5nfVxyXG5cdCAqL1xyXG5cdGdldFRhZ05hbWUgOiBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB0aGlzLnRhZ05hbWUgfHwgXCJcIjtcclxuXHR9LFxyXG5cclxuXHJcblx0LyoqXHJcblx0ICogU2V0cyBhbiBhdHRyaWJ1dGUgb24gdGhlIEh0bWxUYWcuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gYXR0ck5hbWUgVGhlIGF0dHJpYnV0ZSBuYW1lIHRvIHNldC5cclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gYXR0clZhbHVlIFRoZSBhdHRyaWJ1dGUgdmFsdWUgdG8gc2V0LlxyXG5cdCAqIEByZXR1cm4ge0F1dG9saW5rZXIuSHRtbFRhZ30gVGhpcyBIdG1sVGFnIGluc3RhbmNlLCBzbyB0aGF0IG1ldGhvZCBjYWxscyBtYXkgYmUgY2hhaW5lZC5cclxuXHQgKi9cclxuXHRzZXRBdHRyIDogZnVuY3Rpb24oIGF0dHJOYW1lLCBhdHRyVmFsdWUgKSB7XHJcblx0XHR2YXIgdGFnQXR0cnMgPSB0aGlzLmdldEF0dHJzKCk7XHJcblx0XHR0YWdBdHRyc1sgYXR0ck5hbWUgXSA9IGF0dHJWYWx1ZTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHJcblx0LyoqXHJcblx0ICogUmV0cmlldmVzIGFuIGF0dHJpYnV0ZSBmcm9tIHRoZSBIdG1sVGFnLiBJZiB0aGUgYXR0cmlidXRlIGRvZXMgbm90IGV4aXN0LCByZXR1cm5zIGB1bmRlZmluZWRgLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIGF0dHJpYnV0ZSBuYW1lIHRvIHJldHJpZXZlLlxyXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGF0dHJpYnV0ZSdzIHZhbHVlLCBvciBgdW5kZWZpbmVkYCBpZiBpdCBkb2VzIG5vdCBleGlzdCBvbiB0aGUgSHRtbFRhZy5cclxuXHQgKi9cclxuXHRnZXRBdHRyIDogZnVuY3Rpb24oIGF0dHJOYW1lICkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0QXR0cnMoKVsgYXR0ck5hbWUgXTtcclxuXHR9LFxyXG5cclxuXHJcblx0LyoqXHJcblx0ICogU2V0cyBvbmUgb3IgbW9yZSBhdHRyaWJ1dGVzIG9uIHRoZSBIdG1sVGFnLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtPYmplY3QuPFN0cmluZywgU3RyaW5nPn0gYXR0cnMgQSBrZXkvdmFsdWUgT2JqZWN0IChtYXApIG9mIHRoZSBhdHRyaWJ1dGVzIHRvIHNldC5cclxuXHQgKiBAcmV0dXJuIHtBdXRvbGlua2VyLkh0bWxUYWd9IFRoaXMgSHRtbFRhZyBpbnN0YW5jZSwgc28gdGhhdCBtZXRob2QgY2FsbHMgbWF5IGJlIGNoYWluZWQuXHJcblx0ICovXHJcblx0c2V0QXR0cnMgOiBmdW5jdGlvbiggYXR0cnMgKSB7XHJcblx0XHR2YXIgdGFnQXR0cnMgPSB0aGlzLmdldEF0dHJzKCk7XHJcblx0XHRBdXRvbGlua2VyLlV0aWwuYXNzaWduKCB0YWdBdHRycywgYXR0cnMgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHJcblx0LyoqXHJcblx0ICogUmV0cmlldmVzIHRoZSBhdHRyaWJ1dGVzIE9iamVjdCAobWFwKSBmb3IgdGhlIEh0bWxUYWcuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJuIHtPYmplY3QuPFN0cmluZywgU3RyaW5nPn0gQSBrZXkvdmFsdWUgb2JqZWN0IG9mIHRoZSBhdHRyaWJ1dGVzIGZvciB0aGUgSHRtbFRhZy5cclxuXHQgKi9cclxuXHRnZXRBdHRycyA6IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuYXR0cnMgfHwgKCB0aGlzLmF0dHJzID0ge30gKTtcclxuXHR9LFxyXG5cclxuXHJcblx0LyoqXHJcblx0ICogU2V0cyB0aGUgcHJvdmlkZWQgYGNzc0NsYXNzYCwgb3ZlcndyaXRpbmcgYW55IGN1cnJlbnQgQ1NTIGNsYXNzZXMgb24gdGhlIEh0bWxUYWcuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gY3NzQ2xhc3MgT25lIG9yIG1vcmUgc3BhY2Utc2VwYXJhdGVkIENTUyBjbGFzc2VzIHRvIHNldCAob3ZlcndyaXRlKS5cclxuXHQgKiBAcmV0dXJuIHtBdXRvbGlua2VyLkh0bWxUYWd9IFRoaXMgSHRtbFRhZyBpbnN0YW5jZSwgc28gdGhhdCBtZXRob2QgY2FsbHMgbWF5IGJlIGNoYWluZWQuXHJcblx0ICovXHJcblx0c2V0Q2xhc3MgOiBmdW5jdGlvbiggY3NzQ2xhc3MgKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5zZXRBdHRyKCAnY2xhc3MnLCBjc3NDbGFzcyApO1xyXG5cdH0sXHJcblxyXG5cclxuXHQvKipcclxuXHQgKiBDb252ZW5pZW5jZSBtZXRob2QgdG8gYWRkIG9uZSBvciBtb3JlIENTUyBjbGFzc2VzIHRvIHRoZSBIdG1sVGFnLiBXaWxsIG5vdCBhZGQgZHVwbGljYXRlIENTUyBjbGFzc2VzLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IGNzc0NsYXNzIE9uZSBvciBtb3JlIHNwYWNlLXNlcGFyYXRlZCBDU1MgY2xhc3NlcyB0byBhZGQuXHJcblx0ICogQHJldHVybiB7QXV0b2xpbmtlci5IdG1sVGFnfSBUaGlzIEh0bWxUYWcgaW5zdGFuY2UsIHNvIHRoYXQgbWV0aG9kIGNhbGxzIG1heSBiZSBjaGFpbmVkLlxyXG5cdCAqL1xyXG5cdGFkZENsYXNzIDogZnVuY3Rpb24oIGNzc0NsYXNzICkge1xyXG5cdFx0dmFyIGNsYXNzQXR0ciA9IHRoaXMuZ2V0Q2xhc3MoKSxcclxuXHRcdCAgICB3aGl0ZXNwYWNlUmVnZXggPSB0aGlzLndoaXRlc3BhY2VSZWdleCxcclxuXHRcdCAgICBpbmRleE9mID0gQXV0b2xpbmtlci5VdGlsLmluZGV4T2YsICAvLyB0byBzdXBwb3J0IElFOCBhbmQgYmVsb3dcclxuXHRcdCAgICBjbGFzc2VzID0gKCAhY2xhc3NBdHRyICkgPyBbXSA6IGNsYXNzQXR0ci5zcGxpdCggd2hpdGVzcGFjZVJlZ2V4ICksXHJcblx0XHQgICAgbmV3Q2xhc3NlcyA9IGNzc0NsYXNzLnNwbGl0KCB3aGl0ZXNwYWNlUmVnZXggKSxcclxuXHRcdCAgICBuZXdDbGFzcztcclxuXHJcblx0XHR3aGlsZSggbmV3Q2xhc3MgPSBuZXdDbGFzc2VzLnNoaWZ0KCkgKSB7XHJcblx0XHRcdGlmKCBpbmRleE9mKCBjbGFzc2VzLCBuZXdDbGFzcyApID09PSAtMSApIHtcclxuXHRcdFx0XHRjbGFzc2VzLnB1c2goIG5ld0NsYXNzICk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmdldEF0dHJzKClbICdjbGFzcycgXSA9IGNsYXNzZXMuam9pbiggXCIgXCIgKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cclxuXHQvKipcclxuXHQgKiBDb252ZW5pZW5jZSBtZXRob2QgdG8gcmVtb3ZlIG9uZSBvciBtb3JlIENTUyBjbGFzc2VzIGZyb20gdGhlIEh0bWxUYWcuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gY3NzQ2xhc3MgT25lIG9yIG1vcmUgc3BhY2Utc2VwYXJhdGVkIENTUyBjbGFzc2VzIHRvIHJlbW92ZS5cclxuXHQgKiBAcmV0dXJuIHtBdXRvbGlua2VyLkh0bWxUYWd9IFRoaXMgSHRtbFRhZyBpbnN0YW5jZSwgc28gdGhhdCBtZXRob2QgY2FsbHMgbWF5IGJlIGNoYWluZWQuXHJcblx0ICovXHJcblx0cmVtb3ZlQ2xhc3MgOiBmdW5jdGlvbiggY3NzQ2xhc3MgKSB7XHJcblx0XHR2YXIgY2xhc3NBdHRyID0gdGhpcy5nZXRDbGFzcygpLFxyXG5cdFx0ICAgIHdoaXRlc3BhY2VSZWdleCA9IHRoaXMud2hpdGVzcGFjZVJlZ2V4LFxyXG5cdFx0ICAgIGluZGV4T2YgPSBBdXRvbGlua2VyLlV0aWwuaW5kZXhPZiwgIC8vIHRvIHN1cHBvcnQgSUU4IGFuZCBiZWxvd1xyXG5cdFx0ICAgIGNsYXNzZXMgPSAoICFjbGFzc0F0dHIgKSA/IFtdIDogY2xhc3NBdHRyLnNwbGl0KCB3aGl0ZXNwYWNlUmVnZXggKSxcclxuXHRcdCAgICByZW1vdmVDbGFzc2VzID0gY3NzQ2xhc3Muc3BsaXQoIHdoaXRlc3BhY2VSZWdleCApLFxyXG5cdFx0ICAgIHJlbW92ZUNsYXNzO1xyXG5cclxuXHRcdHdoaWxlKCBjbGFzc2VzLmxlbmd0aCAmJiAoIHJlbW92ZUNsYXNzID0gcmVtb3ZlQ2xhc3Nlcy5zaGlmdCgpICkgKSB7XHJcblx0XHRcdHZhciBpZHggPSBpbmRleE9mKCBjbGFzc2VzLCByZW1vdmVDbGFzcyApO1xyXG5cdFx0XHRpZiggaWR4ICE9PSAtMSApIHtcclxuXHRcdFx0XHRjbGFzc2VzLnNwbGljZSggaWR4LCAxICk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmdldEF0dHJzKClbICdjbGFzcycgXSA9IGNsYXNzZXMuam9pbiggXCIgXCIgKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cclxuXHQvKipcclxuXHQgKiBDb252ZW5pZW5jZSBtZXRob2QgdG8gcmV0cmlldmUgdGhlIENTUyBjbGFzcyhlcykgZm9yIHRoZSBIdG1sVGFnLCB3aGljaCB3aWxsIGVhY2ggYmUgc2VwYXJhdGVkIGJ5IHNwYWNlcyB3aGVuXHJcblx0ICogdGhlcmUgYXJlIG11bHRpcGxlLlxyXG5cdCAqXHJcblx0ICogQHJldHVybiB7U3RyaW5nfVxyXG5cdCAqL1xyXG5cdGdldENsYXNzIDogZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5nZXRBdHRycygpWyAnY2xhc3MnIF0gfHwgXCJcIjtcclxuXHR9LFxyXG5cclxuXHJcblx0LyoqXHJcblx0ICogQ29udmVuaWVuY2UgbWV0aG9kIHRvIGNoZWNrIGlmIHRoZSB0YWcgaGFzIGEgQ1NTIGNsYXNzIG9yIG5vdC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBjc3NDbGFzcyBUaGUgQ1NTIGNsYXNzIHRvIGNoZWNrIGZvci5cclxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIEh0bWxUYWcgaGFzIHRoZSBDU1MgY2xhc3MsIGBmYWxzZWAgb3RoZXJ3aXNlLlxyXG5cdCAqL1xyXG5cdGhhc0NsYXNzIDogZnVuY3Rpb24oIGNzc0NsYXNzICkge1xyXG5cdFx0cmV0dXJuICggJyAnICsgdGhpcy5nZXRDbGFzcygpICsgJyAnICkuaW5kZXhPZiggJyAnICsgY3NzQ2xhc3MgKyAnICcgKSAhPT0gLTE7XHJcblx0fSxcclxuXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldHMgdGhlIGlubmVyIEhUTUwgZm9yIHRoZSB0YWcuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaHRtbCBUaGUgaW5uZXIgSFRNTCB0byBzZXQuXHJcblx0ICogQHJldHVybiB7QXV0b2xpbmtlci5IdG1sVGFnfSBUaGlzIEh0bWxUYWcgaW5zdGFuY2UsIHNvIHRoYXQgbWV0aG9kIGNhbGxzIG1heSBiZSBjaGFpbmVkLlxyXG5cdCAqL1xyXG5cdHNldElubmVySHRtbCA6IGZ1bmN0aW9uKCBodG1sICkge1xyXG5cdFx0dGhpcy5pbm5lckh0bWwgPSBodG1sO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cclxuXHQvKipcclxuXHQgKiBSZXRyaWV2ZXMgdGhlIGlubmVyIEhUTUwgZm9yIHRoZSB0YWcuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9XHJcblx0ICovXHJcblx0Z2V0SW5uZXJIdG1sIDogZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5pbm5lckh0bWwgfHwgXCJcIjtcclxuXHR9LFxyXG5cclxuXHJcblx0LyoqXHJcblx0ICogT3ZlcnJpZGUgb2Ygc3VwZXJjbGFzcyBtZXRob2QgdXNlZCB0byBnZW5lcmF0ZSB0aGUgSFRNTCBzdHJpbmcgZm9yIHRoZSB0YWcuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9XHJcblx0ICovXHJcblx0dG9BbmNob3JTdHJpbmcgOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciB0YWdOYW1lID0gdGhpcy5nZXRUYWdOYW1lKCksXHJcblx0XHQgICAgYXR0cnNTdHIgPSB0aGlzLmJ1aWxkQXR0cnNTdHIoKTtcclxuXHJcblx0XHRhdHRyc1N0ciA9ICggYXR0cnNTdHIgKSA/ICcgJyArIGF0dHJzU3RyIDogJyc7ICAvLyBwcmVwZW5kIGEgc3BhY2UgaWYgdGhlcmUgYXJlIGFjdHVhbGx5IGF0dHJpYnV0ZXNcclxuXHJcblx0XHRyZXR1cm4gWyAnPCcsIHRhZ05hbWUsIGF0dHJzU3RyLCAnPicsIHRoaXMuZ2V0SW5uZXJIdG1sKCksICc8LycsIHRhZ05hbWUsICc+JyBdLmpvaW4oIFwiXCIgKTtcclxuXHR9LFxyXG5cclxuXHJcblx0LyoqXHJcblx0ICogU3VwcG9ydCBtZXRob2QgZm9yIHtAbGluayAjdG9BbmNob3JTdHJpbmd9LCByZXR1cm5zIHRoZSBzdHJpbmcgc3BhY2Utc2VwYXJhdGVkIGtleT1cInZhbHVlXCIgcGFpcnMsIHVzZWQgdG8gcG9wdWxhdGVcclxuXHQgKiB0aGUgc3RyaW5naWZpZWQgSHRtbFRhZy5cclxuXHQgKlxyXG5cdCAqIEBwcm90ZWN0ZWRcclxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IEV4YW1wbGUgcmV0dXJuOiBgYXR0cjE9XCJ2YWx1ZTFcIiBhdHRyMj1cInZhbHVlMlwiYFxyXG5cdCAqL1xyXG5cdGJ1aWxkQXR0cnNTdHIgOiBmdW5jdGlvbigpIHtcclxuXHRcdGlmKCAhdGhpcy5hdHRycyApIHJldHVybiBcIlwiOyAgLy8gbm8gYGF0dHJzYCBPYmplY3QgKG1hcCkgaGFzIGJlZW4gc2V0LCByZXR1cm4gZW1wdHkgc3RyaW5nXHJcblxyXG5cdFx0dmFyIGF0dHJzID0gdGhpcy5nZXRBdHRycygpLFxyXG5cdFx0ICAgIGF0dHJzQXJyID0gW107XHJcblxyXG5cdFx0Zm9yKCB2YXIgcHJvcCBpbiBhdHRycyApIHtcclxuXHRcdFx0aWYoIGF0dHJzLmhhc093blByb3BlcnR5KCBwcm9wICkgKSB7XHJcblx0XHRcdFx0YXR0cnNBcnIucHVzaCggcHJvcCArICc9XCInICsgYXR0cnNbIHByb3AgXSArICdcIicgKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGF0dHJzQXJyLmpvaW4oIFwiIFwiICk7XHJcblx0fVxyXG5cclxufSApO1xyXG5cclxuLypnbG9iYWwgQXV0b2xpbmtlciAqL1xyXG4vKmpzaGludCBzdWI6dHJ1ZSAqL1xyXG4vKipcclxuICogQHByb3RlY3RlZFxyXG4gKiBAY2xhc3MgQXV0b2xpbmtlci5BbmNob3JUYWdCdWlsZGVyXHJcbiAqIEBleHRlbmRzIE9iamVjdFxyXG4gKlxyXG4gKiBCdWlsZHMgYW5jaG9yICgmbHQ7YSZndDspIHRhZ3MgZm9yIHRoZSBBdXRvbGlua2VyIHV0aWxpdHkgd2hlbiBhIG1hdGNoIGlzIGZvdW5kLlxyXG4gKlxyXG4gKiBOb3JtYWxseSB0aGlzIGNsYXNzIGlzIGluc3RhbnRpYXRlZCwgY29uZmlndXJlZCwgYW5kIHVzZWQgaW50ZXJuYWxseSBieSBhbiB7QGxpbmsgQXV0b2xpbmtlcn0gaW5zdGFuY2UsIGJ1dCBtYXlcclxuICogYWN0dWFsbHkgYmUgcmV0cmlldmVkIGluIGEge0BsaW5rIEF1dG9saW5rZXIjcmVwbGFjZUZuIHJlcGxhY2VGbn0gdG8gY3JlYXRlIHtAbGluayBBdXRvbGlua2VyLkh0bWxUYWcgSHRtbFRhZ30gaW5zdGFuY2VzXHJcbiAqIHdoaWNoIG1heSBiZSBtb2RpZmllZCBiZWZvcmUgcmV0dXJuaW5nIGZyb20gdGhlIHtAbGluayBBdXRvbGlua2VyI3JlcGxhY2VGbiByZXBsYWNlRm59LiBGb3IgZXhhbXBsZTpcclxuICpcclxuICogICAgIHZhciBodG1sID0gQXV0b2xpbmtlci5saW5rKCBcIlRlc3QgZ29vZ2xlLmNvbVwiLCB7XHJcbiAqICAgICAgICAgcmVwbGFjZUZuIDogZnVuY3Rpb24oIGF1dG9saW5rZXIsIG1hdGNoICkge1xyXG4gKiAgICAgICAgICAgICB2YXIgdGFnID0gYXV0b2xpbmtlci5nZXRUYWdCdWlsZGVyKCkuYnVpbGQoIG1hdGNoICk7ICAvLyByZXR1cm5zIGFuIHtAbGluayBBdXRvbGlua2VyLkh0bWxUYWd9IGluc3RhbmNlXHJcbiAqICAgICAgICAgICAgIHRhZy5zZXRBdHRyKCAncmVsJywgJ25vZm9sbG93JyApO1xyXG4gKlxyXG4gKiAgICAgICAgICAgICByZXR1cm4gdGFnO1xyXG4gKiAgICAgICAgIH1cclxuICogICAgIH0gKTtcclxuICpcclxuICogICAgIC8vIGdlbmVyYXRlZCBodG1sOlxyXG4gKiAgICAgLy8gICBUZXN0IDxhIGhyZWY9XCJodHRwOi8vZ29vZ2xlLmNvbVwiIHRhcmdldD1cIl9ibGFua1wiIHJlbD1cIm5vZm9sbG93XCI+Z29vZ2xlLmNvbTwvYT5cclxuICovXHJcbkF1dG9saW5rZXIuQW5jaG9yVGFnQnVpbGRlciA9IEF1dG9saW5rZXIuVXRpbC5leHRlbmQoIE9iamVjdCwge1xyXG5cclxuXHQvKipcclxuXHQgKiBAY2ZnIHtCb29sZWFufSBuZXdXaW5kb3dcclxuXHQgKiBAaW5oZXJpdGRvYyBBdXRvbGlua2VyI25ld1dpbmRvd1xyXG5cdCAqL1xyXG5cclxuXHQvKipcclxuXHQgKiBAY2ZnIHtOdW1iZXJ9IHRydW5jYXRlXHJcblx0ICogQGluaGVyaXRkb2MgQXV0b2xpbmtlciN0cnVuY2F0ZVxyXG5cdCAqL1xyXG5cclxuXHQvKipcclxuXHQgKiBAY2ZnIHtTdHJpbmd9IGNsYXNzTmFtZVxyXG5cdCAqIEBpbmhlcml0ZG9jIEF1dG9saW5rZXIjY2xhc3NOYW1lXHJcblx0ICovXHJcblxyXG5cclxuXHQvKipcclxuXHQgKiBAY29uc3RydWN0b3JcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gW2NmZ10gVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIEFuY2hvclRhZ0J1aWxkZXIgaW5zdGFuY2UsIHNwZWNpZmllZCBpbiBhbiBPYmplY3QgKG1hcCkuXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IgOiBmdW5jdGlvbiggY2ZnICkge1xyXG5cdFx0QXV0b2xpbmtlci5VdGlsLmFzc2lnbiggdGhpcywgY2ZnICk7XHJcblx0fSxcclxuXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdlbmVyYXRlcyB0aGUgYWN0dWFsIGFuY2hvciAoJmx0O2EmZ3Q7KSB0YWcgdG8gdXNlIGluIHBsYWNlIG9mIHRoZVxyXG5cdCAqIG1hdGNoZWQgdGV4dCwgdmlhIGl0cyBgbWF0Y2hgIG9iamVjdC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7QXV0b2xpbmtlci5tYXRjaC5NYXRjaH0gbWF0Y2ggVGhlIE1hdGNoIGluc3RhbmNlIHRvIGdlbmVyYXRlIGFuXHJcblx0ICogICBhbmNob3IgdGFnIGZyb20uXHJcblx0ICogQHJldHVybiB7QXV0b2xpbmtlci5IdG1sVGFnfSBUaGUgSHRtbFRhZyBpbnN0YW5jZSBmb3IgdGhlIGFuY2hvciB0YWcuXHJcblx0ICovXHJcblx0YnVpbGQgOiBmdW5jdGlvbiggbWF0Y2ggKSB7XHJcblx0XHR2YXIgdGFnID0gbmV3IEF1dG9saW5rZXIuSHRtbFRhZygge1xyXG5cdFx0XHR0YWdOYW1lICAgOiAnYScsXHJcblx0XHRcdGF0dHJzICAgICA6IHRoaXMuY3JlYXRlQXR0cnMoIG1hdGNoLmdldFR5cGUoKSwgbWF0Y2guZ2V0QW5jaG9ySHJlZigpICksXHJcblx0XHRcdGlubmVySHRtbCA6IHRoaXMucHJvY2Vzc0FuY2hvclRleHQoIG1hdGNoLmdldEFuY2hvclRleHQoKSApXHJcblx0XHR9ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRhZztcclxuXHR9LFxyXG5cclxuXHJcblx0LyoqXHJcblx0ICogQ3JlYXRlcyB0aGUgT2JqZWN0IChtYXApIG9mIHRoZSBIVE1MIGF0dHJpYnV0ZXMgZm9yIHRoZSBhbmNob3IgKCZsdDthJmd0OylcclxuXHQgKiAgIHRhZyBiZWluZyBnZW5lcmF0ZWQuXHJcblx0ICpcclxuXHQgKiBAcHJvdGVjdGVkXHJcblx0ICogQHBhcmFtIHtcInVybFwiL1wiZW1haWxcIi9cInBob25lXCIvXCJ0d2l0dGVyXCIvXCJoYXNodGFnXCJ9IG1hdGNoVHlwZSBUaGUgdHlwZSBvZlxyXG5cdCAqICAgbWF0Y2ggdGhhdCBhbiBhbmNob3IgdGFnIGlzIGJlaW5nIGdlbmVyYXRlZCBmb3IuXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IGhyZWYgVGhlIGhyZWYgZm9yIHRoZSBhbmNob3IgdGFnLlxyXG5cdCAqIEByZXR1cm4ge09iamVjdH0gQSBrZXkvdmFsdWUgT2JqZWN0IChtYXApIG9mIHRoZSBhbmNob3IgdGFnJ3MgYXR0cmlidXRlcy5cclxuXHQgKi9cclxuXHRjcmVhdGVBdHRycyA6IGZ1bmN0aW9uKCBtYXRjaFR5cGUsIGFuY2hvckhyZWYgKSB7XHJcblx0XHR2YXIgYXR0cnMgPSB7XHJcblx0XHRcdCdocmVmJyA6IGFuY2hvckhyZWYgIC8vIHdlJ2xsIGFsd2F5cyBoYXZlIHRoZSBgaHJlZmAgYXR0cmlidXRlXHJcblx0XHR9O1xyXG5cclxuXHRcdHZhciBjc3NDbGFzcyA9IHRoaXMuY3JlYXRlQ3NzQ2xhc3MoIG1hdGNoVHlwZSApO1xyXG5cdFx0aWYoIGNzc0NsYXNzICkge1xyXG5cdFx0XHRhdHRyc1sgJ2NsYXNzJyBdID0gY3NzQ2xhc3M7XHJcblx0XHR9XHJcblx0XHRpZiggdGhpcy5uZXdXaW5kb3cgKSB7XHJcblx0XHRcdGF0dHJzWyAndGFyZ2V0JyBdID0gXCJfYmxhbmtcIjtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gYXR0cnM7XHJcblx0fSxcclxuXHJcblxyXG5cdC8qKlxyXG5cdCAqIENyZWF0ZXMgdGhlIENTUyBjbGFzcyB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgYSBnaXZlbiBhbmNob3IgdGFnLCBiYXNlZCBvblxyXG5cdCAqIHRoZSBgbWF0Y2hUeXBlYCBhbmQgdGhlIHtAbGluayAjY2xhc3NOYW1lfSBjb25maWcuXHJcblx0ICpcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSB7XCJ1cmxcIi9cImVtYWlsXCIvXCJwaG9uZVwiL1widHdpdHRlclwiL1wiaGFzaHRhZ1wifSBtYXRjaFR5cGUgVGhlIHR5cGUgb2ZcclxuXHQgKiAgIG1hdGNoIHRoYXQgYW4gYW5jaG9yIHRhZyBpcyBiZWluZyBnZW5lcmF0ZWQgZm9yLlxyXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gVGhlIENTUyBjbGFzcyBzdHJpbmcgZm9yIHRoZSBsaW5rLiBFeGFtcGxlIHJldHVybjpcclxuXHQgKiAgIFwibXlMaW5rIG15TGluay11cmxcIi4gSWYgbm8ge0BsaW5rICNjbGFzc05hbWV9IHdhcyBjb25maWd1cmVkLCByZXR1cm5zXHJcblx0ICogICBhbiBlbXB0eSBzdHJpbmcuXHJcblx0ICovXHJcblx0Y3JlYXRlQ3NzQ2xhc3MgOiBmdW5jdGlvbiggbWF0Y2hUeXBlICkge1xyXG5cdFx0dmFyIGNsYXNzTmFtZSA9IHRoaXMuY2xhc3NOYW1lO1xyXG5cclxuXHRcdGlmKCAhY2xhc3NOYW1lIClcclxuXHRcdFx0cmV0dXJuIFwiXCI7XHJcblx0XHRlbHNlXHJcblx0XHRcdHJldHVybiBjbGFzc05hbWUgKyBcIiBcIiArIGNsYXNzTmFtZSArIFwiLVwiICsgbWF0Y2hUeXBlOyAgLy8gZXg6IFwibXlMaW5rIG15TGluay11cmxcIiwgXCJteUxpbmsgbXlMaW5rLWVtYWlsXCIsIFwibXlMaW5rIG15TGluay1waG9uZVwiLCBcIm15TGluayBteUxpbmstdHdpdHRlclwiLCBvciBcIm15TGluayBteUxpbmstaGFzaHRhZ1wiXHJcblx0fSxcclxuXHJcblxyXG5cdC8qKlxyXG5cdCAqIFByb2Nlc3NlcyB0aGUgYGFuY2hvclRleHRgIGJ5IHRydW5jYXRpbmcgdGhlIHRleHQgYWNjb3JkaW5nIHRvIHRoZVxyXG5cdCAqIHtAbGluayAjdHJ1bmNhdGV9IGNvbmZpZy5cclxuXHQgKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IGFuY2hvclRleHQgVGhlIGFuY2hvciB0YWcncyB0ZXh0IChpLmUuIHdoYXQgd2lsbCBiZVxyXG5cdCAqICAgZGlzcGxheWVkKS5cclxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBwcm9jZXNzZWQgYGFuY2hvclRleHRgLlxyXG5cdCAqL1xyXG5cdHByb2Nlc3NBbmNob3JUZXh0IDogZnVuY3Rpb24oIGFuY2hvclRleHQgKSB7XHJcblx0XHRhbmNob3JUZXh0ID0gdGhpcy5kb1RydW5jYXRlKCBhbmNob3JUZXh0ICk7XHJcblxyXG5cdFx0cmV0dXJuIGFuY2hvclRleHQ7XHJcblx0fSxcclxuXHJcblxyXG5cdC8qKlxyXG5cdCAqIFBlcmZvcm1zIHRoZSB0cnVuY2F0aW9uIG9mIHRoZSBgYW5jaG9yVGV4dGAsIGlmIHRoZSBgYW5jaG9yVGV4dGAgaXNcclxuXHQgKiBsb25nZXIgdGhhbiB0aGUge0BsaW5rICN0cnVuY2F0ZX0gb3B0aW9uLiBUcnVuY2F0ZXMgdGhlIHRleHQgdG8gMlxyXG5cdCAqIGNoYXJhY3RlcnMgZmV3ZXIgdGhhbiB0aGUge0BsaW5rICN0cnVuY2F0ZX0gb3B0aW9uLCBhbmQgYWRkcyBcIi4uXCIgdG8gdGhlXHJcblx0ICogZW5kLlxyXG5cdCAqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCBUaGUgYW5jaG9yIHRhZydzIHRleHQgKGkuZS4gd2hhdCB3aWxsIGJlIGRpc3BsYXllZCkuXHJcblx0ICogQHJldHVybiB7U3RyaW5nfSBUaGUgdHJ1bmNhdGVkIGFuY2hvciB0ZXh0LlxyXG5cdCAqL1xyXG5cdGRvVHJ1bmNhdGUgOiBmdW5jdGlvbiggYW5jaG9yVGV4dCApIHtcclxuXHRcdHJldHVybiBBdXRvbGlua2VyLlV0aWwuZWxsaXBzaXMoIGFuY2hvclRleHQsIHRoaXMudHJ1bmNhdGUgfHwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZICk7XHJcblx0fVxyXG5cclxufSApO1xyXG4vKmdsb2JhbCBBdXRvbGlua2VyICovXHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAY2xhc3MgQXV0b2xpbmtlci5odG1sUGFyc2VyLkh0bWxQYXJzZXJcclxuICogQGV4dGVuZHMgT2JqZWN0XHJcbiAqXHJcbiAqIEFuIEhUTUwgcGFyc2VyIGltcGxlbWVudGF0aW9uIHdoaWNoIHNpbXBseSB3YWxrcyBhbiBIVE1MIHN0cmluZyBhbmQgcmV0dXJucyBhbiBhcnJheSBvZlxyXG4gKiB7QGxpbmsgQXV0b2xpbmtlci5odG1sUGFyc2VyLkh0bWxOb2RlIEh0bWxOb2Rlc30gdGhhdCByZXByZXNlbnQgdGhlIGJhc2ljIEhUTUwgc3RydWN0dXJlIG9mIHRoZSBpbnB1dCBzdHJpbmcuXHJcbiAqXHJcbiAqIEF1dG9saW5rZXIgdXNlcyB0aGlzIHRvIG9ubHkgbGluayBVUkxzL2VtYWlscy9Ud2l0dGVyIGhhbmRsZXMgd2l0aGluIHRleHQgbm9kZXMsIGVmZmVjdGl2ZWx5IGlnbm9yaW5nIC8gXCJ3YWxraW5nXHJcbiAqIGFyb3VuZFwiIEhUTUwgdGFncy5cclxuICovXHJcbkF1dG9saW5rZXIuaHRtbFBhcnNlci5IdG1sUGFyc2VyID0gQXV0b2xpbmtlci5VdGlsLmV4dGVuZCggT2JqZWN0LCB7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHByb3BlcnR5IHtSZWdFeHB9IGh0bWxSZWdleFxyXG5cdCAqXHJcblx0ICogVGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiB1c2VkIHRvIHB1bGwgb3V0IEhUTUwgdGFncyBmcm9tIGEgc3RyaW5nLiBIYW5kbGVzIG5hbWVzcGFjZWQgSFRNTCB0YWdzIGFuZFxyXG5cdCAqIGF0dHJpYnV0ZSBuYW1lcywgYXMgc3BlY2lmaWVkIGJ5IGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWwtbWFya3VwL3N5bnRheC5odG1sLlxyXG5cdCAqXHJcblx0ICogQ2FwdHVyaW5nIGdyb3VwczpcclxuXHQgKlxyXG5cdCAqIDEuIFRoZSBcIiFET0NUWVBFXCIgdGFnIG5hbWUsIGlmIGEgdGFnIGlzIGEgJmx0OyFET0NUWVBFJmd0OyB0YWcuXHJcblx0ICogMi4gSWYgaXQgaXMgYW4gZW5kIHRhZywgdGhpcyBncm91cCB3aWxsIGhhdmUgdGhlICcvJy5cclxuXHQgKiAzLiBJZiBpdCBpcyBhIGNvbW1lbnQgdGFnLCB0aGlzIGdyb3VwIHdpbGwgaG9sZCB0aGUgY29tbWVudCB0ZXh0IChpLmUuXHJcblx0ICogICAgdGhlIHRleHQgaW5zaWRlIHRoZSBgJmx0OyEtLWAgYW5kIGAtLSZndDtgLlxyXG5cdCAqIDQuIFRoZSB0YWcgbmFtZSBmb3IgYWxsIHRhZ3MgKG90aGVyIHRoYW4gdGhlICZsdDshRE9DVFlQRSZndDsgdGFnKVxyXG5cdCAqL1xyXG5cdGh0bWxSZWdleCA6IChmdW5jdGlvbigpIHtcclxuXHRcdHZhciBjb21tZW50VGFnUmVnZXggPSAvIS0tKFtcXHNcXFNdKz8pLS0vLFxyXG5cdFx0ICAgIHRhZ05hbWVSZWdleCA9IC9bMC05YS16QS1aXVswLTlhLXpBLVo6XSovLFxyXG5cdFx0ICAgIGF0dHJOYW1lUmVnZXggPSAvW15cXHNcXDBcIic+XFwvPVxceDAxLVxceDFGXFx4N0ZdKy8sICAgLy8gdGhlIHVuaWNvZGUgcmFuZ2UgYWNjb3VudHMgZm9yIGV4Y2x1ZGluZyBjb250cm9sIGNoYXJzLCBhbmQgdGhlIGRlbGV0ZSBjaGFyXHJcblx0XHQgICAgYXR0clZhbHVlUmVnZXggPSAvKD86XCJbXlwiXSo/XCJ8J1teJ10qPyd8W14nXCI9PD5gXFxzXSspLywgLy8gZG91YmxlIHF1b3RlZCwgc2luZ2xlIHF1b3RlZCwgb3IgdW5xdW90ZWQgYXR0cmlidXRlIHZhbHVlc1xyXG5cdFx0ICAgIG5hbWVFcXVhbHNWYWx1ZVJlZ2V4ID0gYXR0ck5hbWVSZWdleC5zb3VyY2UgKyAnKD86XFxcXHMqPVxcXFxzKicgKyBhdHRyVmFsdWVSZWdleC5zb3VyY2UgKyAnKT8nOyAgLy8gb3B0aW9uYWwgJz1bdmFsdWVdJ1xyXG5cclxuXHRcdHJldHVybiBuZXcgUmVnRXhwKCBbXHJcblx0XHRcdC8vIGZvciA8IURPQ1RZUEU+IHRhZy4gRXg6IDwhRE9DVFlQRSBodG1sIFBVQkxJQyBcIi0vL1czQy8vRFREIFhIVE1MIDEuMCBTdHJpY3QvL0VOXCIgXCJodHRwOi8vd3d3LnczLm9yZy9UUi94aHRtbDEvRFREL3hodG1sMS1zdHJpY3QuZHRkXCI+KVxyXG5cdFx0XHQnKD86JyxcclxuXHRcdFx0XHQnPCghRE9DVFlQRSknLCAgLy8gKioqIENhcHR1cmluZyBHcm91cCAxIC0gSWYgaXQncyBhIGRvY3R5cGUgdGFnXHJcblxyXG5cdFx0XHRcdFx0Ly8gWmVybyBvciBtb3JlIGF0dHJpYnV0ZXMgZm9sbG93aW5nIHRoZSB0YWcgbmFtZVxyXG5cdFx0XHRcdFx0Jyg/OicsXHJcblx0XHRcdFx0XHRcdCdcXFxccysnLCAgLy8gb25lIG9yIG1vcmUgd2hpdGVzcGFjZSBjaGFycyBiZWZvcmUgYW4gYXR0cmlidXRlXHJcblxyXG5cdFx0XHRcdFx0XHQvLyBFaXRoZXI6XHJcblx0XHRcdFx0XHRcdC8vIEEuIGF0dHI9XCJ2YWx1ZVwiLCBvclxyXG5cdFx0XHRcdFx0XHQvLyBCLiBcInZhbHVlXCIgYWxvbmUgKFRvIGNvdmVyIGV4YW1wbGUgZG9jdHlwZSB0YWc6IDwhRE9DVFlQRSBodG1sIFBVQkxJQyBcIi0vL1czQy8vRFREIFhIVE1MIDEuMCBTdHJpY3QvL0VOXCIgXCJodHRwOi8vd3d3LnczLm9yZy9UUi94aHRtbDEvRFREL3hodG1sMS1zdHJpY3QuZHRkXCI+KVxyXG5cdFx0XHRcdFx0XHQnKD86JywgbmFtZUVxdWFsc1ZhbHVlUmVnZXgsICd8JywgYXR0clZhbHVlUmVnZXguc291cmNlICsgJyknLFxyXG5cdFx0XHRcdFx0JykqJyxcclxuXHRcdFx0XHQnPicsXHJcblx0XHRcdCcpJyxcclxuXHJcblx0XHRcdCd8JyxcclxuXHJcblx0XHRcdC8vIEFsbCBvdGhlciBIVE1MIHRhZ3MgKGkuZS4gdGFncyB0aGF0IGFyZSBub3QgPCFET0NUWVBFPilcclxuXHRcdFx0Jyg/OicsXHJcblx0XHRcdFx0JzwoLyk/JywgIC8vIEJlZ2lubmluZyBvZiBhIHRhZyBvciBjb21tZW50LiBFaXRoZXIgJzwnIGZvciBhIHN0YXJ0IHRhZywgb3IgJzwvJyBmb3IgYW4gZW5kIHRhZy5cclxuXHRcdFx0XHQgICAgICAgICAgLy8gKioqIENhcHR1cmluZyBHcm91cCAyOiBUaGUgc2xhc2ggb3IgYW4gZW1wdHkgc3RyaW5nLiBTbGFzaCAoJy8nKSBmb3IgZW5kIHRhZywgZW1wdHkgc3RyaW5nIGZvciBzdGFydCBvciBzZWxmLWNsb3NpbmcgdGFnLlxyXG5cclxuXHRcdFx0XHRcdCcoPzonLFxyXG5cdFx0XHRcdFx0XHRjb21tZW50VGFnUmVnZXguc291cmNlLCAgLy8gKioqIENhcHR1cmluZyBHcm91cCAzIC0gQSBDb21tZW50IFRhZydzIFRleHRcclxuXHJcblx0XHRcdFx0XHRcdCd8JyxcclxuXHJcblx0XHRcdFx0XHRcdCcoPzonLFxyXG5cclxuXHRcdFx0XHRcdFx0XHQvLyAqKiogQ2FwdHVyaW5nIEdyb3VwIDQgLSBUaGUgdGFnIG5hbWVcclxuXHRcdFx0XHRcdFx0XHQnKCcgKyB0YWdOYW1lUmVnZXguc291cmNlICsgJyknLFxyXG5cclxuXHRcdFx0XHRcdFx0XHQvLyBaZXJvIG9yIG1vcmUgYXR0cmlidXRlcyBmb2xsb3dpbmcgdGhlIHRhZyBuYW1lXHJcblx0XHRcdFx0XHRcdFx0Jyg/OicsXHJcblx0XHRcdFx0XHRcdFx0XHQnXFxcXHMrJywgICAgICAgICAgICAgICAgLy8gb25lIG9yIG1vcmUgd2hpdGVzcGFjZSBjaGFycyBiZWZvcmUgYW4gYXR0cmlidXRlXHJcblx0XHRcdFx0XHRcdFx0XHRuYW1lRXF1YWxzVmFsdWVSZWdleCwgIC8vIGF0dHI9XCJ2YWx1ZVwiICh3aXRoIG9wdGlvbmFsID1cInZhbHVlXCIgcGFydClcclxuXHRcdFx0XHRcdFx0XHQnKSonLFxyXG5cclxuXHRcdFx0XHRcdFx0XHQnXFxcXHMqLz8nLCAgLy8gYW55IHRyYWlsaW5nIHNwYWNlcyBhbmQgb3B0aW9uYWwgJy8nIGJlZm9yZSB0aGUgY2xvc2luZyAnPidcclxuXHJcblx0XHRcdFx0XHRcdCcpJyxcclxuXHRcdFx0XHRcdCcpJyxcclxuXHRcdFx0XHQnPicsXHJcblx0XHRcdCcpJ1xyXG5cdFx0XS5qb2luKCBcIlwiICksICdnaScgKTtcclxuXHR9ICkoKSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcHJvcGVydHkge1JlZ0V4cH0gaHRtbENoYXJhY3RlckVudGl0aWVzUmVnZXhcclxuXHQgKlxyXG5cdCAqIFRoZSByZWd1bGFyIGV4cHJlc3Npb24gdGhhdCBtYXRjaGVzIGNvbW1vbiBIVE1MIGNoYXJhY3RlciBlbnRpdGllcy5cclxuXHQgKlxyXG5cdCAqIElnbm9yaW5nICZhbXA7IGFzIGl0IGNvdWxkIGJlIHBhcnQgb2YgYSBxdWVyeSBzdHJpbmcgLS0gaGFuZGxpbmcgaXQgc2VwYXJhdGVseS5cclxuXHQgKi9cclxuXHRodG1sQ2hhcmFjdGVyRW50aXRpZXNSZWdleDogLygmbmJzcDt8JiMxNjA7fCZsdDt8JiM2MDt8Jmd0O3wmIzYyO3wmcXVvdDt8JiMzNDt8JiMzOTspL2dpLFxyXG5cclxuXHJcblx0LyoqXHJcblx0ICogUGFyc2VzIGFuIEhUTUwgc3RyaW5nIGFuZCByZXR1cm5zIGEgc2ltcGxlIGFycmF5IG9mIHtAbGluayBBdXRvbGlua2VyLmh0bWxQYXJzZXIuSHRtbE5vZGUgSHRtbE5vZGVzfVxyXG5cdCAqIHRvIHJlcHJlc2VudCB0aGUgSFRNTCBzdHJ1Y3R1cmUgb2YgdGhlIGlucHV0IHN0cmluZy5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBodG1sIFRoZSBIVE1MIHRvIHBhcnNlLlxyXG5cdCAqIEByZXR1cm4ge0F1dG9saW5rZXIuaHRtbFBhcnNlci5IdG1sTm9kZVtdfVxyXG5cdCAqL1xyXG5cdHBhcnNlIDogZnVuY3Rpb24oIGh0bWwgKSB7XHJcblx0XHR2YXIgaHRtbFJlZ2V4ID0gdGhpcy5odG1sUmVnZXgsXHJcblx0XHQgICAgY3VycmVudFJlc3VsdCxcclxuXHRcdCAgICBsYXN0SW5kZXggPSAwLFxyXG5cdFx0ICAgIHRleHRBbmRFbnRpdHlOb2RlcyxcclxuXHRcdCAgICBub2RlcyA9IFtdOyAgLy8gd2lsbCBiZSB0aGUgcmVzdWx0IG9mIHRoZSBtZXRob2RcclxuXHJcblx0XHR3aGlsZSggKCBjdXJyZW50UmVzdWx0ID0gaHRtbFJlZ2V4LmV4ZWMoIGh0bWwgKSApICE9PSBudWxsICkge1xyXG5cdFx0XHR2YXIgdGFnVGV4dCA9IGN1cnJlbnRSZXN1bHRbIDAgXSxcclxuXHRcdFx0ICAgIGNvbW1lbnRUZXh0ID0gY3VycmVudFJlc3VsdFsgMyBdLCAvLyBpZiB3ZSd2ZSBtYXRjaGVkIGEgY29tbWVudFxyXG5cdFx0XHQgICAgdGFnTmFtZSA9IGN1cnJlbnRSZXN1bHRbIDEgXSB8fCBjdXJyZW50UmVzdWx0WyA0IF0sICAvLyBUaGUgPCFET0NUWVBFPiB0YWcgKGV4OiBcIiFET0NUWVBFXCIpLCBvciBhbm90aGVyIHRhZyAoZXg6IFwiYVwiIG9yIFwiaW1nXCIpXHJcblx0XHRcdCAgICBpc0Nsb3NpbmdUYWcgPSAhIWN1cnJlbnRSZXN1bHRbIDIgXSxcclxuXHRcdFx0ICAgIGluQmV0d2VlblRhZ3NUZXh0ID0gaHRtbC5zdWJzdHJpbmcoIGxhc3RJbmRleCwgY3VycmVudFJlc3VsdC5pbmRleCApO1xyXG5cclxuXHRcdFx0Ly8gUHVzaCBUZXh0Tm9kZXMgYW5kIEVudGl0eU5vZGVzIGZvciBhbnkgdGV4dCBmb3VuZCBiZXR3ZWVuIHRhZ3NcclxuXHRcdFx0aWYoIGluQmV0d2VlblRhZ3NUZXh0ICkge1xyXG5cdFx0XHRcdHRleHRBbmRFbnRpdHlOb2RlcyA9IHRoaXMucGFyc2VUZXh0QW5kRW50aXR5Tm9kZXMoIGluQmV0d2VlblRhZ3NUZXh0ICk7XHJcblx0XHRcdFx0bm9kZXMucHVzaC5hcHBseSggbm9kZXMsIHRleHRBbmRFbnRpdHlOb2RlcyApO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBQdXNoIHRoZSBDb21tZW50Tm9kZSBvciBFbGVtZW50Tm9kZVxyXG5cdFx0XHRpZiggY29tbWVudFRleHQgKSB7XHJcblx0XHRcdFx0bm9kZXMucHVzaCggdGhpcy5jcmVhdGVDb21tZW50Tm9kZSggdGFnVGV4dCwgY29tbWVudFRleHQgKSApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdG5vZGVzLnB1c2goIHRoaXMuY3JlYXRlRWxlbWVudE5vZGUoIHRhZ1RleHQsIHRhZ05hbWUsIGlzQ2xvc2luZ1RhZyApICk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGxhc3RJbmRleCA9IGN1cnJlbnRSZXN1bHQuaW5kZXggKyB0YWdUZXh0Lmxlbmd0aDtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBQcm9jZXNzIGFueSByZW1haW5pbmcgdGV4dCBhZnRlciB0aGUgbGFzdCBIVE1MIGVsZW1lbnQuIFdpbGwgcHJvY2VzcyBhbGwgb2YgdGhlIHRleHQgaWYgdGhlcmUgd2VyZSBubyBIVE1MIGVsZW1lbnRzLlxyXG5cdFx0aWYoIGxhc3RJbmRleCA8IGh0bWwubGVuZ3RoICkge1xyXG5cdFx0XHR2YXIgdGV4dCA9IGh0bWwuc3Vic3RyaW5nKCBsYXN0SW5kZXggKTtcclxuXHJcblx0XHRcdC8vIFB1c2ggVGV4dE5vZGVzIGFuZCBFbnRpdHlOb2RlcyBmb3IgYW55IHRleHQgZm91bmQgYmV0d2VlbiB0YWdzXHJcblx0XHRcdGlmKCB0ZXh0ICkge1xyXG5cdFx0XHRcdHRleHRBbmRFbnRpdHlOb2RlcyA9IHRoaXMucGFyc2VUZXh0QW5kRW50aXR5Tm9kZXMoIHRleHQgKTtcclxuXHRcdFx0XHRub2Rlcy5wdXNoLmFwcGx5KCBub2RlcywgdGV4dEFuZEVudGl0eU5vZGVzICk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbm9kZXM7XHJcblx0fSxcclxuXHJcblxyXG5cdC8qKlxyXG5cdCAqIFBhcnNlcyB0ZXh0IGFuZCBIVE1MIGVudGl0eSBub2RlcyBmcm9tIGEgZ2l2ZW4gc3RyaW5nLiBUaGUgaW5wdXQgc3RyaW5nXHJcblx0ICogc2hvdWxkIG5vdCBoYXZlIGFueSBIVE1MIHRhZ3MgKGVsZW1lbnRzKSB3aXRoaW4gaXQuXHJcblx0ICpcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IFRoZSB0ZXh0IHRvIHBhcnNlLlxyXG5cdCAqIEByZXR1cm4ge0F1dG9saW5rZXIuaHRtbFBhcnNlci5IdG1sTm9kZVtdfSBBbiBhcnJheSBvZiBIdG1sTm9kZXMgdG9cclxuXHQgKiAgIHJlcHJlc2VudCB0aGUge0BsaW5rIEF1dG9saW5rZXIuaHRtbFBhcnNlci5UZXh0Tm9kZSBUZXh0Tm9kZXN9IGFuZFxyXG5cdCAqICAge0BsaW5rIEF1dG9saW5rZXIuaHRtbFBhcnNlci5FbnRpdHlOb2RlIEVudGl0eU5vZGVzfSBmb3VuZC5cclxuXHQgKi9cclxuXHRwYXJzZVRleHRBbmRFbnRpdHlOb2RlcyA6IGZ1bmN0aW9uKCB0ZXh0ICkge1xyXG5cdFx0dmFyIG5vZGVzID0gW10sXHJcblx0XHQgICAgdGV4dEFuZEVudGl0eVRva2VucyA9IEF1dG9saW5rZXIuVXRpbC5zcGxpdEFuZENhcHR1cmUoIHRleHQsIHRoaXMuaHRtbENoYXJhY3RlckVudGl0aWVzUmVnZXggKTsgIC8vIHNwbGl0IGF0IEhUTUwgZW50aXRpZXMsIGJ1dCBpbmNsdWRlIHRoZSBIVE1MIGVudGl0aWVzIGluIHRoZSByZXN1bHRzIGFycmF5XHJcblxyXG5cdFx0Ly8gRXZlcnkgZXZlbiBudW1iZXJlZCB0b2tlbiBpcyBhIFRleHROb2RlLCBhbmQgZXZlcnkgb2RkIG51bWJlcmVkIHRva2VuIGlzIGFuIEVudGl0eU5vZGVcclxuXHRcdC8vIEZvciBleGFtcGxlOiBhbiBpbnB1dCBgdGV4dGAgb2YgXCJUZXN0ICZxdW90O3RoaXMmcXVvdDsgdG9kYXlcIiB3b3VsZCB0dXJuIGludG8gdGhlXHJcblx0XHQvLyAgIGB0ZXh0QW5kRW50aXR5VG9rZW5zYDogWyAnVGVzdCAnLCAnJnF1b3Q7JywgJ3RoaXMnLCAnJnF1b3Q7JywgJyB0b2RheScgXVxyXG5cdFx0Zm9yKCB2YXIgaSA9IDAsIGxlbiA9IHRleHRBbmRFbnRpdHlUb2tlbnMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDIgKSB7XHJcblx0XHRcdHZhciB0ZXh0VG9rZW4gPSB0ZXh0QW5kRW50aXR5VG9rZW5zWyBpIF0sXHJcblx0XHRcdCAgICBlbnRpdHlUb2tlbiA9IHRleHRBbmRFbnRpdHlUb2tlbnNbIGkgKyAxIF07XHJcblxyXG5cdFx0XHRpZiggdGV4dFRva2VuICkgbm9kZXMucHVzaCggdGhpcy5jcmVhdGVUZXh0Tm9kZSggdGV4dFRva2VuICkgKTtcclxuXHRcdFx0aWYoIGVudGl0eVRva2VuICkgbm9kZXMucHVzaCggdGhpcy5jcmVhdGVFbnRpdHlOb2RlKCBlbnRpdHlUb2tlbiApICk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbm9kZXM7XHJcblx0fSxcclxuXHJcblxyXG5cdC8qKlxyXG5cdCAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhbiB7QGxpbmsgQXV0b2xpbmtlci5odG1sUGFyc2VyLkNvbW1lbnROb2RlIENvbW1lbnROb2RlfS5cclxuXHQgKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHRhZ1RleHQgVGhlIGZ1bGwgdGV4dCBvZiB0aGUgdGFnIChjb21tZW50KSB0aGF0IHdhc1xyXG5cdCAqICAgbWF0Y2hlZCwgaW5jbHVkaW5nIGl0cyAmbHQ7IS0tIGFuZCAtLSZndDsuXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IGNvbW1lbnQgVGhlIGZ1bGwgdGV4dCBvZiB0aGUgY29tbWVudCB0aGF0IHdhcyBtYXRjaGVkLlxyXG5cdCAqL1xyXG5cdGNyZWF0ZUNvbW1lbnROb2RlIDogZnVuY3Rpb24oIHRhZ1RleHQsIGNvbW1lbnRUZXh0ICkge1xyXG5cdFx0cmV0dXJuIG5ldyBBdXRvbGlua2VyLmh0bWxQYXJzZXIuQ29tbWVudE5vZGUoIHtcclxuXHRcdFx0dGV4dDogdGFnVGV4dCxcclxuXHRcdFx0Y29tbWVudDogQXV0b2xpbmtlci5VdGlsLnRyaW0oIGNvbW1lbnRUZXh0IClcclxuXHRcdH0gKTtcclxuXHR9LFxyXG5cclxuXHJcblx0LyoqXHJcblx0ICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGFuIHtAbGluayBBdXRvbGlua2VyLmh0bWxQYXJzZXIuRWxlbWVudE5vZGUgRWxlbWVudE5vZGV9LlxyXG5cdCAqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdGFnVGV4dCBUaGUgZnVsbCB0ZXh0IG9mIHRoZSB0YWcgKGVsZW1lbnQpIHRoYXQgd2FzXHJcblx0ICogICBtYXRjaGVkLCBpbmNsdWRpbmcgaXRzIGF0dHJpYnV0ZXMuXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHRhZ05hbWUgVGhlIG5hbWUgb2YgdGhlIHRhZy4gRXg6IEFuICZsdDtpbWcmZ3Q7IHRhZyB3b3VsZFxyXG5cdCAqICAgYmUgcGFzc2VkIHRvIHRoaXMgbWV0aG9kIGFzIFwiaW1nXCIuXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBpc0Nsb3NpbmdUYWcgYHRydWVgIGlmIGl0J3MgYSBjbG9zaW5nIHRhZywgZmFsc2VcclxuXHQgKiAgIG90aGVyd2lzZS5cclxuXHQgKiBAcmV0dXJuIHtBdXRvbGlua2VyLmh0bWxQYXJzZXIuRWxlbWVudE5vZGV9XHJcblx0ICovXHJcblx0Y3JlYXRlRWxlbWVudE5vZGUgOiBmdW5jdGlvbiggdGFnVGV4dCwgdGFnTmFtZSwgaXNDbG9zaW5nVGFnICkge1xyXG5cdFx0cmV0dXJuIG5ldyBBdXRvbGlua2VyLmh0bWxQYXJzZXIuRWxlbWVudE5vZGUoIHtcclxuXHRcdFx0dGV4dCAgICA6IHRhZ1RleHQsXHJcblx0XHRcdHRhZ05hbWUgOiB0YWdOYW1lLnRvTG93ZXJDYXNlKCksXHJcblx0XHRcdGNsb3NpbmcgOiBpc0Nsb3NpbmdUYWdcclxuXHRcdH0gKTtcclxuXHR9LFxyXG5cclxuXHJcblx0LyoqXHJcblx0ICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEge0BsaW5rIEF1dG9saW5rZXIuaHRtbFBhcnNlci5FbnRpdHlOb2RlIEVudGl0eU5vZGV9LlxyXG5cdCAqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCBUaGUgdGV4dCB0aGF0IHdhcyBtYXRjaGVkIGZvciB0aGUgSFRNTCBlbnRpdHkgKHN1Y2hcclxuXHQgKiAgIGFzICcmYW1wO25ic3A7JykuXHJcblx0ICogQHJldHVybiB7QXV0b2xpbmtlci5odG1sUGFyc2VyLkVudGl0eU5vZGV9XHJcblx0ICovXHJcblx0Y3JlYXRlRW50aXR5Tm9kZSA6IGZ1bmN0aW9uKCB0ZXh0ICkge1xyXG5cdFx0cmV0dXJuIG5ldyBBdXRvbGlua2VyLmh0bWxQYXJzZXIuRW50aXR5Tm9kZSggeyB0ZXh0OiB0ZXh0IH0gKTtcclxuXHR9LFxyXG5cclxuXHJcblx0LyoqXHJcblx0ICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEge0BsaW5rIEF1dG9saW5rZXIuaHRtbFBhcnNlci5UZXh0Tm9kZSBUZXh0Tm9kZX0uXHJcblx0ICpcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IFRoZSB0ZXh0IHRoYXQgd2FzIG1hdGNoZWQuXHJcblx0ICogQHJldHVybiB7QXV0b2xpbmtlci5odG1sUGFyc2VyLlRleHROb2RlfVxyXG5cdCAqL1xyXG5cdGNyZWF0ZVRleHROb2RlIDogZnVuY3Rpb24oIHRleHQgKSB7XHJcblx0XHRyZXR1cm4gbmV3IEF1dG9saW5rZXIuaHRtbFBhcnNlci5UZXh0Tm9kZSggeyB0ZXh0OiB0ZXh0IH0gKTtcclxuXHR9XHJcblxyXG59ICk7XHJcbi8qZ2xvYmFsIEF1dG9saW5rZXIgKi9cclxuLyoqXHJcbiAqIEBhYnN0cmFjdFxyXG4gKiBAY2xhc3MgQXV0b2xpbmtlci5odG1sUGFyc2VyLkh0bWxOb2RlXHJcbiAqIFxyXG4gKiBSZXByZXNlbnRzIGFuIEhUTUwgbm9kZSBmb3VuZCBpbiBhbiBpbnB1dCBzdHJpbmcuIEFuIEhUTUwgbm9kZSBpcyBvbmUgb2YgdGhlIGZvbGxvd2luZzpcclxuICogXHJcbiAqIDEuIEFuIHtAbGluayBBdXRvbGlua2VyLmh0bWxQYXJzZXIuRWxlbWVudE5vZGUgRWxlbWVudE5vZGV9LCB3aGljaCByZXByZXNlbnRzIEhUTUwgdGFncy5cclxuICogMi4gQSB7QGxpbmsgQXV0b2xpbmtlci5odG1sUGFyc2VyLlRleHROb2RlIFRleHROb2RlfSwgd2hpY2ggcmVwcmVzZW50cyB0ZXh0IG91dHNpZGUgb3Igd2l0aGluIEhUTUwgdGFncy5cclxuICogMy4gQSB7QGxpbmsgQXV0b2xpbmtlci5odG1sUGFyc2VyLkVudGl0eU5vZGUgRW50aXR5Tm9kZX0sIHdoaWNoIHJlcHJlc2VudHMgb25lIG9mIHRoZSBrbm93biBIVE1MXHJcbiAqICAgIGVudGl0aWVzIHRoYXQgQXV0b2xpbmtlciBsb29rcyBmb3IuIFRoaXMgaW5jbHVkZXMgY29tbW9uIG9uZXMgc3VjaCBhcyAmYW1wO3F1b3Q7IGFuZCAmYW1wO25ic3A7XHJcbiAqL1xyXG5BdXRvbGlua2VyLmh0bWxQYXJzZXIuSHRtbE5vZGUgPSBBdXRvbGlua2VyLlV0aWwuZXh0ZW5kKCBPYmplY3QsIHtcclxuXHRcclxuXHQvKipcclxuXHQgKiBAY2ZnIHtTdHJpbmd9IHRleHQgKHJlcXVpcmVkKVxyXG5cdCAqIFxyXG5cdCAqIFRoZSBvcmlnaW5hbCB0ZXh0IHRoYXQgd2FzIG1hdGNoZWQgZm9yIHRoZSBIdG1sTm9kZS4gXHJcblx0ICogXHJcblx0ICogLSBJbiB0aGUgY2FzZSBvZiBhbiB7QGxpbmsgQXV0b2xpbmtlci5odG1sUGFyc2VyLkVsZW1lbnROb2RlIEVsZW1lbnROb2RlfSwgdGhpcyB3aWxsIGJlIHRoZSB0YWcnc1xyXG5cdCAqICAgdGV4dC5cclxuXHQgKiAtIEluIHRoZSBjYXNlIG9mIGEge0BsaW5rIEF1dG9saW5rZXIuaHRtbFBhcnNlci5UZXh0Tm9kZSBUZXh0Tm9kZX0sIHRoaXMgd2lsbCBiZSB0aGUgdGV4dCBpdHNlbGYuXHJcblx0ICogLSBJbiB0aGUgY2FzZSBvZiBhIHtAbGluayBBdXRvbGlua2VyLmh0bWxQYXJzZXIuRW50aXR5Tm9kZSBFbnRpdHlOb2RlfSwgdGhpcyB3aWxsIGJlIHRoZSB0ZXh0IG9mXHJcblx0ICogICB0aGUgSFRNTCBlbnRpdHkuXHJcblx0ICovXHJcblx0dGV4dCA6IFwiXCIsXHJcblx0XHJcblx0XHJcblx0LyoqXHJcblx0ICogQGNvbnN0cnVjdG9yXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IGNmZyBUaGUgY29uZmlndXJhdGlvbiBwcm9wZXJ0aWVzIGZvciB0aGUgTWF0Y2ggaW5zdGFuY2UsIHNwZWNpZmllZCBpbiBhbiBPYmplY3QgKG1hcCkuXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IgOiBmdW5jdGlvbiggY2ZnICkge1xyXG5cdFx0QXV0b2xpbmtlci5VdGlsLmFzc2lnbiggdGhpcywgY2ZnICk7XHJcblx0fSxcclxuXHJcblx0XHJcblx0LyoqXHJcblx0ICogUmV0dXJucyBhIHN0cmluZyBuYW1lIGZvciB0aGUgdHlwZSBvZiBub2RlIHRoYXQgdGhpcyBjbGFzcyByZXByZXNlbnRzLlxyXG5cdCAqIFxyXG5cdCAqIEBhYnN0cmFjdFxyXG5cdCAqIEByZXR1cm4ge1N0cmluZ31cclxuXHQgKi9cclxuXHRnZXRUeXBlIDogQXV0b2xpbmtlci5VdGlsLmFic3RyYWN0TWV0aG9kLFxyXG5cdFxyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIFJldHJpZXZlcyB0aGUge0BsaW5rICN0ZXh0fSBmb3IgdGhlIEh0bWxOb2RlLlxyXG5cdCAqIFxyXG5cdCAqIEByZXR1cm4ge1N0cmluZ31cclxuXHQgKi9cclxuXHRnZXRUZXh0IDogZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gdGhpcy50ZXh0O1xyXG5cdH1cclxuXHJcbn0gKTtcclxuLypnbG9iYWwgQXV0b2xpbmtlciAqL1xyXG4vKipcclxuICogQGNsYXNzIEF1dG9saW5rZXIuaHRtbFBhcnNlci5Db21tZW50Tm9kZVxyXG4gKiBAZXh0ZW5kcyBBdXRvbGlua2VyLmh0bWxQYXJzZXIuSHRtbE5vZGVcclxuICpcclxuICogUmVwcmVzZW50cyBhbiBIVE1MIGNvbW1lbnQgbm9kZSB0aGF0IGhhcyBiZWVuIHBhcnNlZCBieSB0aGVcclxuICoge0BsaW5rIEF1dG9saW5rZXIuaHRtbFBhcnNlci5IdG1sUGFyc2VyfS5cclxuICpcclxuICogU2VlIHRoaXMgY2xhc3MncyBzdXBlcmNsYXNzICh7QGxpbmsgQXV0b2xpbmtlci5odG1sUGFyc2VyLkh0bWxOb2RlfSkgZm9yIG1vcmVcclxuICogZGV0YWlscy5cclxuICovXHJcbkF1dG9saW5rZXIuaHRtbFBhcnNlci5Db21tZW50Tm9kZSA9IEF1dG9saW5rZXIuVXRpbC5leHRlbmQoIEF1dG9saW5rZXIuaHRtbFBhcnNlci5IdG1sTm9kZSwge1xyXG5cclxuXHQvKipcclxuXHQgKiBAY2ZnIHtTdHJpbmd9IGNvbW1lbnQgKHJlcXVpcmVkKVxyXG5cdCAqXHJcblx0ICogVGhlIHRleHQgaW5zaWRlIHRoZSBjb21tZW50IHRhZy4gVGhpcyB0ZXh0IGlzIHN0cmlwcGVkIG9mIGFueSBsZWFkaW5nIG9yXHJcblx0ICogdHJhaWxpbmcgd2hpdGVzcGFjZS5cclxuXHQgKi9cclxuXHRjb21tZW50IDogJycsXHJcblxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIG5hbWUgZm9yIHRoZSB0eXBlIG9mIG5vZGUgdGhhdCB0aGlzIGNsYXNzIHJlcHJlc2VudHMuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9XHJcblx0ICovXHJcblx0Z2V0VHlwZSA6IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuICdjb21tZW50JztcclxuXHR9LFxyXG5cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgY29tbWVudCBpbnNpZGUgdGhlIGNvbW1lbnQgdGFnLlxyXG5cdCAqXHJcblx0ICogQHJldHVybiB7U3RyaW5nfVxyXG5cdCAqL1xyXG5cdGdldENvbW1lbnQgOiBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB0aGlzLmNvbW1lbnQ7XHJcblx0fVxyXG5cclxufSApO1xyXG4vKmdsb2JhbCBBdXRvbGlua2VyICovXHJcbi8qKlxyXG4gKiBAY2xhc3MgQXV0b2xpbmtlci5odG1sUGFyc2VyLkVsZW1lbnROb2RlXHJcbiAqIEBleHRlbmRzIEF1dG9saW5rZXIuaHRtbFBhcnNlci5IdG1sTm9kZVxyXG4gKiBcclxuICogUmVwcmVzZW50cyBhbiBIVE1MIGVsZW1lbnQgbm9kZSB0aGF0IGhhcyBiZWVuIHBhcnNlZCBieSB0aGUge0BsaW5rIEF1dG9saW5rZXIuaHRtbFBhcnNlci5IdG1sUGFyc2VyfS5cclxuICogXHJcbiAqIFNlZSB0aGlzIGNsYXNzJ3Mgc3VwZXJjbGFzcyAoe0BsaW5rIEF1dG9saW5rZXIuaHRtbFBhcnNlci5IdG1sTm9kZX0pIGZvciBtb3JlIGRldGFpbHMuXHJcbiAqL1xyXG5BdXRvbGlua2VyLmh0bWxQYXJzZXIuRWxlbWVudE5vZGUgPSBBdXRvbGlua2VyLlV0aWwuZXh0ZW5kKCBBdXRvbGlua2VyLmh0bWxQYXJzZXIuSHRtbE5vZGUsIHtcclxuXHRcclxuXHQvKipcclxuXHQgKiBAY2ZnIHtTdHJpbmd9IHRhZ05hbWUgKHJlcXVpcmVkKVxyXG5cdCAqIFxyXG5cdCAqIFRoZSBuYW1lIG9mIHRoZSB0YWcgdGhhdCB3YXMgbWF0Y2hlZC5cclxuXHQgKi9cclxuXHR0YWdOYW1lIDogJycsXHJcblx0XHJcblx0LyoqXHJcblx0ICogQGNmZyB7Qm9vbGVhbn0gY2xvc2luZyAocmVxdWlyZWQpXHJcblx0ICogXHJcblx0ICogYHRydWVgIGlmIHRoZSBlbGVtZW50ICh0YWcpIGlzIGEgY2xvc2luZyB0YWcsIGBmYWxzZWAgaWYgaXRzIGFuIG9wZW5pbmcgdGFnLlxyXG5cdCAqL1xyXG5cdGNsb3NpbmcgOiBmYWxzZSxcclxuXHJcblx0XHJcblx0LyoqXHJcblx0ICogUmV0dXJucyBhIHN0cmluZyBuYW1lIGZvciB0aGUgdHlwZSBvZiBub2RlIHRoYXQgdGhpcyBjbGFzcyByZXByZXNlbnRzLlxyXG5cdCAqIFxyXG5cdCAqIEByZXR1cm4ge1N0cmluZ31cclxuXHQgKi9cclxuXHRnZXRUeXBlIDogZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gJ2VsZW1lbnQnO1xyXG5cdH0sXHJcblx0XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIEhUTUwgZWxlbWVudCdzICh0YWcncykgbmFtZS4gRXg6IGZvciBhbiAmbHQ7aW1nJmd0OyB0YWcsIHJldHVybnMgXCJpbWdcIi5cclxuXHQgKiBcclxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9XHJcblx0ICovXHJcblx0Z2V0VGFnTmFtZSA6IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMudGFnTmFtZTtcclxuXHR9LFxyXG5cdFxyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIERldGVybWluZXMgaWYgdGhlIEhUTUwgZWxlbWVudCAodGFnKSBpcyBhIGNsb3NpbmcgdGFnLiBFeDogJmx0O2RpdiZndDsgcmV0dXJuc1xyXG5cdCAqIGBmYWxzZWAsIHdoaWxlICZsdDsvZGl2Jmd0OyByZXR1cm5zIGB0cnVlYC5cclxuXHQgKiBcclxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxyXG5cdCAqL1xyXG5cdGlzQ2xvc2luZyA6IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvc2luZztcclxuXHR9XHJcblx0XHJcbn0gKTtcclxuLypnbG9iYWwgQXV0b2xpbmtlciAqL1xyXG4vKipcclxuICogQGNsYXNzIEF1dG9saW5rZXIuaHRtbFBhcnNlci5FbnRpdHlOb2RlXHJcbiAqIEBleHRlbmRzIEF1dG9saW5rZXIuaHRtbFBhcnNlci5IdG1sTm9kZVxyXG4gKiBcclxuICogUmVwcmVzZW50cyBhIGtub3duIEhUTUwgZW50aXR5IG5vZGUgdGhhdCBoYXMgYmVlbiBwYXJzZWQgYnkgdGhlIHtAbGluayBBdXRvbGlua2VyLmh0bWxQYXJzZXIuSHRtbFBhcnNlcn0uXHJcbiAqIEV4OiAnJmFtcDtuYnNwOycsIG9yICcmYW1wIzE2MDsnICh3aGljaCB3aWxsIGJlIHJldHJpZXZhYmxlIGZyb20gdGhlIHtAbGluayAjZ2V0VGV4dH0gbWV0aG9kLlxyXG4gKiBcclxuICogTm90ZSB0aGF0IHRoaXMgY2xhc3Mgd2lsbCBvbmx5IGJlIHJldHVybmVkIGZyb20gdGhlIEh0bWxQYXJzZXIgZm9yIHRoZSBzZXQgb2YgY2hlY2tlZCBIVE1MIGVudGl0eSBub2RlcyBcclxuICogZGVmaW5lZCBieSB0aGUge0BsaW5rIEF1dG9saW5rZXIuaHRtbFBhcnNlci5IdG1sUGFyc2VyI2h0bWxDaGFyYWN0ZXJFbnRpdGllc1JlZ2V4fS5cclxuICogXHJcbiAqIFNlZSB0aGlzIGNsYXNzJ3Mgc3VwZXJjbGFzcyAoe0BsaW5rIEF1dG9saW5rZXIuaHRtbFBhcnNlci5IdG1sTm9kZX0pIGZvciBtb3JlIGRldGFpbHMuXHJcbiAqL1xyXG5BdXRvbGlua2VyLmh0bWxQYXJzZXIuRW50aXR5Tm9kZSA9IEF1dG9saW5rZXIuVXRpbC5leHRlbmQoIEF1dG9saW5rZXIuaHRtbFBhcnNlci5IdG1sTm9kZSwge1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgbmFtZSBmb3IgdGhlIHR5cGUgb2Ygbm9kZSB0aGF0IHRoaXMgY2xhc3MgcmVwcmVzZW50cy5cclxuXHQgKiBcclxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9XHJcblx0ICovXHJcblx0Z2V0VHlwZSA6IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuICdlbnRpdHknO1xyXG5cdH1cclxuXHRcclxufSApO1xyXG4vKmdsb2JhbCBBdXRvbGlua2VyICovXHJcbi8qKlxyXG4gKiBAY2xhc3MgQXV0b2xpbmtlci5odG1sUGFyc2VyLlRleHROb2RlXHJcbiAqIEBleHRlbmRzIEF1dG9saW5rZXIuaHRtbFBhcnNlci5IdG1sTm9kZVxyXG4gKiBcclxuICogUmVwcmVzZW50cyBhIHRleHQgbm9kZSB0aGF0IGhhcyBiZWVuIHBhcnNlZCBieSB0aGUge0BsaW5rIEF1dG9saW5rZXIuaHRtbFBhcnNlci5IdG1sUGFyc2VyfS5cclxuICogXHJcbiAqIFNlZSB0aGlzIGNsYXNzJ3Mgc3VwZXJjbGFzcyAoe0BsaW5rIEF1dG9saW5rZXIuaHRtbFBhcnNlci5IdG1sTm9kZX0pIGZvciBtb3JlIGRldGFpbHMuXHJcbiAqL1xyXG5BdXRvbGlua2VyLmh0bWxQYXJzZXIuVGV4dE5vZGUgPSBBdXRvbGlua2VyLlV0aWwuZXh0ZW5kKCBBdXRvbGlua2VyLmh0bWxQYXJzZXIuSHRtbE5vZGUsIHtcclxuXHRcclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIG5hbWUgZm9yIHRoZSB0eXBlIG9mIG5vZGUgdGhhdCB0aGlzIGNsYXNzIHJlcHJlc2VudHMuXHJcblx0ICogXHJcblx0ICogQHJldHVybiB7U3RyaW5nfVxyXG5cdCAqL1xyXG5cdGdldFR5cGUgOiBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiAndGV4dCc7XHJcblx0fVxyXG5cdFxyXG59ICk7XHJcbi8qZ2xvYmFsIEF1dG9saW5rZXIgKi9cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBjbGFzcyBBdXRvbGlua2VyLm1hdGNoUGFyc2VyLk1hdGNoUGFyc2VyXHJcbiAqIEBleHRlbmRzIE9iamVjdFxyXG4gKlxyXG4gKiBVc2VkIGJ5IEF1dG9saW5rZXIgdG8gcGFyc2UgcG90ZW50aWFsIG1hdGNoZXMsIGdpdmVuIGFuIGlucHV0IHN0cmluZyBvZiB0ZXh0LlxyXG4gKlxyXG4gKiBUaGUgTWF0Y2hQYXJzZXIgaXMgZmVkIGEgbm9uLUhUTUwgc3RyaW5nIGluIG9yZGVyIHRvIHNlYXJjaCBmb3IgbWF0Y2hlcy5cclxuICogQXV0b2xpbmtlciBmaXJzdCB1c2VzIHRoZSB7QGxpbmsgQXV0b2xpbmtlci5odG1sUGFyc2VyLkh0bWxQYXJzZXJ9IHRvIFwid2Fsa1xyXG4gKiBhcm91bmRcIiBIVE1MIHRhZ3MsIGFuZCB0aGVuIHRoZSB0ZXh0IGFyb3VuZCB0aGUgSFRNTCB0YWdzIGlzIHBhc3NlZCBpbnRvIHRoZVxyXG4gKiBNYXRjaFBhcnNlciBpbiBvcmRlciB0byBmaW5kIHRoZSBhY3R1YWwgbWF0Y2hlcy5cclxuICovXHJcbkF1dG9saW5rZXIubWF0Y2hQYXJzZXIuTWF0Y2hQYXJzZXIgPSBBdXRvbGlua2VyLlV0aWwuZXh0ZW5kKCBPYmplY3QsIHtcclxuXHJcblx0LyoqXHJcblx0ICogQGNmZyB7Qm9vbGVhbn0gdXJsc1xyXG5cdCAqIEBpbmhlcml0ZG9jIEF1dG9saW5rZXIjdXJsc1xyXG5cdCAqL1xyXG5cdHVybHMgOiB0cnVlLFxyXG5cclxuXHQvKipcclxuXHQgKiBAY2ZnIHtCb29sZWFufSBlbWFpbFxyXG5cdCAqIEBpbmhlcml0ZG9jIEF1dG9saW5rZXIjZW1haWxcclxuXHQgKi9cclxuXHRlbWFpbCA6IHRydWUsXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBjZmcge0Jvb2xlYW59IHR3aXR0ZXJcclxuXHQgKiBAaW5oZXJpdGRvYyBBdXRvbGlua2VyI3R3aXR0ZXJcclxuXHQgKi9cclxuXHR0d2l0dGVyIDogdHJ1ZSxcclxuXHJcblx0LyoqXHJcblx0ICogQGNmZyB7Qm9vbGVhbn0gcGhvbmVcclxuXHQgKiBAaW5oZXJpdGRvYyBBdXRvbGlua2VyI3Bob25lXHJcblx0ICovXHJcblx0cGhvbmU6IHRydWUsXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBjZmcge0Jvb2xlYW4vU3RyaW5nfSBoYXNodGFnXHJcblx0ICogQGluaGVyaXRkb2MgQXV0b2xpbmtlciNoYXNodGFnXHJcblx0ICovXHJcblx0aGFzaHRhZyA6IGZhbHNlLFxyXG5cclxuXHQvKipcclxuXHQgKiBAY2ZnIHtCb29sZWFufSBzdHJpcFByZWZpeFxyXG5cdCAqIEBpbmhlcml0ZG9jIEF1dG9saW5rZXIjc3RyaXBQcmVmaXhcclxuXHQgKi9cclxuXHRzdHJpcFByZWZpeCA6IHRydWUsXHJcblxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwcm9wZXJ0eSB7UmVnRXhwfSBtYXRjaGVyUmVnZXhcclxuXHQgKlxyXG5cdCAqIFRoZSByZWd1bGFyIGV4cHJlc3Npb24gdGhhdCBtYXRjaGVzIFVSTHMsIGVtYWlsIGFkZHJlc3NlcywgcGhvbmUgI3MsXHJcblx0ICogVHdpdHRlciBoYW5kbGVzLCBhbmQgSGFzaHRhZ3MuXHJcblx0ICpcclxuXHQgKiBUaGlzIHJlZ3VsYXIgZXhwcmVzc2lvbiBoYXMgdGhlIGZvbGxvd2luZyBjYXB0dXJpbmcgZ3JvdXBzOlxyXG5cdCAqXHJcblx0ICogMS4gIEdyb3VwIHRoYXQgaXMgdXNlZCB0byBkZXRlcm1pbmUgaWYgdGhlcmUgaXMgYSBUd2l0dGVyIGhhbmRsZSBtYXRjaFxyXG5cdCAqICAgICAoaS5lLiBcXEBzb21lVHdpdHRlclVzZXIpLiBTaW1wbHkgY2hlY2sgZm9yIGl0cyBleGlzdGVuY2UgdG8gZGV0ZXJtaW5lXHJcblx0ICogICAgIGlmIHRoZXJlIGlzIGEgVHdpdHRlciBoYW5kbGUgbWF0Y2guIFRoZSBuZXh0IGNvdXBsZSBvZiBjYXB0dXJpbmdcclxuXHQgKiAgICAgZ3JvdXBzIGdpdmUgaW5mb3JtYXRpb24gYWJvdXQgdGhlIFR3aXR0ZXIgaGFuZGxlIG1hdGNoLlxyXG5cdCAqIDIuICBUaGUgd2hpdGVzcGFjZSBjaGFyYWN0ZXIgYmVmb3JlIHRoZSBcXEBzaWduIGluIGEgVHdpdHRlciBoYW5kbGUuIFRoaXNcclxuXHQgKiAgICAgaXMgbmVlZGVkIGJlY2F1c2UgdGhlcmUgYXJlIG5vIGxvb2tiZWhpbmRzIGluIEpTIHJlZ3VsYXIgZXhwcmVzc2lvbnMsXHJcblx0ICogICAgIGFuZCBjYW4gYmUgdXNlZCB0byByZWNvbnN0cnVjdCB0aGUgb3JpZ2luYWwgc3RyaW5nIGluIGEgcmVwbGFjZSgpLlxyXG5cdCAqIDMuICBUaGUgVHdpdHRlciBoYW5kbGUgaXRzZWxmIGluIGEgVHdpdHRlciBtYXRjaC4gSWYgdGhlIG1hdGNoIGlzXHJcblx0ICogICAgICdAc29tZVR3aXR0ZXJVc2VyJywgdGhlIGhhbmRsZSBpcyAnc29tZVR3aXR0ZXJVc2VyJy5cclxuXHQgKiA0LiAgR3JvdXAgdGhhdCBtYXRjaGVzIGFuIGVtYWlsIGFkZHJlc3MuIFVzZWQgdG8gZGV0ZXJtaW5lIGlmIHRoZSBtYXRjaFxyXG5cdCAqICAgICBpcyBhbiBlbWFpbCBhZGRyZXNzLCBhcyB3ZWxsIGFzIGhvbGRpbmcgdGhlIGZ1bGwgYWRkcmVzcy4gRXg6XHJcblx0ICogICAgICdtZUBteS5jb20nXHJcblx0ICogNS4gIEdyb3VwIHRoYXQgbWF0Y2hlcyBhIFVSTCBpbiB0aGUgaW5wdXQgdGV4dC4gRXg6ICdodHRwOi8vZ29vZ2xlLmNvbScsXHJcblx0ICogICAgICd3d3cuZ29vZ2xlLmNvbScsIG9yIGp1c3QgJ2dvb2dsZS5jb20nLiBUaGlzIGFsc28gaW5jbHVkZXMgYSBwYXRoLFxyXG5cdCAqICAgICB1cmwgcGFyYW1ldGVycywgb3IgaGFzaCBhbmNob3JzLiBFeDogZ29vZ2xlLmNvbS9wYXRoL3RvL2ZpbGU/cTE9MSZxMj0yI215QW5jaG9yXHJcblx0ICogNi4gIEdyb3VwIHRoYXQgbWF0Y2hlcyBhIHByb3RvY29sIFVSTCAoaS5lLiAnaHR0cDovL2dvb2dsZS5jb20nKS4gVGhpcyBpc1xyXG5cdCAqICAgICB1c2VkIHRvIG1hdGNoIHByb3RvY29sIFVSTHMgd2l0aCBqdXN0IGEgc2luZ2xlIHdvcmQsIGxpa2UgJ2h0dHA6Ly9sb2NhbGhvc3QnLFxyXG5cdCAqICAgICB3aGVyZSB3ZSB3b24ndCBkb3VibGUgY2hlY2sgdGhhdCB0aGUgZG9tYWluIG5hbWUgaGFzIGF0IGxlYXN0IG9uZSAnLidcclxuXHQgKiAgICAgaW4gaXQuXHJcblx0ICogNy4gIEEgcHJvdG9jb2wtcmVsYXRpdmUgKCcvLycpIG1hdGNoIGZvciB0aGUgY2FzZSBvZiBhICd3d3cuJyBwcmVmaXhlZFxyXG5cdCAqICAgICBVUkwuIFdpbGwgYmUgYW4gZW1wdHkgc3RyaW5nIGlmIGl0IGlzIG5vdCBhIHByb3RvY29sLXJlbGF0aXZlIG1hdGNoLlxyXG5cdCAqICAgICBXZSBuZWVkIHRvIGtub3cgdGhlIGNoYXJhY3RlciBiZWZvcmUgdGhlICcvLycgaW4gb3JkZXIgdG8gZGV0ZXJtaW5lXHJcblx0ICogICAgIGlmIGl0IGlzIGEgdmFsaWQgbWF0Y2ggb3IgdGhlIC8vIHdhcyBpbiBhIHN0cmluZyB3ZSBkb24ndCB3YW50IHRvXHJcblx0ICogICAgIGF1dG8tbGluay5cclxuXHQgKiA4LiAgQSBwcm90b2NvbC1yZWxhdGl2ZSAoJy8vJykgbWF0Y2ggZm9yIHRoZSBjYXNlIG9mIGEga25vd24gVExEIHByZWZpeGVkXHJcblx0ICogICAgIFVSTC4gV2lsbCBiZSBhbiBlbXB0eSBzdHJpbmcgaWYgaXQgaXMgbm90IGEgcHJvdG9jb2wtcmVsYXRpdmUgbWF0Y2guXHJcblx0ICogICAgIFNlZSAjNiBmb3IgbW9yZSBpbmZvLlxyXG5cdCAqIDkuICBHcm91cCB0aGF0IGlzIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIHRoZXJlIGlzIGEgcGhvbmUgbnVtYmVyIG1hdGNoLiBUaGVcclxuXHQgKiAgICAgbmV4dCAzIGdyb3VwcyBnaXZlIHNlZ21lbnRzIG9mIHRoZSBwaG9uZSBudW1iZXIuXHJcblx0ICogMTAuIEdyb3VwIHRoYXQgaXMgdXNlZCB0byBkZXRlcm1pbmUgaWYgdGhlcmUgaXMgYSBIYXNodGFnIG1hdGNoXHJcblx0ICogICAgIChpLmUuIFxcI3NvbWVIYXNodGFnKS4gU2ltcGx5IGNoZWNrIGZvciBpdHMgZXhpc3RlbmNlIHRvIGRldGVybWluZSBpZlxyXG5cdCAqICAgICB0aGVyZSBpcyBhIEhhc2h0YWcgbWF0Y2guIFRoZSBuZXh0IGNvdXBsZSBvZiBjYXB0dXJpbmcgZ3JvdXBzIGdpdmVcclxuXHQgKiAgICAgaW5mb3JtYXRpb24gYWJvdXQgdGhlIEhhc2h0YWcgbWF0Y2guXHJcblx0ICogMTEuIFRoZSB3aGl0ZXNwYWNlIGNoYXJhY3RlciBiZWZvcmUgdGhlICNzaWduIGluIGEgSGFzaHRhZyBoYW5kbGUuIFRoaXNcclxuXHQgKiAgICAgaXMgbmVlZGVkIGJlY2F1c2UgdGhlcmUgYXJlIG5vIGxvb2stYmVoaW5kcyBpbiBKUyByZWd1bGFyXHJcblx0ICogICAgIGV4cHJlc3Npb25zLCBhbmQgY2FuIGJlIHVzZWQgdG8gcmVjb25zdHJ1Y3QgdGhlIG9yaWdpbmFsIHN0cmluZyBpbiBhXHJcblx0ICogICAgIHJlcGxhY2UoKS5cclxuXHQgKiAxMi4gVGhlIEhhc2h0YWcgaXRzZWxmIGluIGEgSGFzaHRhZyBtYXRjaC4gSWYgdGhlIG1hdGNoIGlzXHJcblx0ICogICAgICcjc29tZUhhc2h0YWcnLCB0aGUgaGFzaHRhZyBpcyAnc29tZUhhc2h0YWcnLlxyXG5cdCAqL1xyXG5cdG1hdGNoZXJSZWdleCA6IChmdW5jdGlvbigpIHtcclxuXHRcdHZhciB0d2l0dGVyUmVnZXggPSAvKF58W15cXHddKUAoXFx3ezEsMTV9KS8sICAgICAgICAgICAgICAvLyBGb3IgbWF0Y2hpbmcgYSB0d2l0dGVyIGhhbmRsZS4gRXg6IEBncmVnb3J5X2phY29ic1xyXG5cclxuXHRcdCAgICBoYXNodGFnUmVnZXggPSAvKF58W15cXHddKSMoXFx3ezEsMTV9KS8sICAgICAgICAgICAgICAvLyBGb3IgbWF0Y2hpbmcgYSBIYXNodGFnLiBFeDogI2dhbWVzXHJcblxyXG5cdFx0ICAgIGVtYWlsUmVnZXggPSAvKD86W1xcLTs6Jj1cXCtcXCQsXFx3XFwuXStAKS8sICAgICAgICAgICAgIC8vIHNvbWV0aGluZ0AgZm9yIGVtYWlsIGFkZHJlc3NlcyAoYS5rLmEuIGxvY2FsLXBhcnQpXHJcblx0XHQgICAgcGhvbmVSZWdleCA9IC8oPzpcXCs/XFxkezEsM31bLVxccy5dKT9cXCg/XFxkezN9XFwpP1stXFxzLl0/XFxkezN9Wy1cXHMuXVxcZHs0fS8sICAvLyBleDogKDEyMykgNDU2LTc4OTAsIDEyMyA0NTYgNzg5MCwgMTIzLTQ1Ni03ODkwLCBldGMuXHJcblx0XHQgICAgcHJvdG9jb2xSZWdleCA9IC8oPzpbQS1aYS16XVstLitBLVphLXowLTldKzooPyFbQS1aYS16XVstLitBLVphLXowLTldKzpcXC9cXC8pKD8hXFxkK1xcLz8pKD86XFwvXFwvKT8pLywgIC8vIG1hdGNoIHByb3RvY29sLCBhbGxvdyBpbiBmb3JtYXQgXCJodHRwOi8vXCIgb3IgXCJtYWlsdG86XCIuIEhvd2V2ZXIsIGRvIG5vdCBtYXRjaCB0aGUgZmlyc3QgcGFydCBvZiBzb21ldGhpbmcgbGlrZSAnbGluazpodHRwOi8vd3d3Lmdvb2dsZS5jb20nIChpLmUuIGRvbid0IG1hdGNoIFwibGluazpcIikuIEFsc28sIG1ha2Ugc3VyZSB3ZSBkb24ndCBpbnRlcnByZXQgJ2dvb2dsZS5jb206ODAwMCcgYXMgaWYgJ2dvb2dsZS5jb20nIHdhcyBhIHByb3RvY29sIGhlcmUgKGkuZS4gaWdub3JlIGEgdHJhaWxpbmcgcG9ydCBudW1iZXIgaW4gdGhpcyByZWdleClcclxuXHRcdCAgICB3d3dSZWdleCA9IC8oPzp3d3dcXC4pLywgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0YXJ0aW5nIHdpdGggJ3d3dy4nXHJcblx0XHQgICAgZG9tYWluTmFtZVJlZ2V4ID0gL1tBLVphLXowLTlcXC5cXC1dKltBLVphLXowLTlcXC1dLywgIC8vIGFueXRoaW5nIGxvb2tpbmcgYXQgYWxsIGxpa2UgYSBkb21haW4sIG5vbi11bmljb2RlIGRvbWFpbnMsIG5vdCBlbmRpbmcgaW4gYSBwZXJpb2RcclxuXHRcdCAgICB0bGRSZWdleCA9IC9cXC4oPzppbnRlcm5hdGlvbmFsfGNvbnN0cnVjdGlvbnxjb250cmFjdG9yc3xlbnRlcnByaXNlc3xwaG90b2dyYXBoeXxwcm9kdWN0aW9uc3xmb3VuZGF0aW9ufGltbW9iaWxpZW58aW5kdXN0cmllc3xtYW5hZ2VtZW50fHByb3BlcnRpZXN8dGVjaG5vbG9neXxjaHJpc3RtYXN8Y29tbXVuaXR5fGRpcmVjdG9yeXxlZHVjYXRpb258ZXF1aXBtZW50fGluc3RpdHV0ZXxtYXJrZXRpbmd8c29sdXRpb25zfHZhY2F0aW9uc3xiYXJnYWluc3xib3V0aXF1ZXxidWlsZGVyc3xjYXRlcmluZ3xjbGVhbmluZ3xjbG90aGluZ3xjb21wdXRlcnxkZW1vY3JhdHxkaWFtb25kc3xncmFwaGljc3xob2xkaW5nc3xsaWdodGluZ3xwYXJ0bmVyc3xwbHVtYmluZ3xzdXBwbGllc3x0cmFpbmluZ3x2ZW50dXJlc3xhY2FkZW15fGNhcmVlcnN8Y29tcGFueXxjcnVpc2VzfGRvbWFpbnN8ZXhwb3NlZHxmbGlnaHRzfGZsb3Jpc3R8Z2FsbGVyeXxndWl0YXJzfGhvbGlkYXl8a2l0Y2hlbnxuZXVzdGFyfG9raW5hd2F8cmVjaXBlc3xyZW50YWxzfHJldmlld3N8c2hpa3NoYXxzaW5nbGVzfHN1cHBvcnR8c3lzdGVtc3xhZ2VuY3l8YmVybGlufGNhbWVyYXxjZW50ZXJ8Y29mZmVlfGNvbmRvc3xkYXRpbmd8ZXN0YXRlfGV2ZW50c3xleHBlcnR8ZnV0Ym9sfGthdWZlbnxsdXh1cnl8bWFpc29ufG1vbmFzaHxtdXNldW18bmFnb3lhfHBob3Rvc3xyZXBhaXJ8cmVwb3J0fHNvY2lhbHxzdXBwbHl8dGF0dG9vfHRpZW5kYXx0cmF2ZWx8dmlhamVzfHZpbGxhc3x2aXNpb258dm90aW5nfHZveWFnZXxhY3RvcnxidWlsZHxjYXJkc3xjaGVhcHxjb2Rlc3xkYW5jZXxlbWFpbHxnbGFzc3xob3VzZXxtYW5nb3xuaW5qYXxwYXJ0c3xwaG90b3xzaG9lc3xzb2xhcnx0b2RheXx0b2t5b3x0b29sc3x3YXRjaHx3b3Jrc3xhZXJvfGFycGF8YXNpYXxiZXN0fGJpa2V8Ymx1ZXxidXp6fGNhbXB8Y2x1Ynxjb29sfGNvb3B8ZmFybXxmaXNofGdpZnR8Z3VydXxpbmZvfGpvYnN8a2l3aXxrcmVkfGxhbmR8bGltb3xsaW5rfG1lbnV8bW9iaXxtb2RhfG5hbWV8cGljc3xwaW5rfHBvc3R8cXBvbnxyaWNofHJ1aHJ8c2V4eXx0aXBzfHZvdGV8dm90b3x3YW5nfHdpZW58d2lraXx6b25lfGJhcnxiaWR8Yml6fGNhYnxjYXR8Y2VvfGNvbXxlZHV8Z292fGludHxraW18bWlsfG5ldHxvbmx8b3JnfHByb3xwdWJ8cmVkfHRlbHx1bm98d2VkfHh4eHx4eXp8YWN8YWR8YWV8YWZ8YWd8YWl8YWx8YW18YW58YW98YXF8YXJ8YXN8YXR8YXV8YXd8YXh8YXp8YmF8YmJ8YmR8YmV8YmZ8Ymd8Ymh8Yml8Ymp8Ym18Ym58Ym98YnJ8YnN8YnR8YnZ8Ynd8Ynl8Ynp8Y2F8Y2N8Y2R8Y2Z8Y2d8Y2h8Y2l8Y2t8Y2x8Y218Y258Y298Y3J8Y3V8Y3Z8Y3d8Y3h8Y3l8Y3p8ZGV8ZGp8ZGt8ZG18ZG98ZHp8ZWN8ZWV8ZWd8ZXJ8ZXN8ZXR8ZXV8Zml8Zmp8Zmt8Zm18Zm98ZnJ8Z2F8Z2J8Z2R8Z2V8Z2Z8Z2d8Z2h8Z2l8Z2x8Z218Z258Z3B8Z3F8Z3J8Z3N8Z3R8Z3V8Z3d8Z3l8aGt8aG18aG58aHJ8aHR8aHV8aWR8aWV8aWx8aW18aW58aW98aXF8aXJ8aXN8aXR8amV8am18am98anB8a2V8a2d8a2h8a2l8a218a258a3B8a3J8a3d8a3l8a3p8bGF8bGJ8bGN8bGl8bGt8bHJ8bHN8bHR8bHV8bHZ8bHl8bWF8bWN8bWR8bWV8bWd8bWh8bWt8bWx8bW18bW58bW98bXB8bXF8bXJ8bXN8bXR8bXV8bXZ8bXd8bXh8bXl8bXp8bmF8bmN8bmV8bmZ8bmd8bml8bmx8bm98bnB8bnJ8bnV8bnp8b218cGF8cGV8cGZ8cGd8cGh8cGt8cGx8cG18cG58cHJ8cHN8cHR8cHd8cHl8cWF8cmV8cm98cnN8cnV8cnd8c2F8c2J8c2N8c2R8c2V8c2d8c2h8c2l8c2p8c2t8c2x8c218c258c298c3J8c3R8c3V8c3Z8c3h8c3l8c3p8dGN8dGR8dGZ8dGd8dGh8dGp8dGt8dGx8dG18dG58dG98dHB8dHJ8dHR8dHZ8dHd8dHp8dWF8dWd8dWt8dXN8dXl8dXp8dmF8dmN8dmV8dmd8dml8dm58dnV8d2Z8d3N8eWV8eXR8emF8em18encpXFxiLywgICAvLyBtYXRjaCBvdXIga25vd24gdG9wIGxldmVsIGRvbWFpbnMgKFRMRHMpXHJcblxyXG5cdFx0ICAgIC8vIEFsbG93IG9wdGlvbmFsIHBhdGgsIHF1ZXJ5IHN0cmluZywgYW5kIGhhc2ggYW5jaG9yLCBub3QgZW5kaW5nIGluIHRoZSBmb2xsb3dpbmcgY2hhcmFjdGVyczogXCI/ITosLjtcIlxyXG5cdFx0ICAgIC8vIGh0dHA6Ly9ibG9nLmNvZGluZ2hvcnJvci5jb20vdGhlLXByb2JsZW0td2l0aC11cmxzL1xyXG5cdFx0ICAgIHVybFN1ZmZpeFJlZ2V4ID0gL1tcXC1BLVphLXowLTkrJkAjXFwvJT1+XygpfCckKlxcW1xcXT8hOiwuO10qW1xcLUEtWmEtejAtOSsmQCNcXC8lPX5fKCl8JyQqXFxbXFxdXS87XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBSZWdFeHAoIFtcclxuXHRcdFx0JygnLCAgLy8gKioqIENhcHR1cmluZyBncm91cCAkMSwgd2hpY2ggY2FuIGJlIHVzZWQgdG8gY2hlY2sgZm9yIGEgdHdpdHRlciBoYW5kbGUgbWF0Y2guIFVzZSBncm91cCAkMyBmb3IgdGhlIGFjdHVhbCB0d2l0dGVyIGhhbmRsZSB0aG91Z2guICQyIG1heSBiZSB1c2VkIHRvIHJlY29uc3RydWN0IHRoZSBvcmlnaW5hbCBzdHJpbmcgaW4gYSByZXBsYWNlKClcclxuXHRcdFx0XHQvLyAqKiogQ2FwdHVyaW5nIGdyb3VwICQyLCB3aGljaCBtYXRjaGVzIHRoZSB3aGl0ZXNwYWNlIGNoYXJhY3RlciBiZWZvcmUgdGhlICdAJyBzaWduIChuZWVkZWQgYmVjYXVzZSBvZiBubyBsb29rYmVoaW5kcyksIGFuZFxyXG5cdFx0XHRcdC8vICoqKiBDYXB0dXJpbmcgZ3JvdXAgJDMsIHdoaWNoIG1hdGNoZXMgdGhlIGFjdHVhbCB0d2l0dGVyIGhhbmRsZVxyXG5cdFx0XHRcdHR3aXR0ZXJSZWdleC5zb3VyY2UsXHJcblx0XHRcdCcpJyxcclxuXHJcblx0XHRcdCd8JyxcclxuXHJcblx0XHRcdCcoJywgIC8vICoqKiBDYXB0dXJpbmcgZ3JvdXAgJDQsIHdoaWNoIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIGFuIGVtYWlsIG1hdGNoXHJcblx0XHRcdFx0ZW1haWxSZWdleC5zb3VyY2UsXHJcblx0XHRcdFx0ZG9tYWluTmFtZVJlZ2V4LnNvdXJjZSxcclxuXHRcdFx0XHR0bGRSZWdleC5zb3VyY2UsXHJcblx0XHRcdCcpJyxcclxuXHJcblx0XHRcdCd8JyxcclxuXHJcblx0XHRcdCcoJywgIC8vICoqKiBDYXB0dXJpbmcgZ3JvdXAgJDUsIHdoaWNoIGlzIHVzZWQgdG8gbWF0Y2ggYSBVUkxcclxuXHRcdFx0XHQnKD86JywgLy8gcGFyZW5zIHRvIGNvdmVyIG1hdGNoIGZvciBwcm90b2NvbCAob3B0aW9uYWwpLCBhbmQgZG9tYWluXHJcblx0XHRcdFx0XHQnKCcsICAvLyAqKiogQ2FwdHVyaW5nIGdyb3VwICQ2LCBmb3IgYSBwcm90b2NvbC1wcmVmaXhlZCB1cmwgKGV4OiBodHRwOi8vZ29vZ2xlLmNvbSlcclxuXHRcdFx0XHRcdFx0cHJvdG9jb2xSZWdleC5zb3VyY2UsXHJcblx0XHRcdFx0XHRcdGRvbWFpbk5hbWVSZWdleC5zb3VyY2UsXHJcblx0XHRcdFx0XHQnKScsXHJcblxyXG5cdFx0XHRcdFx0J3wnLFxyXG5cclxuXHRcdFx0XHRcdCcoPzonLCAgLy8gbm9uLWNhcHR1cmluZyBwYXJlbiBmb3IgYSAnd3d3LicgcHJlZml4ZWQgdXJsIChleDogd3d3Lmdvb2dsZS5jb20pXHJcblx0XHRcdFx0XHRcdCcoLj8vLyk/JywgIC8vICoqKiBDYXB0dXJpbmcgZ3JvdXAgJDcgZm9yIGFuIG9wdGlvbmFsIHByb3RvY29sLXJlbGF0aXZlIFVSTC4gTXVzdCBiZSBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzdHJpbmcgb3Igc3RhcnQgd2l0aCBhIG5vbi13b3JkIGNoYXJhY3RlclxyXG5cdFx0XHRcdFx0XHR3d3dSZWdleC5zb3VyY2UsXHJcblx0XHRcdFx0XHRcdGRvbWFpbk5hbWVSZWdleC5zb3VyY2UsXHJcblx0XHRcdFx0XHQnKScsXHJcblxyXG5cdFx0XHRcdFx0J3wnLFxyXG5cclxuXHRcdFx0XHRcdCcoPzonLCAgLy8gbm9uLWNhcHR1cmluZyBwYXJlbiBmb3Iga25vd24gYSBUTEQgdXJsIChleDogZ29vZ2xlLmNvbSlcclxuXHRcdFx0XHRcdFx0JyguPy8vKT8nLCAgLy8gKioqIENhcHR1cmluZyBncm91cCAkOCBmb3IgYW4gb3B0aW9uYWwgcHJvdG9jb2wtcmVsYXRpdmUgVVJMLiBNdXN0IGJlIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIHN0cmluZyBvciBzdGFydCB3aXRoIGEgbm9uLXdvcmQgY2hhcmFjdGVyXHJcblx0XHRcdFx0XHRcdGRvbWFpbk5hbWVSZWdleC5zb3VyY2UsXHJcblx0XHRcdFx0XHRcdHRsZFJlZ2V4LnNvdXJjZSxcclxuXHRcdFx0XHRcdCcpJyxcclxuXHRcdFx0XHQnKScsXHJcblxyXG5cdFx0XHRcdCcoPzonICsgdXJsU3VmZml4UmVnZXguc291cmNlICsgJyk/JywgIC8vIG1hdGNoIGZvciBwYXRoLCBxdWVyeSBzdHJpbmcsIGFuZC9vciBoYXNoIGFuY2hvciAtIG9wdGlvbmFsXHJcblx0XHRcdCcpJyxcclxuXHJcblx0XHRcdCd8JyxcclxuXHJcblx0XHRcdC8vIHRoaXMgc2V0dXAgZG9lcyBub3Qgc2NhbGUgd2VsbCBmb3Igb3BlbiBleHRlbnNpb24gOiggTmVlZCB0byByZXRoaW5rIGRlc2lnbiBvZiBhdXRvbGlua2VyLi4uXHJcblx0XHRcdC8vICoqKiAgQ2FwdHVyaW5nIGdyb3VwICQ5LCB3aGljaCBtYXRjaGVzIGEgKFVTQSBmb3Igbm93KSBwaG9uZSBudW1iZXJcclxuXHRcdFx0JygnLFxyXG5cdFx0XHRcdHBob25lUmVnZXguc291cmNlLFxyXG5cdFx0XHQnKScsXHJcblxyXG5cdFx0XHQnfCcsXHJcblxyXG5cdFx0XHQnKCcsICAvLyAqKiogQ2FwdHVyaW5nIGdyb3VwICQxMCwgd2hpY2ggY2FuIGJlIHVzZWQgdG8gY2hlY2sgZm9yIGEgSGFzaHRhZyBtYXRjaC4gVXNlIGdyb3VwICQxMiBmb3IgdGhlIGFjdHVhbCBIYXNodGFnIHRob3VnaC4gJDExIG1heSBiZSB1c2VkIHRvIHJlY29uc3RydWN0IHRoZSBvcmlnaW5hbCBzdHJpbmcgaW4gYSByZXBsYWNlKClcclxuXHRcdFx0XHQvLyAqKiogQ2FwdHVyaW5nIGdyb3VwICQxMSwgd2hpY2ggbWF0Y2hlcyB0aGUgd2hpdGVzcGFjZSBjaGFyYWN0ZXIgYmVmb3JlIHRoZSAnIycgc2lnbiAobmVlZGVkIGJlY2F1c2Ugb2Ygbm8gbG9va2JlaGluZHMpLCBhbmRcclxuXHRcdFx0XHQvLyAqKiogQ2FwdHVyaW5nIGdyb3VwICQxMiwgd2hpY2ggbWF0Y2hlcyB0aGUgYWN0dWFsIEhhc2h0YWdcclxuXHRcdFx0XHRoYXNodGFnUmVnZXguc291cmNlLFxyXG5cdFx0XHQnKSdcclxuXHRcdF0uam9pbiggXCJcIiApLCAnZ2knICk7XHJcblx0fSApKCksXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHByb3BlcnR5IHtSZWdFeHB9IGNoYXJCZWZvcmVQcm90b2NvbFJlbE1hdGNoUmVnZXhcclxuXHQgKlxyXG5cdCAqIFRoZSByZWd1bGFyIGV4cHJlc3Npb24gdXNlZCB0byByZXRyaWV2ZSB0aGUgY2hhcmFjdGVyIGJlZm9yZSBhXHJcblx0ICogcHJvdG9jb2wtcmVsYXRpdmUgVVJMIG1hdGNoLlxyXG5cdCAqXHJcblx0ICogVGhpcyBpcyB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggdGhlIHtAbGluayAjbWF0Y2hlclJlZ2V4fSwgd2hpY2ggbmVlZHNcclxuXHQgKiB0byBncmFiIHRoZSBjaGFyYWN0ZXIgYmVmb3JlIGEgcHJvdG9jb2wtcmVsYXRpdmUgJy8vJyBkdWUgdG8gdGhlIGxhY2sgb2ZcclxuXHQgKiBhIG5lZ2F0aXZlIGxvb2stYmVoaW5kIGluIEphdmFTY3JpcHQgcmVndWxhciBleHByZXNzaW9ucy4gVGhlIGNoYXJhY3RlclxyXG5cdCAqIGJlZm9yZSB0aGUgbWF0Y2ggaXMgc3RyaXBwZWQgZnJvbSB0aGUgVVJMLlxyXG5cdCAqL1xyXG5cdGNoYXJCZWZvcmVQcm90b2NvbFJlbE1hdGNoUmVnZXggOiAvXiguKT9cXC9cXC8vLFxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwcm9wZXJ0eSB7QXV0b2xpbmtlci5NYXRjaFZhbGlkYXRvcn0gbWF0Y2hWYWxpZGF0b3JcclxuXHQgKlxyXG5cdCAqIFRoZSBNYXRjaFZhbGlkYXRvciBvYmplY3QsIHVzZWQgdG8gZmlsdGVyIG91dCBhbnkgZmFsc2UgcG9zaXRpdmVzIGZyb21cclxuXHQgKiB0aGUge0BsaW5rICNtYXRjaGVyUmVnZXh9LiBTZWUge0BsaW5rIEF1dG9saW5rZXIuTWF0Y2hWYWxpZGF0b3J9IGZvciBkZXRhaWxzLlxyXG5cdCAqL1xyXG5cclxuXHJcblx0LyoqXHJcblx0ICogQGNvbnN0cnVjdG9yXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IFtjZmddIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBBbmNob3JUYWdCdWlsZGVyXHJcblx0ICogaW5zdGFuY2UsIHNwZWNpZmllZCBpbiBhbiBPYmplY3QgKG1hcCkuXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IgOiBmdW5jdGlvbiggY2ZnICkge1xyXG5cdFx0QXV0b2xpbmtlci5VdGlsLmFzc2lnbiggdGhpcywgY2ZnICk7XHJcblxyXG5cdFx0dGhpcy5tYXRjaFZhbGlkYXRvciA9IG5ldyBBdXRvbGlua2VyLk1hdGNoVmFsaWRhdG9yKCk7XHJcblx0fSxcclxuXHJcblxyXG5cdC8qKlxyXG5cdCAqIFBhcnNlcyB0aGUgaW5wdXQgYHRleHRgIHRvIHNlYXJjaCBmb3IgbWF0Y2hlcywgYW5kIGNhbGxzIHRoZSBgcmVwbGFjZUZuYFxyXG5cdCAqIHRvIGFsbG93IHJlcGxhY2VtZW50cyBvZiB0aGUgbWF0Y2hlcy4gUmV0dXJucyB0aGUgYHRleHRgIHdpdGggbWF0Y2hlc1xyXG5cdCAqIHJlcGxhY2VkLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHRleHQgVGhlIHRleHQgdG8gc2VhcmNoIGFuZCByZXBhY2UgbWF0Y2hlcyBpbi5cclxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXBsYWNlRm4gVGhlIGl0ZXJhdG9yIGZ1bmN0aW9uIHRvIGhhbmRsZSB0aGVcclxuXHQgKiAgIHJlcGxhY2VtZW50cy4gVGhlIGZ1bmN0aW9uIHRha2VzIGEgc2luZ2xlIGFyZ3VtZW50LCBhIHtAbGluayBBdXRvbGlua2VyLm1hdGNoLk1hdGNofVxyXG5cdCAqICAgb2JqZWN0LCBhbmQgc2hvdWxkIHJldHVybiB0aGUgdGV4dCB0aGF0IHNob3VsZCBtYWtlIHRoZSByZXBsYWNlbWVudC5cclxuXHQgKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHRPYmo9d2luZG93XSBUaGUgY29udGV4dCBvYmplY3QgKFwic2NvcGVcIikgdG8gcnVuXHJcblx0ICogICB0aGUgYHJlcGxhY2VGbmAgaW4uXHJcblx0ICogQHJldHVybiB7U3RyaW5nfVxyXG5cdCAqL1xyXG5cdHJlcGxhY2UgOiBmdW5jdGlvbiggdGV4dCwgcmVwbGFjZUZuLCBjb250ZXh0T2JqICkge1xyXG5cdFx0dmFyIG1lID0gdGhpczsgIC8vIGZvciBjbG9zdXJlXHJcblxyXG5cdFx0cmV0dXJuIHRleHQucmVwbGFjZSggdGhpcy5tYXRjaGVyUmVnZXgsIGZ1bmN0aW9uKCBtYXRjaFN0ciwgJDEsICQyLCAkMywgJDQsICQ1LCAkNiwgJDcsICQ4LCAkOSwgJDEwLCAkMTEsICQxMiApIHtcclxuXHRcdFx0dmFyIG1hdGNoRGVzY09iaiA9IG1lLnByb2Nlc3NDYW5kaWRhdGVNYXRjaCggbWF0Y2hTdHIsICQxLCAkMiwgJDMsICQ0LCAkNSwgJDYsICQ3LCAkOCwgJDksICQxMCwgJDExLCAkMTIgKTsgIC8vIFwibWF0Y2ggZGVzY3JpcHRpb25cIiBvYmplY3RcclxuXHJcblx0XHRcdC8vIFJldHVybiBvdXQgd2l0aCBubyBjaGFuZ2VzIGZvciBtYXRjaCB0eXBlcyB0aGF0IGFyZSBkaXNhYmxlZCAodXJsLFxyXG5cdFx0XHQvLyBlbWFpbCwgcGhvbmUsIGV0Yy4pLCBvciBmb3IgbWF0Y2hlcyB0aGF0IGFyZSBpbnZhbGlkIChmYWxzZVxyXG5cdFx0XHQvLyBwb3NpdGl2ZXMgZnJvbSB0aGUgbWF0Y2hlclJlZ2V4LCB3aGljaCBjYW4ndCB1c2UgbG9vay1iZWhpbmRzXHJcblx0XHRcdC8vIHNpbmNlIHRoZXkgYXJlIHVuYXZhaWxhYmxlIGluIEpTKS5cclxuXHRcdFx0aWYoICFtYXRjaERlc2NPYmogKSB7XHJcblx0XHRcdFx0cmV0dXJuIG1hdGNoU3RyO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHQvLyBHZW5lcmF0ZSByZXBsYWNlbWVudCB0ZXh0IGZvciB0aGUgbWF0Y2ggZnJvbSB0aGUgYHJlcGxhY2VGbmBcclxuXHRcdFx0XHR2YXIgcmVwbGFjZVN0ciA9IHJlcGxhY2VGbi5jYWxsKCBjb250ZXh0T2JqLCBtYXRjaERlc2NPYmoubWF0Y2ggKTtcclxuXHRcdFx0XHRyZXR1cm4gbWF0Y2hEZXNjT2JqLnByZWZpeFN0ciArIHJlcGxhY2VTdHIgKyBtYXRjaERlc2NPYmouc3VmZml4U3RyO1xyXG5cdFx0XHR9XHJcblx0XHR9ICk7XHJcblx0fSxcclxuXHJcblxyXG5cdC8qKlxyXG5cdCAqIFByb2Nlc3NlcyBhIGNhbmRpZGF0ZSBtYXRjaCBmcm9tIHRoZSB7QGxpbmsgI21hdGNoZXJSZWdleH0uXHJcblx0ICpcclxuXHQgKiBOb3QgYWxsIG1hdGNoZXMgZm91bmQgYnkgdGhlIHJlZ2V4IGFyZSBhY3R1YWwgVVJML0VtYWlsL1Bob25lL1R3aXR0ZXIvSGFzaHRhZ1xyXG5cdCAqIG1hdGNoZXMsIGFzIGRldGVybWluZWQgYnkgdGhlIHtAbGluayAjbWF0Y2hWYWxpZGF0b3J9LiBJbiB0aGlzIGNhc2UsIHRoZVxyXG5cdCAqIG1ldGhvZCByZXR1cm5zIGBudWxsYC4gT3RoZXJ3aXNlLCBhIHZhbGlkIE9iamVjdCB3aXRoIGBwcmVmaXhTdHJgLFxyXG5cdCAqIGBtYXRjaGAsIGFuZCBgc3VmZml4U3RyYCBpcyByZXR1cm5lZC5cclxuXHQgKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IG1hdGNoU3RyIFRoZSBmdWxsIG1hdGNoIHRoYXQgd2FzIGZvdW5kIGJ5IHRoZVxyXG5cdCAqICAge0BsaW5rICNtYXRjaGVyUmVnZXh9LlxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0d2l0dGVyTWF0Y2ggVGhlIG1hdGNoZWQgdGV4dCBvZiBhIFR3aXR0ZXIgaGFuZGxlLCBpZiB0aGVcclxuXHQgKiAgIG1hdGNoIGlzIGEgVHdpdHRlciBtYXRjaC5cclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHdpdHRlckhhbmRsZVByZWZpeFdoaXRlc3BhY2VDaGFyIFRoZSB3aGl0ZXNwYWNlIGNoYXJcclxuXHQgKiAgIGJlZm9yZSB0aGUgQCBzaWduIGluIGEgVHdpdHRlciBoYW5kbGUgbWF0Y2guIFRoaXMgaXMgbmVlZGVkIGJlY2F1c2Ugb2ZcclxuXHQgKiAgIG5vIGxvb2tiZWhpbmRzIGluIEpTIHJlZ2V4ZXMsIGFuZCBpcyBuZWVkIHRvIHJlLWluY2x1ZGUgdGhlIGNoYXJhY3RlclxyXG5cdCAqICAgZm9yIHRoZSBhbmNob3IgdGFnIHJlcGxhY2VtZW50LlxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0d2l0dGVySGFuZGxlIFRoZSBhY3R1YWwgVHdpdHRlciB1c2VyIChpLmUgdGhlIHdvcmQgYWZ0ZXJcclxuXHQgKiAgIHRoZSBAIHNpZ24gaW4gYSBUd2l0dGVyIG1hdGNoKS5cclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZW1haWxBZGRyZXNzTWF0Y2ggVGhlIG1hdGNoZWQgZW1haWwgYWRkcmVzcyBmb3IgYW4gZW1haWxcclxuXHQgKiAgIGFkZHJlc3MgbWF0Y2guXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHVybE1hdGNoIFRoZSBtYXRjaGVkIFVSTCBzdHJpbmcgZm9yIGEgVVJMIG1hdGNoLlxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBwcm90b2NvbFVybE1hdGNoIFRoZSBtYXRjaCBVUkwgc3RyaW5nIGZvciBhIHByb3RvY29sXHJcblx0ICogICBtYXRjaC4gRXg6ICdodHRwOi8veWFob28uY29tJy4gVGhpcyBpcyB1c2VkIHRvIG1hdGNoIHNvbWV0aGluZyBsaWtlXHJcblx0ICogICAnaHR0cDovL2xvY2FsaG9zdCcsIHdoZXJlIHdlIHdvbid0IGRvdWJsZSBjaGVjayB0aGF0IHRoZSBkb21haW4gbmFtZVxyXG5cdCAqICAgaGFzIGF0IGxlYXN0IG9uZSAnLicgaW4gaXQuXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHd3d1Byb3RvY29sUmVsYXRpdmVNYXRjaCBUaGUgJy8vJyBmb3IgYSBwcm90b2NvbC1yZWxhdGl2ZVxyXG5cdCAqICAgbWF0Y2ggZnJvbSBhICd3d3cnIHVybCwgd2l0aCB0aGUgY2hhcmFjdGVyIHRoYXQgY29tZXMgYmVmb3JlIHRoZSAnLy8nLlxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0bGRQcm90b2NvbFJlbGF0aXZlTWF0Y2ggVGhlICcvLycgZm9yIGEgcHJvdG9jb2wtcmVsYXRpdmVcclxuXHQgKiAgIG1hdGNoIGZyb20gYSBUTEQgKHRvcCBsZXZlbCBkb21haW4pIG1hdGNoLCB3aXRoIHRoZSBjaGFyYWN0ZXIgdGhhdFxyXG5cdCAqICAgY29tZXMgYmVmb3JlIHRoZSAnLy8nLlxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBwaG9uZU1hdGNoIFRoZSBtYXRjaGVkIHRleHQgb2YgYSBwaG9uZSBudW1iZXJcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaGFzaHRhZ01hdGNoIFRoZSBtYXRjaGVkIHRleHQgb2YgYSBUd2l0dGVyXHJcblx0ICogICBIYXNodGFnLCBpZiB0aGUgbWF0Y2ggaXMgYSBIYXNodGFnIG1hdGNoLlxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBoYXNodGFnUHJlZml4V2hpdGVzcGFjZUNoYXIgVGhlIHdoaXRlc3BhY2UgY2hhclxyXG5cdCAqICAgYmVmb3JlIHRoZSAjIHNpZ24gaW4gYSBIYXNodGFnIG1hdGNoLiBUaGlzIGlzIG5lZWRlZCBiZWNhdXNlIG9mIG5vXHJcblx0ICogICBsb29rYmVoaW5kcyBpbiBKUyByZWdleGVzLCBhbmQgaXMgbmVlZCB0byByZS1pbmNsdWRlIHRoZSBjaGFyYWN0ZXIgZm9yXHJcblx0ICogICB0aGUgYW5jaG9yIHRhZyByZXBsYWNlbWVudC5cclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaGFzaHRhZyBUaGUgYWN0dWFsIEhhc2h0YWcgKGkuZSB0aGUgd29yZFxyXG5cdCAqICAgYWZ0ZXIgdGhlICMgc2lnbiBpbiBhIEhhc2h0YWcgbWF0Y2gpLlxyXG5cdCAqXHJcblx0ICogQHJldHVybiB7T2JqZWN0fSBBIFwibWF0Y2ggZGVzY3JpcHRpb24gb2JqZWN0XCIuIFRoaXMgd2lsbCBiZSBgbnVsbGAgaWYgdGhlXHJcblx0ICogICBtYXRjaCB3YXMgaW52YWxpZCwgb3IgaWYgYSBtYXRjaCB0eXBlIGlzIGRpc2FibGVkLiBPdGhlcndpc2UsIHRoaXMgd2lsbFxyXG5cdCAqICAgYmUgYW4gT2JqZWN0IChtYXApIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxyXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJuLnByZWZpeFN0ciBUaGUgY2hhcihzKSB0aGF0IHNob3VsZCBiZSBwcmVwZW5kZWQgdG9cclxuXHQgKiAgIHRoZSByZXBsYWNlbWVudCBzdHJpbmcuIFRoZXNlIGFyZSBjaGFyKHMpIHRoYXQgd2VyZSBuZWVkZWQgdG8gYmVcclxuXHQgKiAgIGluY2x1ZGVkIGZyb20gdGhlIHJlZ2V4IG1hdGNoIHRoYXQgd2VyZSBpZ25vcmVkIGJ5IHByb2Nlc3NpbmcgY29kZSwgYW5kXHJcblx0ICogICBzaG91bGQgYmUgcmUtaW5zZXJ0ZWQgaW50byB0aGUgcmVwbGFjZW1lbnQgc3RyZWFtLlxyXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJuLnN1ZmZpeFN0ciBUaGUgY2hhcihzKSB0aGF0IHNob3VsZCBiZSBhcHBlbmRlZCB0b1xyXG5cdCAqICAgdGhlIHJlcGxhY2VtZW50IHN0cmluZy4gVGhlc2UgYXJlIGNoYXIocykgdGhhdCB3ZXJlIG5lZWRlZCB0byBiZVxyXG5cdCAqICAgaW5jbHVkZWQgZnJvbSB0aGUgcmVnZXggbWF0Y2ggdGhhdCB3ZXJlIGlnbm9yZWQgYnkgcHJvY2Vzc2luZyBjb2RlLCBhbmRcclxuXHQgKiAgIHNob3VsZCBiZSByZS1pbnNlcnRlZCBpbnRvIHRoZSByZXBsYWNlbWVudCBzdHJlYW0uXHJcblx0ICogQHJldHVybiB7QXV0b2xpbmtlci5tYXRjaC5NYXRjaH0gcmV0dXJuLm1hdGNoIFRoZSBNYXRjaCBvYmplY3QgdGhhdFxyXG5cdCAqICAgcmVwcmVzZW50cyB0aGUgbWF0Y2ggdGhhdCB3YXMgZm91bmQuXHJcblx0ICovXHJcblx0cHJvY2Vzc0NhbmRpZGF0ZU1hdGNoIDogZnVuY3Rpb24oXHJcblx0XHRtYXRjaFN0ciwgdHdpdHRlck1hdGNoLCB0d2l0dGVySGFuZGxlUHJlZml4V2hpdGVzcGFjZUNoYXIsIHR3aXR0ZXJIYW5kbGUsXHJcblx0XHRlbWFpbEFkZHJlc3NNYXRjaCwgdXJsTWF0Y2gsIHByb3RvY29sVXJsTWF0Y2gsIHd3d1Byb3RvY29sUmVsYXRpdmVNYXRjaCxcclxuXHRcdHRsZFByb3RvY29sUmVsYXRpdmVNYXRjaCwgcGhvbmVNYXRjaCwgaGFzaHRhZ01hdGNoLFxyXG5cdFx0aGFzaHRhZ1ByZWZpeFdoaXRlc3BhY2VDaGFyLCBoYXNodGFnXHJcblx0KSB7XHJcblx0XHQvLyBOb3RlOiBUaGUgYG1hdGNoU3RyYCB2YXJpYWJsZSB3aWwgYmUgZml4ZWQgdXAgdG8gcmVtb3ZlIGNoYXJhY3RlcnMgdGhhdCBhcmUgbm8gbG9uZ2VyIG5lZWRlZCAod2hpY2ggd2lsbFxyXG5cdFx0Ly8gYmUgYWRkZWQgdG8gYHByZWZpeFN0cmAgYW5kIGBzdWZmaXhTdHJgKS5cclxuXHJcblx0XHR2YXIgcHJvdG9jb2xSZWxhdGl2ZU1hdGNoID0gd3d3UHJvdG9jb2xSZWxhdGl2ZU1hdGNoIHx8IHRsZFByb3RvY29sUmVsYXRpdmVNYXRjaCxcclxuXHRcdCAgICBtYXRjaCwgIC8vIFdpbGwgYmUgYW4gQXV0b2xpbmtlci5tYXRjaC5NYXRjaCBvYmplY3RcclxuXHJcblx0XHQgICAgcHJlZml4U3RyID0gXCJcIiwgIC8vIEEgc3RyaW5nIHRvIHVzZSB0byBwcmVmaXggdGhlIGFuY2hvciB0YWcgdGhhdCBpcyBjcmVhdGVkLiBUaGlzIGlzIG5lZWRlZCBmb3IgdGhlIFR3aXR0ZXIgYW5kIEhhc2h0YWcgbWF0Y2hlcy5cclxuXHRcdCAgICBzdWZmaXhTdHIgPSBcIlwiOyAgLy8gQSBzdHJpbmcgdG8gc3VmZml4IHRoZSBhbmNob3IgdGFnIHRoYXQgaXMgY3JlYXRlZC4gVGhpcyBpcyB1c2VkIGlmIHRoZXJlIGlzIGEgdHJhaWxpbmcgcGFyZW50aGVzaXMgdGhhdCBzaG91bGQgbm90IGJlIGF1dG8tbGlua2VkLlxyXG5cclxuXHRcdC8vIFJldHVybiBvdXQgd2l0aCBgbnVsbGAgZm9yIG1hdGNoIHR5cGVzIHRoYXQgYXJlIGRpc2FibGVkICh1cmwsIGVtYWlsLFxyXG5cdFx0Ly8gdHdpdHRlciwgaGFzaHRhZyksIG9yIGZvciBtYXRjaGVzIHRoYXQgYXJlIGludmFsaWQgKGZhbHNlIHBvc2l0aXZlc1xyXG5cdFx0Ly8gZnJvbSB0aGUgbWF0Y2hlclJlZ2V4LCB3aGljaCBjYW4ndCB1c2UgbG9vay1iZWhpbmRzIHNpbmNlIHRoZXkgYXJlXHJcblx0XHQvLyB1bmF2YWlsYWJsZSBpbiBKUykuXHJcblx0XHRpZihcclxuXHRcdFx0KCB1cmxNYXRjaCAmJiAhdGhpcy51cmxzICkgfHxcclxuXHRcdFx0KCBlbWFpbEFkZHJlc3NNYXRjaCAmJiAhdGhpcy5lbWFpbCApIHx8XHJcblx0XHRcdCggcGhvbmVNYXRjaCAmJiAhdGhpcy5waG9uZSApIHx8XHJcblx0XHRcdCggdHdpdHRlck1hdGNoICYmICF0aGlzLnR3aXR0ZXIgKSB8fFxyXG5cdFx0XHQoIGhhc2h0YWdNYXRjaCAmJiAhdGhpcy5oYXNodGFnICkgfHxcclxuXHRcdFx0IXRoaXMubWF0Y2hWYWxpZGF0b3IuaXNWYWxpZE1hdGNoKCB1cmxNYXRjaCwgcHJvdG9jb2xVcmxNYXRjaCwgcHJvdG9jb2xSZWxhdGl2ZU1hdGNoIClcclxuXHRcdCkge1xyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBIYW5kbGUgYSBjbG9zaW5nIHBhcmVudGhlc2lzIGF0IHRoZSBlbmQgb2YgdGhlIG1hdGNoLCBhbmQgZXhjbHVkZSBpdFxyXG5cdFx0Ly8gaWYgdGhlcmUgaXMgbm90IGEgbWF0Y2hpbmcgb3BlbiBwYXJlbnRoZXNpc1xyXG5cdFx0Ly8gaW4gdGhlIG1hdGNoIGl0c2VsZi5cclxuXHRcdGlmKCB0aGlzLm1hdGNoSGFzVW5iYWxhbmNlZENsb3NpbmdQYXJlbiggbWF0Y2hTdHIgKSApIHtcclxuXHRcdFx0bWF0Y2hTdHIgPSBtYXRjaFN0ci5zdWJzdHIoIDAsIG1hdGNoU3RyLmxlbmd0aCAtIDEgKTsgIC8vIHJlbW92ZSB0aGUgdHJhaWxpbmcgXCIpXCJcclxuXHRcdFx0c3VmZml4U3RyID0gXCIpXCI7ICAvLyB0aGlzIHdpbGwgYmUgYWRkZWQgYWZ0ZXIgdGhlIGdlbmVyYXRlZCA8YT4gdGFnXHJcblx0XHR9XHJcblxyXG5cdFx0aWYoIGVtYWlsQWRkcmVzc01hdGNoICkge1xyXG5cdFx0XHRtYXRjaCA9IG5ldyBBdXRvbGlua2VyLm1hdGNoLkVtYWlsKCB7IG1hdGNoZWRUZXh0OiBtYXRjaFN0ciwgZW1haWw6IGVtYWlsQWRkcmVzc01hdGNoIH0gKTtcclxuXHJcblx0XHR9IGVsc2UgaWYoIHR3aXR0ZXJNYXRjaCApIHtcclxuXHRcdFx0Ly8gZml4IHVwIHRoZSBgbWF0Y2hTdHJgIGlmIHRoZXJlIHdhcyBhIHByZWNlZGluZyB3aGl0ZXNwYWNlIGNoYXIsXHJcblx0XHRcdC8vIHdoaWNoIHdhcyBuZWVkZWQgdG8gZGV0ZXJtaW5lIHRoZSBtYXRjaCBpdHNlbGYgKHNpbmNlIHRoZXJlIGFyZVxyXG5cdFx0XHQvLyBubyBsb29rLWJlaGluZHMgaW4gSlMgcmVnZXhlcylcclxuXHRcdFx0aWYoIHR3aXR0ZXJIYW5kbGVQcmVmaXhXaGl0ZXNwYWNlQ2hhciApIHtcclxuXHRcdFx0XHRwcmVmaXhTdHIgPSB0d2l0dGVySGFuZGxlUHJlZml4V2hpdGVzcGFjZUNoYXI7XHJcblx0XHRcdFx0bWF0Y2hTdHIgPSBtYXRjaFN0ci5zbGljZSggMSApOyAgLy8gcmVtb3ZlIHRoZSBwcmVmaXhlZCB3aGl0ZXNwYWNlIGNoYXIgZnJvbSB0aGUgbWF0Y2hcclxuXHRcdFx0fVxyXG5cdFx0XHRtYXRjaCA9IG5ldyBBdXRvbGlua2VyLm1hdGNoLlR3aXR0ZXIoIHsgbWF0Y2hlZFRleHQ6IG1hdGNoU3RyLCB0d2l0dGVySGFuZGxlOiB0d2l0dGVySGFuZGxlIH0gKTtcclxuXHJcblx0XHR9IGVsc2UgaWYoIHBob25lTWF0Y2ggKSB7XHJcblx0XHRcdC8vIHJlbW92ZSBub24tbnVtZXJpYyB2YWx1ZXMgZnJvbSBwaG9uZSBudW1iZXIgc3RyaW5nXHJcblx0XHRcdHZhciBjbGVhbk51bWJlciA9IG1hdGNoU3RyLnJlcGxhY2UoIC9cXEQvZywgJycgKTtcclxuIFx0XHRcdG1hdGNoID0gbmV3IEF1dG9saW5rZXIubWF0Y2guUGhvbmUoIHsgbWF0Y2hlZFRleHQ6IG1hdGNoU3RyLCBudW1iZXI6IGNsZWFuTnVtYmVyIH0gKTtcclxuXHJcblx0XHR9IGVsc2UgaWYoIGhhc2h0YWdNYXRjaCApIHtcclxuXHRcdFx0Ly8gZml4IHVwIHRoZSBgbWF0Y2hTdHJgIGlmIHRoZXJlIHdhcyBhIHByZWNlZGluZyB3aGl0ZXNwYWNlIGNoYXIsXHJcblx0XHRcdC8vIHdoaWNoIHdhcyBuZWVkZWQgdG8gZGV0ZXJtaW5lIHRoZSBtYXRjaCBpdHNlbGYgKHNpbmNlIHRoZXJlIGFyZVxyXG5cdFx0XHQvLyBubyBsb29rLWJlaGluZHMgaW4gSlMgcmVnZXhlcylcclxuXHRcdFx0aWYoIGhhc2h0YWdQcmVmaXhXaGl0ZXNwYWNlQ2hhciApIHtcclxuXHRcdFx0XHRwcmVmaXhTdHIgPSBoYXNodGFnUHJlZml4V2hpdGVzcGFjZUNoYXI7XHJcblx0XHRcdFx0bWF0Y2hTdHIgPSBtYXRjaFN0ci5zbGljZSggMSApOyAgLy8gcmVtb3ZlIHRoZSBwcmVmaXhlZCB3aGl0ZXNwYWNlIGNoYXIgZnJvbSB0aGUgbWF0Y2hcclxuXHRcdFx0fVxyXG5cdFx0XHRtYXRjaCA9IG5ldyBBdXRvbGlua2VyLm1hdGNoLkhhc2h0YWcoIHsgbWF0Y2hlZFRleHQ6IG1hdGNoU3RyLCBzZXJ2aWNlTmFtZTogdGhpcy5oYXNodGFnLCBoYXNodGFnOiBoYXNodGFnIH0gKTtcclxuXHJcblx0XHR9IGVsc2UgeyAgLy8gdXJsIG1hdGNoXHJcblx0XHRcdC8vIElmIGl0J3MgYSBwcm90b2NvbC1yZWxhdGl2ZSAnLy8nIG1hdGNoLCByZW1vdmUgdGhlIGNoYXJhY3RlclxyXG5cdFx0XHQvLyBiZWZvcmUgdGhlICcvLycgKHdoaWNoIHRoZSBtYXRjaGVyUmVnZXggbmVlZGVkIHRvIG1hdGNoIGR1ZSB0b1xyXG5cdFx0XHQvLyB0aGUgbGFjayBvZiBhIG5lZ2F0aXZlIGxvb2stYmVoaW5kIGluIEphdmFTY3JpcHQgcmVndWxhclxyXG5cdFx0XHQvLyBleHByZXNzaW9ucylcclxuXHRcdFx0aWYoIHByb3RvY29sUmVsYXRpdmVNYXRjaCApIHtcclxuXHRcdFx0XHR2YXIgY2hhckJlZm9yZU1hdGNoID0gcHJvdG9jb2xSZWxhdGl2ZU1hdGNoLm1hdGNoKCB0aGlzLmNoYXJCZWZvcmVQcm90b2NvbFJlbE1hdGNoUmVnZXggKVsgMSBdIHx8IFwiXCI7XHJcblxyXG5cdFx0XHRcdGlmKCBjaGFyQmVmb3JlTWF0Y2ggKSB7ICAvLyBmaXggdXAgdGhlIGBtYXRjaFN0cmAgaWYgdGhlcmUgd2FzIGEgcHJlY2VkaW5nIGNoYXIgYmVmb3JlIGEgcHJvdG9jb2wtcmVsYXRpdmUgbWF0Y2gsIHdoaWNoIHdhcyBuZWVkZWQgdG8gZGV0ZXJtaW5lIHRoZSBtYXRjaCBpdHNlbGYgKHNpbmNlIHRoZXJlIGFyZSBubyBsb29rLWJlaGluZHMgaW4gSlMgcmVnZXhlcylcclxuXHRcdFx0XHRcdHByZWZpeFN0ciA9IGNoYXJCZWZvcmVNYXRjaDtcclxuXHRcdFx0XHRcdG1hdGNoU3RyID0gbWF0Y2hTdHIuc2xpY2UoIDEgKTsgIC8vIHJlbW92ZSB0aGUgcHJlZml4ZWQgY2hhciBmcm9tIHRoZSBtYXRjaFxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bWF0Y2ggPSBuZXcgQXV0b2xpbmtlci5tYXRjaC5VcmwoIHtcclxuXHRcdFx0XHRtYXRjaGVkVGV4dCA6IG1hdGNoU3RyLFxyXG5cdFx0XHRcdHVybCA6IG1hdGNoU3RyLFxyXG5cdFx0XHRcdHByb3RvY29sVXJsTWF0Y2ggOiAhIXByb3RvY29sVXJsTWF0Y2gsXHJcblx0XHRcdFx0cHJvdG9jb2xSZWxhdGl2ZU1hdGNoIDogISFwcm90b2NvbFJlbGF0aXZlTWF0Y2gsXHJcblx0XHRcdFx0c3RyaXBQcmVmaXggOiB0aGlzLnN0cmlwUHJlZml4XHJcblx0XHRcdH0gKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHRwcmVmaXhTdHIgOiBwcmVmaXhTdHIsXHJcblx0XHRcdHN1ZmZpeFN0ciA6IHN1ZmZpeFN0cixcclxuXHRcdFx0bWF0Y2ggICAgIDogbWF0Y2hcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblxyXG5cdC8qKlxyXG5cdCAqIERldGVybWluZXMgaWYgYSBtYXRjaCBmb3VuZCBoYXMgYW4gdW5tYXRjaGVkIGNsb3NpbmcgcGFyZW50aGVzaXMuIElmIHNvLFxyXG5cdCAqIHRoaXMgcGFyZW50aGVzaXMgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIG1hdGNoIGl0c2VsZiwgYW5kIGFwcGVuZGVkXHJcblx0ICogYWZ0ZXIgdGhlIGdlbmVyYXRlZCBhbmNob3IgdGFnIGluIHtAbGluayAjcHJvY2Vzc0NhbmRpZGF0ZU1hdGNofS5cclxuXHQgKlxyXG5cdCAqIEEgbWF0Y2ggbWF5IGhhdmUgYW4gZXh0cmEgY2xvc2luZyBwYXJlbnRoZXNpcyBhdCB0aGUgZW5kIG9mIHRoZSBtYXRjaFxyXG5cdCAqIGJlY2F1c2UgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBtdXN0IGluY2x1ZGUgcGFyZW50aGVzaXMgZm9yIFVSTHMgc3VjaCBhc1xyXG5cdCAqIFwid2lraXBlZGlhLmNvbS9zb21ldGhpbmdfKGRpc2FtYmlndWF0aW9uKVwiLCB3aGljaCBzaG91bGQgYmUgYXV0by1saW5rZWQuXHJcblx0ICpcclxuXHQgKiBIb3dldmVyLCBhbiBleHRyYSBwYXJlbnRoZXNpcyAqd2lsbCogYmUgaW5jbHVkZWQgd2hlbiB0aGUgVVJMIGl0c2VsZiBpc1xyXG5cdCAqIHdyYXBwZWQgaW4gcGFyZW50aGVzaXMsIHN1Y2ggYXMgaW4gdGhlIGNhc2Ugb2YgXCIod2lraXBlZGlhLmNvbS9zb21ldGhpbmdfKGRpc2FtYmlndWF0aW9uKSlcIi5cclxuXHQgKiBJbiB0aGlzIGNhc2UsIHRoZSBsYXN0IGNsb3NpbmcgcGFyZW50aGVzaXMgc2hvdWxkICpub3QqIGJlIHBhcnQgb2YgdGhlXHJcblx0ICogVVJMIGl0c2VsZiwgYW5kIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIGB0cnVlYC5cclxuXHQgKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IG1hdGNoU3RyIFRoZSBmdWxsIG1hdGNoIHN0cmluZyBmcm9tIHRoZSB7QGxpbmsgI21hdGNoZXJSZWdleH0uXHJcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZXJlIGlzIGFuIHVuYmFsYW5jZWQgY2xvc2luZyBwYXJlbnRoZXNpcyBhdFxyXG5cdCAqICAgdGhlIGVuZCBvZiB0aGUgYG1hdGNoU3RyYCwgYGZhbHNlYCBvdGhlcndpc2UuXHJcblx0ICovXHJcblx0bWF0Y2hIYXNVbmJhbGFuY2VkQ2xvc2luZ1BhcmVuIDogZnVuY3Rpb24oIG1hdGNoU3RyICkge1xyXG5cdFx0dmFyIGxhc3RDaGFyID0gbWF0Y2hTdHIuY2hhckF0KCBtYXRjaFN0ci5sZW5ndGggLSAxICk7XHJcblxyXG5cdFx0aWYoIGxhc3RDaGFyID09PSAnKScgKSB7XHJcblx0XHRcdHZhciBvcGVuUGFyZW5zTWF0Y2ggPSBtYXRjaFN0ci5tYXRjaCggL1xcKC9nICksXHJcblx0XHRcdCAgICBjbG9zZVBhcmVuc01hdGNoID0gbWF0Y2hTdHIubWF0Y2goIC9cXCkvZyApLFxyXG5cdFx0XHQgICAgbnVtT3BlblBhcmVucyA9ICggb3BlblBhcmVuc01hdGNoICYmIG9wZW5QYXJlbnNNYXRjaC5sZW5ndGggKSB8fCAwLFxyXG5cdFx0XHQgICAgbnVtQ2xvc2VQYXJlbnMgPSAoIGNsb3NlUGFyZW5zTWF0Y2ggJiYgY2xvc2VQYXJlbnNNYXRjaC5sZW5ndGggKSB8fCAwO1xyXG5cclxuXHRcdFx0aWYoIG51bU9wZW5QYXJlbnMgPCBudW1DbG9zZVBhcmVucyApIHtcclxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9XHJcblxyXG59ICk7XHJcbi8qZ2xvYmFsIEF1dG9saW5rZXIgKi9cclxuLypqc2hpbnQgc2NyaXB0dXJsOnRydWUgKi9cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBjbGFzcyBBdXRvbGlua2VyLk1hdGNoVmFsaWRhdG9yXHJcbiAqIEBleHRlbmRzIE9iamVjdFxyXG4gKlxyXG4gKiBVc2VkIGJ5IEF1dG9saW5rZXIgdG8gZmlsdGVyIG91dCBmYWxzZSBwb3NpdGl2ZXMgZnJvbSB0aGVcclxuICoge0BsaW5rIEF1dG9saW5rZXIubWF0Y2hQYXJzZXIuTWF0Y2hQYXJzZXIjbWF0Y2hlclJlZ2V4fS5cclxuICpcclxuICogRHVlIHRvIHRoZSBsaW1pdGF0aW9ucyBvZiByZWd1bGFyIGV4cHJlc3Npb25zIChpbmNsdWRpbmcgdGhlIG1pc3NpbmcgZmVhdHVyZVxyXG4gKiBvZiBsb29rLWJlaGluZHMgaW4gSlMgcmVndWxhciBleHByZXNzaW9ucyksIHdlIGNhbm5vdCBhbHdheXMgZGV0ZXJtaW5lIHRoZVxyXG4gKiB2YWxpZGl0eSBvZiBhIGdpdmVuIG1hdGNoLiBUaGlzIGNsYXNzIGFwcGxpZXMgYSBiaXQgb2YgYWRkaXRpb25hbCBsb2dpYyB0b1xyXG4gKiBmaWx0ZXIgb3V0IGFueSBmYWxzZSBwb3NpdGl2ZXMgdGhhdCBoYXZlIGJlZW4gbWF0Y2hlZCBieSB0aGVcclxuICoge0BsaW5rIEF1dG9saW5rZXIubWF0Y2hQYXJzZXIuTWF0Y2hQYXJzZXIjbWF0Y2hlclJlZ2V4fS5cclxuICovXHJcbkF1dG9saW5rZXIuTWF0Y2hWYWxpZGF0b3IgPSBBdXRvbGlua2VyLlV0aWwuZXh0ZW5kKCBPYmplY3QsIHtcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcHJvcGVydHkge1JlZ0V4cH0gaW52YWxpZFByb3RvY29sUmVsTWF0Y2hSZWdleFxyXG5cdCAqXHJcblx0ICogVGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiB1c2VkIHRvIGNoZWNrIGEgcG90ZW50aWFsIHByb3RvY29sLXJlbGF0aXZlIFVSTFxyXG5cdCAqIG1hdGNoLCBjb21pbmcgZnJvbSB0aGUge0BsaW5rIEF1dG9saW5rZXIubWF0Y2hQYXJzZXIuTWF0Y2hQYXJzZXIjbWF0Y2hlclJlZ2V4fS5cclxuXHQgKiBBIHByb3RvY29sLXJlbGF0aXZlIFVSTCBpcywgZm9yIGV4YW1wbGUsIFwiLy95YWhvby5jb21cIlxyXG5cdCAqXHJcblx0ICogVGhpcyByZWd1bGFyIGV4cHJlc3Npb24gY2hlY2tzIHRvIHNlZSBpZiB0aGVyZSBpcyBhIHdvcmQgY2hhcmFjdGVyIGJlZm9yZVxyXG5cdCAqIHRoZSAnLy8nIG1hdGNoIGluIG9yZGVyIHRvIGRldGVybWluZSBpZiB3ZSBzaG91bGQgYWN0dWFsbHkgYXV0b2xpbmsgYVxyXG5cdCAqIHByb3RvY29sLXJlbGF0aXZlIFVSTC4gVGhpcyBpcyBuZWVkZWQgYmVjYXVzZSB0aGVyZSBpcyBubyBuZWdhdGl2ZVxyXG5cdCAqIGxvb2stYmVoaW5kIGluIEphdmFTY3JpcHQgcmVndWxhciBleHByZXNzaW9ucy5cclxuXHQgKlxyXG5cdCAqIEZvciBpbnN0YW5jZSwgd2Ugd2FudCB0byBhdXRvbGluayBzb21ldGhpbmcgbGlrZSBcIkdvIHRvOiAvL2dvb2dsZS5jb21cIixcclxuXHQgKiBidXQgd2UgZG9uJ3Qgd2FudCB0byBhdXRvbGluayBzb21ldGhpbmcgbGlrZSBcImFiYy8vZ29vZ2xlLmNvbVwiXHJcblx0ICovXHJcblx0aW52YWxpZFByb3RvY29sUmVsTWF0Y2hSZWdleCA6IC9eW1xcd11cXC9cXC8vLFxyXG5cclxuXHQvKipcclxuXHQgKiBSZWdleCB0byB0ZXN0IGZvciBhIGZ1bGwgcHJvdG9jb2wsIHdpdGggdGhlIHR3byB0cmFpbGluZyBzbGFzaGVzLiBFeDogJ2h0dHA6Ly8nXHJcblx0ICpcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwcm9wZXJ0eSB7UmVnRXhwfSBoYXNGdWxsUHJvdG9jb2xSZWdleFxyXG5cdCAqL1xyXG5cdGhhc0Z1bGxQcm90b2NvbFJlZ2V4IDogL15bQS1aYS16XVstLitBLVphLXowLTldKzpcXC9cXC8vLFxyXG5cclxuXHQvKipcclxuXHQgKiBSZWdleCB0byBmaW5kIHRoZSBVUkkgc2NoZW1lLCBzdWNoIGFzICdtYWlsdG86Jy5cclxuXHQgKlxyXG5cdCAqIFRoaXMgaXMgdXNlZCB0byBmaWx0ZXIgb3V0ICdqYXZhc2NyaXB0OicgYW5kICd2YnNjcmlwdDonIHNjaGVtZXMuXHJcblx0ICpcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwcm9wZXJ0eSB7UmVnRXhwfSB1cmlTY2hlbWVSZWdleFxyXG5cdCAqL1xyXG5cdHVyaVNjaGVtZVJlZ2V4IDogL15bQS1aYS16XVstLitBLVphLXowLTldKzovLFxyXG5cclxuXHQvKipcclxuXHQgKiBSZWdleCB0byBkZXRlcm1pbmUgaWYgYXQgbGVhc3Qgb25lIHdvcmQgY2hhciBleGlzdHMgYWZ0ZXIgdGhlIHByb3RvY29sIChpLmUuIGFmdGVyIHRoZSAnOicpXHJcblx0ICpcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwcm9wZXJ0eSB7UmVnRXhwfSBoYXNXb3JkQ2hhckFmdGVyUHJvdG9jb2xSZWdleFxyXG5cdCAqL1xyXG5cdGhhc1dvcmRDaGFyQWZ0ZXJQcm90b2NvbFJlZ2V4IDogLzpbXlxcc10qP1tBLVphLXpdLyxcclxuXHJcblxyXG5cdC8qKlxyXG5cdCAqIERldGVybWluZXMgaWYgYSBnaXZlbiBtYXRjaCBmb3VuZCBieSB0aGUge0BsaW5rIEF1dG9saW5rZXIubWF0Y2hQYXJzZXIuTWF0Y2hQYXJzZXJ9XHJcblx0ICogaXMgdmFsaWQuIFdpbGwgcmV0dXJuIGBmYWxzZWAgZm9yOlxyXG5cdCAqXHJcblx0ICogMSkgVVJMIG1hdGNoZXMgd2hpY2ggZG8gbm90IGhhdmUgYXQgbGVhc3QgaGF2ZSBvbmUgcGVyaW9kICgnLicpIGluIHRoZVxyXG5cdCAqICAgIGRvbWFpbiBuYW1lIChlZmZlY3RpdmVseSBza2lwcGluZyBvdmVyIG1hdGNoZXMgbGlrZSBcImFiYzpkZWZcIikuXHJcblx0ICogICAgSG93ZXZlciwgVVJMIG1hdGNoZXMgd2l0aCBhIHByb3RvY29sIHdpbGwgYmUgYWxsb3dlZCAoZXg6ICdodHRwOi8vbG9jYWxob3N0JylcclxuXHQgKiAyKSBVUkwgbWF0Y2hlcyB3aGljaCBkbyBub3QgaGF2ZSBhdCBsZWFzdCBvbmUgd29yZCBjaGFyYWN0ZXIgaW4gdGhlXHJcblx0ICogICAgZG9tYWluIG5hbWUgKGVmZmVjdGl2ZWx5IHNraXBwaW5nIG92ZXIgbWF0Y2hlcyBsaWtlIFwiZ2l0OjEuMFwiKS5cclxuXHQgKiAzKSBBIHByb3RvY29sLXJlbGF0aXZlIHVybCBtYXRjaCAoYSBVUkwgYmVnaW5uaW5nIHdpdGggJy8vJykgd2hvc2VcclxuXHQgKiAgICBwcmV2aW91cyBjaGFyYWN0ZXIgaXMgYSB3b3JkIGNoYXJhY3RlciAoZWZmZWN0aXZlbHkgc2tpcHBpbmcgb3ZlclxyXG5cdCAqICAgIHN0cmluZ3MgbGlrZSBcImFiYy8vZ29vZ2xlLmNvbVwiKVxyXG5cdCAqXHJcblx0ICogT3RoZXJ3aXNlLCByZXR1cm5zIGB0cnVlYC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB1cmxNYXRjaCBUaGUgbWF0Y2hlZCBVUkwsIGlmIHRoZXJlIHdhcyBvbmUuIFdpbGwgYmUgYW5cclxuXHQgKiAgIGVtcHR5IHN0cmluZyBpZiB0aGUgbWF0Y2ggaXMgbm90IGEgVVJMIG1hdGNoLlxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBwcm90b2NvbFVybE1hdGNoIFRoZSBtYXRjaCBVUkwgc3RyaW5nIGZvciBhIHByb3RvY29sXHJcblx0ICogICBtYXRjaC4gRXg6ICdodHRwOi8veWFob28uY29tJy4gVGhpcyBpcyB1c2VkIHRvIG1hdGNoIHNvbWV0aGluZyBsaWtlXHJcblx0ICogICAnaHR0cDovL2xvY2FsaG9zdCcsIHdoZXJlIHdlIHdvbid0IGRvdWJsZSBjaGVjayB0aGF0IHRoZSBkb21haW4gbmFtZVxyXG5cdCAqICAgaGFzIGF0IGxlYXN0IG9uZSAnLicgaW4gaXQuXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHByb3RvY29sUmVsYXRpdmVNYXRjaCBUaGUgcHJvdG9jb2wtcmVsYXRpdmUgc3RyaW5nIGZvciBhXHJcblx0ICogICBVUkwgbWF0Y2ggKGkuZS4gJy8vJyksIHBvc3NpYmx5IHdpdGggYSBwcmVjZWRpbmcgY2hhcmFjdGVyIChleCwgYVxyXG5cdCAqICAgc3BhY2UsIHN1Y2ggYXM6ICcgLy8nLCBvciBhIGxldHRlciwgc3VjaCBhczogJ2EvLycpLiBUaGUgbWF0Y2ggaXNcclxuXHQgKiAgIGludmFsaWQgaWYgdGhlcmUgaXMgYSB3b3JkIGNoYXJhY3RlciBwcmVjZWRpbmcgdGhlICcvLycuXHJcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBtYXRjaCBnaXZlbiBpcyB2YWxpZCBhbmQgc2hvdWxkIGJlXHJcblx0ICogICBwcm9jZXNzZWQsIG9yIGBmYWxzZWAgaWYgdGhlIG1hdGNoIGlzIGludmFsaWQgYW5kL29yIHNob3VsZCBqdXN0IG5vdCBiZVxyXG5cdCAqICAgcHJvY2Vzc2VkLlxyXG5cdCAqL1xyXG5cdGlzVmFsaWRNYXRjaCA6IGZ1bmN0aW9uKCB1cmxNYXRjaCwgcHJvdG9jb2xVcmxNYXRjaCwgcHJvdG9jb2xSZWxhdGl2ZU1hdGNoICkge1xyXG5cdFx0aWYoXHJcblx0XHRcdCggcHJvdG9jb2xVcmxNYXRjaCAmJiAhdGhpcy5pc1ZhbGlkVXJpU2NoZW1lKCBwcm90b2NvbFVybE1hdGNoICkgKSB8fFxyXG5cdFx0XHR0aGlzLnVybE1hdGNoRG9lc05vdEhhdmVQcm90b2NvbE9yRG90KCB1cmxNYXRjaCwgcHJvdG9jb2xVcmxNYXRjaCApIHx8ICAgICAgIC8vIEF0IGxlYXN0IG9uZSBwZXJpb2QgKCcuJykgbXVzdCBleGlzdCBpbiB0aGUgVVJMIG1hdGNoIGZvciB1cyB0byBjb25zaWRlciBpdCBhbiBhY3R1YWwgVVJMLCAqdW5sZXNzKiBpdCB3YXMgYSBmdWxsIHByb3RvY29sIG1hdGNoIChsaWtlICdodHRwOi8vbG9jYWxob3N0JylcclxuXHRcdFx0dGhpcy51cmxNYXRjaERvZXNOb3RIYXZlQXRMZWFzdE9uZVdvcmRDaGFyKCB1cmxNYXRjaCwgcHJvdG9jb2xVcmxNYXRjaCApIHx8ICAvLyBBdCBsZWFzdCBvbmUgbGV0dGVyIGNoYXJhY3RlciBtdXN0IGV4aXN0IGluIHRoZSBkb21haW4gbmFtZSBhZnRlciBhIHByb3RvY29sIG1hdGNoLiBFeDogc2tpcCBvdmVyIHNvbWV0aGluZyBsaWtlIFwiZ2l0OjEuMFwiXHJcblx0XHRcdHRoaXMuaXNJbnZhbGlkUHJvdG9jb2xSZWxhdGl2ZU1hdGNoKCBwcm90b2NvbFJlbGF0aXZlTWF0Y2ggKSAgICAgICAgICAgICAgICAgLy8gQSBwcm90b2NvbC1yZWxhdGl2ZSBtYXRjaCB3aGljaCBoYXMgYSB3b3JkIGNoYXJhY3RlciBpbiBmcm9udCBvZiBpdCAoc28gd2UgY2FuIHNraXAgc29tZXRoaW5nIGxpa2UgXCJhYmMvL2dvb2dsZS5jb21cIilcclxuXHRcdCkge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fSxcclxuXHJcblxyXG5cdC8qKlxyXG5cdCAqIERldGVybWluZXMgaWYgdGhlIFVSSSBzY2hlbWUgaXMgYSB2YWxpZCBzY2hlbWUgdG8gYmUgYXV0b2xpbmtlZC4gUmV0dXJuc1xyXG5cdCAqIGBmYWxzZWAgaWYgdGhlIHNjaGVtZSBpcyAnamF2YXNjcmlwdDonIG9yICd2YnNjcmlwdDonXHJcblx0ICpcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB1cmlTY2hlbWVNYXRjaCBUaGUgbWF0Y2ggVVJMIHN0cmluZyBmb3IgYSBmdWxsIFVSSSBzY2hlbWVcclxuXHQgKiAgIG1hdGNoLiBFeDogJ2h0dHA6Ly95YWhvby5jb20nIG9yICdtYWlsdG86YUBhLmNvbScuXHJcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBzY2hlbWUgaXMgYSB2YWxpZCBvbmUsIGBmYWxzZWAgb3RoZXJ3aXNlLlxyXG5cdCAqL1xyXG5cdGlzVmFsaWRVcmlTY2hlbWUgOiBmdW5jdGlvbiggdXJpU2NoZW1lTWF0Y2ggKSB7XHJcblx0XHR2YXIgdXJpU2NoZW1lID0gdXJpU2NoZW1lTWF0Y2gubWF0Y2goIHRoaXMudXJpU2NoZW1lUmVnZXggKVsgMCBdLnRvTG93ZXJDYXNlKCk7XHJcblxyXG5cdFx0cmV0dXJuICggdXJpU2NoZW1lICE9PSAnamF2YXNjcmlwdDonICYmIHVyaVNjaGVtZSAhPT0gJ3Zic2NyaXB0OicgKTtcclxuXHR9LFxyXG5cclxuXHJcblx0LyoqXHJcblx0ICogRGV0ZXJtaW5lcyBpZiBhIFVSTCBtYXRjaCBkb2VzIG5vdCBoYXZlIGVpdGhlcjpcclxuXHQgKlxyXG5cdCAqIGEpIGEgZnVsbCBwcm90b2NvbCAoaS5lLiAnaHR0cDovLycpLCBvclxyXG5cdCAqIGIpIGF0IGxlYXN0IG9uZSBkb3QgKCcuJykgaW4gdGhlIGRvbWFpbiBuYW1lIChmb3IgYSBub24tZnVsbC1wcm90b2NvbFxyXG5cdCAqICAgIG1hdGNoKS5cclxuXHQgKlxyXG5cdCAqIEVpdGhlciBzaXR1YXRpb24gaXMgY29uc2lkZXJlZCBhbiBpbnZhbGlkIFVSTCAoZXg6ICdnaXQ6ZCcgZG9lcyBub3QgaGF2ZVxyXG5cdCAqIGVpdGhlciB0aGUgJzovLycgcGFydCwgb3IgYXQgbGVhc3Qgb25lIGRvdCBpbiB0aGUgZG9tYWluIG5hbWUuIElmIHRoZVxyXG5cdCAqIG1hdGNoIHdhcyAnZ2l0OmFiYy5jb20nLCB3ZSB3b3VsZCBjb25zaWRlciB0aGlzIHZhbGlkLilcclxuXHQgKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHVybE1hdGNoIFRoZSBtYXRjaGVkIFVSTCwgaWYgdGhlcmUgd2FzIG9uZS4gV2lsbCBiZSBhblxyXG5cdCAqICAgZW1wdHkgc3RyaW5nIGlmIHRoZSBtYXRjaCBpcyBub3QgYSBVUkwgbWF0Y2guXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHByb3RvY29sVXJsTWF0Y2ggVGhlIG1hdGNoIFVSTCBzdHJpbmcgZm9yIGEgcHJvdG9jb2xcclxuXHQgKiAgIG1hdGNoLiBFeDogJ2h0dHA6Ly95YWhvby5jb20nLiBUaGlzIGlzIHVzZWQgdG8gbWF0Y2ggc29tZXRoaW5nIGxpa2VcclxuXHQgKiAgICdodHRwOi8vbG9jYWxob3N0Jywgd2hlcmUgd2Ugd29uJ3QgZG91YmxlIGNoZWNrIHRoYXQgdGhlIGRvbWFpbiBuYW1lXHJcblx0ICogICBoYXMgYXQgbGVhc3Qgb25lICcuJyBpbiBpdC5cclxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIFVSTCBtYXRjaCBkb2VzIG5vdCBoYXZlIGEgZnVsbCBwcm90b2NvbCxcclxuXHQgKiAgIG9yIGF0IGxlYXN0IG9uZSBkb3QgKCcuJykgaW4gYSBub24tZnVsbC1wcm90b2NvbCBtYXRjaC5cclxuXHQgKi9cclxuXHR1cmxNYXRjaERvZXNOb3RIYXZlUHJvdG9jb2xPckRvdCA6IGZ1bmN0aW9uKCB1cmxNYXRjaCwgcHJvdG9jb2xVcmxNYXRjaCApIHtcclxuXHRcdHJldHVybiAoICEhdXJsTWF0Y2ggJiYgKCAhcHJvdG9jb2xVcmxNYXRjaCB8fCAhdGhpcy5oYXNGdWxsUHJvdG9jb2xSZWdleC50ZXN0KCBwcm90b2NvbFVybE1hdGNoICkgKSAmJiB1cmxNYXRjaC5pbmRleE9mKCAnLicgKSA9PT0gLTEgKTtcclxuXHR9LFxyXG5cclxuXHJcblx0LyoqXHJcblx0ICogRGV0ZXJtaW5lcyBpZiBhIFVSTCBtYXRjaCBkb2VzIG5vdCBoYXZlIGF0IGxlYXN0IG9uZSB3b3JkIGNoYXJhY3RlciBhZnRlclxyXG5cdCAqIHRoZSBwcm90b2NvbCAoaS5lLiBpbiB0aGUgZG9tYWluIG5hbWUpLlxyXG5cdCAqXHJcblx0ICogQXQgbGVhc3Qgb25lIGxldHRlciBjaGFyYWN0ZXIgbXVzdCBleGlzdCBpbiB0aGUgZG9tYWluIG5hbWUgYWZ0ZXIgYVxyXG5cdCAqIHByb3RvY29sIG1hdGNoLiBFeDogc2tpcCBvdmVyIHNvbWV0aGluZyBsaWtlIFwiZ2l0OjEuMFwiXHJcblx0ICpcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB1cmxNYXRjaCBUaGUgbWF0Y2hlZCBVUkwsIGlmIHRoZXJlIHdhcyBvbmUuIFdpbGwgYmUgYW5cclxuXHQgKiAgIGVtcHR5IHN0cmluZyBpZiB0aGUgbWF0Y2ggaXMgbm90IGEgVVJMIG1hdGNoLlxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBwcm90b2NvbFVybE1hdGNoIFRoZSBtYXRjaCBVUkwgc3RyaW5nIGZvciBhIHByb3RvY29sXHJcblx0ICogICBtYXRjaC4gRXg6ICdodHRwOi8veWFob28uY29tJy4gVGhpcyBpcyB1c2VkIHRvIGtub3cgd2hldGhlciBvciBub3Qgd2VcclxuXHQgKiAgIGhhdmUgYSBwcm90b2NvbCBpbiB0aGUgVVJMIHN0cmluZywgaW4gb3JkZXIgdG8gY2hlY2sgZm9yIGEgd29yZFxyXG5cdCAqICAgY2hhcmFjdGVyIGFmdGVyIHRoZSBwcm90b2NvbCBzZXBhcmF0b3IgKCc6JykuXHJcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBVUkwgbWF0Y2ggZG9lcyBub3QgaGF2ZSBhdCBsZWFzdCBvbmUgd29yZFxyXG5cdCAqICAgY2hhcmFjdGVyIGluIGl0IGFmdGVyIHRoZSBwcm90b2NvbCwgYGZhbHNlYCBvdGhlcndpc2UuXHJcblx0ICovXHJcblx0dXJsTWF0Y2hEb2VzTm90SGF2ZUF0TGVhc3RPbmVXb3JkQ2hhciA6IGZ1bmN0aW9uKCB1cmxNYXRjaCwgcHJvdG9jb2xVcmxNYXRjaCApIHtcclxuXHRcdGlmKCB1cmxNYXRjaCAmJiBwcm90b2NvbFVybE1hdGNoICkge1xyXG5cdFx0XHRyZXR1cm4gIXRoaXMuaGFzV29yZENoYXJBZnRlclByb3RvY29sUmVnZXgudGVzdCggdXJsTWF0Y2ggKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHJcblx0LyoqXHJcblx0ICogRGV0ZXJtaW5lcyBpZiBhIHByb3RvY29sLXJlbGF0aXZlIG1hdGNoIGlzIGFuIGludmFsaWQgb25lLiBUaGlzIG1ldGhvZFxyXG5cdCAqIHJldHVybnMgYHRydWVgIGlmIHRoZXJlIGlzIGEgYHByb3RvY29sUmVsYXRpdmVNYXRjaGAsIGFuZCB0aGF0IG1hdGNoXHJcblx0ICogY29udGFpbnMgYSB3b3JkIGNoYXJhY3RlciBiZWZvcmUgdGhlICcvLycgKGkuZS4gaXQgbXVzdCBjb250YWluXHJcblx0ICogd2hpdGVzcGFjZSBvciBub3RoaW5nIGJlZm9yZSB0aGUgJy8vJyBpbiBvcmRlciB0byBiZSBjb25zaWRlcmVkIHZhbGlkKS5cclxuXHQgKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHByb3RvY29sUmVsYXRpdmVNYXRjaCBUaGUgcHJvdG9jb2wtcmVsYXRpdmUgc3RyaW5nIGZvciBhXHJcblx0ICogICBVUkwgbWF0Y2ggKGkuZS4gJy8vJyksIHBvc3NpYmx5IHdpdGggYSBwcmVjZWRpbmcgY2hhcmFjdGVyIChleCwgYVxyXG5cdCAqICAgc3BhY2UsIHN1Y2ggYXM6ICcgLy8nLCBvciBhIGxldHRlciwgc3VjaCBhczogJ2EvLycpLiBUaGUgbWF0Y2ggaXNcclxuXHQgKiAgIGludmFsaWQgaWYgdGhlcmUgaXMgYSB3b3JkIGNoYXJhY3RlciBwcmVjZWRpbmcgdGhlICcvLycuXHJcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIGl0IGlzIGFuIGludmFsaWQgcHJvdG9jb2wtcmVsYXRpdmUgbWF0Y2gsXHJcblx0ICogICBgZmFsc2VgIG90aGVyd2lzZS5cclxuXHQgKi9cclxuXHRpc0ludmFsaWRQcm90b2NvbFJlbGF0aXZlTWF0Y2ggOiBmdW5jdGlvbiggcHJvdG9jb2xSZWxhdGl2ZU1hdGNoICkge1xyXG5cdFx0cmV0dXJuICggISFwcm90b2NvbFJlbGF0aXZlTWF0Y2ggJiYgdGhpcy5pbnZhbGlkUHJvdG9jb2xSZWxNYXRjaFJlZ2V4LnRlc3QoIHByb3RvY29sUmVsYXRpdmVNYXRjaCApICk7XHJcblx0fVxyXG5cclxufSApO1xyXG4vKmdsb2JhbCBBdXRvbGlua2VyICovXHJcbi8qKlxyXG4gKiBAYWJzdHJhY3RcclxuICogQGNsYXNzIEF1dG9saW5rZXIubWF0Y2guTWF0Y2hcclxuICogXHJcbiAqIFJlcHJlc2VudHMgYSBtYXRjaCBmb3VuZCBpbiBhbiBpbnB1dCBzdHJpbmcgd2hpY2ggc2hvdWxkIGJlIEF1dG9saW5rZWQuIEEgTWF0Y2ggb2JqZWN0IGlzIHdoYXQgaXMgcHJvdmlkZWQgaW4gYSBcclxuICoge0BsaW5rIEF1dG9saW5rZXIjcmVwbGFjZUZuIHJlcGxhY2VGbn0sIGFuZCBtYXkgYmUgdXNlZCB0byBxdWVyeSBmb3IgZGV0YWlscyBhYm91dCB0aGUgbWF0Y2guXHJcbiAqIFxyXG4gKiBGb3IgZXhhbXBsZTpcclxuICogXHJcbiAqICAgICB2YXIgaW5wdXQgPSBcIi4uLlwiOyAgLy8gc3RyaW5nIHdpdGggVVJMcywgRW1haWwgQWRkcmVzc2VzLCBhbmQgVHdpdHRlciBIYW5kbGVzXHJcbiAqICAgICBcclxuICogICAgIHZhciBsaW5rZWRUZXh0ID0gQXV0b2xpbmtlci5saW5rKCBpbnB1dCwge1xyXG4gKiAgICAgICAgIHJlcGxhY2VGbiA6IGZ1bmN0aW9uKCBhdXRvbGlua2VyLCBtYXRjaCApIHtcclxuICogICAgICAgICAgICAgY29uc29sZS5sb2coIFwiaHJlZiA9IFwiLCBtYXRjaC5nZXRBbmNob3JIcmVmKCkgKTtcclxuICogICAgICAgICAgICAgY29uc29sZS5sb2coIFwidGV4dCA9IFwiLCBtYXRjaC5nZXRBbmNob3JUZXh0KCkgKTtcclxuICogICAgICAgICBcclxuICogICAgICAgICAgICAgc3dpdGNoKCBtYXRjaC5nZXRUeXBlKCkgKSB7XHJcbiAqICAgICAgICAgICAgICAgICBjYXNlICd1cmwnIDogXHJcbiAqICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coIFwidXJsOiBcIiwgbWF0Y2guZ2V0VXJsKCkgKTtcclxuICogICAgICAgICAgICAgICAgICAgICBcclxuICogICAgICAgICAgICAgICAgIGNhc2UgJ2VtYWlsJyA6XHJcbiAqICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coIFwiZW1haWw6IFwiLCBtYXRjaC5nZXRFbWFpbCgpICk7XHJcbiAqICAgICAgICAgICAgICAgICAgICAgXHJcbiAqICAgICAgICAgICAgICAgICBjYXNlICd0d2l0dGVyJyA6XHJcbiAqICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coIFwidHdpdHRlcjogXCIsIG1hdGNoLmdldFR3aXR0ZXJIYW5kbGUoKSApO1xyXG4gKiAgICAgICAgICAgICB9XHJcbiAqICAgICAgICAgfVxyXG4gKiAgICAgfSApO1xyXG4gKiAgICAgXHJcbiAqIFNlZSB0aGUge0BsaW5rIEF1dG9saW5rZXJ9IGNsYXNzIGZvciBtb3JlIGRldGFpbHMgb24gdXNpbmcgdGhlIHtAbGluayBBdXRvbGlua2VyI3JlcGxhY2VGbiByZXBsYWNlRm59LlxyXG4gKi9cclxuQXV0b2xpbmtlci5tYXRjaC5NYXRjaCA9IEF1dG9saW5rZXIuVXRpbC5leHRlbmQoIE9iamVjdCwge1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIEBjZmcge1N0cmluZ30gbWF0Y2hlZFRleHQgKHJlcXVpcmVkKVxyXG5cdCAqIFxyXG5cdCAqIFRoZSBvcmlnaW5hbCB0ZXh0IHRoYXQgd2FzIG1hdGNoZWQuXHJcblx0ICovXHJcblx0XHJcblx0XHJcblx0LyoqXHJcblx0ICogQGNvbnN0cnVjdG9yXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IGNmZyBUaGUgY29uZmlndXJhdGlvbiBwcm9wZXJ0aWVzIGZvciB0aGUgTWF0Y2ggaW5zdGFuY2UsIHNwZWNpZmllZCBpbiBhbiBPYmplY3QgKG1hcCkuXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IgOiBmdW5jdGlvbiggY2ZnICkge1xyXG5cdFx0QXV0b2xpbmtlci5VdGlsLmFzc2lnbiggdGhpcywgY2ZnICk7XHJcblx0fSxcclxuXHJcblx0XHJcblx0LyoqXHJcblx0ICogUmV0dXJucyBhIHN0cmluZyBuYW1lIGZvciB0aGUgdHlwZSBvZiBtYXRjaCB0aGF0IHRoaXMgY2xhc3MgcmVwcmVzZW50cy5cclxuXHQgKiBcclxuXHQgKiBAYWJzdHJhY3RcclxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9XHJcblx0ICovXHJcblx0Z2V0VHlwZSA6IEF1dG9saW5rZXIuVXRpbC5hYnN0cmFjdE1ldGhvZCxcclxuXHRcclxuXHRcclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCB0ZXh0IHRoYXQgd2FzIG1hdGNoZWQuXHJcblx0ICogXHJcblx0ICogQHJldHVybiB7U3RyaW5nfVxyXG5cdCAqL1xyXG5cdGdldE1hdGNoZWRUZXh0IDogZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5tYXRjaGVkVGV4dDtcclxuXHR9LFxyXG5cdFxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSBhbmNob3IgaHJlZiB0aGF0IHNob3VsZCBiZSBnZW5lcmF0ZWQgZm9yIHRoZSBtYXRjaC5cclxuXHQgKiBcclxuXHQgKiBAYWJzdHJhY3RcclxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9XHJcblx0ICovXHJcblx0Z2V0QW5jaG9ySHJlZiA6IEF1dG9saW5rZXIuVXRpbC5hYnN0cmFjdE1ldGhvZCxcclxuXHRcclxuXHRcclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSBhbmNob3IgdGV4dCB0aGF0IHNob3VsZCBiZSBnZW5lcmF0ZWQgZm9yIHRoZSBtYXRjaC5cclxuXHQgKiBcclxuXHQgKiBAYWJzdHJhY3RcclxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9XHJcblx0ICovXHJcblx0Z2V0QW5jaG9yVGV4dCA6IEF1dG9saW5rZXIuVXRpbC5hYnN0cmFjdE1ldGhvZFxyXG5cclxufSApO1xyXG4vKmdsb2JhbCBBdXRvbGlua2VyICovXHJcbi8qKlxyXG4gKiBAY2xhc3MgQXV0b2xpbmtlci5tYXRjaC5FbWFpbFxyXG4gKiBAZXh0ZW5kcyBBdXRvbGlua2VyLm1hdGNoLk1hdGNoXHJcbiAqIFxyXG4gKiBSZXByZXNlbnRzIGEgRW1haWwgbWF0Y2ggZm91bmQgaW4gYW4gaW5wdXQgc3RyaW5nIHdoaWNoIHNob3VsZCBiZSBBdXRvbGlua2VkLlxyXG4gKiBcclxuICogU2VlIHRoaXMgY2xhc3MncyBzdXBlcmNsYXNzICh7QGxpbmsgQXV0b2xpbmtlci5tYXRjaC5NYXRjaH0pIGZvciBtb3JlIGRldGFpbHMuXHJcbiAqL1xyXG5BdXRvbGlua2VyLm1hdGNoLkVtYWlsID0gQXV0b2xpbmtlci5VdGlsLmV4dGVuZCggQXV0b2xpbmtlci5tYXRjaC5NYXRjaCwge1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIEBjZmcge1N0cmluZ30gZW1haWwgKHJlcXVpcmVkKVxyXG5cdCAqIFxyXG5cdCAqIFRoZSBlbWFpbCBhZGRyZXNzIHRoYXQgd2FzIG1hdGNoZWQuXHJcblx0ICovXHJcblx0XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgbmFtZSBmb3IgdGhlIHR5cGUgb2YgbWF0Y2ggdGhhdCB0aGlzIGNsYXNzIHJlcHJlc2VudHMuXHJcblx0ICogXHJcblx0ICogQHJldHVybiB7U3RyaW5nfVxyXG5cdCAqL1xyXG5cdGdldFR5cGUgOiBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiAnZW1haWwnO1xyXG5cdH0sXHJcblx0XHJcblx0XHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgZW1haWwgYWRkcmVzcyB0aGF0IHdhcyBtYXRjaGVkLlxyXG5cdCAqIFxyXG5cdCAqIEByZXR1cm4ge1N0cmluZ31cclxuXHQgKi9cclxuXHRnZXRFbWFpbCA6IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZW1haWw7XHJcblx0fSxcclxuXHRcclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgYW5jaG9yIGhyZWYgdGhhdCBzaG91bGQgYmUgZ2VuZXJhdGVkIGZvciB0aGUgbWF0Y2guXHJcblx0ICogXHJcblx0ICogQHJldHVybiB7U3RyaW5nfVxyXG5cdCAqL1xyXG5cdGdldEFuY2hvckhyZWYgOiBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiAnbWFpbHRvOicgKyB0aGlzLmVtYWlsO1xyXG5cdH0sXHJcblx0XHJcblx0XHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgYW5jaG9yIHRleHQgdGhhdCBzaG91bGQgYmUgZ2VuZXJhdGVkIGZvciB0aGUgbWF0Y2guXHJcblx0ICogXHJcblx0ICogQHJldHVybiB7U3RyaW5nfVxyXG5cdCAqL1xyXG5cdGdldEFuY2hvclRleHQgOiBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB0aGlzLmVtYWlsO1xyXG5cdH1cclxuXHRcclxufSApO1xyXG4vKmdsb2JhbCBBdXRvbGlua2VyICovXHJcbi8qKlxyXG4gKiBAY2xhc3MgQXV0b2xpbmtlci5tYXRjaC5IYXNodGFnXHJcbiAqIEBleHRlbmRzIEF1dG9saW5rZXIubWF0Y2guTWF0Y2hcclxuICpcclxuICogUmVwcmVzZW50cyBhIEhhc2h0YWcgbWF0Y2ggZm91bmQgaW4gYW4gaW5wdXQgc3RyaW5nIHdoaWNoIHNob3VsZCBiZVxyXG4gKiBBdXRvbGlua2VkLlxyXG4gKlxyXG4gKiBTZWUgdGhpcyBjbGFzcydzIHN1cGVyY2xhc3MgKHtAbGluayBBdXRvbGlua2VyLm1hdGNoLk1hdGNofSkgZm9yIG1vcmVcclxuICogZGV0YWlscy5cclxuICovXHJcbkF1dG9saW5rZXIubWF0Y2guSGFzaHRhZyA9IEF1dG9saW5rZXIuVXRpbC5leHRlbmQoIEF1dG9saW5rZXIubWF0Y2guTWF0Y2gsIHtcclxuXHJcblx0LyoqXHJcblx0ICogQGNmZyB7U3RyaW5nfSBzZXJ2aWNlTmFtZSAocmVxdWlyZWQpXHJcblx0ICpcclxuXHQgKiBUaGUgc2VydmljZSB0byBwb2ludCBoYXNodGFnIG1hdGNoZXMgdG8uIFNlZSB7QGxpbmsgQXV0b2xpbmtlciNoYXNodGFnfVxyXG5cdCAqIGZvciBhdmFpbGFibGUgdmFsdWVzLlxyXG5cdCAqL1xyXG5cclxuXHQvKipcclxuXHQgKiBAY2ZnIHtTdHJpbmd9IGhhc2h0YWcgKHJlcXVpcmVkKVxyXG5cdCAqXHJcblx0ICogVGhlIEhhc2h0YWcgdGhhdCB3YXMgbWF0Y2hlZCwgd2l0aG91dCB0aGUgJyMnLlxyXG5cdCAqL1xyXG5cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgdHlwZSBvZiBtYXRjaCB0aGF0IHRoaXMgY2xhc3MgcmVwcmVzZW50cy5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm4ge1N0cmluZ31cclxuXHQgKi9cclxuXHRnZXRUeXBlIDogZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gJ2hhc2h0YWcnO1xyXG5cdH0sXHJcblxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSBtYXRjaGVkIGhhc2h0YWcuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9XHJcblx0ICovXHJcblx0Z2V0SGFzaHRhZyA6IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaGFzaHRhZztcclxuXHR9LFxyXG5cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgYW5jaG9yIGhyZWYgdGhhdCBzaG91bGQgYmUgZ2VuZXJhdGVkIGZvciB0aGUgbWF0Y2guXHJcblx0ICpcclxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9XHJcblx0ICovXHJcblx0Z2V0QW5jaG9ySHJlZiA6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIHNlcnZpY2VOYW1lID0gdGhpcy5zZXJ2aWNlTmFtZSxcclxuXHRcdCAgICBoYXNodGFnID0gdGhpcy5oYXNodGFnO1xyXG5cclxuXHRcdHN3aXRjaCggc2VydmljZU5hbWUgKSB7XHJcblx0XHRcdGNhc2UgJ3R3aXR0ZXInIDpcclxuXHRcdFx0XHRyZXR1cm4gJ2h0dHBzOi8vdHdpdHRlci5jb20vaGFzaHRhZy8nICsgaGFzaHRhZztcclxuXHRcdFx0Y2FzZSAnZmFjZWJvb2snIDpcclxuXHRcdFx0XHRyZXR1cm4gJ2h0dHBzOi8vd3d3LmZhY2Vib29rLmNvbS9oYXNodGFnLycgKyBoYXNodGFnO1xyXG5cclxuXHRcdFx0ZGVmYXVsdCA6ICAvLyBTaG91bGRuJ3QgaGFwcGVuIGJlY2F1c2UgQXV0b2xpbmtlcidzIGNvbnN0cnVjdG9yIHNob3VsZCBibG9jayBhbnkgaW52YWxpZCB2YWx1ZXMsIGJ1dCBqdXN0IGluIGNhc2UuXHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVW5rbm93biBzZXJ2aWNlIG5hbWUgdG8gcG9pbnQgaGFzaHRhZyB0bzogJywgc2VydmljZU5hbWUgKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgYW5jaG9yIHRleHQgdGhhdCBzaG91bGQgYmUgZ2VuZXJhdGVkIGZvciB0aGUgbWF0Y2guXHJcblx0ICpcclxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9XHJcblx0ICovXHJcblx0Z2V0QW5jaG9yVGV4dCA6IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuICcjJyArIHRoaXMuaGFzaHRhZztcclxuXHR9XHJcblxyXG59ICk7XHJcbi8qZ2xvYmFsIEF1dG9saW5rZXIgKi9cclxuLyoqXHJcbiAqIEBjbGFzcyBBdXRvbGlua2VyLm1hdGNoLlBob25lXHJcbiAqIEBleHRlbmRzIEF1dG9saW5rZXIubWF0Y2guTWF0Y2hcclxuICpcclxuICogUmVwcmVzZW50cyBhIFBob25lIG51bWJlciBtYXRjaCBmb3VuZCBpbiBhbiBpbnB1dCBzdHJpbmcgd2hpY2ggc2hvdWxkIGJlXHJcbiAqIEF1dG9saW5rZWQuXHJcbiAqXHJcbiAqIFNlZSB0aGlzIGNsYXNzJ3Mgc3VwZXJjbGFzcyAoe0BsaW5rIEF1dG9saW5rZXIubWF0Y2guTWF0Y2h9KSBmb3IgbW9yZVxyXG4gKiBkZXRhaWxzLlxyXG4gKi9cclxuQXV0b2xpbmtlci5tYXRjaC5QaG9uZSA9IEF1dG9saW5rZXIuVXRpbC5leHRlbmQoIEF1dG9saW5rZXIubWF0Y2guTWF0Y2gsIHtcclxuXHJcblx0LyoqXHJcblx0ICogQGNmZyB7U3RyaW5nfSBudW1iZXIgKHJlcXVpcmVkKVxyXG5cdCAqXHJcblx0ICogVGhlIHBob25lIG51bWJlciB0aGF0IHdhcyBtYXRjaGVkLlxyXG5cdCAqL1xyXG5cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyBhIHN0cmluZyBuYW1lIGZvciB0aGUgdHlwZSBvZiBtYXRjaCB0aGF0IHRoaXMgY2xhc3MgcmVwcmVzZW50cy5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm4ge1N0cmluZ31cclxuXHQgKi9cclxuXHRnZXRUeXBlIDogZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gJ3Bob25lJztcclxuXHR9LFxyXG5cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgcGhvbmUgbnVtYmVyIHRoYXQgd2FzIG1hdGNoZWQuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9XHJcblx0ICovXHJcblx0Z2V0TnVtYmVyOiBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB0aGlzLm51bWJlcjtcclxuXHR9LFxyXG5cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgYW5jaG9yIGhyZWYgdGhhdCBzaG91bGQgYmUgZ2VuZXJhdGVkIGZvciB0aGUgbWF0Y2guXHJcblx0ICpcclxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9XHJcblx0ICovXHJcblx0Z2V0QW5jaG9ySHJlZiA6IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuICd0ZWw6JyArIHRoaXMubnVtYmVyO1xyXG5cdH0sXHJcblxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSBhbmNob3IgdGV4dCB0aGF0IHNob3VsZCBiZSBnZW5lcmF0ZWQgZm9yIHRoZSBtYXRjaC5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm4ge1N0cmluZ31cclxuXHQgKi9cclxuXHRnZXRBbmNob3JUZXh0IDogZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5tYXRjaGVkVGV4dDtcclxuXHR9XHJcblxyXG59ICk7XHJcblxyXG4vKmdsb2JhbCBBdXRvbGlua2VyICovXHJcbi8qKlxyXG4gKiBAY2xhc3MgQXV0b2xpbmtlci5tYXRjaC5Ud2l0dGVyXHJcbiAqIEBleHRlbmRzIEF1dG9saW5rZXIubWF0Y2guTWF0Y2hcclxuICogXHJcbiAqIFJlcHJlc2VudHMgYSBUd2l0dGVyIG1hdGNoIGZvdW5kIGluIGFuIGlucHV0IHN0cmluZyB3aGljaCBzaG91bGQgYmUgQXV0b2xpbmtlZC5cclxuICogXHJcbiAqIFNlZSB0aGlzIGNsYXNzJ3Mgc3VwZXJjbGFzcyAoe0BsaW5rIEF1dG9saW5rZXIubWF0Y2guTWF0Y2h9KSBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gKi9cclxuQXV0b2xpbmtlci5tYXRjaC5Ud2l0dGVyID0gQXV0b2xpbmtlci5VdGlsLmV4dGVuZCggQXV0b2xpbmtlci5tYXRjaC5NYXRjaCwge1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIEBjZmcge1N0cmluZ30gdHdpdHRlckhhbmRsZSAocmVxdWlyZWQpXHJcblx0ICogXHJcblx0ICogVGhlIFR3aXR0ZXIgaGFuZGxlIHRoYXQgd2FzIG1hdGNoZWQuXHJcblx0ICovXHJcblx0XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIHR5cGUgb2YgbWF0Y2ggdGhhdCB0aGlzIGNsYXNzIHJlcHJlc2VudHMuXHJcblx0ICogXHJcblx0ICogQHJldHVybiB7U3RyaW5nfVxyXG5cdCAqL1xyXG5cdGdldFR5cGUgOiBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiAndHdpdHRlcic7XHJcblx0fSxcclxuXHRcclxuXHRcclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIG5hbWUgZm9yIHRoZSB0eXBlIG9mIG1hdGNoIHRoYXQgdGhpcyBjbGFzcyByZXByZXNlbnRzLlxyXG5cdCAqIFxyXG5cdCAqIEByZXR1cm4ge1N0cmluZ31cclxuXHQgKi9cclxuXHRnZXRUd2l0dGVySGFuZGxlIDogZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gdGhpcy50d2l0dGVySGFuZGxlO1xyXG5cdH0sXHJcblx0XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIGFuY2hvciBocmVmIHRoYXQgc2hvdWxkIGJlIGdlbmVyYXRlZCBmb3IgdGhlIG1hdGNoLlxyXG5cdCAqIFxyXG5cdCAqIEByZXR1cm4ge1N0cmluZ31cclxuXHQgKi9cclxuXHRnZXRBbmNob3JIcmVmIDogZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gJ2h0dHBzOi8vdHdpdHRlci5jb20vJyArIHRoaXMudHdpdHRlckhhbmRsZTtcclxuXHR9LFxyXG5cdFxyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIGFuY2hvciB0ZXh0IHRoYXQgc2hvdWxkIGJlIGdlbmVyYXRlZCBmb3IgdGhlIG1hdGNoLlxyXG5cdCAqIFxyXG5cdCAqIEByZXR1cm4ge1N0cmluZ31cclxuXHQgKi9cclxuXHRnZXRBbmNob3JUZXh0IDogZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gJ0AnICsgdGhpcy50d2l0dGVySGFuZGxlO1xyXG5cdH1cclxuXHRcclxufSApO1xyXG4vKmdsb2JhbCBBdXRvbGlua2VyICovXHJcbi8qKlxyXG4gKiBAY2xhc3MgQXV0b2xpbmtlci5tYXRjaC5VcmxcclxuICogQGV4dGVuZHMgQXV0b2xpbmtlci5tYXRjaC5NYXRjaFxyXG4gKiBcclxuICogUmVwcmVzZW50cyBhIFVybCBtYXRjaCBmb3VuZCBpbiBhbiBpbnB1dCBzdHJpbmcgd2hpY2ggc2hvdWxkIGJlIEF1dG9saW5rZWQuXHJcbiAqIFxyXG4gKiBTZWUgdGhpcyBjbGFzcydzIHN1cGVyY2xhc3MgKHtAbGluayBBdXRvbGlua2VyLm1hdGNoLk1hdGNofSkgZm9yIG1vcmUgZGV0YWlscy5cclxuICovXHJcbkF1dG9saW5rZXIubWF0Y2guVXJsID0gQXV0b2xpbmtlci5VdGlsLmV4dGVuZCggQXV0b2xpbmtlci5tYXRjaC5NYXRjaCwge1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIEBjZmcge1N0cmluZ30gdXJsIChyZXF1aXJlZClcclxuXHQgKiBcclxuXHQgKiBUaGUgdXJsIHRoYXQgd2FzIG1hdGNoZWQuXHJcblx0ICovXHJcblx0XHJcblx0LyoqXHJcblx0ICogQGNmZyB7Qm9vbGVhbn0gcHJvdG9jb2xVcmxNYXRjaCAocmVxdWlyZWQpXHJcblx0ICogXHJcblx0ICogYHRydWVgIGlmIHRoZSBVUkwgaXMgYSBtYXRjaCB3aGljaCBhbHJlYWR5IGhhcyBhIHByb3RvY29sIChpLmUuICdodHRwOi8vJyksIGBmYWxzZWAgaWYgdGhlIG1hdGNoIHdhcyBmcm9tIGEgJ3d3dycgb3JcclxuXHQgKiBrbm93biBUTEQgbWF0Y2guXHJcblx0ICovXHJcblx0XHJcblx0LyoqXHJcblx0ICogQGNmZyB7Qm9vbGVhbn0gcHJvdG9jb2xSZWxhdGl2ZU1hdGNoIChyZXF1aXJlZClcclxuXHQgKiBcclxuXHQgKiBgdHJ1ZWAgaWYgdGhlIFVSTCBpcyBhIHByb3RvY29sLXJlbGF0aXZlIG1hdGNoLiBBIHByb3RvY29sLXJlbGF0aXZlIG1hdGNoIGlzIGEgVVJMIHRoYXQgc3RhcnRzIHdpdGggJy8vJyxcclxuXHQgKiBhbmQgd2lsbCBiZSBlaXRoZXIgaHR0cDovLyBvciBodHRwczovLyBiYXNlZCBvbiB0aGUgcHJvdG9jb2wgdGhhdCB0aGUgc2l0ZSBpcyBsb2FkZWQgdW5kZXIuXHJcblx0ICovXHJcblx0XHJcblx0LyoqXHJcblx0ICogQGNmZyB7Qm9vbGVhbn0gc3RyaXBQcmVmaXggKHJlcXVpcmVkKVxyXG5cdCAqIEBpbmhlcml0ZG9jIEF1dG9saW5rZXIjc3RyaXBQcmVmaXhcclxuXHQgKi9cclxuXHRcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcHJvcGVydHkge1JlZ0V4cH0gdXJsUHJlZml4UmVnZXhcclxuXHQgKiBcclxuXHQgKiBBIHJlZ3VsYXIgZXhwcmVzc2lvbiB1c2VkIHRvIHJlbW92ZSB0aGUgJ2h0dHA6Ly8nIG9yICdodHRwczovLycgYW5kL29yIHRoZSAnd3d3LicgZnJvbSBVUkxzLlxyXG5cdCAqL1xyXG5cdHVybFByZWZpeFJlZ2V4OiAvXihodHRwcz86XFwvXFwvKT8od3d3XFwuKT8vaSxcclxuXHRcclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwcm9wZXJ0eSB7UmVnRXhwfSBwcm90b2NvbFJlbGF0aXZlUmVnZXhcclxuXHQgKiBcclxuXHQgKiBUaGUgcmVndWxhciBleHByZXNzaW9uIHVzZWQgdG8gcmVtb3ZlIHRoZSBwcm90b2NvbC1yZWxhdGl2ZSAnLy8nIGZyb20gdGhlIHtAbGluayAjdXJsfSBzdHJpbmcsIGZvciBwdXJwb3Nlc1xyXG5cdCAqIG9mIHtAbGluayAjZ2V0QW5jaG9yVGV4dH0uIEEgcHJvdG9jb2wtcmVsYXRpdmUgVVJMIGlzLCBmb3IgZXhhbXBsZSwgXCIvL3lhaG9vLmNvbVwiXHJcblx0ICovXHJcblx0cHJvdG9jb2xSZWxhdGl2ZVJlZ2V4IDogL15cXC9cXC8vLFxyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHByb3BlcnR5IHtCb29sZWFufSBwcm90b2NvbFByZXBlbmRlZFxyXG5cdCAqIFxyXG5cdCAqIFdpbGwgYmUgc2V0IHRvIGB0cnVlYCBpZiB0aGUgJ2h0dHA6Ly8nIHByb3RvY29sIGhhcyBiZWVuIHByZXBlbmRlZCB0byB0aGUge0BsaW5rICN1cmx9IChiZWNhdXNlIHRoZVxyXG5cdCAqIHtAbGluayAjdXJsfSBkaWQgbm90IGhhdmUgYSBwcm90b2NvbClcclxuXHQgKi9cclxuXHRwcm90b2NvbFByZXBlbmRlZCA6IGZhbHNlLFxyXG5cdFxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIG5hbWUgZm9yIHRoZSB0eXBlIG9mIG1hdGNoIHRoYXQgdGhpcyBjbGFzcyByZXByZXNlbnRzLlxyXG5cdCAqIFxyXG5cdCAqIEByZXR1cm4ge1N0cmluZ31cclxuXHQgKi9cclxuXHRnZXRUeXBlIDogZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gJ3VybCc7XHJcblx0fSxcclxuXHRcclxuXHRcclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSB1cmwgdGhhdCB3YXMgbWF0Y2hlZCwgYXNzdW1pbmcgdGhlIHByb3RvY29sIHRvIGJlICdodHRwOi8vJyBpZiB0aGUgb3JpZ2luYWxcclxuXHQgKiBtYXRjaCB3YXMgbWlzc2luZyBhIHByb3RvY29sLlxyXG5cdCAqIFxyXG5cdCAqIEByZXR1cm4ge1N0cmluZ31cclxuXHQgKi9cclxuXHRnZXRVcmwgOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciB1cmwgPSB0aGlzLnVybDtcclxuXHRcdFxyXG5cdFx0Ly8gaWYgdGhlIHVybCBzdHJpbmcgZG9lc24ndCBiZWdpbiB3aXRoIGEgcHJvdG9jb2wsIGFzc3VtZSAnaHR0cDovLydcclxuXHRcdGlmKCAhdGhpcy5wcm90b2NvbFJlbGF0aXZlTWF0Y2ggJiYgIXRoaXMucHJvdG9jb2xVcmxNYXRjaCAmJiAhdGhpcy5wcm90b2NvbFByZXBlbmRlZCApIHtcclxuXHRcdFx0dXJsID0gdGhpcy51cmwgPSAnaHR0cDovLycgKyB1cmw7XHJcblx0XHRcdFxyXG5cdFx0XHR0aGlzLnByb3RvY29sUHJlcGVuZGVkID0gdHJ1ZTtcclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0cmV0dXJuIHVybDtcclxuXHR9LFxyXG5cdFxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSBhbmNob3IgaHJlZiB0aGF0IHNob3VsZCBiZSBnZW5lcmF0ZWQgZm9yIHRoZSBtYXRjaC5cclxuXHQgKiBcclxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9XHJcblx0ICovXHJcblx0Z2V0QW5jaG9ySHJlZiA6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIHVybCA9IHRoaXMuZ2V0VXJsKCk7XHJcblx0XHRcclxuXHRcdHJldHVybiB1cmwucmVwbGFjZSggLyZhbXA7L2csICcmJyApOyAgLy8gYW55ICZhbXA7J3MgaW4gdGhlIFVSTCBzaG91bGQgYmUgY29udmVydGVkIGJhY2sgdG8gJyYnIGlmIHRoZXkgd2VyZSBkaXNwbGF5ZWQgYXMgJmFtcDsgaW4gdGhlIHNvdXJjZSBodG1sIFxyXG5cdH0sXHJcblx0XHJcblx0XHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgYW5jaG9yIHRleHQgdGhhdCBzaG91bGQgYmUgZ2VuZXJhdGVkIGZvciB0aGUgbWF0Y2guXHJcblx0ICogXHJcblx0ICogQHJldHVybiB7U3RyaW5nfVxyXG5cdCAqL1xyXG5cdGdldEFuY2hvclRleHQgOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBhbmNob3JUZXh0ID0gdGhpcy5nZXRVcmwoKTtcclxuXHRcdFxyXG5cdFx0aWYoIHRoaXMucHJvdG9jb2xSZWxhdGl2ZU1hdGNoICkge1xyXG5cdFx0XHQvLyBTdHJpcCBvZmYgYW55IHByb3RvY29sLXJlbGF0aXZlICcvLycgZnJvbSB0aGUgYW5jaG9yIHRleHRcclxuXHRcdFx0YW5jaG9yVGV4dCA9IHRoaXMuc3RyaXBQcm90b2NvbFJlbGF0aXZlUHJlZml4KCBhbmNob3JUZXh0ICk7XHJcblx0XHR9XHJcblx0XHRpZiggdGhpcy5zdHJpcFByZWZpeCApIHtcclxuXHRcdFx0YW5jaG9yVGV4dCA9IHRoaXMuc3RyaXBVcmxQcmVmaXgoIGFuY2hvclRleHQgKTtcclxuXHRcdH1cclxuXHRcdGFuY2hvclRleHQgPSB0aGlzLnJlbW92ZVRyYWlsaW5nU2xhc2goIGFuY2hvclRleHQgKTsgIC8vIHJlbW92ZSB0cmFpbGluZyBzbGFzaCwgaWYgdGhlcmUgaXMgb25lXHJcblx0XHRcclxuXHRcdHJldHVybiBhbmNob3JUZXh0O1xyXG5cdH0sXHJcblx0XHJcblx0XHJcblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblx0XHJcblx0Ly8gVXRpbGl0eSBGdW5jdGlvbmFsaXR5XHJcblx0XHJcblx0LyoqXHJcblx0ICogU3RyaXBzIHRoZSBVUkwgcHJlZml4IChzdWNoIGFzIFwiaHR0cDovL1wiIG9yIFwiaHR0cHM6Ly9cIikgZnJvbSB0aGUgZ2l2ZW4gdGV4dC5cclxuXHQgKiBcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IFRoZSB0ZXh0IG9mIHRoZSBhbmNob3IgdGhhdCBpcyBiZWluZyBnZW5lcmF0ZWQsIGZvciB3aGljaCB0byBzdHJpcCBvZmYgdGhlXHJcblx0ICogICB1cmwgcHJlZml4IChzdWNoIGFzIHN0cmlwcGluZyBvZmYgXCJodHRwOi8vXCIpXHJcblx0ICogQHJldHVybiB7U3RyaW5nfSBUaGUgYGFuY2hvclRleHRgLCB3aXRoIHRoZSBwcmVmaXggc3RyaXBwZWQuXHJcblx0ICovXHJcblx0c3RyaXBVcmxQcmVmaXggOiBmdW5jdGlvbiggdGV4dCApIHtcclxuXHRcdHJldHVybiB0ZXh0LnJlcGxhY2UoIHRoaXMudXJsUHJlZml4UmVnZXgsICcnICk7XHJcblx0fSxcclxuXHRcclxuXHRcclxuXHQvKipcclxuXHQgKiBTdHJpcHMgYW55IHByb3RvY29sLXJlbGF0aXZlICcvLycgZnJvbSB0aGUgYW5jaG9yIHRleHQuXHJcblx0ICogXHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCBUaGUgdGV4dCBvZiB0aGUgYW5jaG9yIHRoYXQgaXMgYmVpbmcgZ2VuZXJhdGVkLCBmb3Igd2hpY2ggdG8gc3RyaXAgb2ZmIHRoZVxyXG5cdCAqICAgcHJvdG9jb2wtcmVsYXRpdmUgcHJlZml4IChzdWNoIGFzIHN0cmlwcGluZyBvZmYgXCIvL1wiKVxyXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGBhbmNob3JUZXh0YCwgd2l0aCB0aGUgcHJvdG9jb2wtcmVsYXRpdmUgcHJlZml4IHN0cmlwcGVkLlxyXG5cdCAqL1xyXG5cdHN0cmlwUHJvdG9jb2xSZWxhdGl2ZVByZWZpeCA6IGZ1bmN0aW9uKCB0ZXh0ICkge1xyXG5cdFx0cmV0dXJuIHRleHQucmVwbGFjZSggdGhpcy5wcm90b2NvbFJlbGF0aXZlUmVnZXgsICcnICk7XHJcblx0fSxcclxuXHRcclxuXHRcclxuXHQvKipcclxuXHQgKiBSZW1vdmVzIGFueSB0cmFpbGluZyBzbGFzaCBmcm9tIHRoZSBnaXZlbiBgYW5jaG9yVGV4dGAsIGluIHByZXBhcmF0aW9uIGZvciB0aGUgdGV4dCB0byBiZSBkaXNwbGF5ZWQuXHJcblx0ICogXHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gYW5jaG9yVGV4dCBUaGUgdGV4dCBvZiB0aGUgYW5jaG9yIHRoYXQgaXMgYmVpbmcgZ2VuZXJhdGVkLCBmb3Igd2hpY2ggdG8gcmVtb3ZlIGFueSB0cmFpbGluZ1xyXG5cdCAqICAgc2xhc2ggKCcvJykgdGhhdCBtYXkgZXhpc3QuXHJcblx0ICogQHJldHVybiB7U3RyaW5nfSBUaGUgYGFuY2hvclRleHRgLCB3aXRoIHRoZSB0cmFpbGluZyBzbGFzaCByZW1vdmVkLlxyXG5cdCAqL1xyXG5cdHJlbW92ZVRyYWlsaW5nU2xhc2ggOiBmdW5jdGlvbiggYW5jaG9yVGV4dCApIHtcclxuXHRcdGlmKCBhbmNob3JUZXh0LmNoYXJBdCggYW5jaG9yVGV4dC5sZW5ndGggLSAxICkgPT09ICcvJyApIHtcclxuXHRcdFx0YW5jaG9yVGV4dCA9IGFuY2hvclRleHQuc2xpY2UoIDAsIC0xICk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gYW5jaG9yVGV4dDtcclxuXHR9XHJcblx0XHJcbn0gKTtcclxucmV0dXJuIEF1dG9saW5rZXI7XHJcblxyXG59KSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3RlcnJpYWpzLWNlc2l1bS9Tb3VyY2UvVGhpcmRQYXJ0eS9BdXRvbGlua2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImRlZmluZShbXSwgZnVuY3Rpb24oKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICAvKipcclxuICAgICAqIFJlcHJlc2VudGF0aW9uIG9mIDxDYW1lcmE+IGZyb20gS01MXHJcbiAgICAgKiBAYWxpYXMgS21sQ2FtZXJhXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0NhcnRlc2lhbjN9IHBvc2l0aW9uIGNhbWVyYSBwb3NpdGlvblxyXG4gICAgICogQHBhcmFtIHtIZWFkaW5nUGl0Y2hSb2xsfSBoZWFkaW5nUGl0Y2hSb2xsIGNhbWVyYSBvcmllbnRhdGlvblxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBLbWxDYW1lcmEocG9zaXRpb24sIGhlYWRpbmdQaXRjaFJvbGwpIHtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247XHJcbiAgICAgICAgdGhpcy5oZWFkaW5nUGl0Y2hSb2xsID0gaGVhZGluZ1BpdGNoUm9sbDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gS21sQ2FtZXJhO1xyXG59KTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvdGVycmlhanMtY2VzaXVtL1NvdXJjZS9EYXRhU291cmNlcy9LbWxDYW1lcmEuanNcbi8vIG1vZHVsZSBpZCA9IDEyMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZGVmaW5lKFtdLCBmdW5jdGlvbigpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIC8qKlxyXG4gICAgICogQGFsaWFzIEttbExvb2tBdFxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtDYXJ0ZXNpYW4zfSBwb3NpdGlvbiBjYW1lcmEgcG9zaXRpb25cclxuICAgICAqIEBwYXJhbSB7SGVhZGluZ1BpdGNoUmFuZ2V9IGhlYWRpbmdQaXRjaFJhbmdlIGNhbWVyYSBvcmllbnRhdGlvblxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBLbWxMb29rQXQocG9zaXRpb24sIGhlYWRpbmdQaXRjaFJhbmdlKSB7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xyXG4gICAgICAgIHRoaXMuaGVhZGluZ1BpdGNoUmFuZ2UgPSBoZWFkaW5nUGl0Y2hSYW5nZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gS21sTG9va0F0O1xyXG59KTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvdGVycmlhanMtY2VzaXVtL1NvdXJjZS9EYXRhU291cmNlcy9LbWxMb29rQXQuanNcbi8vIG1vZHVsZSBpZCA9IDEyMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZGVmaW5lKFtcclxuICAgICAgICAnLi4vQ29yZS9kZWZpbmVkJyxcclxuICAgICAgICAnLi4vQ29yZS9FdmVudCdcclxuICAgIF0sIGZ1bmN0aW9uKFxyXG4gICAgICAgIGRlZmluZWQsXHJcbiAgICAgICAgRXZlbnQpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIC8qKlxyXG4gICAgICogQGFsaWFzIEttbFRvdXJcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG5hbWUgcGFyc2VkIGZyb20gS01MXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaWQgaWQgcGFyc2VkIGZyb20gS01MXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwbGF5bGlzdCBhcnJheSB3aXRoIEtNTFRvdXJGbHlUb3MsIEtNTFRvdXJXYWl0cyBhbmQgS01MVG91clNvdW5kQ3Vlc1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBLbWxUb3VyKG5hbWUsIGlkKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSWQgb2Yga21sIGd4OlRvdXIgZW50cnlcclxuICAgICAgICAgKiBAdHlwZSBTdHJpbmdcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmlkID0gaWQ7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVG91ciBuYW1lXHJcbiAgICAgICAgICogQHR5cGUgU3RyaW5nXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbmRleCBvZiBjdXJyZW50IGVudHJ5IGZyb20gcGxheWxpc3RcclxuICAgICAgICAgKiBAdHlwZSBOdW1iZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnBsYXlsaXN0SW5kZXggPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFycmF5IG9mIHBsYXlsaXN0IGVudHJpZXNcclxuICAgICAgICAgKiBAdHlwZSBBcnJheVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucGxheWxpc3QgPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFdmVudCB3aWxsIGJlIGNhbGxlZCB3aGVuIHRvdXIgc3RhcnRzIHRvIHBsYXksXHJcbiAgICAgICAgICogYmVmb3JlIGFueSBwbGF5bGlzdCBlbnRyeSBzdGFydHMgdG8gcGxheS5cclxuICAgICAgICAgKiBAdHlwZSBFdmVudFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudG91clN0YXJ0ID0gbmV3IEV2ZW50KCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRXZlbnQgd2lsbCBiZSBjYWxsZWQgd2hlbiBhbGwgcGxheWxpc3QgZW50cmllcyBhcmVcclxuICAgICAgICAgKiBwbGF5ZWQsIG9yIHRvdXIgcGxheWJhY2sgYmVpbmcgY2FuY2VsZWQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBJZiB0b3VyIHBsYXliYWNrIHdhcyB0ZXJtaW5hdGVkLCBldmVudCBjYWxsYmFjayB3aWxsXHJcbiAgICAgICAgICogYmUgY2FsbGVkIHdpdGggdGVybWluYXRlZD10cnVlIHBhcmFtZXRlci5cclxuICAgICAgICAgKiBAdHlwZSBFdmVudFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudG91ckVuZCA9IG5ldyBFdmVudCgpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEV2ZW50IHdpbGwgYmUgY2FsbGVkIHdoZW4gZW50cnkgZnJvbSBwbGF5bGlzdCBzdGFydHMgdG8gcGxheS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEV2ZW50IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHdpdGggY3VyZW50IGVudHJ5IGFzIGZpcnN0IHBhcmFtZXRlci5cclxuICAgICAgICAgKiBAdHlwZSBFdmVudFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZW50cnlTdGFydCA9IG5ldyBFdmVudCgpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEV2ZW50IHdpbGwgYmUgY2FsbGVkIHdoZW4gZW50cnkgZnJvbSBwbGF5bGlzdCBlbmRzIHRvIHBsYXkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBFdmVudCBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCB3aXRoIGZvbGxvd2luZyBwYXJhbWV0ZXJzOlxyXG4gICAgICAgICAqIDEuIGVudHJ5IC0gZW50cnlcclxuICAgICAgICAgKiAyLiB0ZXJtaW5hdGVkIC0gdHJ1ZSBpZiBwbGF5YmFjayB3YXMgdGVybWluYXRlZCBieSBjYWxsaW5nIHtAbGluayBLbWxUb3VyI3N0b3B9XHJcbiAgICAgICAgICogQHR5cGUgRXZlbnRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmVudHJ5RW5kID0gbmV3IEV2ZW50KCk7XHJcblxyXG4gICAgICAgIHRoaXMuX2FjdGl2ZUVudHJpZXMgPSBbXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZCBlbnRyeSB0byB0aGlzIHRvdXIgcGxheWxpc3QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtLbWxUb3VyRmx5VG98S21sVG91cldhaXR9IGVudHJ5IGFuIGVudHJ5IHRvIGFkZCB0byB0aGUgcGxheWxpc3QuXHJcbiAgICAgKi9cclxuICAgIEttbFRvdXIucHJvdG90eXBlLmFkZFBsYXlsaXN0RW50cnkgPSBmdW5jdGlvbihlbnRyeSkge1xyXG4gICAgICAgIHRoaXMucGxheWxpc3QucHVzaChlbnRyeSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGxheSB0aGlzIHRvdXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtWaWV3ZXJ9IHZpZXdlciB2aWV3ZXIgd2lkZ2V0LlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjYW1lcmFPcHRpb25zXSB0aGVzZSBvcHRpb25zIHdpbGwgYmUgbWVyZ2VkIHdpdGgge0BsaW5rIENhbWVyYSNmbHlUb31cclxuICAgICAqIG9wdGlvbnMgZm9yIEZseVRvIHBsYXlsaXN0IGVudHJpZXMuXHJcbiAgICAgKi9cclxuICAgIEttbFRvdXIucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbih2aWV3ZXIsIGNhbWVyYU9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLnRvdXJTdGFydC5yYWlzZUV2ZW50KCk7XHJcblxyXG4gICAgICAgIHZhciB0b3VyID0gdGhpcztcclxuICAgICAgICBwbGF5RW50cnkuY2FsbCh0aGlzLCB2aWV3ZXIsIGNhbWVyYU9wdGlvbnMsIGZ1bmN0aW9uKHRlcm1pbmF0ZWQpIHtcclxuICAgICAgICAgICAgdG91ci5wbGF5bGlzdEluZGV4ID0gMDtcclxuICAgICAgICAgICAgLy8gU3RvcCBub25ibG9ja2luZyBlbnRyaWVzXHJcbiAgICAgICAgICAgIGlmICghdGVybWluYXRlZCkge1xyXG4gICAgICAgICAgICAgICAgY2FuY2VsQWxsRW50cmllcyh0b3VyLl9hY3RpdmVFbnRyaWVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0b3VyLnRvdXJFbmQucmFpc2VFdmVudCh0ZXJtaW5hdGVkKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdG9wIGN1cmVudGx5IHBsYXlpbmcgdG91ci5cclxuICAgICAqL1xyXG4gICAgS21sVG91ci5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGNhbmNlbEFsbEVudHJpZXModGhpcy5fYWN0aXZlRW50cmllcyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3RvcCBhbGwgYWN0aXZlRW50cmllcy5cclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFjdGl2ZUVudHJpZXNcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gY2FuY2VsQWxsRW50cmllcyhhY3RpdmVFbnRyaWVzKSB7XHJcbiAgICAgICAgZm9yKHZhciBlbnRyeSA9IGFjdGl2ZUVudHJpZXMucG9wKCk7IGVudHJ5ICE9PSB1bmRlZmluZWQ7IGVudHJ5ID0gYWN0aXZlRW50cmllcy5wb3AoKSkge1xyXG4gICAgICAgICAgICBlbnRyeS5zdG9wKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGxheSBwbGF5bGlzdCBlbnRyeS5cclxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHJlY3Vyc2V2bHkgd2l0aCBwbGF5TmV4dFxyXG4gICAgICogYW5kIGl0ZXJhdGVzIG92ZXIgYWxsIGVudHJpZXMgZnJvbSBwbGF5bGlzdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1ZpZXdlcldpZGdldH0gdmlld2VyIENlc2l1bSB2aWV3ZXIuXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2FtZXJhT3B0aW9ucyBzZWUge0BsaW5rIENhbWVyYSNmbHlUb30uXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhbGxEb25lIGEgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2hlbiBhbGwgZW50cmllcyBmcm9tIHBsYXlsaXN0XHJcbiAgICAgKiBiZWluZyBwbGF5ZWQgb3IgdXNlciBjYWxsIHtAbGluayBLbWxUb3VyI3N0b3B9LlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBwbGF5RW50cnkodmlld2VyLCBjYW1lcmFPcHRpb25zLCBhbGxEb25lKSB7XHJcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5wbGF5bGlzdFt0aGlzLnBsYXlsaXN0SW5kZXhdO1xyXG4gICAgICAgIGlmIChlbnRyeSkge1xyXG4gICAgICAgICAgICB2YXIgX3BsYXlOZXh0ID0gcGxheU5leHQuYmluZCh0aGlzLCB2aWV3ZXIsIGNhbWVyYU9wdGlvbnMsIGFsbERvbmUpO1xyXG4gICAgICAgICAgICB0aGlzLl9hY3RpdmVFbnRyaWVzLnB1c2goZW50cnkpO1xyXG4gICAgICAgICAgICB0aGlzLmVudHJ5U3RhcnQucmFpc2VFdmVudChlbnRyeSk7XHJcbiAgICAgICAgICAgIGlmIChlbnRyeS5ibG9ja2luZykge1xyXG4gICAgICAgICAgICAgICAgZW50cnkucGxheShfcGxheU5leHQsIHZpZXdlci5zY2VuZS5jYW1lcmEsIGNhbWVyYU9wdGlvbnMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRvdXIgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgZW50cnkucGxheShmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICB0b3VyLmVudHJ5RW5kLnJhaXNlRXZlbnQoZW50cnkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmR4ID0gdG91ci5fYWN0aXZlRW50cmllcy5pbmRleE9mKGVudHJ5KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5keCA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvdXIuX2FjdGl2ZUVudHJpZXMuc3BsaWNlKGluZHgsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgX3BsYXlOZXh0KHZpZXdlciwgY2FtZXJhT3B0aW9ucywgYWxsRG9uZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZihkZWZpbmVkKGFsbERvbmUpKSB7XHJcbiAgICAgICAgICAgIGFsbERvbmUoZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEluY3JlbWVudCBwbGF5bGlzdEluZGV4IGFuZCBjYWxsIHBsYXlFbnRyeVxyXG4gICAgICogaWYgdGVybWluYXRlZCBpc24ndCB0cnVlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Vmlld2VyV2lkZ2V0fSB2aWV3ZXIgcGFzc2VkIGZvciByZWN1cnNpb24uXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2FtZXJhT3B0aW9ucyBwYXNzZWQgZm9yIHJlY3Vyc2lvbi5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGFsbERvbmUgcGFzc2VkIGZvciByZWN1cnNpb24uXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHRlcm1pbmF0ZWQgdHJ1ZSBpZiBhY3RpdmUgZW50cnkgd2FzIHRlcm1pbmF0ZWQsXHJcbiAgICAgKiBhbmQgdGhlIHdob2xlIHRvdXIgc2hvdWxkIGJlIHRlcm1pbmF0ZWQuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHBsYXlOZXh0KHZpZXdlciwgY2FtZXJhT3B0aW9ucywgYWxsRG9uZSwgdGVybWluYXRlZCkge1xyXG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMucGxheWxpc3RbdGhpcy5wbGF5bGlzdEluZGV4XTtcclxuICAgICAgICB0aGlzLmVudHJ5RW5kLnJhaXNlRXZlbnQoZW50cnksIHRlcm1pbmF0ZWQpO1xyXG5cclxuICAgICAgICBpZiAodGVybWluYXRlZCkge1xyXG4gICAgICAgICAgICBhbGxEb25lKHRlcm1pbmF0ZWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIGluZHggPSB0aGlzLl9hY3RpdmVFbnRyaWVzLmluZGV4T2YoZW50cnkpO1xyXG4gICAgICAgICAgICBpZiAoaW5keCA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmVFbnRyaWVzLnNwbGljZShpbmR4LCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnBsYXlsaXN0SW5kZXgrKztcclxuICAgICAgICAgICAgcGxheUVudHJ5LmNhbGwodGhpcywgdmlld2VyLCBjYW1lcmFPcHRpb25zLCBhbGxEb25lKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIEttbFRvdXI7XHJcbn0pO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy90ZXJyaWFqcy1jZXNpdW0vU291cmNlL0RhdGFTb3VyY2VzL0ttbFRvdXIuanNcbi8vIG1vZHVsZSBpZCA9IDEyMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZGVmaW5lKFtcclxuICAgICAgICAnLi4vQ29yZS9Cb3VuZGluZ1NwaGVyZScsXHJcbiAgICAgICAgJy4uL0NvcmUvY29tYmluZScsXHJcbiAgICAgICAgJy4uL0NvcmUvZGVmaW5lZCcsXHJcbiAgICAgICAgJy4uL0NvcmUvRWFzaW5nRnVuY3Rpb24nXHJcbiAgICBdLCBmdW5jdGlvbihcclxuICAgICAgICBCb3VuZGluZ1NwaGVyZSxcclxuICAgICAgICBjb21iaW5lLFxyXG4gICAgICAgIGRlZmluZWQsXHJcbiAgICAgICAgRWFzaW5nRnVuY3Rpb24pIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIC8qKlxyXG4gICAgICogQGFsaWFzIEttbFRvdXJGbHlUb1xyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGR1cmF0aW9uIGVudHJ5IGR1cmF0aW9uXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZmx5VG9Nb2RlIEtNTCBmbHkgdG8gbW9kZTogYm91bmNlLCBzbW9vdGgsIGV0Y1xyXG4gICAgICogQHBhcmFtIHtLbWxDYW1lcmF8S21sTG9va0F0fSB2aWV3IEttbENhbWVyYSBvciBLbWxMb29rQXRcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gS21sVG91ckZseVRvKGR1cmF0aW9uLCBmbHlUb01vZGUsIHZpZXcpIHtcclxuICAgICAgICB0aGlzLnR5cGUgPSAnS21sVG91ckZseVRvJztcclxuICAgICAgICB0aGlzLmJsb2NraW5nID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmFjdGl2ZUNhbWVyYSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5hY3RpdmVDYWxsYmFjayA9IG51bGw7XHJcblxyXG4gICAgICAgIHRoaXMuZHVyYXRpb24gPSBkdXJhdGlvbjtcclxuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xyXG4gICAgICAgIHRoaXMuZmx5VG9Nb2RlID0gZmx5VG9Nb2RlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGxheSB0aGlzIHBsYXlsaXN0IGVudHJ5XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtLbWxUb3VyRmx5VG9+RG9uZUNhbGxiYWNrfSBkb25lIGZ1bmN0aW9uIHdoaWNoIHdpbGwgYmUgY2FsbGVkIHdoZW4gcGxheWJhY2sgZW5kc1xyXG4gICAgICogQHBhcmFtIHtDYW1lcmF9IGNhbWVyYSBDZXNpdW0gY2FtZXJhXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NhbWVyYU9wdGlvbnNdIHdoaWNoIHdpbGwgYmUgbWVyZ2VkIHdpdGggY2FtZXJhIGZseVRvIG9wdGlvbnMuIFNlZSB7QGxpbmsgQ2FtZXJhI2ZseVRvfVxyXG4gICAgICovXHJcbiAgICBLbWxUb3VyRmx5VG8ucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbihkb25lLCBjYW1lcmEsIGNhbWVyYU9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLmFjdGl2ZUNhbWVyYSA9IGNhbWVyYTtcclxuICAgICAgICBpZiAoZGVmaW5lZChkb25lKSAmJiBkb25lICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICAgICAgdGhpcy5hY3RpdmVDYWxsYmFjayA9IGZ1bmN0aW9uKHRlcm1pbmF0ZWQpIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBzZWxmLmFjdGl2ZUNhbGxiYWNrO1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHNlbGYuYWN0aXZlQ2FtZXJhO1xyXG4gICAgICAgICAgICAgICAgZG9uZShkZWZpbmVkKHRlcm1pbmF0ZWQpID8gZmFsc2UgOiB0ZXJtaW5hdGVkKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5nZXRDYW1lcmFPcHRpb25zKGNhbWVyYU9wdGlvbnMpO1xyXG4gICAgICAgIGlmICh0aGlzLnZpZXcuaGVhZGluZ1BpdGNoUm9sbCkge1xyXG4gICAgICAgICAgICBjYW1lcmEuZmx5VG8ob3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMudmlldy5oZWFkaW5nUGl0Y2hSYW5nZSkge1xyXG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gbmV3IEJvdW5kaW5nU3BoZXJlKHRoaXMudmlldy5wb3NpdGlvbik7XHJcbiAgICAgICAgICAgIGNhbWVyYS5mbHlUb0JvdW5kaW5nU3BoZXJlKHRhcmdldCwgb3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0b3AgZXhlY3V0aW9uIG9mIGN1cmVudCBlbnRyeS4gQ2FuY2VsIGNhbWVyYSBmbHlUb1xyXG4gICAgICovXHJcbiAgICBLbWxUb3VyRmx5VG8ucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAoZGVmaW5lZCh0aGlzLmFjdGl2ZUNhbWVyYSkpIHtcclxuICAgICAgICAgICAgdGhpcy5hY3RpdmVDYW1lcmEuY2FuY2VsRmxpZ2h0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkZWZpbmVkKHRoaXMuYWN0aXZlQ2FsbGJhY2spKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlQ2FsbGJhY2sodHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgb3B0aW9ucyBmb3Ige0BsaW5rIENhbWVyYSNmbHlUb30gb3Ige0BsaW5rIENhbWVyYSNmbHlUb0JvdW5kaW5nU3BoZXJlfVxyXG4gICAgICogZGVwZW5kcyBvbiB0aGlzLnZpZXcgdHlwZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2FtZXJhT3B0aW9ucyBvcHRpb25zIHRvIG1lcmdlIHdpdGggZ2VuZXJhdGVkLiBTZWUge0BsaW5rIENhbWVyYSNmbHlUb31cclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHtAbGluayBDYW1lcmEjZmx5VG99IG9yIHtAbGluayBDYW1lcmEjZmx5VG9Cb3VuZGluZ1NwaGVyZX0gb3B0aW9uc1xyXG4gICAgICovXHJcbiAgICBLbWxUb3VyRmx5VG8ucHJvdG90eXBlLmdldENhbWVyYU9wdGlvbnMgPSBmdW5jdGlvbihjYW1lcmFPcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgaWYgKGRlZmluZWQodGhpcy5hY3RpdmVDYWxsYmFjaykpIHtcclxuICAgICAgICAgICAgb3B0aW9ucy5jb21wbGV0ZSA9IHRoaXMuYWN0aXZlQ2FsbGJhY2s7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5mbHlUb01vZGUgPT09ICdzbW9vdGgnICkge1xyXG4gICAgICAgICAgICBvcHRpb25zLmVhc2luZ0Z1bmN0aW9uID0gRWFzaW5nRnVuY3Rpb24uTElORUFSX05PTkU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy52aWV3LmhlYWRpbmdQaXRjaFJvbGwpIHtcclxuICAgICAgICAgICAgb3B0aW9ucy5kZXN0aW5hdGlvbiA9IHRoaXMudmlldy5wb3NpdGlvbjtcclxuICAgICAgICAgICAgb3B0aW9ucy5vcmllbnRhdGlvbiA9IHRoaXMudmlldy5oZWFkaW5nUGl0Y2hSb2xsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLnZpZXcuaGVhZGluZ1BpdGNoUmFuZ2UpIHtcclxuICAgICAgICAgICAgb3B0aW9ucy5vZmZzZXQgPSB0aGlzLnZpZXcuaGVhZGluZ1BpdGNoUmFuZ2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZGVmaW5lZChjYW1lcmFPcHRpb25zKSkge1xyXG4gICAgICAgICAgICBvcHRpb25zID0gY29tYmluZShvcHRpb25zLCBjYW1lcmFPcHRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiB0aGUgZmxpZ2h0IGNvbXBsZXRlcy5cclxuICAgICAqIEBjYWxsYmFjayBLbWxUb3VyRmx5VG9+RG9uZUNhbGxiYWNrXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB0ZXJtaW5hdGVkIHRydWUgaWYge0BsaW5rIEttbFRvdXJGbHlUbyNzdG9wfSB3YXNcclxuICAgICAqIGNhbGxlZCBiZWZvcmUgZW50cnkgZG9uZSBwbGF5YmFjay5cclxuICAgICAqL1xyXG5cclxuICAgIHJldHVybiBLbWxUb3VyRmx5VG87XHJcbn0pO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy90ZXJyaWFqcy1jZXNpdW0vU291cmNlL0RhdGFTb3VyY2VzL0ttbFRvdXJGbHlUby5qc1xuLy8gbW9kdWxlIGlkID0gMTIxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJkZWZpbmUoW1xyXG4gICAgICAgICcuLi9Db3JlL2RlZmluZWQnXHJcbiAgICBdLCBmdW5jdGlvbihcclxuICAgICAgICBkZWZpbmVkKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICAvKipcclxuICAgICAqIEBhbGlhcyBLbWxUb3VyV2FpdFxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGR1cmF0aW9uIGVudHJ5IGR1cmF0aW9uXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIEttbFRvdXJXYWl0KGR1cmF0aW9uKSB7XHJcbiAgICAgICAgdGhpcy50eXBlID0gJ0ttbFRvdXJXYWl0JztcclxuICAgICAgICB0aGlzLmJsb2NraW5nID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmR1cmF0aW9uID0gZHVyYXRpb247XHJcblxyXG4gICAgICAgIHRoaXMudGltZW91dCA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQbGF5IHRoaXMgcGxheWxpc3QgZW50cnlcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0ttbFRvdXJXYWl0fkRvbmVDYWxsYmFja30gZG9uZSBmdW5jdGlvbiB3aGljaCB3aWxsIGJlIGNhbGxlZCB3aGVuIHBsYXliYWNrIGVuZHNcclxuICAgICAqL1xyXG4gICAgS21sVG91cldhaXQucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbihkb25lKSB7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuYWN0aXZlQ2FsbGJhY2sgPSBkb25lO1xyXG4gICAgICAgIHRoaXMudGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBzZWxmLmFjdGl2ZUNhbGxiYWNrO1xyXG4gICAgICAgICAgICBkb25lKGZhbHNlKTtcclxuICAgICAgICB9LCB0aGlzLmR1cmF0aW9uICogMTAwMCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3RvcCBleGVjdXRpb24gb2YgY3VyZW50IGVudHJ5LCBjYW5jZWwgY3VyZW50IHRpbWVvdXRcclxuICAgICAqL1xyXG4gICAgS21sVG91cldhaXQucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KTtcclxuICAgICAgICBpZiAoZGVmaW5lZCh0aGlzLmFjdGl2ZUNhbGxiYWNrKSkge1xyXG4gICAgICAgICAgICB0aGlzLmFjdGl2ZUNhbGxiYWNrKHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGZ1bmN0aW9uIHdoaWNoIHdpbGwgYmUgY2FsbGVkIHdoZW4gcGxheWJhY2sgZW5kcy5cclxuICAgICAqXHJcbiAgICAgKiBAY2FsbGJhY2sgS21sVG91cldhaXR+RG9uZUNhbGxiYWNrXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHRlcm1pbmF0ZWQgdHJ1ZSBpZiB7QGxpbmsgS21sVG91cldhaXQjc3RvcH0gd2FzXHJcbiAgICAgKiBjYWxsZWQgYmVmb3JlIGVudHJ5IGRvbmUgcGxheWJhY2suXHJcbiAgICAgKi9cclxuXHJcbiAgICByZXR1cm4gS21sVG91cldhaXQ7XHJcbn0pO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy90ZXJyaWFqcy1jZXNpdW0vU291cmNlL0RhdGFTb3VyY2VzL0ttbFRvdXJXYWl0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMjE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImRlZmluZShbXHJcbiAgICAgICAgJy4uL0NvcmUvZGVmaW5lZCcsXHJcbiAgICAgICAgJy4uL0NvcmUvZGVmaW5lUHJvcGVydGllcycsXHJcbiAgICAgICAgJy4uL0NvcmUvRGV2ZWxvcGVyRXJyb3InLFxyXG4gICAgICAgICcuLi9Db3JlL0VsbGlwc29pZCcsXHJcbiAgICAgICAgJy4uL0NvcmUvRXZlbnQnLFxyXG4gICAgICAgICcuLi9Db3JlL1JlZmVyZW5jZUZyYW1lJyxcclxuICAgICAgICAnLi9Qcm9wZXJ0eSdcclxuICAgIF0sIGZ1bmN0aW9uKFxyXG4gICAgICAgIGRlZmluZWQsXHJcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyxcclxuICAgICAgICBEZXZlbG9wZXJFcnJvcixcclxuICAgICAgICBFbGxpcHNvaWQsXHJcbiAgICAgICAgRXZlbnQsXHJcbiAgICAgICAgUmVmZXJlbmNlRnJhbWUsXHJcbiAgICAgICAgUHJvcGVydHkpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgaXMgYSB0ZW1wb3JhcnkgY2xhc3MgZm9yIHNjYWxpbmcgcG9zaXRpb24gcHJvcGVydGllcyB0byB0aGUgV0dTODQgc3VyZmFjZS5cclxuICAgICAqIEl0IHdpbGwgZ28gYXdheSBvciBiZSByZWZhY3RvcmVkIHRvIHN1cHBvcnQgZGF0YSB3aXRoIGFyYml0cmFyeSBoZWlnaHQgcmVmZXJlbmNlcy5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFNjYWxlZFBvc2l0aW9uUHJvcGVydHkodmFsdWUpIHtcclxuICAgICAgICB0aGlzLl9kZWZpbml0aW9uQ2hhbmdlZCA9IG5ldyBFdmVudCgpO1xyXG4gICAgICAgIHRoaXMuX3ZhbHVlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuX3JlbW92ZVN1YnNjcmlwdGlvbiA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLnNldFZhbHVlKHZhbHVlKTtcclxuICAgIH1cclxuXHJcbiAgICBkZWZpbmVQcm9wZXJ0aWVzKFNjYWxlZFBvc2l0aW9uUHJvcGVydHkucHJvdG90eXBlLCB7XHJcbiAgICAgICAgaXNDb25zdGFudCA6IHtcclxuICAgICAgICAgICAgZ2V0IDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvcGVydHkuaXNDb25zdGFudCh0aGlzLl92YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGRlZmluaXRpb25DaGFuZ2VkIDoge1xyXG4gICAgICAgICAgICBnZXQgOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWZpbml0aW9uQ2hhbmdlZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVmZXJlbmNlRnJhbWUgOiB7XHJcbiAgICAgICAgICAgIGdldCA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmluZWQodGhpcy5fdmFsdWUpID8gdGhpcy5fdmFsdWUucmVmZXJlbmNlRnJhbWUgOiBSZWZlcmVuY2VGcmFtZS5GSVhFRDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIFNjYWxlZFBvc2l0aW9uUHJvcGVydHkucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24odGltZSwgcmVzdWx0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWVJblJlZmVyZW5jZUZyYW1lKHRpbWUsIFJlZmVyZW5jZUZyYW1lLkZJWEVELCByZXN1bHQpO1xyXG4gICAgfTtcclxuXHJcbiAgICBTY2FsZWRQb3NpdGlvblByb3BlcnR5LnByb3RvdHlwZS5zZXRWYWx1ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3ZhbHVlICE9PSB2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xyXG5cclxuICAgICAgICAgICAgaWYgKGRlZmluZWQodGhpcy5fcmVtb3ZlU3Vic2NyaXB0aW9uKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlU3Vic2NyaXB0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVTdWJzY3JpcHRpb24gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChkZWZpbmVkKHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlU3Vic2NyaXB0aW9uID0gdmFsdWUuZGVmaW5pdGlvbkNoYW5nZWQuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLl9yYWlzZURlZmluaXRpb25DaGFuZ2VkLCB0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9kZWZpbml0aW9uQ2hhbmdlZC5yYWlzZUV2ZW50KHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgU2NhbGVkUG9zaXRpb25Qcm9wZXJ0eS5wcm90b3R5cGUuZ2V0VmFsdWVJblJlZmVyZW5jZUZyYW1lID0gZnVuY3Rpb24odGltZSwgcmVmZXJlbmNlRnJhbWUsIHJlc3VsdCkge1xyXG4gICAgICAgIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XHJcbiAgICAgICAgaWYgKCFkZWZpbmVkKHRpbWUpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcigndGltZSBpcyByZXF1aXJlZC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFkZWZpbmVkKHJlZmVyZW5jZUZyYW1lKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoJ3JlZmVyZW5jZUZyYW1lIGlzIHJlcXVpcmVkLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcclxuXHJcbiAgICAgICAgaWYgKCFkZWZpbmVkKHRoaXMuX3ZhbHVlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5fdmFsdWUuZ2V0VmFsdWVJblJlZmVyZW5jZUZyYW1lKHRpbWUsIHJlZmVyZW5jZUZyYW1lLCByZXN1bHQpO1xyXG4gICAgICAgIHJldHVybiBkZWZpbmVkKHJlc3VsdCkgPyBFbGxpcHNvaWQuV0dTODQuc2NhbGVUb0dlb2RldGljU3VyZmFjZShyZXN1bHQsIHJlc3VsdCkgOiB1bmRlZmluZWQ7XHJcbiAgICB9O1xyXG5cclxuICAgIFNjYWxlZFBvc2l0aW9uUHJvcGVydHkucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMgPT09IG90aGVyIHx8IChvdGhlciBpbnN0YW5jZW9mIFNjYWxlZFBvc2l0aW9uUHJvcGVydHkgJiYgdGhpcy5fdmFsdWUgPT09IG90aGVyLl92YWx1ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIFNjYWxlZFBvc2l0aW9uUHJvcGVydHkucHJvdG90eXBlLl9yYWlzZURlZmluaXRpb25DaGFuZ2VkID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5fZGVmaW5pdGlvbkNoYW5nZWQucmFpc2VFdmVudCh0aGlzKTtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIFNjYWxlZFBvc2l0aW9uUHJvcGVydHk7XHJcbn0pO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy90ZXJyaWFqcy1jZXNpdW0vU291cmNlL0RhdGFTb3VyY2VzL1NjYWxlZFBvc2l0aW9uUHJvcGVydHkuanNcbi8vIG1vZHVsZSBpZCA9IDEyMjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZGVmaW5lKFtcclxuICAgICAgICAnLi4vQ29yZS9DYXJ0ZXNpYW4zJyxcclxuICAgICAgICAnLi4vQ29yZS9Db2xvcicsXHJcbiAgICAgICAgJy4uL0NvcmUvY3JlYXRlR3VpZCcsXHJcbiAgICAgICAgJy4uL0NvcmUvZGVmYXVsdFZhbHVlJyxcclxuICAgICAgICAnLi4vQ29yZS9kZWZpbmVkJyxcclxuICAgICAgICAnLi4vQ29yZS9kZWZpbmVQcm9wZXJ0aWVzJyxcclxuICAgICAgICAnLi4vQ29yZS9EZXZlbG9wZXJFcnJvcicsXHJcbiAgICAgICAgJy4uL0NvcmUvRXZlbnQnLFxyXG4gICAgICAgICcuLi9Db3JlL2dldEZpbGVuYW1lRnJvbVVyaScsXHJcbiAgICAgICAgJy4uL0NvcmUvUGluQnVpbGRlcicsXHJcbiAgICAgICAgJy4uL0NvcmUvUG9seWdvbkhpZXJhcmNoeScsXHJcbiAgICAgICAgJy4uL0NvcmUvUmVzb3VyY2UnLFxyXG4gICAgICAgICcuLi9Db3JlL1J1bnRpbWVFcnJvcicsXHJcbiAgICAgICAgJy4uL1NjZW5lL0hlaWdodFJlZmVyZW5jZScsXHJcbiAgICAgICAgJy4uL1NjZW5lL1ZlcnRpY2FsT3JpZ2luJyxcclxuICAgICAgICAnLi4vVGhpcmRQYXJ0eS90b3BvanNvbicsXHJcbiAgICAgICAgJy4uL1RoaXJkUGFydHkvd2hlbicsXHJcbiAgICAgICAgJy4vQmlsbGJvYXJkR3JhcGhpY3MnLFxyXG4gICAgICAgICcuL0NhbGxiYWNrUHJvcGVydHknLFxyXG4gICAgICAgICcuL0NvbG9yTWF0ZXJpYWxQcm9wZXJ0eScsXHJcbiAgICAgICAgJy4vQ29uc3RhbnRQb3NpdGlvblByb3BlcnR5JyxcclxuICAgICAgICAnLi9Db25zdGFudFByb3BlcnR5JyxcclxuICAgICAgICAnLi9EYXRhU291cmNlJyxcclxuICAgICAgICAnLi9FbnRpdHlDbHVzdGVyJyxcclxuICAgICAgICAnLi9FbnRpdHlDb2xsZWN0aW9uJyxcclxuICAgICAgICAnLi9Qb2x5Z29uR3JhcGhpY3MnLFxyXG4gICAgICAgICcuL1BvbHlsaW5lR3JhcGhpY3MnXHJcbiAgICBdLCBmdW5jdGlvbihcclxuICAgICAgICBDYXJ0ZXNpYW4zLFxyXG4gICAgICAgIENvbG9yLFxyXG4gICAgICAgIGNyZWF0ZUd1aWQsXHJcbiAgICAgICAgZGVmYXVsdFZhbHVlLFxyXG4gICAgICAgIGRlZmluZWQsXHJcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyxcclxuICAgICAgICBEZXZlbG9wZXJFcnJvcixcclxuICAgICAgICBFdmVudCxcclxuICAgICAgICBnZXRGaWxlbmFtZUZyb21VcmksXHJcbiAgICAgICAgUGluQnVpbGRlcixcclxuICAgICAgICBQb2x5Z29uSGllcmFyY2h5LFxyXG4gICAgICAgIFJlc291cmNlLFxyXG4gICAgICAgIFJ1bnRpbWVFcnJvcixcclxuICAgICAgICBIZWlnaHRSZWZlcmVuY2UsXHJcbiAgICAgICAgVmVydGljYWxPcmlnaW4sXHJcbiAgICAgICAgdG9wb2pzb24sXHJcbiAgICAgICAgd2hlbixcclxuICAgICAgICBCaWxsYm9hcmRHcmFwaGljcyxcclxuICAgICAgICBDYWxsYmFja1Byb3BlcnR5LFxyXG4gICAgICAgIENvbG9yTWF0ZXJpYWxQcm9wZXJ0eSxcclxuICAgICAgICBDb25zdGFudFBvc2l0aW9uUHJvcGVydHksXHJcbiAgICAgICAgQ29uc3RhbnRQcm9wZXJ0eSxcclxuICAgICAgICBEYXRhU291cmNlLFxyXG4gICAgICAgIEVudGl0eUNsdXN0ZXIsXHJcbiAgICAgICAgRW50aXR5Q29sbGVjdGlvbixcclxuICAgICAgICBQb2x5Z29uR3JhcGhpY3MsXHJcbiAgICAgICAgUG9seWxpbmVHcmFwaGljcykge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICAgIGZ1bmN0aW9uIGRlZmF1bHRDcnNGdW5jdGlvbihjb29yZGluYXRlcykge1xyXG4gICAgICAgIHJldHVybiBDYXJ0ZXNpYW4zLmZyb21EZWdyZWVzKGNvb3JkaW5hdGVzWzBdLCBjb29yZGluYXRlc1sxXSwgY29vcmRpbmF0ZXNbMl0pO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBjcnNOYW1lcyA9IHtcclxuICAgICAgICAndXJuOm9nYzpkZWY6Y3JzOk9HQzoxLjM6Q1JTODQnIDogZGVmYXVsdENyc0Z1bmN0aW9uLFxyXG4gICAgICAgICdFUFNHOjQzMjYnIDogZGVmYXVsdENyc0Z1bmN0aW9uLFxyXG4gICAgICAgICd1cm46b2djOmRlZjpjcnM6RVBTRzo6NDMyNicgOiBkZWZhdWx0Q3JzRnVuY3Rpb25cclxuICAgIH07XHJcblxyXG4gICAgdmFyIGNyc0xpbmtIcmVmcyA9IHt9O1xyXG4gICAgdmFyIGNyc0xpbmtUeXBlcyA9IHt9O1xyXG4gICAgdmFyIGRlZmF1bHRNYXJrZXJTaXplID0gNDg7XHJcbiAgICB2YXIgZGVmYXVsdE1hcmtlclN5bWJvbDtcclxuICAgIHZhciBkZWZhdWx0TWFya2VyQ29sb3IgPSBDb2xvci5ST1lBTEJMVUU7XHJcbiAgICB2YXIgZGVmYXVsdFN0cm9rZSA9IENvbG9yLllFTExPVztcclxuICAgIHZhciBkZWZhdWx0U3Ryb2tlV2lkdGggPSAyO1xyXG4gICAgdmFyIGRlZmF1bHRGaWxsID0gQ29sb3IuZnJvbUJ5dGVzKDI1NSwgMjU1LCAwLCAxMDApO1xyXG4gICAgdmFyIGRlZmF1bHRDbGFtcFRvR3JvdW5kID0gZmFsc2U7XHJcblxyXG4gICAgdmFyIHNpemVzID0ge1xyXG4gICAgICAgIHNtYWxsIDogMjQsXHJcbiAgICAgICAgbWVkaXVtIDogNDgsXHJcbiAgICAgICAgbGFyZ2UgOiA2NFxyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgc2ltcGxlU3R5bGVJZGVudGlmaWVycyA9IFsndGl0bGUnLCAnZGVzY3JpcHRpb24nLCAvL1xyXG4gICAgJ21hcmtlci1zaXplJywgJ21hcmtlci1zeW1ib2wnLCAnbWFya2VyLWNvbG9yJywgJ3N0cm9rZScsIC8vXHJcbiAgICAnc3Ryb2tlLW9wYWNpdHknLCAnc3Ryb2tlLXdpZHRoJywgJ2ZpbGwnLCAnZmlsbC1vcGFjaXR5J107XHJcblxyXG4gICAgZnVuY3Rpb24gZGVmYXVsdERlc2NyaWJlKHByb3BlcnRpZXMsIG5hbWVQcm9wZXJ0eSkge1xyXG4gICAgICAgIHZhciBodG1sID0gJyc7XHJcbiAgICAgICAgZm9yICggdmFyIGtleSBpbiBwcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IG5hbWVQcm9wZXJ0eSB8fCBzaW1wbGVTdHlsZUlkZW50aWZpZXJzLmluZGV4T2Yoa2V5KSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHByb3BlcnRpZXNba2V5XTtcclxuICAgICAgICAgICAgICAgIGlmIChkZWZpbmVkKHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWwgKz0gJzx0cj48dGg+JyArIGtleSArICc8L3RoPjx0ZD4nICsgZGVmYXVsdERlc2NyaWJlKHZhbHVlKSArICc8L3RkPjwvdHI+JztcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sICs9ICc8dHI+PHRoPicgKyBrZXkgKyAnPC90aD48dGQ+JyArIHZhbHVlICsgJzwvdGQ+PC90cj4nO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGh0bWwubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBodG1sID0gJzx0YWJsZSBjbGFzcz1cImNlc2l1bS1pbmZvQm94LWRlZmF1bHRUYWJsZVwiPjx0Ym9keT4nICsgaHRtbCArICc8L3Rib2R5PjwvdGFibGU+JztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBodG1sO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZURlc2NyaXB0aW9uQ2FsbGJhY2soZGVzY3JpYmUsIHByb3BlcnRpZXMsIG5hbWVQcm9wZXJ0eSkge1xyXG4gICAgICAgIHZhciBkZXNjcmlwdGlvbjtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24odGltZSwgcmVzdWx0KSB7XHJcbiAgICAgICAgICAgIGlmICghZGVmaW5lZChkZXNjcmlwdGlvbikpIHtcclxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uID0gZGVzY3JpYmUocHJvcGVydGllcywgbmFtZVByb3BlcnR5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpcHRpb247XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkZWZhdWx0RGVzY3JpYmVQcm9wZXJ0eShwcm9wZXJ0aWVzLCBuYW1lUHJvcGVydHkpIHtcclxuICAgICAgICByZXR1cm4gbmV3IENhbGxiYWNrUHJvcGVydHkoY3JlYXRlRGVzY3JpcHRpb25DYWxsYmFjayhkZWZhdWx0RGVzY3JpYmUsIHByb3BlcnRpZXMsIG5hbWVQcm9wZXJ0eSksIHRydWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vR2VvSlNPTiBzcGVjaWZpZXMgb25seSB0aGUgRmVhdHVyZSBvYmplY3QgaGFzIGEgdXNhYmxlIGlkIHByb3BlcnR5XHJcbiAgICAvL0J1dCBzaW5jZSBcIm11bHRpXCIgZ2VvbWV0cmllcyBjcmVhdGUgbXVsdGlwbGUgZW50aXR5LFxyXG4gICAgLy93ZSBjYW4ndCB1c2UgaXQgZm9yIHRoZW0gZWl0aGVyLlxyXG4gICAgZnVuY3Rpb24gY3JlYXRlT2JqZWN0KGdlb0pzb24sIGVudGl0eUNvbGxlY3Rpb24sIGRlc2NyaWJlKSB7XHJcbiAgICAgICAgdmFyIGlkID0gZ2VvSnNvbi5pZDtcclxuICAgICAgICBpZiAoIWRlZmluZWQoaWQpIHx8IGdlb0pzb24udHlwZSAhPT0gJ0ZlYXR1cmUnKSB7XHJcbiAgICAgICAgICAgIGlkID0gY3JlYXRlR3VpZCgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBpID0gMjtcclxuICAgICAgICAgICAgdmFyIGZpbmFsSWQgPSBpZDtcclxuICAgICAgICAgICAgd2hpbGUgKGRlZmluZWQoZW50aXR5Q29sbGVjdGlvbi5nZXRCeUlkKGZpbmFsSWQpKSkge1xyXG4gICAgICAgICAgICAgICAgZmluYWxJZCA9IGlkICsgJ18nICsgaTtcclxuICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZCA9IGZpbmFsSWQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgZW50aXR5ID0gZW50aXR5Q29sbGVjdGlvbi5nZXRPckNyZWF0ZUVudGl0eShpZCk7XHJcbiAgICAgICAgdmFyIHByb3BlcnRpZXMgPSBnZW9Kc29uLnByb3BlcnRpZXM7XHJcbiAgICAgICAgaWYgKGRlZmluZWQocHJvcGVydGllcykpIHtcclxuICAgICAgICAgICAgZW50aXR5LnByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzO1xyXG5cclxuICAgICAgICAgICAgdmFyIG5hbWVQcm9wZXJ0eTtcclxuXHJcbiAgICAgICAgICAgIC8vQ2hlY2sgZm9yIHRoZSBzaW1wbGVzdHlsZSBzcGVjaWZpZWQgbmFtZSBmaXJzdC5cclxuICAgICAgICAgICAgdmFyIG5hbWUgPSBwcm9wZXJ0aWVzLnRpdGxlO1xyXG4gICAgICAgICAgICBpZiAoZGVmaW5lZChuYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgZW50aXR5Lm5hbWUgPSBuYW1lO1xyXG4gICAgICAgICAgICAgICAgbmFtZVByb3BlcnR5ID0gJ3RpdGxlJztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vRWxzZSwgZmluZCB0aGUgbmFtZSBieSBzZWxlY3RpbmcgYW4gYXBwcm9wcmlhdGUgcHJvcGVydHkuXHJcbiAgICAgICAgICAgICAgICAvL1RoZSBuYW1lIHdpbGwgYmUgb2J0YWluZWQgYmFzZWQgb24gdGhpcyBvcmRlcjpcclxuICAgICAgICAgICAgICAgIC8vMSkgVGhlIGZpcnN0IGNhc2UtaW5zZW5zaXRpdmUgcHJvcGVydHkgd2l0aCB0aGUgbmFtZSAndGl0bGUnLFxyXG4gICAgICAgICAgICAgICAgLy8yKSBUaGUgZmlyc3QgY2FzZS1pbnNlbnNpdGl2ZSBwcm9wZXJ0eSB3aXRoIHRoZSBuYW1lICduYW1lJyxcclxuICAgICAgICAgICAgICAgIC8vMykgVGhlIGZpcnN0IHByb3BlcnR5IGNvbnRhaW5pbmcgdGhlIHdvcmQgJ3RpdGxlJy5cclxuICAgICAgICAgICAgICAgIC8vNCkgVGhlIGZpcnN0IHByb3BlcnR5IGNvbnRhaW5pbmcgdGhlIHdvcmQgJ25hbWUnLFxyXG4gICAgICAgICAgICAgICAgdmFyIG5hbWVQcm9wZXJ0eVByZWNlZGVuY2UgPSBOdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGtleSBpbiBwcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBwcm9wZXJ0aWVzW2tleV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxvd2VyS2V5ID0ga2V5LnRvTG93ZXJDYXNlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmFtZVByb3BlcnR5UHJlY2VkZW5jZSA+IDEgJiYgbG93ZXJLZXkgPT09ICd0aXRsZScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVQcm9wZXJ0eVByZWNlZGVuY2UgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZVByb3BlcnR5ID0ga2V5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmFtZVByb3BlcnR5UHJlY2VkZW5jZSA+IDIgJiYgbG93ZXJLZXkgPT09ICduYW1lJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZVByb3BlcnR5UHJlY2VkZW5jZSA9IDI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lUHJvcGVydHkgPSBrZXk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmFtZVByb3BlcnR5UHJlY2VkZW5jZSA+IDMgJiYgL3RpdGxlL2kudGVzdChrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lUHJvcGVydHlQcmVjZWRlbmNlID0gMztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVQcm9wZXJ0eSA9IGtleTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChuYW1lUHJvcGVydHlQcmVjZWRlbmNlID4gNCAmJiAvbmFtZS9pLnRlc3Qoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZVByb3BlcnR5UHJlY2VkZW5jZSA9IDQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lUHJvcGVydHkgPSBrZXk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZGVmaW5lZChuYW1lUHJvcGVydHkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW50aXR5Lm5hbWUgPSBwcm9wZXJ0aWVzW25hbWVQcm9wZXJ0eV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBkZXNjcmlwdGlvbiA9IHByb3BlcnRpZXMuZGVzY3JpcHRpb247XHJcbiAgICAgICAgICAgIGlmIChkZXNjcmlwdGlvbiAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgZW50aXR5LmRlc2NyaXB0aW9uID0gIWRlZmluZWQoZGVzY3JpcHRpb24pID8gZGVzY3JpYmUocHJvcGVydGllcywgbmFtZVByb3BlcnR5KSA6IG5ldyBDb25zdGFudFByb3BlcnR5KGRlc2NyaXB0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZW50aXR5O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNvb3JkaW5hdGVzQXJyYXlUb0NhcnRlc2lhbkFycmF5KGNvb3JkaW5hdGVzLCBjcnNGdW5jdGlvbikge1xyXG4gICAgICAgIHZhciBwb3NpdGlvbnMgPSBuZXcgQXJyYXkoY29vcmRpbmF0ZXMubGVuZ3RoKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb3JkaW5hdGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uc1tpXSA9IGNyc0Z1bmN0aW9uKGNvb3JkaW5hdGVzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBvc2l0aW9ucztcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZ2VvSnNvbk9iamVjdFR5cGVzID0ge1xyXG4gICAgICAgIEZlYXR1cmUgOiBwcm9jZXNzRmVhdHVyZSxcclxuICAgICAgICBGZWF0dXJlQ29sbGVjdGlvbiA6IHByb2Nlc3NGZWF0dXJlQ29sbGVjdGlvbixcclxuICAgICAgICBHZW9tZXRyeUNvbGxlY3Rpb24gOiBwcm9jZXNzR2VvbWV0cnlDb2xsZWN0aW9uLFxyXG4gICAgICAgIExpbmVTdHJpbmcgOiBwcm9jZXNzTGluZVN0cmluZyxcclxuICAgICAgICBNdWx0aUxpbmVTdHJpbmcgOiBwcm9jZXNzTXVsdGlMaW5lU3RyaW5nLFxyXG4gICAgICAgIE11bHRpUG9pbnQgOiBwcm9jZXNzTXVsdGlQb2ludCxcclxuICAgICAgICBNdWx0aVBvbHlnb24gOiBwcm9jZXNzTXVsdGlQb2x5Z29uLFxyXG4gICAgICAgIFBvaW50IDogcHJvY2Vzc1BvaW50LFxyXG4gICAgICAgIFBvbHlnb24gOiBwcm9jZXNzUG9seWdvbixcclxuICAgICAgICBUb3BvbG9neSA6IHByb2Nlc3NUb3BvbG9neVxyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgZ2VvbWV0cnlUeXBlcyA9IHtcclxuICAgICAgICBHZW9tZXRyeUNvbGxlY3Rpb24gOiBwcm9jZXNzR2VvbWV0cnlDb2xsZWN0aW9uLFxyXG4gICAgICAgIExpbmVTdHJpbmcgOiBwcm9jZXNzTGluZVN0cmluZyxcclxuICAgICAgICBNdWx0aUxpbmVTdHJpbmcgOiBwcm9jZXNzTXVsdGlMaW5lU3RyaW5nLFxyXG4gICAgICAgIE11bHRpUG9pbnQgOiBwcm9jZXNzTXVsdGlQb2ludCxcclxuICAgICAgICBNdWx0aVBvbHlnb24gOiBwcm9jZXNzTXVsdGlQb2x5Z29uLFxyXG4gICAgICAgIFBvaW50IDogcHJvY2Vzc1BvaW50LFxyXG4gICAgICAgIFBvbHlnb24gOiBwcm9jZXNzUG9seWdvbixcclxuICAgICAgICBUb3BvbG9neSA6IHByb2Nlc3NUb3BvbG9neVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBHZW9KU09OIHByb2Nlc3NpbmcgZnVuY3Rpb25zXHJcbiAgICBmdW5jdGlvbiBwcm9jZXNzRmVhdHVyZShkYXRhU291cmNlLCBmZWF0dXJlLCBub3RVc2VkLCBjcnNGdW5jdGlvbiwgb3B0aW9ucykge1xyXG4gICAgICAgIGlmIChmZWF0dXJlLmdlb21ldHJ5ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIC8vTnVsbCBnZW9tZXRyeSBpcyBhbGxvd2VkLCBzbyBqdXN0IGNyZWF0ZSBhbiBlbXB0eSBlbnRpdHkgaW5zdGFuY2UgZm9yIGl0LlxyXG4gICAgICAgICAgICBjcmVhdGVPYmplY3QoZmVhdHVyZSwgZGF0YVNvdXJjZS5fZW50aXR5Q29sbGVjdGlvbiwgb3B0aW9ucy5kZXNjcmliZSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghZGVmaW5lZChmZWF0dXJlLmdlb21ldHJ5KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgUnVudGltZUVycm9yKCdmZWF0dXJlLmdlb21ldHJ5IGlzIHJlcXVpcmVkLicpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGdlb21ldHJ5VHlwZSA9IGZlYXR1cmUuZ2VvbWV0cnkudHlwZTtcclxuICAgICAgICB2YXIgZ2VvbWV0cnlIYW5kbGVyID0gZ2VvbWV0cnlUeXBlc1tnZW9tZXRyeVR5cGVdO1xyXG4gICAgICAgIGlmICghZGVmaW5lZChnZW9tZXRyeUhhbmRsZXIpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3IoJ1Vua25vd24gZ2VvbWV0cnkgdHlwZTogJyArIGdlb21ldHJ5VHlwZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdlb21ldHJ5SGFuZGxlcihkYXRhU291cmNlLCBmZWF0dXJlLCBmZWF0dXJlLmdlb21ldHJ5LCBjcnNGdW5jdGlvbiwgb3B0aW9ucyk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcHJvY2Vzc0ZlYXR1cmVDb2xsZWN0aW9uKGRhdGFTb3VyY2UsIGZlYXR1cmVDb2xsZWN0aW9uLCBub3RVc2VkLCBjcnNGdW5jdGlvbiwgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBmZWF0dXJlcyA9IGZlYXR1cmVDb2xsZWN0aW9uLmZlYXR1cmVzO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBmZWF0dXJlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICBwcm9jZXNzRmVhdHVyZShkYXRhU291cmNlLCBmZWF0dXJlc1tpXSwgdW5kZWZpbmVkLCBjcnNGdW5jdGlvbiwgb3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHByb2Nlc3NHZW9tZXRyeUNvbGxlY3Rpb24oZGF0YVNvdXJjZSwgZ2VvSnNvbiwgZ2VvbWV0cnlDb2xsZWN0aW9uLCBjcnNGdW5jdGlvbiwgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBnZW9tZXRyaWVzID0gZ2VvbWV0cnlDb2xsZWN0aW9uLmdlb21ldHJpZXM7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGdlb21ldHJpZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGdlb21ldHJ5ID0gZ2VvbWV0cmllc1tpXTtcclxuICAgICAgICAgICAgdmFyIGdlb21ldHJ5VHlwZSA9IGdlb21ldHJ5LnR5cGU7XHJcbiAgICAgICAgICAgIHZhciBnZW9tZXRyeUhhbmRsZXIgPSBnZW9tZXRyeVR5cGVzW2dlb21ldHJ5VHlwZV07XHJcbiAgICAgICAgICAgIGlmICghZGVmaW5lZChnZW9tZXRyeUhhbmRsZXIpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUnVudGltZUVycm9yKCdVbmtub3duIGdlb21ldHJ5IHR5cGU6ICcgKyBnZW9tZXRyeVR5cGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGdlb21ldHJ5SGFuZGxlcihkYXRhU291cmNlLCBnZW9Kc29uLCBnZW9tZXRyeSwgY3JzRnVuY3Rpb24sIG9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVQb2ludChkYXRhU291cmNlLCBnZW9Kc29uLCBjcnNGdW5jdGlvbiwgY29vcmRpbmF0ZXMsIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgc3ltYm9sID0gb3B0aW9ucy5tYXJrZXJTeW1ib2w7XHJcbiAgICAgICAgdmFyIGNvbG9yID0gb3B0aW9ucy5tYXJrZXJDb2xvcjtcclxuICAgICAgICB2YXIgc2l6ZSA9IG9wdGlvbnMubWFya2VyU2l6ZTtcclxuXHJcbiAgICAgICAgdmFyIHByb3BlcnRpZXMgPSBnZW9Kc29uLnByb3BlcnRpZXM7XHJcbiAgICAgICAgaWYgKGRlZmluZWQocHJvcGVydGllcykpIHtcclxuICAgICAgICAgICAgdmFyIGNzc0NvbG9yID0gcHJvcGVydGllc1snbWFya2VyLWNvbG9yJ107XHJcbiAgICAgICAgICAgIGlmIChkZWZpbmVkKGNzc0NvbG9yKSkge1xyXG4gICAgICAgICAgICAgICAgY29sb3IgPSBDb2xvci5mcm9tQ3NzQ29sb3JTdHJpbmcoY3NzQ29sb3IpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBzaXplID0gZGVmYXVsdFZhbHVlKHNpemVzW3Byb3BlcnRpZXNbJ21hcmtlci1zaXplJ11dLCBzaXplKTtcclxuICAgICAgICAgICAgdmFyIG1hcmtlclN5bWJvbCA9IHByb3BlcnRpZXNbJ21hcmtlci1zeW1ib2wnXTtcclxuICAgICAgICAgICAgaWYgKGRlZmluZWQobWFya2VyU3ltYm9sKSkge1xyXG4gICAgICAgICAgICAgICAgc3ltYm9sID0gbWFya2VyU3ltYm9sO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgY2FudmFzT3JQcm9taXNlO1xyXG4gICAgICAgIGlmIChkZWZpbmVkKHN5bWJvbCkpIHtcclxuICAgICAgICAgICAgaWYgKHN5bWJvbC5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgICAgIGNhbnZhc09yUHJvbWlzZSA9IGRhdGFTb3VyY2UuX3BpbkJ1aWxkZXIuZnJvbVRleHQoc3ltYm9sLnRvVXBwZXJDYXNlKCksIGNvbG9yLCBzaXplKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNhbnZhc09yUHJvbWlzZSA9IGRhdGFTb3VyY2UuX3BpbkJ1aWxkZXIuZnJvbU1ha2lJY29uSWQoc3ltYm9sLCBjb2xvciwgc2l6ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjYW52YXNPclByb21pc2UgPSBkYXRhU291cmNlLl9waW5CdWlsZGVyLmZyb21Db2xvcihjb2xvciwgc2l6ZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgYmlsbGJvYXJkID0gbmV3IEJpbGxib2FyZEdyYXBoaWNzKCk7XHJcbiAgICAgICAgYmlsbGJvYXJkLnZlcnRpY2FsT3JpZ2luID0gbmV3IENvbnN0YW50UHJvcGVydHkoVmVydGljYWxPcmlnaW4uQk9UVE9NKTtcclxuXHJcbiAgICAgICAgLy8gQ2xhbXAgdG8gZ3JvdW5kIGlmIHRoZXJlIGlzbid0IGEgaGVpZ2h0IHNwZWNpZmllZFxyXG4gICAgICAgIGlmIChjb29yZGluYXRlcy5sZW5ndGggPT09IDIgJiYgb3B0aW9ucy5jbGFtcFRvR3JvdW5kKSB7XHJcbiAgICAgICAgICAgIGJpbGxib2FyZC5oZWlnaHRSZWZlcmVuY2UgPSBIZWlnaHRSZWZlcmVuY2UuQ0xBTVBfVE9fR1JPVU5EO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGVudGl0eSA9IGNyZWF0ZU9iamVjdChnZW9Kc29uLCBkYXRhU291cmNlLl9lbnRpdHlDb2xsZWN0aW9uLCBvcHRpb25zLmRlc2NyaWJlKTtcclxuICAgICAgICBlbnRpdHkuYmlsbGJvYXJkID0gYmlsbGJvYXJkO1xyXG4gICAgICAgIGVudGl0eS5wb3NpdGlvbiA9IG5ldyBDb25zdGFudFBvc2l0aW9uUHJvcGVydHkoY3JzRnVuY3Rpb24oY29vcmRpbmF0ZXMpKTtcclxuXHJcbiAgICAgICAgdmFyIHByb21pc2UgPSB3aGVuKGNhbnZhc09yUHJvbWlzZSkudGhlbihmdW5jdGlvbihpbWFnZSkge1xyXG4gICAgICAgICAgICBiaWxsYm9hcmQuaW1hZ2UgPSBuZXcgQ29uc3RhbnRQcm9wZXJ0eShpbWFnZSk7XHJcbiAgICAgICAgfSkub3RoZXJ3aXNlKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBiaWxsYm9hcmQuaW1hZ2UgPSBuZXcgQ29uc3RhbnRQcm9wZXJ0eShkYXRhU291cmNlLl9waW5CdWlsZGVyLmZyb21Db2xvcihjb2xvciwgc2l6ZSkpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBkYXRhU291cmNlLl9wcm9taXNlcy5wdXNoKHByb21pc2UpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHByb2Nlc3NQb2ludChkYXRhU291cmNlLCBnZW9Kc29uLCBnZW9tZXRyeSwgY3JzRnVuY3Rpb24sIG9wdGlvbnMpIHtcclxuICAgICAgICBjcmVhdGVQb2ludChkYXRhU291cmNlLCBnZW9Kc29uLCBjcnNGdW5jdGlvbiwgZ2VvbWV0cnkuY29vcmRpbmF0ZXMsIG9wdGlvbnMpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHByb2Nlc3NNdWx0aVBvaW50KGRhdGFTb3VyY2UsIGdlb0pzb24sIGdlb21ldHJ5LCBjcnNGdW5jdGlvbiwgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBjb29yZGluYXRlcyA9IGdlb21ldHJ5LmNvb3JkaW5hdGVzO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29vcmRpbmF0ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY3JlYXRlUG9pbnQoZGF0YVNvdXJjZSwgZ2VvSnNvbiwgY3JzRnVuY3Rpb24sIGNvb3JkaW5hdGVzW2ldLCBvcHRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY3JlYXRlTGluZVN0cmluZyhkYXRhU291cmNlLCBnZW9Kc29uLCBjcnNGdW5jdGlvbiwgY29vcmRpbmF0ZXMsIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgbWF0ZXJpYWwgPSBvcHRpb25zLnBvbHlsaW5lU3Ryb2tlTWF0ZXJpYWxQcm9wZXJ0eTtcclxuICAgICAgICB2YXIgd2lkdGhQcm9wZXJ0eSA9IG9wdGlvbnMuc3Ryb2tlV2lkdGhQcm9wZXJ0eTtcclxuXHJcbiAgICAgICAgdmFyIHByb3BlcnRpZXMgPSBnZW9Kc29uLnByb3BlcnRpZXM7XHJcbiAgICAgICAgaWYgKGRlZmluZWQocHJvcGVydGllcykpIHtcclxuICAgICAgICAgICAgdmFyIHdpZHRoID0gcHJvcGVydGllc1snc3Ryb2tlLXdpZHRoJ107XHJcbiAgICAgICAgICAgIGlmIChkZWZpbmVkKHdpZHRoKSkge1xyXG4gICAgICAgICAgICAgICAgd2lkdGhQcm9wZXJ0eSA9IG5ldyBDb25zdGFudFByb3BlcnR5KHdpZHRoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGNvbG9yO1xyXG4gICAgICAgICAgICB2YXIgc3Ryb2tlID0gcHJvcGVydGllcy5zdHJva2U7XHJcbiAgICAgICAgICAgIGlmIChkZWZpbmVkKHN0cm9rZSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbG9yID0gQ29sb3IuZnJvbUNzc0NvbG9yU3RyaW5nKHN0cm9rZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIG9wYWNpdHkgPSBwcm9wZXJ0aWVzWydzdHJva2Utb3BhY2l0eSddO1xyXG4gICAgICAgICAgICBpZiAoZGVmaW5lZChvcGFjaXR5KSAmJiBvcGFjaXR5ICE9PSAxLjApIHtcclxuICAgICAgICAgICAgICAgIGlmICghZGVmaW5lZChjb2xvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb2xvciA9IG1hdGVyaWFsLmNvbG9yLmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb2xvci5hbHBoYSA9IG9wYWNpdHk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRlZmluZWQoY29sb3IpKSB7XHJcbiAgICAgICAgICAgICAgICBtYXRlcmlhbCA9IG5ldyBDb2xvck1hdGVyaWFsUHJvcGVydHkoY29sb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgZW50aXR5ID0gY3JlYXRlT2JqZWN0KGdlb0pzb24sIGRhdGFTb3VyY2UuX2VudGl0eUNvbGxlY3Rpb24sIG9wdGlvbnMuZGVzY3JpYmUpO1xyXG4gICAgICAgIHZhciBwb2x5bGluZUdyYXBoaWNzID0gbmV3IFBvbHlsaW5lR3JhcGhpY3MoKTtcclxuICAgICAgICBlbnRpdHkucG9seWxpbmUgPSBwb2x5bGluZUdyYXBoaWNzO1xyXG5cclxuICAgICAgICBwb2x5bGluZUdyYXBoaWNzLmNsYW1wVG9Hcm91bmQgPSBvcHRpb25zLmNsYW1wVG9Hcm91bmQ7XHJcbiAgICAgICAgcG9seWxpbmVHcmFwaGljcy5tYXRlcmlhbCA9IG1hdGVyaWFsO1xyXG4gICAgICAgIHBvbHlsaW5lR3JhcGhpY3Mud2lkdGggPSB3aWR0aFByb3BlcnR5O1xyXG4gICAgICAgIHBvbHlsaW5lR3JhcGhpY3MucG9zaXRpb25zID0gbmV3IENvbnN0YW50UHJvcGVydHkoY29vcmRpbmF0ZXNBcnJheVRvQ2FydGVzaWFuQXJyYXkoY29vcmRpbmF0ZXMsIGNyc0Z1bmN0aW9uKSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcHJvY2Vzc0xpbmVTdHJpbmcoZGF0YVNvdXJjZSwgZ2VvSnNvbiwgZ2VvbWV0cnksIGNyc0Z1bmN0aW9uLCBvcHRpb25zKSB7XHJcbiAgICAgICAgY3JlYXRlTGluZVN0cmluZyhkYXRhU291cmNlLCBnZW9Kc29uLCBjcnNGdW5jdGlvbiwgZ2VvbWV0cnkuY29vcmRpbmF0ZXMsIG9wdGlvbnMpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHByb2Nlc3NNdWx0aUxpbmVTdHJpbmcoZGF0YVNvdXJjZSwgZ2VvSnNvbiwgZ2VvbWV0cnksIGNyc0Z1bmN0aW9uLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIGxpbmVTdHJpbmdzID0gZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lU3RyaW5ncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjcmVhdGVMaW5lU3RyaW5nKGRhdGFTb3VyY2UsIGdlb0pzb24sIGNyc0Z1bmN0aW9uLCBsaW5lU3RyaW5nc1tpXSwgb3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZVBvbHlnb24oZGF0YVNvdXJjZSwgZ2VvSnNvbiwgY3JzRnVuY3Rpb24sIGNvb3JkaW5hdGVzLCBvcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKGNvb3JkaW5hdGVzLmxlbmd0aCA9PT0gMCB8fCBjb29yZGluYXRlc1swXS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIG91dGxpbmVDb2xvclByb3BlcnR5ID0gb3B0aW9ucy5wb2x5Z29uU3Ryb2tlQ29sb3I7XHJcbiAgICAgICAgdmFyIG1hdGVyaWFsID0gb3B0aW9ucy5maWxsTWF0ZXJpYWxQcm9wZXJ0eTtcclxuICAgICAgICB2YXIgd2lkdGhQcm9wZXJ0eSA9IG9wdGlvbnMuc3Ryb2tlV2lkdGhQcm9wZXJ0eTtcclxuXHJcbiAgICAgICAgdmFyIHByb3BlcnRpZXMgPSBnZW9Kc29uLnByb3BlcnRpZXM7XHJcbiAgICAgICAgaWYgKGRlZmluZWQocHJvcGVydGllcykpIHtcclxuICAgICAgICAgICAgdmFyIHdpZHRoID0gcHJvcGVydGllc1snc3Ryb2tlLXdpZHRoJ107XHJcbiAgICAgICAgICAgIGlmIChkZWZpbmVkKHdpZHRoKSkge1xyXG4gICAgICAgICAgICAgICAgd2lkdGhQcm9wZXJ0eSA9IG5ldyBDb25zdGFudFByb3BlcnR5KHdpZHRoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGNvbG9yO1xyXG4gICAgICAgICAgICB2YXIgc3Ryb2tlID0gcHJvcGVydGllcy5zdHJva2U7XHJcbiAgICAgICAgICAgIGlmIChkZWZpbmVkKHN0cm9rZSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbG9yID0gQ29sb3IuZnJvbUNzc0NvbG9yU3RyaW5nKHN0cm9rZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIG9wYWNpdHkgPSBwcm9wZXJ0aWVzWydzdHJva2Utb3BhY2l0eSddO1xyXG4gICAgICAgICAgICBpZiAoZGVmaW5lZChvcGFjaXR5KSAmJiBvcGFjaXR5ICE9PSAxLjApIHtcclxuICAgICAgICAgICAgICAgIGlmICghZGVmaW5lZChjb2xvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb2xvciA9IG9wdGlvbnMucG9seWdvblN0cm9rZUNvbG9yLmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb2xvci5hbHBoYSA9IG9wYWNpdHk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChkZWZpbmVkKGNvbG9yKSkge1xyXG4gICAgICAgICAgICAgICAgb3V0bGluZUNvbG9yUHJvcGVydHkgPSBuZXcgQ29uc3RhbnRQcm9wZXJ0eShjb2xvcik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBmaWxsQ29sb3I7XHJcbiAgICAgICAgICAgIHZhciBmaWxsID0gcHJvcGVydGllcy5maWxsO1xyXG4gICAgICAgICAgICBpZiAoZGVmaW5lZChmaWxsKSkge1xyXG4gICAgICAgICAgICAgICAgZmlsbENvbG9yID0gQ29sb3IuZnJvbUNzc0NvbG9yU3RyaW5nKGZpbGwpO1xyXG4gICAgICAgICAgICAgICAgZmlsbENvbG9yLmFscGhhID0gbWF0ZXJpYWwuY29sb3IuYWxwaGE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3BhY2l0eSA9IHByb3BlcnRpZXNbJ2ZpbGwtb3BhY2l0eSddO1xyXG4gICAgICAgICAgICBpZiAoZGVmaW5lZChvcGFjaXR5KSAmJiBvcGFjaXR5ICE9PSBtYXRlcmlhbC5jb2xvci5hbHBoYSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFkZWZpbmVkKGZpbGxDb2xvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICBmaWxsQ29sb3IgPSBtYXRlcmlhbC5jb2xvci5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZmlsbENvbG9yLmFscGhhID0gb3BhY2l0eTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZGVmaW5lZChmaWxsQ29sb3IpKSB7XHJcbiAgICAgICAgICAgICAgICBtYXRlcmlhbCA9IG5ldyBDb2xvck1hdGVyaWFsUHJvcGVydHkoZmlsbENvbG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHBvbHlnb24gPSBuZXcgUG9seWdvbkdyYXBoaWNzKCk7XHJcbiAgICAgICAgcG9seWdvbi5vdXRsaW5lID0gbmV3IENvbnN0YW50UHJvcGVydHkodHJ1ZSk7XHJcbiAgICAgICAgcG9seWdvbi5vdXRsaW5lQ29sb3IgPSBvdXRsaW5lQ29sb3JQcm9wZXJ0eTtcclxuICAgICAgICBwb2x5Z29uLm91dGxpbmVXaWR0aCA9IHdpZHRoUHJvcGVydHk7XHJcbiAgICAgICAgcG9seWdvbi5tYXRlcmlhbCA9IG1hdGVyaWFsO1xyXG5cclxuICAgICAgICB2YXIgaG9sZXMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMSwgbGVuID0gY29vcmRpbmF0ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgaG9sZXMucHVzaChuZXcgUG9seWdvbkhpZXJhcmNoeShjb29yZGluYXRlc0FycmF5VG9DYXJ0ZXNpYW5BcnJheShjb29yZGluYXRlc1tpXSwgY3JzRnVuY3Rpb24pKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgcG9zaXRpb25zID0gY29vcmRpbmF0ZXNbMF07XHJcbiAgICAgICAgcG9seWdvbi5oaWVyYXJjaHkgPSBuZXcgQ29uc3RhbnRQcm9wZXJ0eShuZXcgUG9seWdvbkhpZXJhcmNoeShjb29yZGluYXRlc0FycmF5VG9DYXJ0ZXNpYW5BcnJheShwb3NpdGlvbnMsIGNyc0Z1bmN0aW9uKSwgaG9sZXMpKTtcclxuICAgICAgICBpZiAocG9zaXRpb25zWzBdLmxlbmd0aCA+IDIpIHtcclxuICAgICAgICAgICAgcG9seWdvbi5wZXJQb3NpdGlvbkhlaWdodCA9IG5ldyBDb25zdGFudFByb3BlcnR5KHRydWUpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoIW9wdGlvbnMuY2xhbXBUb0dyb3VuZCkge1xyXG4gICAgICAgICAgICBwb2x5Z29uLmhlaWdodCA9IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgZW50aXR5ID0gY3JlYXRlT2JqZWN0KGdlb0pzb24sIGRhdGFTb3VyY2UuX2VudGl0eUNvbGxlY3Rpb24sIG9wdGlvbnMuZGVzY3JpYmUpO1xyXG4gICAgICAgIGVudGl0eS5wb2x5Z29uID0gcG9seWdvbjtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBwcm9jZXNzUG9seWdvbihkYXRhU291cmNlLCBnZW9Kc29uLCBnZW9tZXRyeSwgY3JzRnVuY3Rpb24sIG9wdGlvbnMpIHtcclxuICAgICAgICBjcmVhdGVQb2x5Z29uKGRhdGFTb3VyY2UsIGdlb0pzb24sIGNyc0Z1bmN0aW9uLCBnZW9tZXRyeS5jb29yZGluYXRlcywgb3B0aW9ucyk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcHJvY2Vzc011bHRpUG9seWdvbihkYXRhU291cmNlLCBnZW9Kc29uLCBnZW9tZXRyeSwgY3JzRnVuY3Rpb24sIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgcG9seWdvbnMgPSBnZW9tZXRyeS5jb29yZGluYXRlcztcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvbHlnb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNyZWF0ZVBvbHlnb24oZGF0YVNvdXJjZSwgZ2VvSnNvbiwgY3JzRnVuY3Rpb24sIHBvbHlnb25zW2ldLCBvcHRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcHJvY2Vzc1RvcG9sb2d5KGRhdGFTb3VyY2UsIGdlb0pzb24sIGdlb21ldHJ5LCBjcnNGdW5jdGlvbiwgb3B0aW9ucykge1xyXG4gICAgICAgIGZvciAoIHZhciBwcm9wZXJ0eSBpbiBnZW9tZXRyeS5vYmplY3RzKSB7XHJcbiAgICAgICAgICAgIGlmIChnZW9tZXRyeS5vYmplY3RzLmhhc093blByb3BlcnR5KHByb3BlcnR5KSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGZlYXR1cmUgPSB0b3BvanNvbi5mZWF0dXJlKGdlb21ldHJ5LCBnZW9tZXRyeS5vYmplY3RzW3Byb3BlcnR5XSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgdHlwZUhhbmRsZXIgPSBnZW9Kc29uT2JqZWN0VHlwZXNbZmVhdHVyZS50eXBlXTtcclxuICAgICAgICAgICAgICAgIHR5cGVIYW5kbGVyKGRhdGFTb3VyY2UsIGZlYXR1cmUsIGZlYXR1cmUsIGNyc0Z1bmN0aW9uLCBvcHRpb25zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEEge0BsaW5rIERhdGFTb3VyY2V9IHdoaWNoIHByb2Nlc3NlcyBib3RoXHJcbiAgICAgKiB7QGxpbmsgaHR0cDovL3d3dy5nZW9qc29uLm9yZy98R2VvSlNPTn0gYW5kIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vbWJvc3RvY2svdG9wb2pzb258VG9wb0pTT059IGRhdGEuXHJcbiAgICAgKiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL21hcGJveC9zaW1wbGVzdHlsZS1zcGVjfHNpbXBsZXN0eWxlLXNwZWN9IHByb3BlcnRpZXMgd2lsbCBhbHNvIGJlIHVzZWQgaWYgdGhleVxyXG4gICAgICogYXJlIHByZXNlbnQuXHJcbiAgICAgKlxyXG4gICAgICogQGFsaWFzIEdlb0pzb25EYXRhU291cmNlXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW25hbWVdIFRoZSBuYW1lIG9mIHRoaXMgZGF0YSBzb3VyY2UuICBJZiB1bmRlZmluZWQsIGEgbmFtZSB3aWxsIGJlIHRha2VuIGZyb21cclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgdGhlIG5hbWUgb2YgdGhlIEdlb0pTT04gZmlsZS5cclxuICAgICAqXHJcbiAgICAgKiBAZGVtbyB7QGxpbmsgaHR0cHM6Ly9jZXNpdW1qcy5vcmcvQ2VzaXVtL0FwcHMvU2FuZGNhc3RsZS9pbmRleC5odG1sP3NyYz1HZW9KU09OJTIwYW5kJTIwVG9wb0pTT04uaHRtbHxDZXNpdW0gU2FuZGNhc3RsZSBHZW9KU09OIGFuZCBUb3BvSlNPTiBEZW1vfVxyXG4gICAgICogQGRlbW8ge0BsaW5rIGh0dHBzOi8vY2VzaXVtanMub3JnL0Nlc2l1bS9BcHBzL1NhbmRjYXN0bGUvaW5kZXguaHRtbD9zcmM9R2VvSlNPTiUyMHNpbXBsZXN0eWxlLmh0bWx8Q2VzaXVtIFNhbmRjYXN0bGUgR2VvSlNPTiBzaW1wbGVzdHlsZSBEZW1vfVxyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiB2YXIgdmlld2VyID0gbmV3IENlc2l1bS5WaWV3ZXIoJ2Nlc2l1bUNvbnRhaW5lcicpO1xyXG4gICAgICogdmlld2VyLmRhdGFTb3VyY2VzLmFkZChDZXNpdW0uR2VvSnNvbkRhdGFTb3VyY2UubG9hZCgnLi4vLi4vU2FtcGxlRGF0YS9uZV8xMG1fdXNfc3RhdGVzLnRvcG9qc29uJywge1xyXG4gICAgICogICBzdHJva2U6IENlc2l1bS5Db2xvci5IT1RQSU5LLFxyXG4gICAgICogICBmaWxsOiBDZXNpdW0uQ29sb3IuUElOSyxcclxuICAgICAqICAgc3Ryb2tlV2lkdGg6IDMsXHJcbiAgICAgKiAgIG1hcmtlclN5bWJvbDogJz8nXHJcbiAgICAgKiB9KSk7XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIEdlb0pzb25EYXRhU291cmNlKG5hbWUpIHtcclxuICAgICAgICB0aGlzLl9uYW1lID0gbmFtZTtcclxuICAgICAgICB0aGlzLl9jaGFuZ2VkID0gbmV3IEV2ZW50KCk7XHJcbiAgICAgICAgdGhpcy5fZXJyb3IgPSBuZXcgRXZlbnQoKTtcclxuICAgICAgICB0aGlzLl9pc0xvYWRpbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9sb2FkaW5nID0gbmV3IEV2ZW50KCk7XHJcbiAgICAgICAgdGhpcy5fZW50aXR5Q29sbGVjdGlvbiA9IG5ldyBFbnRpdHlDb2xsZWN0aW9uKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuX3Byb21pc2VzID0gW107XHJcbiAgICAgICAgdGhpcy5fcGluQnVpbGRlciA9IG5ldyBQaW5CdWlsZGVyKCk7XHJcbiAgICAgICAgdGhpcy5fZW50aXR5Q2x1c3RlciA9IG5ldyBFbnRpdHlDbHVzdGVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgUHJvbWlzZSB0byBhIG5ldyBpbnN0YW5jZSBsb2FkZWQgd2l0aCB0aGUgcHJvdmlkZWQgR2VvSlNPTiBvciBUb3BvSlNPTiBkYXRhLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UmVzb3VyY2V8U3RyaW5nfE9iamVjdH0gZGF0YSBBIHVybCwgR2VvSlNPTiBvYmplY3QsIG9yIFRvcG9KU09OIG9iamVjdCB0byBiZSBsb2FkZWQuXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5zb3VyY2VVcmldIE92ZXJyaWRlcyB0aGUgdXJsIHRvIHVzZSBmb3IgcmVzb2x2aW5nIHJlbGF0aXZlIGxpbmtzLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1hcmtlclNpemU9R2VvSnNvbkRhdGFTb3VyY2UubWFya2VyU2l6ZV0gVGhlIGRlZmF1bHQgc2l6ZSBvZiB0aGUgbWFwIHBpbiBjcmVhdGVkIGZvciBlYWNoIHBvaW50LCBpbiBwaXhlbHMuXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMubWFya2VyU3ltYm9sPUdlb0pzb25EYXRhU291cmNlLm1hcmtlclN5bWJvbF0gVGhlIGRlZmF1bHQgc3ltYm9sIG9mIHRoZSBtYXAgcGluIGNyZWF0ZWQgZm9yIGVhY2ggcG9pbnQuXHJcbiAgICAgKiBAcGFyYW0ge0NvbG9yfSBbb3B0aW9ucy5tYXJrZXJDb2xvcj1HZW9Kc29uRGF0YVNvdXJjZS5tYXJrZXJDb2xvcl0gVGhlIGRlZmF1bHQgY29sb3Igb2YgdGhlIG1hcCBwaW4gY3JlYXRlZCBmb3IgZWFjaCBwb2ludC5cclxuICAgICAqIEBwYXJhbSB7Q29sb3J9IFtvcHRpb25zLnN0cm9rZT1HZW9Kc29uRGF0YVNvdXJjZS5zdHJva2VdIFRoZSBkZWZhdWx0IGNvbG9yIG9mIHBvbHlsaW5lcyBhbmQgcG9seWdvbiBvdXRsaW5lcy5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zdHJva2VXaWR0aD1HZW9Kc29uRGF0YVNvdXJjZS5zdHJva2VXaWR0aF0gVGhlIGRlZmF1bHQgd2lkdGggb2YgcG9seWxpbmVzIGFuZCBwb2x5Z29uIG91dGxpbmVzLlxyXG4gICAgICogQHBhcmFtIHtDb2xvcn0gW29wdGlvbnMuZmlsbD1HZW9Kc29uRGF0YVNvdXJjZS5maWxsXSBUaGUgZGVmYXVsdCBjb2xvciBmb3IgcG9seWdvbiBpbnRlcmlvcnMuXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNsYW1wVG9Hcm91bmQ9R2VvSnNvbkRhdGFTb3VyY2UuY2xhbXBUb0dyb3VuZF0gdHJ1ZSBpZiB3ZSB3YW50IHRoZSBnZW9tZXRyeSBmZWF0dXJlcyAocG9seWdvbnMgb3IgbGluZXN0cmluZ3MpIGNsYW1wZWQgdG8gdGhlIGdyb3VuZC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZS48R2VvSnNvbkRhdGFTb3VyY2U+fSBBIHByb21pc2UgdGhhdCB3aWxsIHJlc29sdmUgd2hlbiB0aGUgZGF0YSBpcyBsb2FkZWQuXHJcbiAgICAgKi9cclxuICAgIEdlb0pzb25EYXRhU291cmNlLmxvYWQgPSBmdW5jdGlvbihkYXRhLCBvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBHZW9Kc29uRGF0YVNvdXJjZSgpLmxvYWQoZGF0YSwgb3B0aW9ucyk7XHJcbiAgICB9O1xyXG5cclxuICAgIGRlZmluZVByb3BlcnRpZXMoR2VvSnNvbkRhdGFTb3VyY2UsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGRlZmF1bHQgc2l6ZSBvZiB0aGUgbWFwIHBpbiBjcmVhdGVkIGZvciBlYWNoIHBvaW50LCBpbiBwaXhlbHMuXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEdlb0pzb25EYXRhU291cmNlXHJcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAgICAgKiBAZGVmYXVsdCA0OFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIG1hcmtlclNpemUgOiB7XHJcbiAgICAgICAgICAgIGdldCA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRNYXJrZXJTaXplO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzZXQgOiBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdE1hcmtlclNpemUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBkZWZhdWx0IHN5bWJvbCBvZiB0aGUgbWFwIHBpbiBjcmVhdGVkIGZvciBlYWNoIHBvaW50LlxyXG4gICAgICAgICAqIFRoaXMgY2FuIGJlIGFueSB2YWxpZCB7QGxpbmsgaHR0cDovL21hcGJveC5jb20vbWFraS98TWFraX0gaWRlbnRpZmllciwgYW55IHNpbmdsZSBjaGFyYWN0ZXIsXHJcbiAgICAgICAgICogb3IgYmxhbmsgaWYgbm8gc3ltYm9sIGlzIHRvIGJlIHVzZWQuXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEdlb0pzb25EYXRhU291cmNlXHJcbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cclxuICAgICAgICAgKi9cclxuICAgICAgICBtYXJrZXJTeW1ib2wgOiB7XHJcbiAgICAgICAgICAgIGdldCA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRNYXJrZXJTeW1ib2w7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNldCA6IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0TWFya2VyU3ltYm9sID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgZGVmYXVsdCBjb2xvciBvZiB0aGUgbWFwIHBpbiBjcmVhdGVkIGZvciBlYWNoIHBvaW50LlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBHZW9Kc29uRGF0YVNvdXJjZVxyXG4gICAgICAgICAqIEB0eXBlIHtDb2xvcn1cclxuICAgICAgICAgKiBAZGVmYXVsdCBDb2xvci5ST1lBTEJMVUVcclxuICAgICAgICAgKi9cclxuICAgICAgICBtYXJrZXJDb2xvciA6IHtcclxuICAgICAgICAgICAgZ2V0IDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdE1hcmtlckNvbG9yO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzZXQgOiBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdE1hcmtlckNvbG9yID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgZGVmYXVsdCBjb2xvciBvZiBwb2x5bGluZXMgYW5kIHBvbHlnb24gb3V0bGluZXMuXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEdlb0pzb25EYXRhU291cmNlXHJcbiAgICAgICAgICogQHR5cGUge0NvbG9yfVxyXG4gICAgICAgICAqIEBkZWZhdWx0IENvbG9yLkJMQUNLXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc3Ryb2tlIDoge1xyXG4gICAgICAgICAgICBnZXQgOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0U3Ryb2tlO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzZXQgOiBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdFN0cm9rZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGRlZmF1bHQgd2lkdGggb2YgcG9seWxpbmVzIGFuZCBwb2x5Z29uIG91dGxpbmVzLlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBHZW9Kc29uRGF0YVNvdXJjZVxyXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgICAgICogQGRlZmF1bHQgMi4wXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc3Ryb2tlV2lkdGggOiB7XHJcbiAgICAgICAgICAgIGdldCA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRTdHJva2VXaWR0aDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2V0IDogZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHRTdHJva2VXaWR0aCA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIG9yIHNldHMgZGVmYXVsdCBjb2xvciBmb3IgcG9seWdvbiBpbnRlcmlvcnMuXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEdlb0pzb25EYXRhU291cmNlXHJcbiAgICAgICAgICogQHR5cGUge0NvbG9yfVxyXG4gICAgICAgICAqIEBkZWZhdWx0IENvbG9yLllFTExPV1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZpbGwgOiB7XHJcbiAgICAgICAgICAgIGdldCA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRGaWxsO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzZXQgOiBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdEZpbGwgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBvciBzZXRzIGRlZmF1bHQgb2Ygd2hldGhlciB0byBjbGFtcCB0byB0aGUgZ3JvdW5kLlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBHZW9Kc29uRGF0YVNvdXJjZVxyXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2xhbXBUb0dyb3VuZCA6IHtcclxuICAgICAgICAgICAgZ2V0IDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdENsYW1wVG9Hcm91bmQ7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNldCA6IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0Q2xhbXBUb0dyb3VuZCA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBhbiBvYmplY3QgdGhhdCBtYXBzIHRoZSBuYW1lIG9mIGEgY3JzIHRvIGEgY2FsbGJhY2sgZnVuY3Rpb24gd2hpY2ggdGFrZXMgYSBHZW9KU09OIGNvb3JkaW5hdGVcclxuICAgICAgICAgKiBhbmQgdHJhbnNmb3JtcyBpdCBpbnRvIGEgV0dTODQgRWFydGgtZml4ZWQgQ2FydGVzaWFuLiAgT2xkZXIgdmVyc2lvbnMgb2YgR2VvSlNPTiB3aGljaFxyXG4gICAgICAgICAqIHN1cHBvcnRlZCB0aGUgRVBTRyB0eXBlIGNhbiBiZSBhZGRlZCB0byB0aGlzIGxpc3QgYXMgd2VsbCwgYnkgc3BlY2lmeWluZyB0aGUgY29tcGxldGUgRVBTRyBuYW1lLFxyXG4gICAgICAgICAqIGZvciBleGFtcGxlICdFUFNHOjQzMjYnLlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBHZW9Kc29uRGF0YVNvdXJjZVxyXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY3JzTmFtZXMgOiB7XHJcbiAgICAgICAgICAgIGdldCA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyc05hbWVzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBhbiBvYmplY3QgdGhhdCBtYXBzIHRoZSBocmVmIHByb3BlcnR5IG9mIGEgY3JzIGxpbmsgdG8gYSBjYWxsYmFjayBmdW5jdGlvblxyXG4gICAgICAgICAqIHdoaWNoIHRha2VzIHRoZSBjcnMgcHJvcGVydGllcyBvYmplY3QgYW5kIHJldHVybnMgYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXNcclxuICAgICAgICAgKiB0byBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBHZW9KU09OIGNvb3JkaW5hdGUgYW5kIHRyYW5zZm9ybXMgaXQgaW50byBhIFdHUzg0IEVhcnRoLWZpeGVkIENhcnRlc2lhbi5cclxuICAgICAgICAgKiBJdGVtcyBpbiB0aGlzIG9iamVjdCB0YWtlIHByZWNlZGVuY2Ugb3ZlciB0aG9zZSBkZWZpbmVkIGluIDxjb2RlPmNyc0xpbmtIcmVmczwvY29kZT4sIGFzc3VtaW5nXHJcbiAgICAgICAgICogdGhlIGxpbmsgaGFzIGEgdHlwZSBzcGVjaWZpZWQuXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEdlb0pzb25EYXRhU291cmNlXHJcbiAgICAgICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBjcnNMaW5rSHJlZnMgOiB7XHJcbiAgICAgICAgICAgIGdldCA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyc0xpbmtIcmVmcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgYW4gb2JqZWN0IHRoYXQgbWFwcyB0aGUgdHlwZSBwcm9wZXJ0eSBvZiBhIGNycyBsaW5rIHRvIGEgY2FsbGJhY2sgZnVuY3Rpb25cclxuICAgICAgICAgKiB3aGljaCB0YWtlcyB0aGUgY3JzIHByb3BlcnRpZXMgb2JqZWN0IGFuZCByZXR1cm5zIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzXHJcbiAgICAgICAgICogdG8gYSBmdW5jdGlvbiB0aGF0IHRha2VzIGEgR2VvSlNPTiBjb29yZGluYXRlIGFuZCB0cmFuc2Zvcm1zIGl0IGludG8gYSBXR1M4NCBFYXJ0aC1maXhlZCBDYXJ0ZXNpYW4uXHJcbiAgICAgICAgICogSXRlbXMgaW4gPGNvZGU+Y3JzTGlua0hyZWZzPC9jb2RlPiB0YWtlIHByZWNlZGVuY2Ugb3ZlciB0aGlzIG9iamVjdC5cclxuICAgICAgICAgKiBAbWVtYmVyb2YgR2VvSnNvbkRhdGFTb3VyY2VcclxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNyc0xpbmtUeXBlcyA6IHtcclxuICAgICAgICAgICAgZ2V0IDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JzTGlua1R5cGVzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgZGVmaW5lUHJvcGVydGllcyhHZW9Kc29uRGF0YVNvdXJjZS5wcm90b3R5cGUsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIG9yIHNldHMgYSBodW1hbi1yZWFkYWJsZSBuYW1lIGZvciB0aGlzIGluc3RhbmNlLlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBHZW9Kc29uRGF0YVNvdXJjZS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIG5hbWUgOiB7XHJcbiAgICAgICAgICAgIGdldCA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNldCA6IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbmFtZSAhPT0gdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9uYW1lID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlZC5yYWlzZUV2ZW50KHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIERhdGFTb3VyY2Ugb25seSBkZWZpbmVzIHN0YXRpYyBkYXRhLCB0aGVyZWZvcmUgdGhpcyBwcm9wZXJ0eSBpcyBhbHdheXMgdW5kZWZpbmVkLlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBHZW9Kc29uRGF0YVNvdXJjZS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAdHlwZSB7RGF0YVNvdXJjZUNsb2NrfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNsb2NrIDoge1xyXG4gICAgICAgICAgICB2YWx1ZSA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgd3JpdGFibGUgOiBmYWxzZVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgY29sbGVjdGlvbiBvZiB7QGxpbmsgRW50aXR5fSBpbnN0YW5jZXMuXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEdlb0pzb25EYXRhU291cmNlLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEB0eXBlIHtFbnRpdHlDb2xsZWN0aW9ufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGVudGl0aWVzIDoge1xyXG4gICAgICAgICAgICBnZXQgOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9lbnRpdHlDb2xsZWN0aW9uO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIGEgdmFsdWUgaW5kaWNhdGluZyBpZiB0aGUgZGF0YSBzb3VyY2UgaXMgY3VycmVudGx5IGxvYWRpbmcgZGF0YS5cclxuICAgICAgICAgKiBAbWVtYmVyb2YgR2VvSnNvbkRhdGFTb3VyY2UucHJvdG90eXBlXHJcbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaXNMb2FkaW5nIDoge1xyXG4gICAgICAgICAgICBnZXQgOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc0xvYWRpbmc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgYW4gZXZlbnQgdGhhdCB3aWxsIGJlIHJhaXNlZCB3aGVuIHRoZSB1bmRlcmx5aW5nIGRhdGEgY2hhbmdlcy5cclxuICAgICAgICAgKiBAbWVtYmVyb2YgR2VvSnNvbkRhdGFTb3VyY2UucHJvdG90eXBlXHJcbiAgICAgICAgICogQHR5cGUge0V2ZW50fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNoYW5nZWRFdmVudCA6IHtcclxuICAgICAgICAgICAgZ2V0IDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2hhbmdlZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBhbiBldmVudCB0aGF0IHdpbGwgYmUgcmFpc2VkIGlmIGFuIGVycm9yIGlzIGVuY291bnRlcmVkIGR1cmluZyBwcm9jZXNzaW5nLlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBHZW9Kc29uRGF0YVNvdXJjZS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAdHlwZSB7RXZlbnR9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZXJyb3JFdmVudCA6IHtcclxuICAgICAgICAgICAgZ2V0IDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZXJyb3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgYW4gZXZlbnQgdGhhdCB3aWxsIGJlIHJhaXNlZCB3aGVuIHRoZSBkYXRhIHNvdXJjZSBlaXRoZXIgc3RhcnRzIG9yIHN0b3BzIGxvYWRpbmcuXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEdlb0pzb25EYXRhU291cmNlLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEB0eXBlIHtFdmVudH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBsb2FkaW5nRXZlbnQgOiB7XHJcbiAgICAgICAgICAgIGdldCA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvYWRpbmc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgd2hldGhlciBvciBub3QgdGhpcyBkYXRhIHNvdXJjZSBzaG91bGQgYmUgZGlzcGxheWVkLlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBHZW9Kc29uRGF0YVNvdXJjZS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBzaG93IDoge1xyXG4gICAgICAgICAgICBnZXQgOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9lbnRpdHlDb2xsZWN0aW9uLnNob3c7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNldCA6IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9lbnRpdHlDb2xsZWN0aW9uLnNob3cgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgY2x1c3RlcmluZyBvcHRpb25zIGZvciB0aGlzIGRhdGEgc291cmNlLiBUaGlzIG9iamVjdCBjYW4gYmUgc2hhcmVkIGJldHdlZW4gbXVsdGlwbGUgZGF0YSBzb3VyY2VzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEdlb0pzb25EYXRhU291cmNlLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEB0eXBlIHtFbnRpdHlDbHVzdGVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNsdXN0ZXJpbmcgOiB7XHJcbiAgICAgICAgICAgIGdldCA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2VudGl0eUNsdXN0ZXI7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNldCA6IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFkZWZpbmVkKHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcigndmFsdWUgbXVzdCBiZSBkZWZpbmVkLicpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9lbnRpdHlDbHVzdGVyID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFzeW5jaHJvbm91c2x5IGxvYWRzIHRoZSBwcm92aWRlZCBHZW9KU09OIG9yIFRvcG9KU09OIGRhdGEsIHJlcGxhY2luZyBhbnkgZXhpc3RpbmcgZGF0YS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1Jlc291cmNlfFN0cmluZ3xPYmplY3R9IGRhdGEgQSB1cmwsIEdlb0pTT04gb2JqZWN0LCBvciBUb3BvSlNPTiBvYmplY3QgdG8gYmUgbG9hZGVkLlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuc291cmNlVXJpXSBPdmVycmlkZXMgdGhlIHVybCB0byB1c2UgZm9yIHJlc29sdmluZyByZWxhdGl2ZSBsaW5rcy5cclxuICAgICAqIEBwYXJhbSB7R2VvSnNvbkRhdGFTb3VyY2V+ZGVzY3JpYmV9IFtvcHRpb25zLmRlc2NyaWJlPUdlb0pzb25EYXRhU291cmNlLmRlZmF1bHREZXNjcmliZVByb3BlcnR5XSBBIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYSBQcm9wZXJ0eSBvYmplY3QgKG9yIGp1c3QgYSBzdHJpbmcpLFxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWNoIGNvbnZlcnRzIHRoZSBwcm9wZXJ0aWVzIGludG8gYW4gaHRtbCBkZXNjcmlwdGlvbi5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXJrZXJTaXplPUdlb0pzb25EYXRhU291cmNlLm1hcmtlclNpemVdIFRoZSBkZWZhdWx0IHNpemUgb2YgdGhlIG1hcCBwaW4gY3JlYXRlZCBmb3IgZWFjaCBwb2ludCwgaW4gcGl4ZWxzLlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLm1hcmtlclN5bWJvbD1HZW9Kc29uRGF0YVNvdXJjZS5tYXJrZXJTeW1ib2xdIFRoZSBkZWZhdWx0IHN5bWJvbCBvZiB0aGUgbWFwIHBpbiBjcmVhdGVkIGZvciBlYWNoIHBvaW50LlxyXG4gICAgICogQHBhcmFtIHtDb2xvcn0gW29wdGlvbnMubWFya2VyQ29sb3I9R2VvSnNvbkRhdGFTb3VyY2UubWFya2VyQ29sb3JdIFRoZSBkZWZhdWx0IGNvbG9yIG9mIHRoZSBtYXAgcGluIGNyZWF0ZWQgZm9yIGVhY2ggcG9pbnQuXHJcbiAgICAgKiBAcGFyYW0ge0NvbG9yfSBbb3B0aW9ucy5zdHJva2U9R2VvSnNvbkRhdGFTb3VyY2Uuc3Ryb2tlXSBUaGUgZGVmYXVsdCBjb2xvciBvZiBwb2x5bGluZXMgYW5kIHBvbHlnb24gb3V0bGluZXMuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc3Ryb2tlV2lkdGg9R2VvSnNvbkRhdGFTb3VyY2Uuc3Ryb2tlV2lkdGhdIFRoZSBkZWZhdWx0IHdpZHRoIG9mIHBvbHlsaW5lcyBhbmQgcG9seWdvbiBvdXRsaW5lcy5cclxuICAgICAqIEBwYXJhbSB7Q29sb3J9IFtvcHRpb25zLmZpbGw9R2VvSnNvbkRhdGFTb3VyY2UuZmlsbF0gVGhlIGRlZmF1bHQgY29sb3IgZm9yIHBvbHlnb24gaW50ZXJpb3JzLlxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jbGFtcFRvR3JvdW5kPUdlb0pzb25EYXRhU291cmNlLmNsYW1wVG9Hcm91bmRdIHRydWUgaWYgd2Ugd2FudCB0aGUgZmVhdHVyZXMgY2xhbXBlZCB0byB0aGUgZ3JvdW5kLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlLjxHZW9Kc29uRGF0YVNvdXJjZT59IGEgcHJvbWlzZSB0aGF0IHdpbGwgcmVzb2x2ZSB3aGVuIHRoZSBHZW9KU09OIGlzIGxvYWRlZC5cclxuICAgICAqL1xyXG4gICAgR2VvSnNvbkRhdGFTb3VyY2UucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbihkYXRhLCBvcHRpb25zKSB7XHJcbiAgICAgICAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcclxuICAgICAgICBpZiAoIWRlZmluZWQoZGF0YSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKCdkYXRhIGlzIHJlcXVpcmVkLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcclxuXHJcbiAgICAgICAgRGF0YVNvdXJjZS5zZXRMb2FkaW5nKHRoaXMsIHRydWUpO1xyXG5cclxuICAgICAgICB2YXIgcHJvbWlzZSA9IGRhdGE7XHJcbiAgICAgICAgb3B0aW9ucyA9IGRlZmF1bHRWYWx1ZShvcHRpb25zLCBkZWZhdWx0VmFsdWUuRU1QVFlfT0JKRUNUKTtcclxuICAgICAgICB2YXIgc291cmNlVXJpID0gb3B0aW9ucy5zb3VyY2VVcmk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyB8fCAoZGF0YSBpbnN0YW5jZW9mIFJlc291cmNlKSkge1xyXG4gICAgICAgICAgICBkYXRhID0gUmVzb3VyY2UuY3JlYXRlSWZOZWVkZWQoZGF0YSk7XHJcblxyXG4gICAgICAgICAgICBwcm9taXNlID0gZGF0YS5mZXRjaEpzb24oKTtcclxuXHJcbiAgICAgICAgICAgIHNvdXJjZVVyaSA9IGRlZmF1bHRWYWx1ZShzb3VyY2VVcmksIGRhdGEuZ2V0VXJsQ29tcG9uZW50KCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgZGVzY3JpYmU6IGRlZmF1bHRWYWx1ZShvcHRpb25zLmRlc2NyaWJlLCBkZWZhdWx0RGVzY3JpYmVQcm9wZXJ0eSksXHJcbiAgICAgICAgICAgIG1hcmtlclNpemUgOiBkZWZhdWx0VmFsdWUob3B0aW9ucy5tYXJrZXJTaXplLCBkZWZhdWx0TWFya2VyU2l6ZSksXHJcbiAgICAgICAgICAgIG1hcmtlclN5bWJvbCA6IGRlZmF1bHRWYWx1ZShvcHRpb25zLm1hcmtlclN5bWJvbCwgZGVmYXVsdE1hcmtlclN5bWJvbCksXHJcbiAgICAgICAgICAgIG1hcmtlckNvbG9yIDogZGVmYXVsdFZhbHVlKG9wdGlvbnMubWFya2VyQ29sb3IsIGRlZmF1bHRNYXJrZXJDb2xvciksXHJcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoUHJvcGVydHkgOiBuZXcgQ29uc3RhbnRQcm9wZXJ0eShkZWZhdWx0VmFsdWUob3B0aW9ucy5zdHJva2VXaWR0aCwgZGVmYXVsdFN0cm9rZVdpZHRoKSksXHJcbiAgICAgICAgICAgIHBvbHlsaW5lU3Ryb2tlTWF0ZXJpYWxQcm9wZXJ0eSA6IG5ldyBDb2xvck1hdGVyaWFsUHJvcGVydHkoZGVmYXVsdFZhbHVlKGdldENvbG9yKG9wdGlvbnMucG9seWxpbmVTdHJva2UpLCBkZWZhdWx0VmFsdWUoZ2V0Q29sb3Iob3B0aW9ucy5zdHJva2UpLCBkZWZhdWx0U3Ryb2tlKSkpLFxyXG4gICAgICAgICAgICBwb2x5Z29uU3Ryb2tlQ29sb3IgOiBkZWZhdWx0VmFsdWUoZ2V0Q29sb3Iob3B0aW9ucy5wb2x5Z29uU3Ryb2tlKSwgZGVmYXVsdFZhbHVlKGdldENvbG9yKG9wdGlvbnMuc3Ryb2tlKSwgZGVmYXVsdFN0cm9rZSkpLFxyXG4gICAgICAgICAgICBmaWxsTWF0ZXJpYWxQcm9wZXJ0eSA6IG5ldyBDb2xvck1hdGVyaWFsUHJvcGVydHkoZGVmYXVsdFZhbHVlKG9wdGlvbnMuZmlsbCwgZGVmYXVsdEZpbGwpKSxcclxuICAgICAgICAgICAgY2xhbXBUb0dyb3VuZCA6IGRlZmF1bHRWYWx1ZShvcHRpb25zLmNsYW1wVG9Hcm91bmQsIGRlZmF1bHRDbGFtcFRvR3JvdW5kKVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICByZXR1cm4gd2hlbihwcm9taXNlLCBmdW5jdGlvbihnZW9Kc29uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBsb2FkKHRoYXQsIGdlb0pzb24sIG9wdGlvbnMsIHNvdXJjZVVyaSk7XHJcbiAgICAgICAgfSkub3RoZXJ3aXNlKGZ1bmN0aW9uKGVycm9yKSB7XHJcbiAgICAgICAgICAgIERhdGFTb3VyY2Uuc2V0TG9hZGluZyh0aGF0LCBmYWxzZSk7XHJcbiAgICAgICAgICAgIHRoYXQuX2Vycm9yLnJhaXNlRXZlbnQodGhhdCwgZXJyb3IpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlcnJvcik7XHJcbiAgICAgICAgICAgIHJldHVybiB3aGVuLnJlamVjdChlcnJvcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGdldENvbG9yKGNvbG9yKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBjb2xvciA9PT0gJ3N0cmluZycgfHwgY29sb3IgaW5zdGFuY2VvZiBTdHJpbmcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIENvbG9yLmZyb21Dc3NDb2xvclN0cmluZyhjb2xvcik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbG9yO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBsb2FkKHRoYXQsIGdlb0pzb24sIG9wdGlvbnMsIHNvdXJjZVVyaSkge1xyXG4gICAgICAgIHZhciBuYW1lO1xyXG4gICAgICAgIGlmIChkZWZpbmVkKHNvdXJjZVVyaSkpIHtcclxuICAgICAgICAgICAgbmFtZSA9IGdldEZpbGVuYW1lRnJvbVVyaShzb3VyY2VVcmkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGRlZmluZWQobmFtZSkgJiYgdGhhdC5fbmFtZSAhPT0gbmFtZSkge1xyXG4gICAgICAgICAgICB0aGF0Ll9uYW1lID0gbmFtZTtcclxuICAgICAgICAgICAgdGhhdC5fY2hhbmdlZC5yYWlzZUV2ZW50KHRoYXQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHR5cGVIYW5kbGVyID0gZ2VvSnNvbk9iamVjdFR5cGVzW2dlb0pzb24udHlwZV07XHJcbiAgICAgICAgaWYgKCFkZWZpbmVkKHR5cGVIYW5kbGVyKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgUnVudGltZUVycm9yKCdVbnN1cHBvcnRlZCBHZW9KU09OIG9iamVjdCB0eXBlOiAnICsgZ2VvSnNvbi50eXBlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vQ2hlY2sgZm9yIGEgQ29vcmRpbmF0ZSBSZWZlcmVuY2UgU3lzdGVtLlxyXG4gICAgICAgIHZhciBjcnMgPSBnZW9Kc29uLmNycztcclxuICAgICAgICB2YXIgY3JzRnVuY3Rpb24gPSBjcnMgIT09IG51bGwgPyBkZWZhdWx0Q3JzRnVuY3Rpb24gOiBudWxsO1xyXG5cclxuICAgICAgICBpZiAoZGVmaW5lZChjcnMpKSB7XHJcbiAgICAgICAgICAgIGlmICghZGVmaW5lZChjcnMucHJvcGVydGllcykpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3IoJ2Nycy5wcm9wZXJ0aWVzIGlzIHVuZGVmaW5lZC4nKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHByb3BlcnRpZXMgPSBjcnMucHJvcGVydGllcztcclxuICAgICAgICAgICAgaWYgKGNycy50eXBlID09PSAnbmFtZScpIHtcclxuICAgICAgICAgICAgICAgIGNyc0Z1bmN0aW9uID0gY3JzTmFtZXNbcHJvcGVydGllcy5uYW1lXTtcclxuICAgICAgICAgICAgICAgIGlmICghZGVmaW5lZChjcnNGdW5jdGlvbikpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUnVudGltZUVycm9yKCdVbmtub3duIGNycyBuYW1lOiAnICsgcHJvcGVydGllcy5uYW1lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChjcnMudHlwZSA9PT0gJ2xpbmsnKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaGFuZGxlciA9IGNyc0xpbmtIcmVmc1twcm9wZXJ0aWVzLmhyZWZdO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFkZWZpbmVkKGhhbmRsZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlciA9IGNyc0xpbmtUeXBlc1twcm9wZXJ0aWVzLnR5cGVdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICghZGVmaW5lZChoYW5kbGVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3IoJ1VuYWJsZSB0byByZXNvbHZlIGNycyBsaW5rOiAnICsgSlNPTi5zdHJpbmdpZnkocHJvcGVydGllcykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGNyc0Z1bmN0aW9uID0gaGFuZGxlcihwcm9wZXJ0aWVzKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChjcnMudHlwZSA9PT0gJ0VQU0cnKSB7XHJcbiAgICAgICAgICAgICAgICBjcnNGdW5jdGlvbiA9IGNyc05hbWVzWydFUFNHOicgKyBwcm9wZXJ0aWVzLmNvZGVdO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFkZWZpbmVkKGNyc0Z1bmN0aW9uKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3IoJ1Vua25vd24gY3JzIEVQU0cgY29kZTogJyArIHByb3BlcnRpZXMuY29kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUnVudGltZUVycm9yKCdVbmtub3duIGNycyB0eXBlOiAnICsgY3JzLnR5cGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gd2hlbihjcnNGdW5jdGlvbiwgZnVuY3Rpb24oY3JzRnVuY3Rpb24pIHtcclxuICAgICAgICAgICAgdGhhdC5fZW50aXR5Q29sbGVjdGlvbi5yZW1vdmVBbGwoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIG51bGwgaXMgYSB2YWxpZCB2YWx1ZSBmb3IgdGhlIGNycywgYnV0IG1lYW5zIHRoZSBlbnRpcmUgbG9hZCBwcm9jZXNzIGJlY29tZXMgYSBuby1vcFxyXG4gICAgICAgICAgICAvLyBiZWNhdXNlIHdlIGNhbid0IGFzc3VtZSBhbnl0aGluZyBhYm91dCB0aGUgY29vcmRpbmF0ZXMuXHJcbiAgICAgICAgICAgIGlmIChjcnNGdW5jdGlvbiAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdHlwZUhhbmRsZXIodGhhdCwgZ2VvSnNvbiwgZ2VvSnNvbiwgY3JzRnVuY3Rpb24sIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gd2hlbi5hbGwodGhhdC5fcHJvbWlzZXMsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgdGhhdC5fcHJvbWlzZXMubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgIERhdGFTb3VyY2Uuc2V0TG9hZGluZyh0aGF0LCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhhdDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGNhbGxiYWNrIGlzIGRpc3BsYXllZCBhcyBwYXJ0IG9mIHRoZSBHZW9Kc29uRGF0YVNvdXJjZSBjbGFzcy5cclxuICAgICAqIEBjYWxsYmFjayBHZW9Kc29uRGF0YVNvdXJjZX5kZXNjcmliZVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXMgVGhlIHByb3BlcnRpZXMgb2YgdGhlIGZlYXR1cmUuXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVByb3BlcnR5IFRoZSBwcm9wZXJ0eSBrZXkgdGhhdCBDZXNpdW0gZXN0aW1hdGVzIHRvIGhhdmUgdGhlIG5hbWUgb2YgdGhlIGZlYXR1cmUuXHJcbiAgICAgKi9cclxuXHJcbiAgICByZXR1cm4gR2VvSnNvbkRhdGFTb3VyY2U7XHJcbn0pO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy90ZXJyaWFqcy1jZXNpdW0vU291cmNlL0RhdGFTb3VyY2VzL0dlb0pzb25EYXRhU291cmNlLmpzXG4vLyBtb2R1bGUgaWQgPSA1Mzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZGVmaW5lKFtcclxuICAgICAgICAnLi4vQ29yZS9Cb3VuZGluZ1JlY3RhbmdsZScsXHJcbiAgICAgICAgJy4uL0NvcmUvQ2FydGVzaWFuMicsXHJcbiAgICAgICAgJy4uL0NvcmUvQ2FydGVzaWFuMycsXHJcbiAgICAgICAgJy4uL0NvcmUvQ2FydG9ncmFwaGljJyxcclxuICAgICAgICAnLi4vQ29yZS9DbG9ja1JhbmdlJyxcclxuICAgICAgICAnLi4vQ29yZS9DbG9ja1N0ZXAnLFxyXG4gICAgICAgICcuLi9Db3JlL0NvbG9yJyxcclxuICAgICAgICAnLi4vQ29yZS9Db3JuZXJUeXBlJyxcclxuICAgICAgICAnLi4vQ29yZS9jcmVhdGVHdWlkJyxcclxuICAgICAgICAnLi4vQ29yZS9kZWZhdWx0VmFsdWUnLFxyXG4gICAgICAgICcuLi9Db3JlL2RlZmluZWQnLFxyXG4gICAgICAgICcuLi9Db3JlL2RlZmluZVByb3BlcnRpZXMnLFxyXG4gICAgICAgICcuLi9Db3JlL0RldmVsb3BlckVycm9yJyxcclxuICAgICAgICAnLi4vQ29yZS9EaXN0YW5jZURpc3BsYXlDb25kaXRpb24nLFxyXG4gICAgICAgICcuLi9Db3JlL0VsbGlwc29pZCcsXHJcbiAgICAgICAgJy4uL0NvcmUvRXZlbnQnLFxyXG4gICAgICAgICcuLi9Db3JlL0V4dHJhcG9sYXRpb25UeXBlJyxcclxuICAgICAgICAnLi4vQ29yZS9nZXRGaWxlbmFtZUZyb21VcmknLFxyXG4gICAgICAgICcuLi9Db3JlL0hlcm1pdGVQb2x5bm9taWFsQXBwcm94aW1hdGlvbicsXHJcbiAgICAgICAgJy4uL0NvcmUvaXNBcnJheScsXHJcbiAgICAgICAgJy4uL0NvcmUvSXNvODYwMScsXHJcbiAgICAgICAgJy4uL0NvcmUvSnVsaWFuRGF0ZScsXHJcbiAgICAgICAgJy4uL0NvcmUvTGFncmFuZ2VQb2x5bm9taWFsQXBwcm94aW1hdGlvbicsXHJcbiAgICAgICAgJy4uL0NvcmUvTGluZWFyQXBwcm94aW1hdGlvbicsXHJcbiAgICAgICAgJy4uL0NvcmUvTWF0aCcsXHJcbiAgICAgICAgJy4uL0NvcmUvTmVhckZhclNjYWxhcicsXHJcbiAgICAgICAgJy4uL0NvcmUvUXVhdGVybmlvbicsXHJcbiAgICAgICAgJy4uL0NvcmUvUmVjdGFuZ2xlJyxcclxuICAgICAgICAnLi4vQ29yZS9SZWZlcmVuY2VGcmFtZScsXHJcbiAgICAgICAgJy4uL0NvcmUvUmVzb3VyY2UnLFxyXG4gICAgICAgICcuLi9Db3JlL1J1bnRpbWVFcnJvcicsXHJcbiAgICAgICAgJy4uL0NvcmUvU3BoZXJpY2FsJyxcclxuICAgICAgICAnLi4vQ29yZS9UaW1lSW50ZXJ2YWwnLFxyXG4gICAgICAgICcuLi9Db3JlL1RpbWVJbnRlcnZhbENvbGxlY3Rpb24nLFxyXG4gICAgICAgICcuLi9TY2VuZS9Db2xvckJsZW5kTW9kZScsXHJcbiAgICAgICAgJy4uL1NjZW5lL0hlaWdodFJlZmVyZW5jZScsXHJcbiAgICAgICAgJy4uL1NjZW5lL0hvcml6b250YWxPcmlnaW4nLFxyXG4gICAgICAgICcuLi9TY2VuZS9MYWJlbFN0eWxlJyxcclxuICAgICAgICAnLi4vU2NlbmUvU2hhZG93TW9kZScsXHJcbiAgICAgICAgJy4uL1NjZW5lL1ZlcnRpY2FsT3JpZ2luJyxcclxuICAgICAgICAnLi4vVGhpcmRQYXJ0eS9VcmknLFxyXG4gICAgICAgICcuLi9UaGlyZFBhcnR5L3doZW4nLFxyXG4gICAgICAgICcuL0JpbGxib2FyZEdyYXBoaWNzJyxcclxuICAgICAgICAnLi9Cb3hHcmFwaGljcycsXHJcbiAgICAgICAgJy4vQ29sb3JNYXRlcmlhbFByb3BlcnR5JyxcclxuICAgICAgICAnLi9Db21wb3NpdGVNYXRlcmlhbFByb3BlcnR5JyxcclxuICAgICAgICAnLi9Db21wb3NpdGVQb3NpdGlvblByb3BlcnR5JyxcclxuICAgICAgICAnLi9Db21wb3NpdGVQcm9wZXJ0eScsXHJcbiAgICAgICAgJy4vQ29uc3RhbnRQb3NpdGlvblByb3BlcnR5JyxcclxuICAgICAgICAnLi9Db25zdGFudFByb3BlcnR5JyxcclxuICAgICAgICAnLi9Db3JyaWRvckdyYXBoaWNzJyxcclxuICAgICAgICAnLi9DeWxpbmRlckdyYXBoaWNzJyxcclxuICAgICAgICAnLi9EYXRhU291cmNlJyxcclxuICAgICAgICAnLi9EYXRhU291cmNlQ2xvY2snLFxyXG4gICAgICAgICcuL0VsbGlwc2VHcmFwaGljcycsXHJcbiAgICAgICAgJy4vRWxsaXBzb2lkR3JhcGhpY3MnLFxyXG4gICAgICAgICcuL0VudGl0eUNsdXN0ZXInLFxyXG4gICAgICAgICcuL0VudGl0eUNvbGxlY3Rpb24nLFxyXG4gICAgICAgICcuL0dyaWRNYXRlcmlhbFByb3BlcnR5JyxcclxuICAgICAgICAnLi9JbWFnZU1hdGVyaWFsUHJvcGVydHknLFxyXG4gICAgICAgICcuL0xhYmVsR3JhcGhpY3MnLFxyXG4gICAgICAgICcuL01vZGVsR3JhcGhpY3MnLFxyXG4gICAgICAgICcuL05vZGVUcmFuc2Zvcm1hdGlvblByb3BlcnR5JyxcclxuICAgICAgICAnLi9QYXRoR3JhcGhpY3MnLFxyXG4gICAgICAgICcuL1BvaW50R3JhcGhpY3MnLFxyXG4gICAgICAgICcuL1BvbHlnb25HcmFwaGljcycsXHJcbiAgICAgICAgJy4vUG9seWxpbmVBcnJvd01hdGVyaWFsUHJvcGVydHknLFxyXG4gICAgICAgICcuL1BvbHlsaW5lRGFzaE1hdGVyaWFsUHJvcGVydHknLFxyXG4gICAgICAgICcuL1BvbHlsaW5lR2xvd01hdGVyaWFsUHJvcGVydHknLFxyXG4gICAgICAgICcuL1BvbHlsaW5lR3JhcGhpY3MnLFxyXG4gICAgICAgICcuL1BvbHlsaW5lT3V0bGluZU1hdGVyaWFsUHJvcGVydHknLFxyXG4gICAgICAgICcuL1Bvc2l0aW9uUHJvcGVydHlBcnJheScsXHJcbiAgICAgICAgJy4vUHJvcGVydHlBcnJheScsXHJcbiAgICAgICAgJy4vUHJvcGVydHlCYWcnLFxyXG4gICAgICAgICcuL1JlY3RhbmdsZUdyYXBoaWNzJyxcclxuICAgICAgICAnLi9SZWZlcmVuY2VQcm9wZXJ0eScsXHJcbiAgICAgICAgJy4vUm90YXRpb24nLFxyXG4gICAgICAgICcuL1NhbXBsZWRQb3NpdGlvblByb3BlcnR5JyxcclxuICAgICAgICAnLi9TYW1wbGVkUHJvcGVydHknLFxyXG4gICAgICAgICcuL1N0cmlwZU1hdGVyaWFsUHJvcGVydHknLFxyXG4gICAgICAgICcuL1N0cmlwZU9yaWVudGF0aW9uJyxcclxuICAgICAgICAnLi9UaW1lSW50ZXJ2YWxDb2xsZWN0aW9uUG9zaXRpb25Qcm9wZXJ0eScsXHJcbiAgICAgICAgJy4vVGltZUludGVydmFsQ29sbGVjdGlvblByb3BlcnR5JyxcclxuICAgICAgICAnLi9WZWxvY2l0eU9yaWVudGF0aW9uUHJvcGVydHknLFxyXG4gICAgICAgICcuL1ZlbG9jaXR5VmVjdG9yUHJvcGVydHknLFxyXG4gICAgICAgICcuL1dhbGxHcmFwaGljcydcclxuICAgIF0sIGZ1bmN0aW9uKFxyXG4gICAgICAgIEJvdW5kaW5nUmVjdGFuZ2xlLFxyXG4gICAgICAgIENhcnRlc2lhbjIsXHJcbiAgICAgICAgQ2FydGVzaWFuMyxcclxuICAgICAgICBDYXJ0b2dyYXBoaWMsXHJcbiAgICAgICAgQ2xvY2tSYW5nZSxcclxuICAgICAgICBDbG9ja1N0ZXAsXHJcbiAgICAgICAgQ29sb3IsXHJcbiAgICAgICAgQ29ybmVyVHlwZSxcclxuICAgICAgICBjcmVhdGVHdWlkLFxyXG4gICAgICAgIGRlZmF1bHRWYWx1ZSxcclxuICAgICAgICBkZWZpbmVkLFxyXG4gICAgICAgIGRlZmluZVByb3BlcnRpZXMsXHJcbiAgICAgICAgRGV2ZWxvcGVyRXJyb3IsXHJcbiAgICAgICAgRGlzdGFuY2VEaXNwbGF5Q29uZGl0aW9uLFxyXG4gICAgICAgIEVsbGlwc29pZCxcclxuICAgICAgICBFdmVudCxcclxuICAgICAgICBFeHRyYXBvbGF0aW9uVHlwZSxcclxuICAgICAgICBnZXRGaWxlbmFtZUZyb21VcmksXHJcbiAgICAgICAgSGVybWl0ZVBvbHlub21pYWxBcHByb3hpbWF0aW9uLFxyXG4gICAgICAgIGlzQXJyYXksXHJcbiAgICAgICAgSXNvODYwMSxcclxuICAgICAgICBKdWxpYW5EYXRlLFxyXG4gICAgICAgIExhZ3JhbmdlUG9seW5vbWlhbEFwcHJveGltYXRpb24sXHJcbiAgICAgICAgTGluZWFyQXBwcm94aW1hdGlvbixcclxuICAgICAgICBDZXNpdW1NYXRoLFxyXG4gICAgICAgIE5lYXJGYXJTY2FsYXIsXHJcbiAgICAgICAgUXVhdGVybmlvbixcclxuICAgICAgICBSZWN0YW5nbGUsXHJcbiAgICAgICAgUmVmZXJlbmNlRnJhbWUsXHJcbiAgICAgICAgUmVzb3VyY2UsXHJcbiAgICAgICAgUnVudGltZUVycm9yLFxyXG4gICAgICAgIFNwaGVyaWNhbCxcclxuICAgICAgICBUaW1lSW50ZXJ2YWwsXHJcbiAgICAgICAgVGltZUludGVydmFsQ29sbGVjdGlvbixcclxuICAgICAgICBDb2xvckJsZW5kTW9kZSxcclxuICAgICAgICBIZWlnaHRSZWZlcmVuY2UsXHJcbiAgICAgICAgSG9yaXpvbnRhbE9yaWdpbixcclxuICAgICAgICBMYWJlbFN0eWxlLFxyXG4gICAgICAgIFNoYWRvd01vZGUsXHJcbiAgICAgICAgVmVydGljYWxPcmlnaW4sXHJcbiAgICAgICAgVXJpLFxyXG4gICAgICAgIHdoZW4sXHJcbiAgICAgICAgQmlsbGJvYXJkR3JhcGhpY3MsXHJcbiAgICAgICAgQm94R3JhcGhpY3MsXHJcbiAgICAgICAgQ29sb3JNYXRlcmlhbFByb3BlcnR5LFxyXG4gICAgICAgIENvbXBvc2l0ZU1hdGVyaWFsUHJvcGVydHksXHJcbiAgICAgICAgQ29tcG9zaXRlUG9zaXRpb25Qcm9wZXJ0eSxcclxuICAgICAgICBDb21wb3NpdGVQcm9wZXJ0eSxcclxuICAgICAgICBDb25zdGFudFBvc2l0aW9uUHJvcGVydHksXHJcbiAgICAgICAgQ29uc3RhbnRQcm9wZXJ0eSxcclxuICAgICAgICBDb3JyaWRvckdyYXBoaWNzLFxyXG4gICAgICAgIEN5bGluZGVyR3JhcGhpY3MsXHJcbiAgICAgICAgRGF0YVNvdXJjZSxcclxuICAgICAgICBEYXRhU291cmNlQ2xvY2ssXHJcbiAgICAgICAgRWxsaXBzZUdyYXBoaWNzLFxyXG4gICAgICAgIEVsbGlwc29pZEdyYXBoaWNzLFxyXG4gICAgICAgIEVudGl0eUNsdXN0ZXIsXHJcbiAgICAgICAgRW50aXR5Q29sbGVjdGlvbixcclxuICAgICAgICBHcmlkTWF0ZXJpYWxQcm9wZXJ0eSxcclxuICAgICAgICBJbWFnZU1hdGVyaWFsUHJvcGVydHksXHJcbiAgICAgICAgTGFiZWxHcmFwaGljcyxcclxuICAgICAgICBNb2RlbEdyYXBoaWNzLFxyXG4gICAgICAgIE5vZGVUcmFuc2Zvcm1hdGlvblByb3BlcnR5LFxyXG4gICAgICAgIFBhdGhHcmFwaGljcyxcclxuICAgICAgICBQb2ludEdyYXBoaWNzLFxyXG4gICAgICAgIFBvbHlnb25HcmFwaGljcyxcclxuICAgICAgICBQb2x5bGluZUFycm93TWF0ZXJpYWxQcm9wZXJ0eSxcclxuICAgICAgICBQb2x5bGluZURhc2hNYXRlcmlhbFByb3BlcnR5LFxyXG4gICAgICAgIFBvbHlsaW5lR2xvd01hdGVyaWFsUHJvcGVydHksXHJcbiAgICAgICAgUG9seWxpbmVHcmFwaGljcyxcclxuICAgICAgICBQb2x5bGluZU91dGxpbmVNYXRlcmlhbFByb3BlcnR5LFxyXG4gICAgICAgIFBvc2l0aW9uUHJvcGVydHlBcnJheSxcclxuICAgICAgICBQcm9wZXJ0eUFycmF5LFxyXG4gICAgICAgIFByb3BlcnR5QmFnLFxyXG4gICAgICAgIFJlY3RhbmdsZUdyYXBoaWNzLFxyXG4gICAgICAgIFJlZmVyZW5jZVByb3BlcnR5LFxyXG4gICAgICAgIFJvdGF0aW9uLFxyXG4gICAgICAgIFNhbXBsZWRQb3NpdGlvblByb3BlcnR5LFxyXG4gICAgICAgIFNhbXBsZWRQcm9wZXJ0eSxcclxuICAgICAgICBTdHJpcGVNYXRlcmlhbFByb3BlcnR5LFxyXG4gICAgICAgIFN0cmlwZU9yaWVudGF0aW9uLFxyXG4gICAgICAgIFRpbWVJbnRlcnZhbENvbGxlY3Rpb25Qb3NpdGlvblByb3BlcnR5LFxyXG4gICAgICAgIFRpbWVJbnRlcnZhbENvbGxlY3Rpb25Qcm9wZXJ0eSxcclxuICAgICAgICBWZWxvY2l0eU9yaWVudGF0aW9uUHJvcGVydHksXHJcbiAgICAgICAgVmVsb2NpdHlWZWN0b3JQcm9wZXJ0eSxcclxuICAgICAgICBXYWxsR3JhcGhpY3MpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgICAvLyBBIG1hcmtlciB0eXBlIHRvIGRpc3Rpbmd1aXNoIENaTUwgcHJvcGVydGllcyB3aGVyZSB3ZSBuZWVkIHRvIGVuZCB1cCB3aXRoIGEgdW5pdCB2ZWN0b3IuXHJcbiAgICAvLyBUaGUgZGF0YSBpcyBzdGlsbCBsb2FkZWQgaW50byBDYXJ0ZXNpYW4zIG9iamVjdHMgYnV0IHRoZXkgYXJlIG5vcm1hbGl6ZWQuXHJcbiAgICBmdW5jdGlvbiBVbml0Q2FydGVzaWFuMygpIHt9XHJcbiAgICBVbml0Q2FydGVzaWFuMy5wYWNrZWRMZW5ndGggPSBDYXJ0ZXNpYW4zLnBhY2tlZExlbmd0aDtcclxuICAgIFVuaXRDYXJ0ZXNpYW4zLnVucGFjayA9IENhcnRlc2lhbjMudW5wYWNrO1xyXG4gICAgVW5pdENhcnRlc2lhbjMucGFjayA9IENhcnRlc2lhbjMucGFjaztcclxuXHJcbiAgICAvLyBBcyBhIHNpZGUgbm90ZSwgZm9yIHRoZSBwdXJwb3NlcyBvZiBDWk1MLCBRdWF0ZXJuaW9uIGFsd2F5cyBpbmRpY2F0ZXMgYSB1bml0IHF1YXRlcm5pb24uXHJcblxyXG4gICAgdmFyIGN1cnJlbnRJZDtcclxuXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVSZWZlcmVuY2VQcm9wZXJ0eShlbnRpdHlDb2xsZWN0aW9uLCByZWZlcmVuY2VTdHJpbmcpIHtcclxuICAgICAgICBpZiAocmVmZXJlbmNlU3RyaW5nWzBdID09PSAnIycpIHtcclxuICAgICAgICAgICAgcmVmZXJlbmNlU3RyaW5nID0gY3VycmVudElkICsgcmVmZXJlbmNlU3RyaW5nO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUmVmZXJlbmNlUHJvcGVydHkuZnJvbVN0cmluZyhlbnRpdHlDb2xsZWN0aW9uLCByZWZlcmVuY2VTdHJpbmcpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZVNwZWNpYWxpemVkUHJvcGVydHkodHlwZSwgZW50aXR5Q29sbGVjdGlvbiwgcGFja2V0RGF0YSkge1xyXG4gICAgICAgIGlmIChkZWZpbmVkKHBhY2tldERhdGEucmVmZXJlbmNlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlUmVmZXJlbmNlUHJvcGVydHkoZW50aXR5Q29sbGVjdGlvbiwgcGFja2V0RGF0YS5yZWZlcmVuY2UpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGRlZmluZWQocGFja2V0RGF0YS52ZWxvY2l0eVJlZmVyZW5jZSkpIHtcclxuICAgICAgICAgICAgdmFyIHJlZmVyZW5jZVByb3BlcnR5ID0gY3JlYXRlUmVmZXJlbmNlUHJvcGVydHkoZW50aXR5Q29sbGVjdGlvbiwgcGFja2V0RGF0YS52ZWxvY2l0eVJlZmVyZW5jZSk7XHJcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBDYXJ0ZXNpYW4zOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBVbml0Q2FydGVzaWFuMzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFZlbG9jaXR5VmVjdG9yUHJvcGVydHkocmVmZXJlbmNlUHJvcGVydHksIHR5cGUgPT09IFVuaXRDYXJ0ZXNpYW4zKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgUXVhdGVybmlvbjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFZlbG9jaXR5T3JpZW50YXRpb25Qcm9wZXJ0eShyZWZlcmVuY2VQcm9wZXJ0eSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3IoSlNPTi5zdHJpbmdpZnkocGFja2V0RGF0YSkgKyAnIGlzIG5vdCB2YWxpZCBDWk1MLicpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBzY3JhdGNoQ2FydGVzaWFuID0gbmV3IENhcnRlc2lhbjMoKTtcclxuICAgIHZhciBzY3JhdGNoU3BoZXJpY2FsID0gbmV3IFNwaGVyaWNhbCgpO1xyXG4gICAgdmFyIHNjcmF0Y2hDYXJ0b2dyYXBoaWMgPSBuZXcgQ2FydG9ncmFwaGljKCk7XHJcbiAgICB2YXIgc2NyYXRjaFRpbWVJbnRlcnZhbCA9IG5ldyBUaW1lSW50ZXJ2YWwoKTtcclxuICAgIHZhciBzY3JhdGNoUXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XHJcblxyXG4gICAgZnVuY3Rpb24gdW53cmFwQ29sb3JJbnRlcnZhbChjem1sSW50ZXJ2YWwpIHtcclxuICAgICAgICB2YXIgcmdiYWYgPSBjem1sSW50ZXJ2YWwucmdiYWY7XHJcbiAgICAgICAgaWYgKGRlZmluZWQocmdiYWYpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZ2JhZjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciByZ2JhID0gY3ptbEludGVydmFsLnJnYmE7XHJcbiAgICAgICAgaWYgKCFkZWZpbmVkKHJnYmEpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgbGVuZ3RoID0gcmdiYS5sZW5ndGg7XHJcbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gQ29sb3IucGFja2VkTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbQ29sb3IuYnl0ZVRvRmxvYXQocmdiYVswXSksIENvbG9yLmJ5dGVUb0Zsb2F0KHJnYmFbMV0pLCBDb2xvci5ieXRlVG9GbG9hdChyZ2JhWzJdKSwgQ29sb3IuYnl0ZVRvRmxvYXQocmdiYVszXSldO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmdiYWYgPSBuZXcgQXJyYXkobGVuZ3RoKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSA1KSB7XHJcbiAgICAgICAgICAgIHJnYmFmW2ldID0gcmdiYVtpXTtcclxuICAgICAgICAgICAgcmdiYWZbaSArIDFdID0gQ29sb3IuYnl0ZVRvRmxvYXQocmdiYVtpICsgMV0pO1xyXG4gICAgICAgICAgICByZ2JhZltpICsgMl0gPSBDb2xvci5ieXRlVG9GbG9hdChyZ2JhW2kgKyAyXSk7XHJcbiAgICAgICAgICAgIHJnYmFmW2kgKyAzXSA9IENvbG9yLmJ5dGVUb0Zsb2F0KHJnYmFbaSArIDNdKTtcclxuICAgICAgICAgICAgcmdiYWZbaSArIDRdID0gQ29sb3IuYnl0ZVRvRmxvYXQocmdiYVtpICsgNF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmdiYWY7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdW53cmFwVXJpSW50ZXJ2YWwoY3ptbEludGVydmFsLCBzb3VyY2VVcmkpIHtcclxuICAgICAgICB2YXIgdXJpID0gZGVmYXVsdFZhbHVlKGN6bWxJbnRlcnZhbC51cmksIGN6bWxJbnRlcnZhbCk7XHJcbiAgICAgICAgaWYgKGRlZmluZWQoc291cmNlVXJpKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gc291cmNlVXJpLmdldERlcml2ZWRSZXNvdXJjZSh7XHJcbiAgICAgICAgICAgICAgICB1cmw6IHVyaVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBSZXNvdXJjZS5jcmVhdGVJZk5lZWRlZCh1cmkpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHVud3JhcFJlY3RhbmdsZUludGVydmFsKGN6bWxJbnRlcnZhbCkge1xyXG4gICAgICAgIHZhciB3c2VuID0gY3ptbEludGVydmFsLndzZW47XHJcbiAgICAgICAgaWYgKGRlZmluZWQod3NlbikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHdzZW47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgd3NlbkRlZ3JlZXMgPSBjem1sSW50ZXJ2YWwud3NlbkRlZ3JlZXM7XHJcbiAgICAgICAgaWYgKCFkZWZpbmVkKHdzZW5EZWdyZWVzKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGxlbmd0aCA9IHdzZW5EZWdyZWVzLmxlbmd0aDtcclxuICAgICAgICBpZiAobGVuZ3RoID09PSBSZWN0YW5nbGUucGFja2VkTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbQ2VzaXVtTWF0aC50b1JhZGlhbnMod3NlbkRlZ3JlZXNbMF0pLCBDZXNpdW1NYXRoLnRvUmFkaWFucyh3c2VuRGVncmVlc1sxXSksIENlc2l1bU1hdGgudG9SYWRpYW5zKHdzZW5EZWdyZWVzWzJdKSwgQ2VzaXVtTWF0aC50b1JhZGlhbnMod3NlbkRlZ3JlZXNbM10pXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHdzZW4gPSBuZXcgQXJyYXkobGVuZ3RoKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSA1KSB7XHJcbiAgICAgICAgICAgIHdzZW5baV0gPSB3c2VuRGVncmVlc1tpXTtcclxuICAgICAgICAgICAgd3NlbltpICsgMV0gPSBDZXNpdW1NYXRoLnRvUmFkaWFucyh3c2VuRGVncmVlc1tpICsgMV0pO1xyXG4gICAgICAgICAgICB3c2VuW2kgKyAyXSA9IENlc2l1bU1hdGgudG9SYWRpYW5zKHdzZW5EZWdyZWVzW2kgKyAyXSk7XHJcbiAgICAgICAgICAgIHdzZW5baSArIDNdID0gQ2VzaXVtTWF0aC50b1JhZGlhbnMod3NlbkRlZ3JlZXNbaSArIDNdKTtcclxuICAgICAgICAgICAgd3NlbltpICsgNF0gPSBDZXNpdW1NYXRoLnRvUmFkaWFucyh3c2VuRGVncmVlc1tpICsgNF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gd3NlbjtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjb252ZXJ0VW5pdFNwaGVyaWNhbFRvQ2FydGVzaWFuKHVuaXRTcGhlcmljYWwpIHtcclxuICAgICAgICB2YXIgbGVuZ3RoID0gdW5pdFNwaGVyaWNhbC5sZW5ndGg7XHJcbiAgICAgICAgc2NyYXRjaFNwaGVyaWNhbC5tYWduaXR1ZGUgPSAxLjA7XHJcbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gMikge1xyXG4gICAgICAgICAgICBzY3JhdGNoU3BoZXJpY2FsLmNsb2NrID0gdW5pdFNwaGVyaWNhbFswXTtcclxuICAgICAgICAgICAgc2NyYXRjaFNwaGVyaWNhbC5jb25lID0gdW5pdFNwaGVyaWNhbFsxXTtcclxuICAgICAgICAgICAgQ2FydGVzaWFuMy5mcm9tU3BoZXJpY2FsKHNjcmF0Y2hTcGhlcmljYWwsIHNjcmF0Y2hDYXJ0ZXNpYW4pO1xyXG4gICAgICAgICAgICByZXR1cm4gW3NjcmF0Y2hDYXJ0ZXNpYW4ueCwgc2NyYXRjaENhcnRlc2lhbi55LCBzY3JhdGNoQ2FydGVzaWFuLnpdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShsZW5ndGggLyAzICogNCk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDMsIGogKz0gNCkge1xyXG4gICAgICAgICAgICByZXN1bHRbal0gPSB1bml0U3BoZXJpY2FsW2ldO1xyXG5cclxuICAgICAgICAgICAgc2NyYXRjaFNwaGVyaWNhbC5jbG9jayA9IHVuaXRTcGhlcmljYWxbaSArIDFdO1xyXG4gICAgICAgICAgICBzY3JhdGNoU3BoZXJpY2FsLmNvbmUgPSB1bml0U3BoZXJpY2FsW2kgKyAyXTtcclxuICAgICAgICAgICAgQ2FydGVzaWFuMy5mcm9tU3BoZXJpY2FsKHNjcmF0Y2hTcGhlcmljYWwsIHNjcmF0Y2hDYXJ0ZXNpYW4pO1xyXG5cclxuICAgICAgICAgICAgcmVzdWx0W2ogKyAxXSA9IHNjcmF0Y2hDYXJ0ZXNpYW4ueDtcclxuICAgICAgICAgICAgcmVzdWx0W2ogKyAyXSA9IHNjcmF0Y2hDYXJ0ZXNpYW4ueTtcclxuICAgICAgICAgICAgcmVzdWx0W2ogKyAzXSA9IHNjcmF0Y2hDYXJ0ZXNpYW4uejtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjb252ZXJ0U3BoZXJpY2FsVG9DYXJ0ZXNpYW4oc3BoZXJpY2FsKSB7XHJcbiAgICAgICAgdmFyIGxlbmd0aCA9IHNwaGVyaWNhbC5sZW5ndGg7XHJcbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gMykge1xyXG4gICAgICAgICAgICBzY3JhdGNoU3BoZXJpY2FsLmNsb2NrID0gc3BoZXJpY2FsWzBdO1xyXG4gICAgICAgICAgICBzY3JhdGNoU3BoZXJpY2FsLmNvbmUgPSBzcGhlcmljYWxbMV07XHJcbiAgICAgICAgICAgIHNjcmF0Y2hTcGhlcmljYWwubWFnbml0dWRlID0gc3BoZXJpY2FsWzJdO1xyXG4gICAgICAgICAgICBDYXJ0ZXNpYW4zLmZyb21TcGhlcmljYWwoc2NyYXRjaFNwaGVyaWNhbCwgc2NyYXRjaENhcnRlc2lhbik7XHJcbiAgICAgICAgICAgIHJldHVybiBbc2NyYXRjaENhcnRlc2lhbi54LCBzY3JhdGNoQ2FydGVzaWFuLnksIHNjcmF0Y2hDYXJ0ZXNpYW4uel07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KGxlbmd0aCk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gNCkge1xyXG4gICAgICAgICAgICByZXN1bHRbaV0gPSBzcGhlcmljYWxbaV07XHJcblxyXG4gICAgICAgICAgICBzY3JhdGNoU3BoZXJpY2FsLmNsb2NrID0gc3BoZXJpY2FsW2kgKyAxXTtcclxuICAgICAgICAgICAgc2NyYXRjaFNwaGVyaWNhbC5jb25lID0gc3BoZXJpY2FsW2kgKyAyXTtcclxuICAgICAgICAgICAgc2NyYXRjaFNwaGVyaWNhbC5tYWduaXR1ZGUgPSBzcGhlcmljYWxbaSArIDNdO1xyXG4gICAgICAgICAgICBDYXJ0ZXNpYW4zLmZyb21TcGhlcmljYWwoc2NyYXRjaFNwaGVyaWNhbCwgc2NyYXRjaENhcnRlc2lhbik7XHJcblxyXG4gICAgICAgICAgICByZXN1bHRbaSArIDFdID0gc2NyYXRjaENhcnRlc2lhbi54O1xyXG4gICAgICAgICAgICByZXN1bHRbaSArIDJdID0gc2NyYXRjaENhcnRlc2lhbi55O1xyXG4gICAgICAgICAgICByZXN1bHRbaSArIDNdID0gc2NyYXRjaENhcnRlc2lhbi56O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNvbnZlcnRDYXJ0b2dyYXBoaWNSYWRpYW5zVG9DYXJ0ZXNpYW4oY2FydG9ncmFwaGljUmFkaWFucykge1xyXG4gICAgICAgIHZhciBsZW5ndGggPSBjYXJ0b2dyYXBoaWNSYWRpYW5zLmxlbmd0aDtcclxuICAgICAgICBpZiAobGVuZ3RoID09PSAzKSB7XHJcbiAgICAgICAgICAgIHNjcmF0Y2hDYXJ0b2dyYXBoaWMubG9uZ2l0dWRlID0gY2FydG9ncmFwaGljUmFkaWFuc1swXTtcclxuICAgICAgICAgICAgc2NyYXRjaENhcnRvZ3JhcGhpYy5sYXRpdHVkZSA9IGNhcnRvZ3JhcGhpY1JhZGlhbnNbMV07XHJcbiAgICAgICAgICAgIHNjcmF0Y2hDYXJ0b2dyYXBoaWMuaGVpZ2h0ID0gY2FydG9ncmFwaGljUmFkaWFuc1syXTtcclxuICAgICAgICAgICAgRWxsaXBzb2lkLldHUzg0LmNhcnRvZ3JhcGhpY1RvQ2FydGVzaWFuKHNjcmF0Y2hDYXJ0b2dyYXBoaWMsIHNjcmF0Y2hDYXJ0ZXNpYW4pO1xyXG4gICAgICAgICAgICByZXR1cm4gW3NjcmF0Y2hDYXJ0ZXNpYW4ueCwgc2NyYXRjaENhcnRlc2lhbi55LCBzY3JhdGNoQ2FydGVzaWFuLnpdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShsZW5ndGgpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDQpIHtcclxuICAgICAgICAgICAgcmVzdWx0W2ldID0gY2FydG9ncmFwaGljUmFkaWFuc1tpXTtcclxuXHJcbiAgICAgICAgICAgIHNjcmF0Y2hDYXJ0b2dyYXBoaWMubG9uZ2l0dWRlID0gY2FydG9ncmFwaGljUmFkaWFuc1tpICsgMV07XHJcbiAgICAgICAgICAgIHNjcmF0Y2hDYXJ0b2dyYXBoaWMubGF0aXR1ZGUgPSBjYXJ0b2dyYXBoaWNSYWRpYW5zW2kgKyAyXTtcclxuICAgICAgICAgICAgc2NyYXRjaENhcnRvZ3JhcGhpYy5oZWlnaHQgPSBjYXJ0b2dyYXBoaWNSYWRpYW5zW2kgKyAzXTtcclxuICAgICAgICAgICAgRWxsaXBzb2lkLldHUzg0LmNhcnRvZ3JhcGhpY1RvQ2FydGVzaWFuKHNjcmF0Y2hDYXJ0b2dyYXBoaWMsIHNjcmF0Y2hDYXJ0ZXNpYW4pO1xyXG5cclxuICAgICAgICAgICAgcmVzdWx0W2kgKyAxXSA9IHNjcmF0Y2hDYXJ0ZXNpYW4ueDtcclxuICAgICAgICAgICAgcmVzdWx0W2kgKyAyXSA9IHNjcmF0Y2hDYXJ0ZXNpYW4ueTtcclxuICAgICAgICAgICAgcmVzdWx0W2kgKyAzXSA9IHNjcmF0Y2hDYXJ0ZXNpYW4uejtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjb252ZXJ0Q2FydG9ncmFwaGljRGVncmVlc1RvQ2FydGVzaWFuKGNhcnRvZ3JhcGhpY0RlZ3JlZXMpIHtcclxuICAgICAgICB2YXIgbGVuZ3RoID0gY2FydG9ncmFwaGljRGVncmVlcy5sZW5ndGg7XHJcbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gMykge1xyXG4gICAgICAgICAgICBzY3JhdGNoQ2FydG9ncmFwaGljLmxvbmdpdHVkZSA9IENlc2l1bU1hdGgudG9SYWRpYW5zKGNhcnRvZ3JhcGhpY0RlZ3JlZXNbMF0pO1xyXG4gICAgICAgICAgICBzY3JhdGNoQ2FydG9ncmFwaGljLmxhdGl0dWRlID0gQ2VzaXVtTWF0aC50b1JhZGlhbnMoY2FydG9ncmFwaGljRGVncmVlc1sxXSk7XHJcbiAgICAgICAgICAgIHNjcmF0Y2hDYXJ0b2dyYXBoaWMuaGVpZ2h0ID0gY2FydG9ncmFwaGljRGVncmVlc1syXTtcclxuICAgICAgICAgICAgRWxsaXBzb2lkLldHUzg0LmNhcnRvZ3JhcGhpY1RvQ2FydGVzaWFuKHNjcmF0Y2hDYXJ0b2dyYXBoaWMsIHNjcmF0Y2hDYXJ0ZXNpYW4pO1xyXG4gICAgICAgICAgICByZXR1cm4gW3NjcmF0Y2hDYXJ0ZXNpYW4ueCwgc2NyYXRjaENhcnRlc2lhbi55LCBzY3JhdGNoQ2FydGVzaWFuLnpdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShsZW5ndGgpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDQpIHtcclxuICAgICAgICAgICAgcmVzdWx0W2ldID0gY2FydG9ncmFwaGljRGVncmVlc1tpXTtcclxuXHJcbiAgICAgICAgICAgIHNjcmF0Y2hDYXJ0b2dyYXBoaWMubG9uZ2l0dWRlID0gQ2VzaXVtTWF0aC50b1JhZGlhbnMoY2FydG9ncmFwaGljRGVncmVlc1tpICsgMV0pO1xyXG4gICAgICAgICAgICBzY3JhdGNoQ2FydG9ncmFwaGljLmxhdGl0dWRlID0gQ2VzaXVtTWF0aC50b1JhZGlhbnMoY2FydG9ncmFwaGljRGVncmVlc1tpICsgMl0pO1xyXG4gICAgICAgICAgICBzY3JhdGNoQ2FydG9ncmFwaGljLmhlaWdodCA9IGNhcnRvZ3JhcGhpY0RlZ3JlZXNbaSArIDNdO1xyXG4gICAgICAgICAgICBFbGxpcHNvaWQuV0dTODQuY2FydG9ncmFwaGljVG9DYXJ0ZXNpYW4oc2NyYXRjaENhcnRvZ3JhcGhpYywgc2NyYXRjaENhcnRlc2lhbik7XHJcblxyXG4gICAgICAgICAgICByZXN1bHRbaSArIDFdID0gc2NyYXRjaENhcnRlc2lhbi54O1xyXG4gICAgICAgICAgICByZXN1bHRbaSArIDJdID0gc2NyYXRjaENhcnRlc2lhbi55O1xyXG4gICAgICAgICAgICByZXN1bHRbaSArIDNdID0gc2NyYXRjaENhcnRlc2lhbi56O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHVud3JhcENhcnRlc2lhbkludGVydmFsKGN6bWxJbnRlcnZhbCkge1xyXG4gICAgICAgIHZhciBjYXJ0ZXNpYW4gPSBjem1sSW50ZXJ2YWwuY2FydGVzaWFuO1xyXG4gICAgICAgIGlmIChkZWZpbmVkKGNhcnRlc2lhbikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNhcnRlc2lhbjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBjYXJ0ZXNpYW5WZWxvY2l0eSA9IGN6bWxJbnRlcnZhbC5jYXJ0ZXNpYW5WZWxvY2l0eTtcclxuICAgICAgICBpZiAoZGVmaW5lZChjYXJ0ZXNpYW5WZWxvY2l0eSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNhcnRlc2lhblZlbG9jaXR5O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHVuaXRDYXJ0ZXNpYW4gPSBjem1sSW50ZXJ2YWwudW5pdENhcnRlc2lhbjtcclxuICAgICAgICBpZiAoZGVmaW5lZCh1bml0Q2FydGVzaWFuKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5pdENhcnRlc2lhbjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciB1bml0U3BoZXJpY2FsID0gY3ptbEludGVydmFsLnVuaXRTcGhlcmljYWw7XHJcbiAgICAgICAgaWYgKGRlZmluZWQodW5pdFNwaGVyaWNhbCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRVbml0U3BoZXJpY2FsVG9DYXJ0ZXNpYW4odW5pdFNwaGVyaWNhbCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgc3BoZXJpY2FsID0gY3ptbEludGVydmFsLnNwaGVyaWNhbDtcclxuICAgICAgICBpZiAoZGVmaW5lZChzcGhlcmljYWwpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjb252ZXJ0U3BoZXJpY2FsVG9DYXJ0ZXNpYW4oc3BoZXJpY2FsKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBjYXJ0b2dyYXBoaWNSYWRpYW5zID0gY3ptbEludGVydmFsLmNhcnRvZ3JhcGhpY1JhZGlhbnM7XHJcbiAgICAgICAgaWYgKGRlZmluZWQoY2FydG9ncmFwaGljUmFkaWFucykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRDYXJ0b2dyYXBoaWNSYWRpYW5zVG9DYXJ0ZXNpYW4oY2FydG9ncmFwaGljUmFkaWFucyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgY2FydG9ncmFwaGljRGVncmVlcyA9IGN6bWxJbnRlcnZhbC5jYXJ0b2dyYXBoaWNEZWdyZWVzO1xyXG4gICAgICAgIGlmIChkZWZpbmVkKGNhcnRvZ3JhcGhpY0RlZ3JlZXMpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjb252ZXJ0Q2FydG9ncmFwaGljRGVncmVlc1RvQ2FydGVzaWFuKGNhcnRvZ3JhcGhpY0RlZ3JlZXMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcihKU09OLnN0cmluZ2lmeShjem1sSW50ZXJ2YWwpICsgJyBpcyBub3QgYSB2YWxpZCBDWk1MIGludGVydmFsLicpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZVBhY2tlZENhcnRlc2lhbkFycmF5KGFycmF5LCBzdGFydGluZ0luZGV4KSB7XHJcbiAgICAgICAgQ2FydGVzaWFuMy51bnBhY2soYXJyYXksIHN0YXJ0aW5nSW5kZXgsIHNjcmF0Y2hDYXJ0ZXNpYW4pO1xyXG4gICAgICAgIENhcnRlc2lhbjMubm9ybWFsaXplKHNjcmF0Y2hDYXJ0ZXNpYW4sIHNjcmF0Y2hDYXJ0ZXNpYW4pO1xyXG4gICAgICAgIENhcnRlc2lhbjMucGFjayhzY3JhdGNoQ2FydGVzaWFuLCBhcnJheSwgc3RhcnRpbmdJbmRleCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdW53cmFwVW5pdENhcnRlc2lhbkludGVydmFsKGN6bWxJbnRlcnZhbCkge1xyXG4gICAgICAgIHZhciBjYXJ0ZXNpYW4gPSB1bndyYXBDYXJ0ZXNpYW5JbnRlcnZhbChjem1sSW50ZXJ2YWwpO1xyXG4gICAgICAgIGlmIChjYXJ0ZXNpYW4ubGVuZ3RoID09PSAzKSB7XHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZVBhY2tlZENhcnRlc2lhbkFycmF5KGNhcnRlc2lhbiwgMCk7XHJcbiAgICAgICAgICAgIHJldHVybiBjYXJ0ZXNpYW47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGNhcnRlc2lhbi5sZW5ndGg7IGkgKz0gNCkge1xyXG4gICAgICAgICAgICBub3JtYWxpemVQYWNrZWRDYXJ0ZXNpYW5BcnJheShjYXJ0ZXNpYW4sIGkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGNhcnRlc2lhbjtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBub3JtYWxpemVQYWNrZWRRdWF0ZXJuaW9uQXJyYXkoYXJyYXksIHN0YXJ0aW5nSW5kZXgpIHtcclxuICAgICAgICBRdWF0ZXJuaW9uLnVucGFjayhhcnJheSwgc3RhcnRpbmdJbmRleCwgc2NyYXRjaFF1YXRlcm5pb24pO1xyXG4gICAgICAgIFF1YXRlcm5pb24ubm9ybWFsaXplKHNjcmF0Y2hRdWF0ZXJuaW9uLCBzY3JhdGNoUXVhdGVybmlvbik7XHJcbiAgICAgICAgUXVhdGVybmlvbi5wYWNrKHNjcmF0Y2hRdWF0ZXJuaW9uLCBhcnJheSwgc3RhcnRpbmdJbmRleCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdW53cmFwUXVhdGVybmlvbkludGVydmFsKGN6bWxJbnRlcnZhbCkge1xyXG4gICAgICAgIHZhciB1bml0UXVhdGVybmlvbiA9IGN6bWxJbnRlcnZhbC51bml0UXVhdGVybmlvbjtcclxuICAgICAgICBpZiAoZGVmaW5lZCh1bml0UXVhdGVybmlvbikpIHtcclxuICAgICAgICAgICAgaWYgKHVuaXRRdWF0ZXJuaW9uLmxlbmd0aCA9PT0gNCkge1xyXG4gICAgICAgICAgICAgICAgbm9ybWFsaXplUGFja2VkUXVhdGVybmlvbkFycmF5KHVuaXRRdWF0ZXJuaW9uLCAwKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB1bml0UXVhdGVybmlvbjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB1bml0UXVhdGVybmlvbi5sZW5ndGg7IGkgKz0gNSkge1xyXG4gICAgICAgICAgICAgICAgbm9ybWFsaXplUGFja2VkUXVhdGVybmlvbkFycmF5KHVuaXRRdWF0ZXJuaW9uLCBpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdW5pdFF1YXRlcm5pb247XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0UHJvcGVydHlUeXBlKGN6bWxJbnRlcnZhbCkge1xyXG4gICAgICAgIC8vIFRoZSBhc3NvY2lhdGlvbnMgaW4gdGhpcyBmdW5jdGlvbiBuZWVkIHRvIGJlIGtlcHQgaW4gc3luYyB3aXRoIHRoZVxyXG4gICAgICAgIC8vIGFzc29jaWF0aW9ucyBpbiB1bndyYXBJbnRlcnZhbC5cclxuXHJcbiAgICAgICAgLy8gSW50ZW50aW9uYWxseSBvbWl0dGVkIGR1ZSB0byBjb25maWN0cyBpbiBDWk1MIHByb3BlcnR5IG5hbWVzOlxyXG4gICAgICAgIC8vICogSW1hZ2UgKGNvbmZsaWN0cyB3aXRoIFVyaSlcclxuICAgICAgICAvLyAqIFJvdGF0aW9uIChjb25mbGljdHMgd2l0aCBOdW1iZXIpXHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBjYXJ0ZXNpYW5WZWxvY2l0eSBpcyBhbHNvIG9taXR0ZWQgZHVlIHRvIGluY29tcGxldGUgc3VwcG9ydCBmb3JcclxuICAgICAgICAvLyBkZXJpdmF0aXZlIGluZm9ybWF0aW9uIGluIENaTUwgcHJvcGVydGllcy5cclxuICAgICAgICAvLyAoQ3VycmVudGx5IGNhcnRlc2lhblZlbG9jaXR5IGlzIGhhY2tlZCBkaXJlY3RseSBpbnRvIHRoZSBwb3NpdGlvbiBwcm9jZXNzaW5nIGNvZGUpXHJcbiAgICAgICAgaWYgKHR5cGVvZiBjem1sSW50ZXJ2YWwgPT09ICdib29sZWFuJykge1xyXG4gICAgICAgICAgICByZXR1cm4gQm9vbGVhbjtcclxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjem1sSW50ZXJ2YWwgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXI7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY3ptbEludGVydmFsID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoY3ptbEludGVydmFsLmhhc093blByb3BlcnR5KCdhcnJheScpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBBcnJheTtcclxuICAgICAgICB9IGVsc2UgaWYgKGN6bWxJbnRlcnZhbC5oYXNPd25Qcm9wZXJ0eSgnYm9vbGVhbicpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBCb29sZWFuO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoY3ptbEludGVydmFsLmhhc093blByb3BlcnR5KCdib3VuZGluZ1JlY3RhbmdsZScpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBCb3VuZGluZ1JlY3RhbmdsZTtcclxuICAgICAgICB9IGVsc2UgaWYgKGN6bWxJbnRlcnZhbC5oYXNPd25Qcm9wZXJ0eSgnY2FydGVzaWFuMicpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBDYXJ0ZXNpYW4yO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoY3ptbEludGVydmFsLmhhc093blByb3BlcnR5KCdjYXJ0ZXNpYW4nKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgY3ptbEludGVydmFsLmhhc093blByb3BlcnR5KCdzcGhlcmljYWwnKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgY3ptbEludGVydmFsLmhhc093blByb3BlcnR5KCdjYXJ0b2dyYXBoaWNSYWRpYW5zJykgfHxcclxuICAgICAgICAgICAgICAgICAgIGN6bWxJbnRlcnZhbC5oYXNPd25Qcm9wZXJ0eSgnY2FydG9ncmFwaGljRGVncmVlcycpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBDYXJ0ZXNpYW4zO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoY3ptbEludGVydmFsLmhhc093blByb3BlcnR5KCd1bml0Q2FydGVzaWFuJykgfHxcclxuICAgICAgICAgICAgICAgICAgIGN6bWxJbnRlcnZhbC5oYXNPd25Qcm9wZXJ0eSgndW5pdFNwaGVyaWNhbCcpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBVbml0Q2FydGVzaWFuMztcclxuICAgICAgICB9IGVsc2UgaWYgKGN6bWxJbnRlcnZhbC5oYXNPd25Qcm9wZXJ0eSgncmdiYScpIHx8XHJcbiAgICAgICAgICAgICAgICAgICBjem1sSW50ZXJ2YWwuaGFzT3duUHJvcGVydHkoJ3JnYmFmJykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIENvbG9yO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoY3ptbEludGVydmFsLmhhc093blByb3BlcnR5KCdjb2xvckJsZW5kTW9kZScpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBDb2xvckJsZW5kTW9kZTtcclxuICAgICAgICB9IGVsc2UgaWYgKGN6bWxJbnRlcnZhbC5oYXNPd25Qcm9wZXJ0eSgnY29ybmVyVHlwZScpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBDb3JuZXJUeXBlO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoY3ptbEludGVydmFsLmhhc093blByb3BlcnR5KCdoZWlnaHRSZWZlcmVuY2UnKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gSGVpZ2h0UmVmZXJlbmNlO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoY3ptbEludGVydmFsLmhhc093blByb3BlcnR5KCdob3Jpem9udGFsT3JpZ2luJykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIEhvcml6b250YWxPcmlnaW47XHJcbiAgICAgICAgfSBlbHNlIGlmIChjem1sSW50ZXJ2YWwuaGFzT3duUHJvcGVydHkoJ2RhdGUnKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gSnVsaWFuRGF0ZTtcclxuICAgICAgICB9IGVsc2UgaWYgKGN6bWxJbnRlcnZhbC5oYXNPd25Qcm9wZXJ0eSgnbGFiZWxTdHlsZScpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBMYWJlbFN0eWxlO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoY3ptbEludGVydmFsLmhhc093blByb3BlcnR5KCdudW1iZXInKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoY3ptbEludGVydmFsLmhhc093blByb3BlcnR5KCduZWFyRmFyU2NhbGFyJykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE5lYXJGYXJTY2FsYXI7XHJcbiAgICAgICAgfSBlbHNlIGlmIChjem1sSW50ZXJ2YWwuaGFzT3duUHJvcGVydHkoJ2Rpc3RhbmNlRGlzcGxheUNvbmRpdGlvbicpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBEaXN0YW5jZURpc3BsYXlDb25kaXRpb247XHJcbiAgICAgICAgfSBlbHNlIGlmIChjem1sSW50ZXJ2YWwuaGFzT3duUHJvcGVydHkoJ29iamVjdCcpIHx8XHJcbiAgICAgICAgICAgICAgICAgICBjem1sSW50ZXJ2YWwuaGFzT3duUHJvcGVydHkoJ3ZhbHVlJykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdDtcclxuICAgICAgICB9IGVsc2UgaWYgKGN6bWxJbnRlcnZhbC5oYXNPd25Qcm9wZXJ0eSgndW5pdFF1YXRlcm5pb24nKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gUXVhdGVybmlvbjtcclxuICAgICAgICB9IGVsc2UgaWYgKGN6bWxJbnRlcnZhbC5oYXNPd25Qcm9wZXJ0eSgnc2hhZG93TW9kZScpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBTaGFkb3dNb2RlO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoY3ptbEludGVydmFsLmhhc093blByb3BlcnR5KCdzdHJpbmcnKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoY3ptbEludGVydmFsLmhhc093blByb3BlcnR5KCdzdHJpcGVPcmllbnRhdGlvbicpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBTdHJpcGVPcmllbnRhdGlvbjtcclxuICAgICAgICB9IGVsc2UgaWYgKGN6bWxJbnRlcnZhbC5oYXNPd25Qcm9wZXJ0eSgnd3NlbicpIHx8XHJcbiAgICAgICAgICAgICAgICAgICBjem1sSW50ZXJ2YWwuaGFzT3duUHJvcGVydHkoJ3dzZW5EZWdyZWVzJykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFJlY3RhbmdsZTtcclxuICAgICAgICB9IGVsc2UgaWYgKGN6bWxJbnRlcnZhbC5oYXNPd25Qcm9wZXJ0eSgndXJpJykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFVyaTtcclxuICAgICAgICB9IGVsc2UgaWYgKGN6bWxJbnRlcnZhbC5oYXNPd25Qcm9wZXJ0eSgndmVydGljYWxPcmlnaW4nKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gVmVydGljYWxPcmlnaW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGZhbGxiYWNrIGNhc2VcclxuICAgICAgICByZXR1cm4gT2JqZWN0O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHVud3JhcEludGVydmFsKHR5cGUsIGN6bWxJbnRlcnZhbCwgc291cmNlVXJpKSB7XHJcbiAgICAgICAgLy8gVGhlIGFzc29jaWF0aW9ucyBpbiB0aGlzIGZ1bmN0aW9uIG5lZWQgdG8gYmUga2VwdCBpbiBzeW5jIHdpdGggdGhlXHJcbiAgICAgICAgLy8gYXNzb2NpYXRpb25zIGluIGdldFByb3BlcnR5VHlwZVxyXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlIEFycmF5OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGN6bWxJbnRlcnZhbC5hcnJheTtcclxuICAgICAgICAgICAgY2FzZSBCb29sZWFuOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZShjem1sSW50ZXJ2YWxbJ2Jvb2xlYW4nXSwgY3ptbEludGVydmFsKTtcclxuICAgICAgICAgICAgY2FzZSBCb3VuZGluZ1JlY3RhbmdsZTpcclxuICAgICAgICAgICAgICAgIHJldHVybiBjem1sSW50ZXJ2YWwuYm91bmRpbmdSZWN0YW5nbGU7XHJcbiAgICAgICAgICAgIGNhc2UgQ2FydGVzaWFuMjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBjem1sSW50ZXJ2YWwuY2FydGVzaWFuMjtcclxuICAgICAgICAgICAgY2FzZSBDYXJ0ZXNpYW4zOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVud3JhcENhcnRlc2lhbkludGVydmFsKGN6bWxJbnRlcnZhbCk7XHJcbiAgICAgICAgICAgIGNhc2UgVW5pdENhcnRlc2lhbjM6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdW53cmFwVW5pdENhcnRlc2lhbkludGVydmFsKGN6bWxJbnRlcnZhbCk7XHJcbiAgICAgICAgICAgIGNhc2UgQ29sb3I6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdW53cmFwQ29sb3JJbnRlcnZhbChjem1sSW50ZXJ2YWwpO1xyXG4gICAgICAgICAgICBjYXNlIENvbG9yQmxlbmRNb2RlOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIENvbG9yQmxlbmRNb2RlW2RlZmF1bHRWYWx1ZShjem1sSW50ZXJ2YWwuY29sb3JCbGVuZE1vZGUsIGN6bWxJbnRlcnZhbCldO1xyXG4gICAgICAgICAgICBjYXNlIENvcm5lclR5cGU6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gQ29ybmVyVHlwZVtkZWZhdWx0VmFsdWUoY3ptbEludGVydmFsLmNvcm5lclR5cGUsIGN6bWxJbnRlcnZhbCldO1xyXG4gICAgICAgICAgICBjYXNlIEhlaWdodFJlZmVyZW5jZTpcclxuICAgICAgICAgICAgICAgIHJldHVybiBIZWlnaHRSZWZlcmVuY2VbZGVmYXVsdFZhbHVlKGN6bWxJbnRlcnZhbC5oZWlnaHRSZWZlcmVuY2UsIGN6bWxJbnRlcnZhbCldO1xyXG4gICAgICAgICAgICBjYXNlIEhvcml6b250YWxPcmlnaW46XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gSG9yaXpvbnRhbE9yaWdpbltkZWZhdWx0VmFsdWUoY3ptbEludGVydmFsLmhvcml6b250YWxPcmlnaW4sIGN6bWxJbnRlcnZhbCldO1xyXG4gICAgICAgICAgICBjYXNlIEltYWdlOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVud3JhcFVyaUludGVydmFsKGN6bWxJbnRlcnZhbCwgc291cmNlVXJpKTtcclxuICAgICAgICAgICAgY2FzZSBKdWxpYW5EYXRlOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEp1bGlhbkRhdGUuZnJvbUlzbzg2MDEoZGVmYXVsdFZhbHVlKGN6bWxJbnRlcnZhbC5kYXRlLCBjem1sSW50ZXJ2YWwpKTtcclxuICAgICAgICAgICAgY2FzZSBMYWJlbFN0eWxlOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIExhYmVsU3R5bGVbZGVmYXVsdFZhbHVlKGN6bWxJbnRlcnZhbC5sYWJlbFN0eWxlLCBjem1sSW50ZXJ2YWwpXTtcclxuICAgICAgICAgICAgY2FzZSBOdW1iZXI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlKGN6bWxJbnRlcnZhbC5udW1iZXIsIGN6bWxJbnRlcnZhbCk7XHJcbiAgICAgICAgICAgIGNhc2UgTmVhckZhclNjYWxhcjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBjem1sSW50ZXJ2YWwubmVhckZhclNjYWxhcjtcclxuICAgICAgICAgICAgY2FzZSBEaXN0YW5jZURpc3BsYXlDb25kaXRpb246XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY3ptbEludGVydmFsLmRpc3RhbmNlRGlzcGxheUNvbmRpdGlvbjtcclxuICAgICAgICAgICAgY2FzZSBPYmplY3Q6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlKGRlZmF1bHRWYWx1ZShjem1sSW50ZXJ2YWwub2JqZWN0LCBjem1sSW50ZXJ2YWwudmFsdWUpLCBjem1sSW50ZXJ2YWwpO1xyXG4gICAgICAgICAgICBjYXNlIFF1YXRlcm5pb246XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdW53cmFwUXVhdGVybmlvbkludGVydmFsKGN6bWxJbnRlcnZhbCk7XHJcbiAgICAgICAgICAgIGNhc2UgUmVjdGFuZ2xlOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVud3JhcFJlY3RhbmdsZUludGVydmFsKGN6bWxJbnRlcnZhbCk7XHJcbiAgICAgICAgICAgIGNhc2UgUm90YXRpb246XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlKGN6bWxJbnRlcnZhbC5udW1iZXIsIGN6bWxJbnRlcnZhbCk7XHJcbiAgICAgICAgICAgIGNhc2UgU2hhZG93TW9kZTpcclxuICAgICAgICAgICAgICAgIHJldHVybiBTaGFkb3dNb2RlW2RlZmF1bHRWYWx1ZShkZWZhdWx0VmFsdWUoY3ptbEludGVydmFsLnNoYWRvd01vZGUsIGN6bWxJbnRlcnZhbC5zaGFkb3dzKSwgY3ptbEludGVydmFsKV07XHJcbiAgICAgICAgICAgIGNhc2UgU3RyaW5nOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZShjem1sSW50ZXJ2YWwuc3RyaW5nLCBjem1sSW50ZXJ2YWwpO1xyXG4gICAgICAgICAgICBjYXNlIFN0cmlwZU9yaWVudGF0aW9uOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cmlwZU9yaWVudGF0aW9uW2RlZmF1bHRWYWx1ZShjem1sSW50ZXJ2YWwuc3RyaXBlT3JpZW50YXRpb24sIGN6bWxJbnRlcnZhbCldO1xyXG4gICAgICAgICAgICBjYXNlIFVyaTpcclxuICAgICAgICAgICAgICAgIHJldHVybiB1bndyYXBVcmlJbnRlcnZhbChjem1sSW50ZXJ2YWwsIHNvdXJjZVVyaSk7XHJcbiAgICAgICAgICAgIGNhc2UgVmVydGljYWxPcmlnaW46XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gVmVydGljYWxPcmlnaW5bZGVmYXVsdFZhbHVlKGN6bWxJbnRlcnZhbC52ZXJ0aWNhbE9yaWdpbiwgY3ptbEludGVydmFsKV07XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUnVudGltZUVycm9yKHR5cGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgaW50ZXJwb2xhdG9ycyA9IHtcclxuICAgICAgICBIRVJNSVRFIDogSGVybWl0ZVBvbHlub21pYWxBcHByb3hpbWF0aW9uLFxyXG4gICAgICAgIExBR1JBTkdFIDogTGFncmFuZ2VQb2x5bm9taWFsQXBwcm94aW1hdGlvbixcclxuICAgICAgICBMSU5FQVIgOiBMaW5lYXJBcHByb3hpbWF0aW9uXHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIHVwZGF0ZUludGVycG9sYXRpb25TZXR0aW5ncyhwYWNrZXREYXRhLCBwcm9wZXJ0eSkge1xyXG4gICAgICAgIHZhciBpbnRlcnBvbGF0aW9uQWxnb3JpdGhtID0gcGFja2V0RGF0YS5pbnRlcnBvbGF0aW9uQWxnb3JpdGhtO1xyXG4gICAgICAgIGlmIChkZWZpbmVkKGludGVycG9sYXRpb25BbGdvcml0aG0pIHx8IGRlZmluZWQocGFja2V0RGF0YS5pbnRlcnBvbGF0aW9uRGVncmVlKSkge1xyXG4gICAgICAgICAgICBwcm9wZXJ0eS5zZXRJbnRlcnBvbGF0aW9uT3B0aW9ucyh7XHJcbiAgICAgICAgICAgICAgICBpbnRlcnBvbGF0aW9uQWxnb3JpdGhtIDogaW50ZXJwb2xhdG9yc1tpbnRlcnBvbGF0aW9uQWxnb3JpdGhtXSxcclxuICAgICAgICAgICAgICAgIGludGVycG9sYXRpb25EZWdyZWUgOiBwYWNrZXREYXRhLmludGVycG9sYXRpb25EZWdyZWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgZm9yd2FyZEV4dHJhcG9sYXRpb25UeXBlID0gcGFja2V0RGF0YS5mb3J3YXJkRXh0cmFwb2xhdGlvblR5cGU7XHJcbiAgICAgICAgaWYgKGRlZmluZWQoZm9yd2FyZEV4dHJhcG9sYXRpb25UeXBlKSkge1xyXG4gICAgICAgICAgICBwcm9wZXJ0eS5mb3J3YXJkRXh0cmFwb2xhdGlvblR5cGUgPSBFeHRyYXBvbGF0aW9uVHlwZVtmb3J3YXJkRXh0cmFwb2xhdGlvblR5cGVdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGZvcndhcmRFeHRyYXBvbGF0aW9uRHVyYXRpb24gPSBwYWNrZXREYXRhLmZvcndhcmRFeHRyYXBvbGF0aW9uRHVyYXRpb247XHJcbiAgICAgICAgaWYgKGRlZmluZWQoZm9yd2FyZEV4dHJhcG9sYXRpb25EdXJhdGlvbikpIHtcclxuICAgICAgICAgICAgcHJvcGVydHkuZm9yd2FyZEV4dHJhcG9sYXRpb25EdXJhdGlvbiA9IGZvcndhcmRFeHRyYXBvbGF0aW9uRHVyYXRpb247XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgYmFja3dhcmRFeHRyYXBvbGF0aW9uVHlwZSA9IHBhY2tldERhdGEuYmFja3dhcmRFeHRyYXBvbGF0aW9uVHlwZTtcclxuICAgICAgICBpZiAoZGVmaW5lZChiYWNrd2FyZEV4dHJhcG9sYXRpb25UeXBlKSkge1xyXG4gICAgICAgICAgICBwcm9wZXJ0eS5iYWNrd2FyZEV4dHJhcG9sYXRpb25UeXBlID0gRXh0cmFwb2xhdGlvblR5cGVbYmFja3dhcmRFeHRyYXBvbGF0aW9uVHlwZV07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgYmFja3dhcmRFeHRyYXBvbGF0aW9uRHVyYXRpb24gPSBwYWNrZXREYXRhLmJhY2t3YXJkRXh0cmFwb2xhdGlvbkR1cmF0aW9uO1xyXG4gICAgICAgIGlmIChkZWZpbmVkKGJhY2t3YXJkRXh0cmFwb2xhdGlvbkR1cmF0aW9uKSkge1xyXG4gICAgICAgICAgICBwcm9wZXJ0eS5iYWNrd2FyZEV4dHJhcG9sYXRpb25EdXJhdGlvbiA9IGJhY2t3YXJkRXh0cmFwb2xhdGlvbkR1cmF0aW9uO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgaXNvODYwMVNjcmF0Y2ggPSB7XHJcbiAgICAgICAgaXNvODYwMSA6IHVuZGVmaW5lZFxyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBwcm9jZXNzUHJvcGVydHkodHlwZSwgb2JqZWN0LCBwcm9wZXJ0eU5hbWUsIHBhY2tldERhdGEsIGNvbnN0cmFpbmVkSW50ZXJ2YWwsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbikge1xyXG4gICAgICAgIHZhciBjb21iaW5lZEludGVydmFsO1xyXG4gICAgICAgIHZhciBwYWNrZXRJbnRlcnZhbCA9IHBhY2tldERhdGEuaW50ZXJ2YWw7XHJcbiAgICAgICAgaWYgKGRlZmluZWQocGFja2V0SW50ZXJ2YWwpKSB7XHJcbiAgICAgICAgICAgIGlzbzg2MDFTY3JhdGNoLmlzbzg2MDEgPSBwYWNrZXRJbnRlcnZhbDtcclxuICAgICAgICAgICAgY29tYmluZWRJbnRlcnZhbCA9IFRpbWVJbnRlcnZhbC5mcm9tSXNvODYwMShpc284NjAxU2NyYXRjaCk7XHJcbiAgICAgICAgICAgIGlmIChkZWZpbmVkKGNvbnN0cmFpbmVkSW50ZXJ2YWwpKSB7XHJcbiAgICAgICAgICAgICAgICBjb21iaW5lZEludGVydmFsID0gVGltZUludGVydmFsLmludGVyc2VjdChjb21iaW5lZEludGVydmFsLCBjb25zdHJhaW5lZEludGVydmFsLCBzY3JhdGNoVGltZUludGVydmFsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAoZGVmaW5lZChjb25zdHJhaW5lZEludGVydmFsKSkge1xyXG4gICAgICAgICAgICBjb21iaW5lZEludGVydmFsID0gY29uc3RyYWluZWRJbnRlcnZhbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBwYWNrZWRMZW5ndGg7XHJcbiAgICAgICAgdmFyIGlzU2FtcGxlZDtcclxuICAgICAgICB2YXIgdW53cmFwcGVkSW50ZXJ2YWw7XHJcbiAgICAgICAgdmFyIHVud3JhcHBlZEludGVydmFsTGVuZ3RoO1xyXG5cclxuICAgICAgICAvLyBDWk1MIHByb3BlcnRpZXMgY2FuIGJlIGRlZmluZWQgaW4gbWFueSB3YXlzLiAgTW9zdCB3YXlzIHJlcHJlc2VudCBhIHN0cnVjdHVyZSBmb3JcclxuICAgICAgICAvLyBlbmNvZGluZyBhIHNpbmdsZSB2YWx1ZSAobnVtYmVyLCBzdHJpbmcsIGNhcnRlc2lhbiwgZXRjLikgIFJlZ2FyZGxlc3Mgb2YgdGhlIHZhbHVlIHR5cGUsXHJcbiAgICAgICAgLy8gaWYgaXQgZW5jb2RlcyBhIHNpbmdsZSB2YWx1ZSBpdCB3aWxsIGdldCBsb2FkZWQgaW50byBhIENvbnN0YW50UHJvcGVydHkgZXZlbnR1YWxseS5cclxuICAgICAgICAvLyBBbHRlcm5hdGl2ZWx5LCB0aGVyZSBhcmUgd2F5cyBvZiBkZWZpbmluZyBhIHByb3BlcnR5IHRoYXQgcmVxdWlyZSBzcGVjaWFsaXplZFxyXG4gICAgICAgIC8vIGNsaWVudC1zaWRlIHJlcHJlc2VudGF0aW9uLiBDdXJyZW50bHksIHRoZXNlIGFyZSBSZWZlcmVuY2VQcm9wZXJ0eSxcclxuICAgICAgICAvLyBhbmQgY2xpZW50LXNpZGUgdmVsb2NpdHkgY29tcHV0YXRpb24gcHJvcGVydGllcyBzdWNoIGFzIFZlbG9jaXR5VmVjdG9yUHJvcGVydHkuXHJcbiAgICAgICAgdmFyIGlzVmFsdWUgPSAhZGVmaW5lZChwYWNrZXREYXRhLnJlZmVyZW5jZSkgJiYgIWRlZmluZWQocGFja2V0RGF0YS52ZWxvY2l0eVJlZmVyZW5jZSk7XHJcbiAgICAgICAgdmFyIGhhc0ludGVydmFsID0gZGVmaW5lZChjb21iaW5lZEludGVydmFsKSAmJiAhY29tYmluZWRJbnRlcnZhbC5lcXVhbHMoSXNvODYwMS5NQVhJTVVNX0lOVEVSVkFMKTtcclxuXHJcbiAgICAgICAgaWYgKGlzVmFsdWUpIHtcclxuICAgICAgICAgICAgdW53cmFwcGVkSW50ZXJ2YWwgPSB1bndyYXBJbnRlcnZhbCh0eXBlLCBwYWNrZXREYXRhLCBzb3VyY2VVcmkpO1xyXG4gICAgICAgICAgICBwYWNrZWRMZW5ndGggPSBkZWZhdWx0VmFsdWUodHlwZS5wYWNrZWRMZW5ndGgsIDEpO1xyXG4gICAgICAgICAgICB1bndyYXBwZWRJbnRlcnZhbExlbmd0aCA9IGRlZmF1bHRWYWx1ZSh1bndyYXBwZWRJbnRlcnZhbC5sZW5ndGgsIDEpO1xyXG4gICAgICAgICAgICBpc1NhbXBsZWQgPSAhZGVmaW5lZChwYWNrZXREYXRhLmFycmF5KSAmJiAodHlwZW9mIHVud3JhcHBlZEludGVydmFsICE9PSAnc3RyaW5nJykgJiYgKHVud3JhcHBlZEludGVydmFsTGVuZ3RoID4gcGFja2VkTGVuZ3RoKSAmJiAodHlwZSAhPT0gT2JqZWN0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vUm90YXRpb24gaXMgYSBzcGVjaWFsIGNhc2UgYmVjYXVzZSBpdCByZXByZXNlbnRzIGEgbmF0aXZlIHR5cGUgKE51bWJlcilcclxuICAgICAgICAvL2FuZCB0aGVyZWZvcmUgZG9lcyBub3QgbmVlZCB0byBiZSB1bnBhY2tlZCB3aGVuIGxvYWRlZCBhcyBhIGNvbnN0YW50IHZhbHVlLlxyXG4gICAgICAgIHZhciBuZWVkc1VucGFja2luZyA9IHR5cGVvZiB0eXBlLnVucGFjayA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlICE9PSBSb3RhdGlvbjtcclxuXHJcbiAgICAgICAgLy9BbnkgdGltZSBhIGNvbnN0YW50IHZhbHVlIGlzIGFzc2lnbmVkLCBpdCBjb21wbGV0ZWx5IGJsb3dzIGF3YXkgYW55dGhpbmcgZWxzZS5cclxuICAgICAgICBpZiAoIWlzU2FtcGxlZCAmJiAhaGFzSW50ZXJ2YWwpIHtcclxuICAgICAgICAgICAgaWYgKGlzVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIG9iamVjdFtwcm9wZXJ0eU5hbWVdID0gbmV3IENvbnN0YW50UHJvcGVydHkobmVlZHNVbnBhY2tpbmcgPyB0eXBlLnVucGFjayh1bndyYXBwZWRJbnRlcnZhbCwgMCkgOiB1bndyYXBwZWRJbnRlcnZhbCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBvYmplY3RbcHJvcGVydHlOYW1lXSA9IGNyZWF0ZVNwZWNpYWxpemVkUHJvcGVydHkodHlwZSwgZW50aXR5Q29sbGVjdGlvbiwgcGFja2V0RGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHByb3BlcnR5ID0gb2JqZWN0W3Byb3BlcnR5TmFtZV07XHJcblxyXG4gICAgICAgIHZhciBlcG9jaDtcclxuICAgICAgICB2YXIgcGFja2V0RXBvY2ggPSBwYWNrZXREYXRhLmVwb2NoO1xyXG4gICAgICAgIGlmIChkZWZpbmVkKHBhY2tldEVwb2NoKSkge1xyXG4gICAgICAgICAgICBlcG9jaCA9IEp1bGlhbkRhdGUuZnJvbUlzbzg2MDEocGFja2V0RXBvY2gpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9XaXRob3V0IGFuIGludGVydmFsLCBhbnkgc2FtcGxlZCB2YWx1ZSBpcyBpbmZpbml0ZSwgbWVhbmluZyBpdCBjb21wbGV0ZWx5XHJcbiAgICAgICAgLy9yZXBsYWNlcyBhbnkgbm9uLXNhbXBsZWQgcHJvcGVydHkgdGhhdCBtYXkgZXhpc3QuXHJcbiAgICAgICAgaWYgKGlzU2FtcGxlZCAmJiAhaGFzSW50ZXJ2YWwpIHtcclxuICAgICAgICAgICAgaWYgKCEocHJvcGVydHkgaW5zdGFuY2VvZiBTYW1wbGVkUHJvcGVydHkpKSB7XHJcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eSA9IG5ldyBTYW1wbGVkUHJvcGVydHkodHlwZSk7XHJcbiAgICAgICAgICAgICAgICBvYmplY3RbcHJvcGVydHlOYW1lXSA9IHByb3BlcnR5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHByb3BlcnR5LmFkZFNhbXBsZXNQYWNrZWRBcnJheSh1bndyYXBwZWRJbnRlcnZhbCwgZXBvY2gpO1xyXG4gICAgICAgICAgICB1cGRhdGVJbnRlcnBvbGF0aW9uU2V0dGluZ3MocGFja2V0RGF0YSwgcHJvcGVydHkpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgaW50ZXJ2YWw7XHJcblxyXG4gICAgICAgIC8vQSBjb25zdGFudCB2YWx1ZSB3aXRoIGFuIGludGVydmFsIGlzIG5vcm1hbGx5IHBhcnQgb2YgYSBUaW1lSW50ZXJ2YWxDb2xsZWN0aW9uLFxyXG4gICAgICAgIC8vSG93ZXZlciwgaWYgdGhlIGN1cnJlbnQgcHJvcGVydHkgaXMgbm90IGEgdGltZS1pbnRlcnZhbCBjb2xsZWN0aW9uLCB3ZSBuZWVkXHJcbiAgICAgICAgLy90byB0dXJuIGl0IGludG8gYSBDb21wb3NpdGUsIHByZXNlcnZpbmcgdGhlIG9sZCBkYXRhIHdpdGggdGhlIG5ldyBpbnRlcnZhbC5cclxuICAgICAgICBpZiAoIWlzU2FtcGxlZCAmJiBoYXNJbnRlcnZhbCkge1xyXG4gICAgICAgICAgICAvL0NyZWF0ZSBhIG5ldyBpbnRlcnZhbCBmb3IgdGhlIGNvbnN0YW50IHZhbHVlLlxyXG4gICAgICAgICAgICBjb21iaW5lZEludGVydmFsID0gY29tYmluZWRJbnRlcnZhbC5jbG9uZSgpO1xyXG4gICAgICAgICAgICBpZiAoaXNWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgY29tYmluZWRJbnRlcnZhbC5kYXRhID0gbmVlZHNVbnBhY2tpbmcgPyB0eXBlLnVucGFjayh1bndyYXBwZWRJbnRlcnZhbCwgMCkgOiB1bndyYXBwZWRJbnRlcnZhbDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbWJpbmVkSW50ZXJ2YWwuZGF0YSA9IGNyZWF0ZVNwZWNpYWxpemVkUHJvcGVydHkodHlwZSwgZW50aXR5Q29sbGVjdGlvbiwgcGFja2V0RGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vSWYgbm8gcHJvcGVydHkgZXhpc3RzLCBzaW1wbHkgdXNlIGEgbmV3IGludGVydmFsIGNvbGxlY3Rpb25cclxuICAgICAgICAgICAgaWYgKCFkZWZpbmVkKHByb3BlcnR5KSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eSA9IG5ldyBUaW1lSW50ZXJ2YWxDb2xsZWN0aW9uUHJvcGVydHkoKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHkgPSBuZXcgQ29tcG9zaXRlUHJvcGVydHkoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG9iamVjdFtwcm9wZXJ0eU5hbWVdID0gcHJvcGVydHk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChpc1ZhbHVlICYmIHByb3BlcnR5IGluc3RhbmNlb2YgVGltZUludGVydmFsQ29sbGVjdGlvblByb3BlcnR5KSB7XHJcbiAgICAgICAgICAgICAgICAvL0lmIHdlIGNyZWF0ZSBhIGNvbGxlY3Rpb24sIG9yIGl0IGFscmVhZHkgZXhpc3RlZCwgdXNlIGl0LlxyXG4gICAgICAgICAgICAgICAgcHJvcGVydHkuaW50ZXJ2YWxzLmFkZEludGVydmFsKGNvbWJpbmVkSW50ZXJ2YWwpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByb3BlcnR5IGluc3RhbmNlb2YgQ29tcG9zaXRlUHJvcGVydHkpIHtcclxuICAgICAgICAgICAgICAgIC8vSWYgdGhlIGNvbGxlY3Rpb24gd2FzIGFscmVhZHkgYSBDb21wb3NpdGVQcm9wZXJ0eSwgdXNlIGl0LlxyXG4gICAgICAgICAgICAgICAgaWYgKGlzVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb21iaW5lZEludGVydmFsLmRhdGEgPSBuZXcgQ29uc3RhbnRQcm9wZXJ0eShjb21iaW5lZEludGVydmFsLmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcHJvcGVydHkuaW50ZXJ2YWxzLmFkZEludGVydmFsKGNvbWJpbmVkSW50ZXJ2YWwpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy9PdGhlcndpc2UsIGNyZWF0ZSBhIENvbXBvc2l0ZVByb3BlcnR5IGJ1dCBwcmVzZXJ2ZSB0aGUgZXhpc3RpbmcgZGF0YS5cclxuXHJcbiAgICAgICAgICAgICAgICAvL1B1dCB0aGUgb2xkIHByb3BlcnR5IGluIGFuIGluZmluaXRlIGludGVydmFsLlxyXG4gICAgICAgICAgICAgICAgaW50ZXJ2YWwgPSBJc284NjAxLk1BWElNVU1fSU5URVJWQUwuY2xvbmUoKTtcclxuICAgICAgICAgICAgICAgIGludGVydmFsLmRhdGEgPSBwcm9wZXJ0eTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL0NyZWF0ZSB0aGUgY29tcG9zaXRlLlxyXG4gICAgICAgICAgICAgICAgcHJvcGVydHkgPSBuZXcgQ29tcG9zaXRlUHJvcGVydHkoKTtcclxuICAgICAgICAgICAgICAgIG9iamVjdFtwcm9wZXJ0eU5hbWVdID0gcHJvcGVydHk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9hZGQgdGhlIG9sZCBwcm9wZXJ0eSBpbnRlcnZhbFxyXG4gICAgICAgICAgICAgICAgcHJvcGVydHkuaW50ZXJ2YWxzLmFkZEludGVydmFsKGludGVydmFsKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL0NoYW5nZSB0aGUgbmV3IGRhdGEgdG8gYSBDb25zdGFudFByb3BlcnR5IGFuZCBhZGQgaXQuXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbWJpbmVkSW50ZXJ2YWwuZGF0YSA9IG5ldyBDb25zdGFudFByb3BlcnR5KGNvbWJpbmVkSW50ZXJ2YWwuZGF0YSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eS5pbnRlcnZhbHMuYWRkSW50ZXJ2YWwoY29tYmluZWRJbnRlcnZhbCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vaXNTYW1wbGVkICYmIGhhc0ludGVydmFsXHJcbiAgICAgICAgaWYgKCFkZWZpbmVkKHByb3BlcnR5KSkge1xyXG4gICAgICAgICAgICBwcm9wZXJ0eSA9IG5ldyBDb21wb3NpdGVQcm9wZXJ0eSgpO1xyXG4gICAgICAgICAgICBvYmplY3RbcHJvcGVydHlOYW1lXSA9IHByb3BlcnR5O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9jcmVhdGUgYSBDb21wb3NpdGVQcm9wZXJ0eSBidXQgcHJlc2VydmUgdGhlIGV4aXN0aW5nIGRhdGEuXHJcbiAgICAgICAgaWYgKCEocHJvcGVydHkgaW5zdGFuY2VvZiBDb21wb3NpdGVQcm9wZXJ0eSkpIHtcclxuICAgICAgICAgICAgLy9QdXQgdGhlIG9sZCBwcm9wZXJ0eSBpbiBhbiBpbmZpbml0ZSBpbnRlcnZhbC5cclxuICAgICAgICAgICAgaW50ZXJ2YWwgPSBJc284NjAxLk1BWElNVU1fSU5URVJWQUwuY2xvbmUoKTtcclxuICAgICAgICAgICAgaW50ZXJ2YWwuZGF0YSA9IHByb3BlcnR5O1xyXG5cclxuICAgICAgICAgICAgLy9DcmVhdGUgdGhlIGNvbXBvc2l0ZS5cclxuICAgICAgICAgICAgcHJvcGVydHkgPSBuZXcgQ29tcG9zaXRlUHJvcGVydHkoKTtcclxuICAgICAgICAgICAgb2JqZWN0W3Byb3BlcnR5TmFtZV0gPSBwcm9wZXJ0eTtcclxuXHJcbiAgICAgICAgICAgIC8vYWRkIHRoZSBvbGQgcHJvcGVydHkgaW50ZXJ2YWxcclxuICAgICAgICAgICAgcHJvcGVydHkuaW50ZXJ2YWxzLmFkZEludGVydmFsKGludGVydmFsKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vQ2hlY2sgaWYgdGhlIGludGVydmFsIGFscmVhZHkgZXhpc3RzIGluIHRoZSBjb21wb3NpdGVcclxuICAgICAgICB2YXIgaW50ZXJ2YWxzID0gcHJvcGVydHkuaW50ZXJ2YWxzO1xyXG4gICAgICAgIGludGVydmFsID0gaW50ZXJ2YWxzLmZpbmRJbnRlcnZhbChjb21iaW5lZEludGVydmFsKTtcclxuICAgICAgICBpZiAoIWRlZmluZWQoaW50ZXJ2YWwpIHx8ICEoaW50ZXJ2YWwuZGF0YSBpbnN0YW5jZW9mIFNhbXBsZWRQcm9wZXJ0eSkpIHtcclxuICAgICAgICAgICAgLy9JZiBub3QsIGNyZWF0ZSBhIFNhbXBsZWRQcm9wZXJ0eSBmb3IgaXQuXHJcbiAgICAgICAgICAgIGludGVydmFsID0gY29tYmluZWRJbnRlcnZhbC5jbG9uZSgpO1xyXG4gICAgICAgICAgICBpbnRlcnZhbC5kYXRhID0gbmV3IFNhbXBsZWRQcm9wZXJ0eSh0eXBlKTtcclxuICAgICAgICAgICAgaW50ZXJ2YWxzLmFkZEludGVydmFsKGludGVydmFsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaW50ZXJ2YWwuZGF0YS5hZGRTYW1wbGVzUGFja2VkQXJyYXkodW53cmFwcGVkSW50ZXJ2YWwsIGVwb2NoKTtcclxuICAgICAgICB1cGRhdGVJbnRlcnBvbGF0aW9uU2V0dGluZ3MocGFja2V0RGF0YSwgaW50ZXJ2YWwuZGF0YSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcHJvY2Vzc1BhY2tldERhdGEodHlwZSwgb2JqZWN0LCBwcm9wZXJ0eU5hbWUsIHBhY2tldERhdGEsIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pIHtcclxuICAgICAgICBpZiAoIWRlZmluZWQocGFja2V0RGF0YSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGlzQXJyYXkocGFja2V0RGF0YSkpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBhY2tldERhdGEubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHByb2Nlc3NQcm9wZXJ0eSh0eXBlLCBvYmplY3QsIHByb3BlcnR5TmFtZSwgcGFja2V0RGF0YVtpXSwgaW50ZXJ2YWwsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBwcm9jZXNzUHJvcGVydHkodHlwZSwgb2JqZWN0LCBwcm9wZXJ0eU5hbWUsIHBhY2tldERhdGEsIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBwcm9jZXNzUG9zaXRpb25Qcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5TmFtZSwgcGFja2V0RGF0YSwgY29uc3RyYWluZWRJbnRlcnZhbCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKSB7XHJcbiAgICAgICAgdmFyIGNvbWJpbmVkSW50ZXJ2YWw7XHJcbiAgICAgICAgdmFyIHBhY2tldEludGVydmFsID0gcGFja2V0RGF0YS5pbnRlcnZhbDtcclxuICAgICAgICBpZiAoZGVmaW5lZChwYWNrZXRJbnRlcnZhbCkpIHtcclxuICAgICAgICAgICAgaXNvODYwMVNjcmF0Y2guaXNvODYwMSA9IHBhY2tldEludGVydmFsO1xyXG4gICAgICAgICAgICBjb21iaW5lZEludGVydmFsID0gVGltZUludGVydmFsLmZyb21Jc284NjAxKGlzbzg2MDFTY3JhdGNoKTtcclxuICAgICAgICAgICAgaWYgKGRlZmluZWQoY29uc3RyYWluZWRJbnRlcnZhbCkpIHtcclxuICAgICAgICAgICAgICAgIGNvbWJpbmVkSW50ZXJ2YWwgPSBUaW1lSW50ZXJ2YWwuaW50ZXJzZWN0KGNvbWJpbmVkSW50ZXJ2YWwsIGNvbnN0cmFpbmVkSW50ZXJ2YWwsIHNjcmF0Y2hUaW1lSW50ZXJ2YWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChkZWZpbmVkKGNvbnN0cmFpbmVkSW50ZXJ2YWwpKSB7XHJcbiAgICAgICAgICAgIGNvbWJpbmVkSW50ZXJ2YWwgPSBjb25zdHJhaW5lZEludGVydmFsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHJlZmVyZW5jZUZyYW1lO1xyXG4gICAgICAgIHZhciB1bndyYXBwZWRJbnRlcnZhbDtcclxuICAgICAgICB2YXIgaXNTYW1wbGVkID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIHVud3JhcHBlZEludGVydmFsTGVuZ3RoO1xyXG4gICAgICAgIHZhciBudW1iZXJPZkRlcml2YXRpdmVzID0gZGVmaW5lZChwYWNrZXREYXRhLmNhcnRlc2lhblZlbG9jaXR5KSA/IDEgOiAwO1xyXG4gICAgICAgIHZhciBwYWNrZWRMZW5ndGggPSBDYXJ0ZXNpYW4zLnBhY2tlZExlbmd0aCAqIChudW1iZXJPZkRlcml2YXRpdmVzICsgMSk7XHJcbiAgICAgICAgdmFyIGlzVmFsdWUgPSAhZGVmaW5lZChwYWNrZXREYXRhLnJlZmVyZW5jZSk7XHJcbiAgICAgICAgdmFyIGhhc0ludGVydmFsID0gZGVmaW5lZChjb21iaW5lZEludGVydmFsKSAmJiAhY29tYmluZWRJbnRlcnZhbC5lcXVhbHMoSXNvODYwMS5NQVhJTVVNX0lOVEVSVkFMKTtcclxuXHJcbiAgICAgICAgaWYgKGlzVmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKGRlZmluZWQocGFja2V0RGF0YS5yZWZlcmVuY2VGcmFtZSkpIHtcclxuICAgICAgICAgICAgICAgIHJlZmVyZW5jZUZyYW1lID0gUmVmZXJlbmNlRnJhbWVbcGFja2V0RGF0YS5yZWZlcmVuY2VGcmFtZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVmZXJlbmNlRnJhbWUgPSBkZWZhdWx0VmFsdWUocmVmZXJlbmNlRnJhbWUsIFJlZmVyZW5jZUZyYW1lLkZJWEVEKTtcclxuICAgICAgICAgICAgdW53cmFwcGVkSW50ZXJ2YWwgPSB1bndyYXBDYXJ0ZXNpYW5JbnRlcnZhbChwYWNrZXREYXRhKTtcclxuICAgICAgICAgICAgdW53cmFwcGVkSW50ZXJ2YWxMZW5ndGggPSBkZWZhdWx0VmFsdWUodW53cmFwcGVkSW50ZXJ2YWwubGVuZ3RoLCAxKTtcclxuICAgICAgICAgICAgaXNTYW1wbGVkID0gdW53cmFwcGVkSW50ZXJ2YWxMZW5ndGggPiBwYWNrZWRMZW5ndGg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL0FueSB0aW1lIGEgY29uc3RhbnQgdmFsdWUgaXMgYXNzaWduZWQsIGl0IGNvbXBsZXRlbHkgYmxvd3MgYXdheSBhbnl0aGluZyBlbHNlLlxyXG4gICAgICAgIGlmICghaXNTYW1wbGVkICYmICFoYXNJbnRlcnZhbCkge1xyXG4gICAgICAgICAgICBpZiAoaXNWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgb2JqZWN0W3Byb3BlcnR5TmFtZV0gPSBuZXcgQ29uc3RhbnRQb3NpdGlvblByb3BlcnR5KENhcnRlc2lhbjMudW5wYWNrKHVud3JhcHBlZEludGVydmFsKSwgcmVmZXJlbmNlRnJhbWUpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgb2JqZWN0W3Byb3BlcnR5TmFtZV0gPSBjcmVhdGVSZWZlcmVuY2VQcm9wZXJ0eShlbnRpdHlDb2xsZWN0aW9uLCBwYWNrZXREYXRhLnJlZmVyZW5jZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHByb3BlcnR5ID0gb2JqZWN0W3Byb3BlcnR5TmFtZV07XHJcblxyXG4gICAgICAgIHZhciBlcG9jaDtcclxuICAgICAgICB2YXIgcGFja2V0RXBvY2ggPSBwYWNrZXREYXRhLmVwb2NoO1xyXG4gICAgICAgIGlmIChkZWZpbmVkKHBhY2tldEVwb2NoKSkge1xyXG4gICAgICAgICAgICBlcG9jaCA9IEp1bGlhbkRhdGUuZnJvbUlzbzg2MDEocGFja2V0RXBvY2gpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9XaXRob3V0IGFuIGludGVydmFsLCBhbnkgc2FtcGxlZCB2YWx1ZSBpcyBpbmZpbml0ZSwgbWVhbmluZyBpdCBjb21wbGV0ZWx5XHJcbiAgICAgICAgLy9yZXBsYWNlcyBhbnkgbm9uLXNhbXBsZWQgcHJvcGVydHkgdGhhdCBtYXkgZXhpc3QuXHJcbiAgICAgICAgaWYgKGlzU2FtcGxlZCAmJiAhaGFzSW50ZXJ2YWwpIHtcclxuICAgICAgICAgICAgaWYgKCEocHJvcGVydHkgaW5zdGFuY2VvZiBTYW1wbGVkUG9zaXRpb25Qcm9wZXJ0eSkgfHwgKGRlZmluZWQocmVmZXJlbmNlRnJhbWUpICYmIHByb3BlcnR5LnJlZmVyZW5jZUZyYW1lICE9PSByZWZlcmVuY2VGcmFtZSkpIHtcclxuICAgICAgICAgICAgICAgIHByb3BlcnR5ID0gbmV3IFNhbXBsZWRQb3NpdGlvblByb3BlcnR5KHJlZmVyZW5jZUZyYW1lLCBudW1iZXJPZkRlcml2YXRpdmVzKTtcclxuICAgICAgICAgICAgICAgIG9iamVjdFtwcm9wZXJ0eU5hbWVdID0gcHJvcGVydHk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcHJvcGVydHkuYWRkU2FtcGxlc1BhY2tlZEFycmF5KHVud3JhcHBlZEludGVydmFsLCBlcG9jaCk7XHJcbiAgICAgICAgICAgIHVwZGF0ZUludGVycG9sYXRpb25TZXR0aW5ncyhwYWNrZXREYXRhLCBwcm9wZXJ0eSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBpbnRlcnZhbDtcclxuXHJcbiAgICAgICAgLy9BIGNvbnN0YW50IHZhbHVlIHdpdGggYW4gaW50ZXJ2YWwgaXMgbm9ybWFsbHkgcGFydCBvZiBhIFRpbWVJbnRlcnZhbENvbGxlY3Rpb24sXHJcbiAgICAgICAgLy9Ib3dldmVyLCBpZiB0aGUgY3VycmVudCBwcm9wZXJ0eSBpcyBub3QgYSB0aW1lLWludGVydmFsIGNvbGxlY3Rpb24sIHdlIG5lZWRcclxuICAgICAgICAvL3RvIHR1cm4gaXQgaW50byBhIENvbXBvc2l0ZSwgcHJlc2VydmluZyB0aGUgb2xkIGRhdGEgd2l0aCB0aGUgbmV3IGludGVydmFsLlxyXG4gICAgICAgIGlmICghaXNTYW1wbGVkICYmIGhhc0ludGVydmFsKSB7XHJcbiAgICAgICAgICAgIC8vQ3JlYXRlIGEgbmV3IGludGVydmFsIGZvciB0aGUgY29uc3RhbnQgdmFsdWUuXHJcbiAgICAgICAgICAgIGNvbWJpbmVkSW50ZXJ2YWwgPSBjb21iaW5lZEludGVydmFsLmNsb25lKCk7XHJcbiAgICAgICAgICAgIGlmIChpc1ZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBjb21iaW5lZEludGVydmFsLmRhdGEgPSBDYXJ0ZXNpYW4zLnVucGFjayh1bndyYXBwZWRJbnRlcnZhbCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb21iaW5lZEludGVydmFsLmRhdGEgPSBjcmVhdGVSZWZlcmVuY2VQcm9wZXJ0eShlbnRpdHlDb2xsZWN0aW9uLCBwYWNrZXREYXRhLnJlZmVyZW5jZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vSWYgbm8gcHJvcGVydHkgZXhpc3RzLCBzaW1wbHkgdXNlIGEgbmV3IGludGVydmFsIGNvbGxlY3Rpb25cclxuICAgICAgICAgICAgaWYgKCFkZWZpbmVkKHByb3BlcnR5KSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eSA9IG5ldyBUaW1lSW50ZXJ2YWxDb2xsZWN0aW9uUG9zaXRpb25Qcm9wZXJ0eShyZWZlcmVuY2VGcmFtZSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5ID0gbmV3IENvbXBvc2l0ZVBvc2l0aW9uUHJvcGVydHkocmVmZXJlbmNlRnJhbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgb2JqZWN0W3Byb3BlcnR5TmFtZV0gPSBwcm9wZXJ0eTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGlzVmFsdWUgJiYgcHJvcGVydHkgaW5zdGFuY2VvZiBUaW1lSW50ZXJ2YWxDb2xsZWN0aW9uUG9zaXRpb25Qcm9wZXJ0eSAmJiAoZGVmaW5lZChyZWZlcmVuY2VGcmFtZSkgJiYgcHJvcGVydHkucmVmZXJlbmNlRnJhbWUgPT09IHJlZmVyZW5jZUZyYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgLy9JZiB3ZSBjcmVhdGUgYSBjb2xsZWN0aW9uLCBvciBpdCBhbHJlYWR5IGV4aXN0ZWQsIHVzZSBpdC5cclxuICAgICAgICAgICAgICAgIHByb3BlcnR5LmludGVydmFscy5hZGRJbnRlcnZhbChjb21iaW5lZEludGVydmFsKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eSBpbnN0YW5jZW9mIENvbXBvc2l0ZVBvc2l0aW9uUHJvcGVydHkpIHtcclxuICAgICAgICAgICAgICAgIC8vSWYgdGhlIGNvbGxlY3Rpb24gd2FzIGFscmVhZHkgYSBDb21wb3NpdGVQb3NpdGlvblByb3BlcnR5LCB1c2UgaXQuXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbWJpbmVkSW50ZXJ2YWwuZGF0YSA9IG5ldyBDb25zdGFudFBvc2l0aW9uUHJvcGVydHkoY29tYmluZWRJbnRlcnZhbC5kYXRhLCByZWZlcmVuY2VGcmFtZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eS5pbnRlcnZhbHMuYWRkSW50ZXJ2YWwoY29tYmluZWRJbnRlcnZhbCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvL090aGVyd2lzZSwgY3JlYXRlIGEgQ29tcG9zaXRlUG9zaXRpb25Qcm9wZXJ0eSBidXQgcHJlc2VydmUgdGhlIGV4aXN0aW5nIGRhdGEuXHJcblxyXG4gICAgICAgICAgICAgICAgLy9QdXQgdGhlIG9sZCBwcm9wZXJ0eSBpbiBhbiBpbmZpbml0ZSBpbnRlcnZhbC5cclxuICAgICAgICAgICAgICAgIGludGVydmFsID0gSXNvODYwMS5NQVhJTVVNX0lOVEVSVkFMLmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICBpbnRlcnZhbC5kYXRhID0gcHJvcGVydHk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9DcmVhdGUgdGhlIGNvbXBvc2l0ZS5cclxuICAgICAgICAgICAgICAgIHByb3BlcnR5ID0gbmV3IENvbXBvc2l0ZVBvc2l0aW9uUHJvcGVydHkocHJvcGVydHkucmVmZXJlbmNlRnJhbWUpO1xyXG4gICAgICAgICAgICAgICAgb2JqZWN0W3Byb3BlcnR5TmFtZV0gPSBwcm9wZXJ0eTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL2FkZCB0aGUgb2xkIHByb3BlcnR5IGludGVydmFsXHJcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eS5pbnRlcnZhbHMuYWRkSW50ZXJ2YWwoaW50ZXJ2YWwpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vQ2hhbmdlIHRoZSBuZXcgZGF0YSB0byBhIENvbnN0YW50UG9zaXRpb25Qcm9wZXJ0eSBhbmQgYWRkIGl0LlxyXG4gICAgICAgICAgICAgICAgaWYgKGlzVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb21iaW5lZEludGVydmFsLmRhdGEgPSBuZXcgQ29uc3RhbnRQb3NpdGlvblByb3BlcnR5KGNvbWJpbmVkSW50ZXJ2YWwuZGF0YSwgcmVmZXJlbmNlRnJhbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcHJvcGVydHkuaW50ZXJ2YWxzLmFkZEludGVydmFsKGNvbWJpbmVkSW50ZXJ2YWwpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2lzU2FtcGxlZCAmJiBoYXNJbnRlcnZhbFxyXG4gICAgICAgIGlmICghZGVmaW5lZChwcm9wZXJ0eSkpIHtcclxuICAgICAgICAgICAgcHJvcGVydHkgPSBuZXcgQ29tcG9zaXRlUG9zaXRpb25Qcm9wZXJ0eShyZWZlcmVuY2VGcmFtZSk7XHJcbiAgICAgICAgICAgIG9iamVjdFtwcm9wZXJ0eU5hbWVdID0gcHJvcGVydHk7XHJcbiAgICAgICAgfSBlbHNlIGlmICghKHByb3BlcnR5IGluc3RhbmNlb2YgQ29tcG9zaXRlUG9zaXRpb25Qcm9wZXJ0eSkpIHtcclxuICAgICAgICAgICAgLy9jcmVhdGUgYSBDb21wb3NpdGVQcm9wZXJ0eSBidXQgcHJlc2VydmUgdGhlIGV4aXN0aW5nIGRhdGEuXHJcbiAgICAgICAgICAgIC8vUHV0IHRoZSBvbGQgcHJvcGVydHkgaW4gYW4gaW5maW5pdGUgaW50ZXJ2YWwuXHJcbiAgICAgICAgICAgIGludGVydmFsID0gSXNvODYwMS5NQVhJTVVNX0lOVEVSVkFMLmNsb25lKCk7XHJcbiAgICAgICAgICAgIGludGVydmFsLmRhdGEgPSBwcm9wZXJ0eTtcclxuXHJcbiAgICAgICAgICAgIC8vQ3JlYXRlIHRoZSBjb21wb3NpdGUuXHJcbiAgICAgICAgICAgIHByb3BlcnR5ID0gbmV3IENvbXBvc2l0ZVBvc2l0aW9uUHJvcGVydHkocHJvcGVydHkucmVmZXJlbmNlRnJhbWUpO1xyXG4gICAgICAgICAgICBvYmplY3RbcHJvcGVydHlOYW1lXSA9IHByb3BlcnR5O1xyXG5cclxuICAgICAgICAgICAgLy9hZGQgdGhlIG9sZCBwcm9wZXJ0eSBpbnRlcnZhbFxyXG4gICAgICAgICAgICBwcm9wZXJ0eS5pbnRlcnZhbHMuYWRkSW50ZXJ2YWwoaW50ZXJ2YWwpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9DaGVjayBpZiB0aGUgaW50ZXJ2YWwgYWxyZWFkeSBleGlzdHMgaW4gdGhlIGNvbXBvc2l0ZVxyXG4gICAgICAgIHZhciBpbnRlcnZhbHMgPSBwcm9wZXJ0eS5pbnRlcnZhbHM7XHJcbiAgICAgICAgaW50ZXJ2YWwgPSBpbnRlcnZhbHMuZmluZEludGVydmFsKGNvbWJpbmVkSW50ZXJ2YWwpO1xyXG4gICAgICAgIGlmICghZGVmaW5lZChpbnRlcnZhbCkgfHwgIShpbnRlcnZhbC5kYXRhIGluc3RhbmNlb2YgU2FtcGxlZFBvc2l0aW9uUHJvcGVydHkpIHx8IChkZWZpbmVkKHJlZmVyZW5jZUZyYW1lKSAmJiBpbnRlcnZhbC5kYXRhLnJlZmVyZW5jZUZyYW1lICE9PSByZWZlcmVuY2VGcmFtZSkpIHtcclxuICAgICAgICAgICAgLy9JZiBub3QsIGNyZWF0ZSBhIFNhbXBsZWRQb3NpdGlvblByb3BlcnR5IGZvciBpdC5cclxuICAgICAgICAgICAgaW50ZXJ2YWwgPSBjb21iaW5lZEludGVydmFsLmNsb25lKCk7XHJcbiAgICAgICAgICAgIGludGVydmFsLmRhdGEgPSBuZXcgU2FtcGxlZFBvc2l0aW9uUHJvcGVydHkocmVmZXJlbmNlRnJhbWUsIG51bWJlck9mRGVyaXZhdGl2ZXMpO1xyXG4gICAgICAgICAgICBpbnRlcnZhbHMuYWRkSW50ZXJ2YWwoaW50ZXJ2YWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpbnRlcnZhbC5kYXRhLmFkZFNhbXBsZXNQYWNrZWRBcnJheSh1bndyYXBwZWRJbnRlcnZhbCwgZXBvY2gpO1xyXG4gICAgICAgIHVwZGF0ZUludGVycG9sYXRpb25TZXR0aW5ncyhwYWNrZXREYXRhLCBpbnRlcnZhbC5kYXRhKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBwcm9jZXNzUG9zaXRpb25QYWNrZXREYXRhKG9iamVjdCwgcHJvcGVydHlOYW1lLCBwYWNrZXREYXRhLCBpbnRlcnZhbCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKSB7XHJcbiAgICAgICAgaWYgKCFkZWZpbmVkKHBhY2tldERhdGEpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChpc0FycmF5KHBhY2tldERhdGEpKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwYWNrZXREYXRhLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBwcm9jZXNzUG9zaXRpb25Qcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5TmFtZSwgcGFja2V0RGF0YVtpXSwgaW50ZXJ2YWwsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBwcm9jZXNzUG9zaXRpb25Qcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5TmFtZSwgcGFja2V0RGF0YSwgaW50ZXJ2YWwsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHByb2Nlc3NNYXRlcmlhbFByb3BlcnR5KG9iamVjdCwgcHJvcGVydHlOYW1lLCBwYWNrZXREYXRhLCBjb25zdHJhaW5lZEludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pIHtcclxuICAgICAgICB2YXIgY29tYmluZWRJbnRlcnZhbDtcclxuICAgICAgICB2YXIgcGFja2V0SW50ZXJ2YWwgPSBwYWNrZXREYXRhLmludGVydmFsO1xyXG4gICAgICAgIGlmIChkZWZpbmVkKHBhY2tldEludGVydmFsKSkge1xyXG4gICAgICAgICAgICBpc284NjAxU2NyYXRjaC5pc284NjAxID0gcGFja2V0SW50ZXJ2YWw7XHJcbiAgICAgICAgICAgIGNvbWJpbmVkSW50ZXJ2YWwgPSBUaW1lSW50ZXJ2YWwuZnJvbUlzbzg2MDEoaXNvODYwMVNjcmF0Y2gpO1xyXG4gICAgICAgICAgICBpZiAoZGVmaW5lZChjb25zdHJhaW5lZEludGVydmFsKSkge1xyXG4gICAgICAgICAgICAgICAgY29tYmluZWRJbnRlcnZhbCA9IFRpbWVJbnRlcnZhbC5pbnRlcnNlY3QoY29tYmluZWRJbnRlcnZhbCwgY29uc3RyYWluZWRJbnRlcnZhbCwgc2NyYXRjaFRpbWVJbnRlcnZhbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKGRlZmluZWQoY29uc3RyYWluZWRJbnRlcnZhbCkpIHtcclxuICAgICAgICAgICAgY29tYmluZWRJbnRlcnZhbCA9IGNvbnN0cmFpbmVkSW50ZXJ2YWw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgcHJvcGVydHkgPSBvYmplY3RbcHJvcGVydHlOYW1lXTtcclxuICAgICAgICB2YXIgZXhpc3RpbmdNYXRlcmlhbDtcclxuICAgICAgICB2YXIgZXhpc3RpbmdJbnRlcnZhbDtcclxuXHJcbiAgICAgICAgaWYgKGRlZmluZWQoY29tYmluZWRJbnRlcnZhbCkpIHtcclxuICAgICAgICAgICAgaWYgKCEocHJvcGVydHkgaW5zdGFuY2VvZiBDb21wb3NpdGVNYXRlcmlhbFByb3BlcnR5KSkge1xyXG4gICAgICAgICAgICAgICAgcHJvcGVydHkgPSBuZXcgQ29tcG9zaXRlTWF0ZXJpYWxQcm9wZXJ0eSgpO1xyXG4gICAgICAgICAgICAgICAgb2JqZWN0W3Byb3BlcnR5TmFtZV0gPSBwcm9wZXJ0eTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL1NlZSBpZiB3ZSBhbHJlYWR5IGhhdmUgZGF0YSBhdCB0aGF0IGludGVydmFsLlxyXG4gICAgICAgICAgICB2YXIgdGhpc0ludGVydmFscyA9IHByb3BlcnR5LmludGVydmFscztcclxuICAgICAgICAgICAgZXhpc3RpbmdJbnRlcnZhbCA9IHRoaXNJbnRlcnZhbHMuZmluZEludGVydmFsKHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0IDogY29tYmluZWRJbnRlcnZhbC5zdGFydCxcclxuICAgICAgICAgICAgICAgIHN0b3AgOiBjb21iaW5lZEludGVydmFsLnN0b3BcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmIChkZWZpbmVkKGV4aXN0aW5nSW50ZXJ2YWwpKSB7XHJcbiAgICAgICAgICAgICAgICAvL1dlIGhhdmUgYW4gaW50ZXJ2YWwsIGJ1dCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGVcclxuICAgICAgICAgICAgICAgIC8vbmV3IGRhdGEgaXMgdGhlIHNhbWUgdHlwZSBvZiBtYXRlcmlhbCBhcyB0aGUgb2xkIGRhdGEuXHJcbiAgICAgICAgICAgICAgICBleGlzdGluZ01hdGVyaWFsID0gZXhpc3RpbmdJbnRlcnZhbC5kYXRhO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy9JZiBub3QsIGNyZWF0ZSBpdC5cclxuICAgICAgICAgICAgICAgIGV4aXN0aW5nSW50ZXJ2YWwgPSBjb21iaW5lZEludGVydmFsLmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzSW50ZXJ2YWxzLmFkZEludGVydmFsKGV4aXN0aW5nSW50ZXJ2YWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZXhpc3RpbmdNYXRlcmlhbCA9IHByb3BlcnR5O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIG1hdGVyaWFsRGF0YTtcclxuICAgICAgICBpZiAoZGVmaW5lZChwYWNrZXREYXRhLnNvbGlkQ29sb3IpKSB7XHJcbiAgICAgICAgICAgIGlmICghKGV4aXN0aW5nTWF0ZXJpYWwgaW5zdGFuY2VvZiBDb2xvck1hdGVyaWFsUHJvcGVydHkpKSB7XHJcbiAgICAgICAgICAgICAgICBleGlzdGluZ01hdGVyaWFsID0gbmV3IENvbG9yTWF0ZXJpYWxQcm9wZXJ0eSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG1hdGVyaWFsRGF0YSA9IHBhY2tldERhdGEuc29saWRDb2xvcjtcclxuICAgICAgICAgICAgcHJvY2Vzc1BhY2tldERhdGEoQ29sb3IsIGV4aXN0aW5nTWF0ZXJpYWwsICdjb2xvcicsIG1hdGVyaWFsRGF0YS5jb2xvciwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZGVmaW5lZChwYWNrZXREYXRhLmdyaWQpKSB7XHJcbiAgICAgICAgICAgIGlmICghKGV4aXN0aW5nTWF0ZXJpYWwgaW5zdGFuY2VvZiBHcmlkTWF0ZXJpYWxQcm9wZXJ0eSkpIHtcclxuICAgICAgICAgICAgICAgIGV4aXN0aW5nTWF0ZXJpYWwgPSBuZXcgR3JpZE1hdGVyaWFsUHJvcGVydHkoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBtYXRlcmlhbERhdGEgPSBwYWNrZXREYXRhLmdyaWQ7XHJcbiAgICAgICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKENvbG9yLCBleGlzdGluZ01hdGVyaWFsLCAnY29sb3InLCBtYXRlcmlhbERhdGEuY29sb3IsIHVuZGVmaW5lZCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgICAgICAgICAgcHJvY2Vzc1BhY2tldERhdGEoTnVtYmVyLCBleGlzdGluZ01hdGVyaWFsLCAnY2VsbEFscGhhJywgbWF0ZXJpYWxEYXRhLmNlbGxBbHBoYSwgdW5kZWZpbmVkLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgICAgICBwcm9jZXNzUGFja2V0RGF0YShDYXJ0ZXNpYW4yLCBleGlzdGluZ01hdGVyaWFsLCAnbGluZUNvdW50JywgbWF0ZXJpYWxEYXRhLmxpbmVDb3VudCwgdW5kZWZpbmVkLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgICAgICBwcm9jZXNzUGFja2V0RGF0YShDYXJ0ZXNpYW4yLCBleGlzdGluZ01hdGVyaWFsLCAnbGluZVRoaWNrbmVzcycsIG1hdGVyaWFsRGF0YS5saW5lVGhpY2tuZXNzLCB1bmRlZmluZWQsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICAgICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKENhcnRlc2lhbjIsIGV4aXN0aW5nTWF0ZXJpYWwsICdsaW5lT2Zmc2V0JywgbWF0ZXJpYWxEYXRhLmxpbmVPZmZzZXQsIHVuZGVmaW5lZCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGRlZmluZWQocGFja2V0RGF0YS5pbWFnZSkpIHtcclxuICAgICAgICAgICAgaWYgKCEoZXhpc3RpbmdNYXRlcmlhbCBpbnN0YW5jZW9mIEltYWdlTWF0ZXJpYWxQcm9wZXJ0eSkpIHtcclxuICAgICAgICAgICAgICAgIGV4aXN0aW5nTWF0ZXJpYWwgPSBuZXcgSW1hZ2VNYXRlcmlhbFByb3BlcnR5KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbWF0ZXJpYWxEYXRhID0gcGFja2V0RGF0YS5pbWFnZTtcclxuICAgICAgICAgICAgcHJvY2Vzc1BhY2tldERhdGEoSW1hZ2UsIGV4aXN0aW5nTWF0ZXJpYWwsICdpbWFnZScsIG1hdGVyaWFsRGF0YS5pbWFnZSwgdW5kZWZpbmVkLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgICAgICBwcm9jZXNzUGFja2V0RGF0YShDYXJ0ZXNpYW4yLCBleGlzdGluZ01hdGVyaWFsLCAncmVwZWF0JywgbWF0ZXJpYWxEYXRhLnJlcGVhdCwgdW5kZWZpbmVkLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgICAgICBwcm9jZXNzUGFja2V0RGF0YShDb2xvciwgZXhpc3RpbmdNYXRlcmlhbCwgJ2NvbG9yJywgbWF0ZXJpYWxEYXRhLmNvbG9yLCB1bmRlZmluZWQsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICAgICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKEJvb2xlYW4sIGV4aXN0aW5nTWF0ZXJpYWwsICd0cmFuc3BhcmVudCcsIG1hdGVyaWFsRGF0YS50cmFuc3BhcmVudCwgdW5kZWZpbmVkLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZGVmaW5lZChwYWNrZXREYXRhLnN0cmlwZSkpIHtcclxuICAgICAgICAgICAgaWYgKCEoZXhpc3RpbmdNYXRlcmlhbCBpbnN0YW5jZW9mIFN0cmlwZU1hdGVyaWFsUHJvcGVydHkpKSB7XHJcbiAgICAgICAgICAgICAgICBleGlzdGluZ01hdGVyaWFsID0gbmV3IFN0cmlwZU1hdGVyaWFsUHJvcGVydHkoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBtYXRlcmlhbERhdGEgPSBwYWNrZXREYXRhLnN0cmlwZTtcclxuICAgICAgICAgICAgcHJvY2Vzc1BhY2tldERhdGEoU3RyaXBlT3JpZW50YXRpb24sIGV4aXN0aW5nTWF0ZXJpYWwsICdvcmllbnRhdGlvbicsIG1hdGVyaWFsRGF0YS5vcmllbnRhdGlvbiwgdW5kZWZpbmVkLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgICAgICBwcm9jZXNzUGFja2V0RGF0YShDb2xvciwgZXhpc3RpbmdNYXRlcmlhbCwgJ2V2ZW5Db2xvcicsIG1hdGVyaWFsRGF0YS5ldmVuQ29sb3IsIHVuZGVmaW5lZCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgICAgICAgICAgcHJvY2Vzc1BhY2tldERhdGEoQ29sb3IsIGV4aXN0aW5nTWF0ZXJpYWwsICdvZGRDb2xvcicsIG1hdGVyaWFsRGF0YS5vZGRDb2xvciwgdW5kZWZpbmVkLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgICAgICBwcm9jZXNzUGFja2V0RGF0YShOdW1iZXIsIGV4aXN0aW5nTWF0ZXJpYWwsICdvZmZzZXQnLCBtYXRlcmlhbERhdGEub2Zmc2V0LCB1bmRlZmluZWQsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICAgICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKE51bWJlciwgZXhpc3RpbmdNYXRlcmlhbCwgJ3JlcGVhdCcsIG1hdGVyaWFsRGF0YS5yZXBlYXQsIHVuZGVmaW5lZCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGRlZmluZWQocGFja2V0RGF0YS5wb2x5bGluZU91dGxpbmUpKSB7XHJcbiAgICAgICAgICAgIGlmICghKGV4aXN0aW5nTWF0ZXJpYWwgaW5zdGFuY2VvZiBQb2x5bGluZU91dGxpbmVNYXRlcmlhbFByb3BlcnR5KSkge1xyXG4gICAgICAgICAgICAgICAgZXhpc3RpbmdNYXRlcmlhbCA9IG5ldyBQb2x5bGluZU91dGxpbmVNYXRlcmlhbFByb3BlcnR5KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbWF0ZXJpYWxEYXRhID0gcGFja2V0RGF0YS5wb2x5bGluZU91dGxpbmU7XHJcbiAgICAgICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKENvbG9yLCBleGlzdGluZ01hdGVyaWFsLCAnY29sb3InLCBtYXRlcmlhbERhdGEuY29sb3IsIHVuZGVmaW5lZCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgICAgICAgICAgcHJvY2Vzc1BhY2tldERhdGEoQ29sb3IsIGV4aXN0aW5nTWF0ZXJpYWwsICdvdXRsaW5lQ29sb3InLCBtYXRlcmlhbERhdGEub3V0bGluZUNvbG9yLCB1bmRlZmluZWQsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICAgICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKE51bWJlciwgZXhpc3RpbmdNYXRlcmlhbCwgJ291dGxpbmVXaWR0aCcsIG1hdGVyaWFsRGF0YS5vdXRsaW5lV2lkdGgsIHVuZGVmaW5lZCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGRlZmluZWQocGFja2V0RGF0YS5wb2x5bGluZUdsb3cpKSB7XHJcbiAgICAgICAgICAgIGlmICghKGV4aXN0aW5nTWF0ZXJpYWwgaW5zdGFuY2VvZiBQb2x5bGluZUdsb3dNYXRlcmlhbFByb3BlcnR5KSkge1xyXG4gICAgICAgICAgICAgICAgZXhpc3RpbmdNYXRlcmlhbCA9IG5ldyBQb2x5bGluZUdsb3dNYXRlcmlhbFByb3BlcnR5KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbWF0ZXJpYWxEYXRhID0gcGFja2V0RGF0YS5wb2x5bGluZUdsb3c7XHJcbiAgICAgICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKENvbG9yLCBleGlzdGluZ01hdGVyaWFsLCAnY29sb3InLCBtYXRlcmlhbERhdGEuY29sb3IsIHVuZGVmaW5lZCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgICAgICAgICAgcHJvY2Vzc1BhY2tldERhdGEoTnVtYmVyLCBleGlzdGluZ01hdGVyaWFsLCAnZ2xvd1Bvd2VyJywgbWF0ZXJpYWxEYXRhLmdsb3dQb3dlciwgdW5kZWZpbmVkLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZGVmaW5lZChwYWNrZXREYXRhLnBvbHlsaW5lQXJyb3cpKSB7XHJcbiAgICAgICAgICAgIGlmICghKGV4aXN0aW5nTWF0ZXJpYWwgaW5zdGFuY2VvZiBQb2x5bGluZUFycm93TWF0ZXJpYWxQcm9wZXJ0eSkpIHtcclxuICAgICAgICAgICAgICAgIGV4aXN0aW5nTWF0ZXJpYWwgPSBuZXcgUG9seWxpbmVBcnJvd01hdGVyaWFsUHJvcGVydHkoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBtYXRlcmlhbERhdGEgPSBwYWNrZXREYXRhLnBvbHlsaW5lQXJyb3c7XHJcbiAgICAgICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKENvbG9yLCBleGlzdGluZ01hdGVyaWFsLCAnY29sb3InLCBtYXRlcmlhbERhdGEuY29sb3IsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGRlZmluZWQocGFja2V0RGF0YS5wb2x5bGluZURhc2gpKSB7XHJcbiAgICAgICAgICAgIGlmICghKGV4aXN0aW5nTWF0ZXJpYWwgaW5zdGFuY2VvZiBQb2x5bGluZURhc2hNYXRlcmlhbFByb3BlcnR5KSkge1xyXG4gICAgICAgICAgICAgICAgZXhpc3RpbmdNYXRlcmlhbCA9IG5ldyBQb2x5bGluZURhc2hNYXRlcmlhbFByb3BlcnR5KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbWF0ZXJpYWxEYXRhID0gcGFja2V0RGF0YS5wb2x5bGluZURhc2g7XHJcbiAgICAgICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKENvbG9yLCBleGlzdGluZ01hdGVyaWFsLCAnY29sb3InLCBtYXRlcmlhbERhdGEuY29sb3IsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgICAgICAgICAgcHJvY2Vzc1BhY2tldERhdGEoQ29sb3IsIGV4aXN0aW5nTWF0ZXJpYWwsICdnYXBDb2xvcicsIG1hdGVyaWFsRGF0YS5nYXBDb2xvciwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgICAgICBwcm9jZXNzUGFja2V0RGF0YShOdW1iZXIsIGV4aXN0aW5nTWF0ZXJpYWwsICdkYXNoTGVuZ3RoJywgbWF0ZXJpYWxEYXRhLmRhc2hMZW5ndGgsIHVuZGVmaW5lZCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgICAgICAgICAgcHJvY2Vzc1BhY2tldERhdGEoTnVtYmVyLCBleGlzdGluZ01hdGVyaWFsLCAnZGFzaFBhdHRlcm4nLCBtYXRlcmlhbERhdGEuZGFzaFBhdHRlcm4sIHVuZGVmaW5lZCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChkZWZpbmVkKGV4aXN0aW5nSW50ZXJ2YWwpKSB7XHJcbiAgICAgICAgICAgIGV4aXN0aW5nSW50ZXJ2YWwuZGF0YSA9IGV4aXN0aW5nTWF0ZXJpYWw7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgb2JqZWN0W3Byb3BlcnR5TmFtZV0gPSBleGlzdGluZ01hdGVyaWFsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBwcm9jZXNzTWF0ZXJpYWxQYWNrZXREYXRhKG9iamVjdCwgcHJvcGVydHlOYW1lLCBwYWNrZXREYXRhLCBpbnRlcnZhbCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKSB7XHJcbiAgICAgICAgaWYgKCFkZWZpbmVkKHBhY2tldERhdGEpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChpc0FycmF5KHBhY2tldERhdGEpKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwYWNrZXREYXRhLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBwcm9jZXNzTWF0ZXJpYWxQcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5TmFtZSwgcGFja2V0RGF0YVtpXSwgaW50ZXJ2YWwsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBwcm9jZXNzTWF0ZXJpYWxQcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5TmFtZSwgcGFja2V0RGF0YSwgaW50ZXJ2YWwsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHByb2Nlc3NOYW1lKGVudGl0eSwgcGFja2V0LCBlbnRpdHlDb2xsZWN0aW9uLCBzb3VyY2VVcmkpIHtcclxuICAgICAgICBlbnRpdHkubmFtZSA9IGRlZmF1bHRWYWx1ZShwYWNrZXQubmFtZSwgZW50aXR5Lm5hbWUpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHByb2Nlc3NEZXNjcmlwdGlvbihlbnRpdHksIHBhY2tldCwgZW50aXR5Q29sbGVjdGlvbiwgc291cmNlVXJpKSB7XHJcbiAgICAgICAgdmFyIGRlc2NyaXB0aW9uRGF0YSA9IHBhY2tldC5kZXNjcmlwdGlvbjtcclxuICAgICAgICBpZiAoZGVmaW5lZChkZXNjcmlwdGlvbkRhdGEpKSB7XHJcbiAgICAgICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKFN0cmluZywgZW50aXR5LCAnZGVzY3JpcHRpb24nLCBkZXNjcmlwdGlvbkRhdGEsIHVuZGVmaW5lZCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcHJvY2Vzc1Bvc2l0aW9uKGVudGl0eSwgcGFja2V0LCBlbnRpdHlDb2xsZWN0aW9uLCBzb3VyY2VVcmkpIHtcclxuICAgICAgICB2YXIgcG9zaXRpb25EYXRhID0gcGFja2V0LnBvc2l0aW9uO1xyXG4gICAgICAgIGlmIChkZWZpbmVkKHBvc2l0aW9uRGF0YSkpIHtcclxuICAgICAgICAgICAgcHJvY2Vzc1Bvc2l0aW9uUGFja2V0RGF0YShlbnRpdHksICdwb3NpdGlvbicsIHBvc2l0aW9uRGF0YSwgdW5kZWZpbmVkLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBwcm9jZXNzVmlld0Zyb20oZW50aXR5LCBwYWNrZXQsIGVudGl0eUNvbGxlY3Rpb24sIHNvdXJjZVVyaSkge1xyXG4gICAgICAgIHZhciB2aWV3RnJvbURhdGEgPSBwYWNrZXQudmlld0Zyb207XHJcbiAgICAgICAgaWYgKGRlZmluZWQodmlld0Zyb21EYXRhKSkge1xyXG4gICAgICAgICAgICBwcm9jZXNzUGFja2V0RGF0YShDYXJ0ZXNpYW4zLCBlbnRpdHksICd2aWV3RnJvbScsIHZpZXdGcm9tRGF0YSwgdW5kZWZpbmVkLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBwcm9jZXNzT3JpZW50YXRpb24oZW50aXR5LCBwYWNrZXQsIGVudGl0eUNvbGxlY3Rpb24sIHNvdXJjZVVyaSkge1xyXG4gICAgICAgIHZhciBvcmllbnRhdGlvbkRhdGEgPSBwYWNrZXQub3JpZW50YXRpb247XHJcbiAgICAgICAgaWYgKGRlZmluZWQob3JpZW50YXRpb25EYXRhKSkge1xyXG4gICAgICAgICAgICBwcm9jZXNzUGFja2V0RGF0YShRdWF0ZXJuaW9uLCBlbnRpdHksICdvcmllbnRhdGlvbicsIG9yaWVudGF0aW9uRGF0YSwgdW5kZWZpbmVkLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBwcm9jZXNzUHJvcGVydGllcyhlbnRpdHksIHBhY2tldCwgZW50aXR5Q29sbGVjdGlvbiwgc291cmNlVXJpKSB7XHJcbiAgICAgICAgdmFyIHByb3BlcnRpZXNEYXRhID0gcGFja2V0LnByb3BlcnRpZXM7XHJcbiAgICAgICAgaWYgKGRlZmluZWQocHJvcGVydGllc0RhdGEpKSB7XHJcbiAgICAgICAgICAgIGlmICghZGVmaW5lZChlbnRpdHkucHJvcGVydGllcykpIHtcclxuICAgICAgICAgICAgICAgIGVudGl0eS5wcm9wZXJ0aWVzID0gbmV3IFByb3BlcnR5QmFnKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy9XZSBjYW5ub3Qgc2ltcGx5IGNhbGwgcHJvY2Vzc1BhY2tldERhdGEoZW50aXR5LCAncHJvcGVydGllcycsIHByb3BlcnR5RGF0YSwgdW5kZWZpbmVkLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pXHJcbiAgICAgICAgICAgIC8vYmVjYXVzZSBlYWNoIHByb3BlcnR5IG9mIFwicHJvcGVydGllc1wiIG1heSB2YXJ5IHNlcGFyYXRlbHkuXHJcbiAgICAgICAgICAgIC8vVGhlIHByb3BlcnRpZXMgd2lsbCBiZSBhY2Nlc3NpYmxlIGFzIGVudGl0eS5wcm9wZXJ0aWVzLm15cHJvcC5nZXRWYWx1ZSh0aW1lKS5cclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wZXJ0aWVzRGF0YSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNEYXRhLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWVudGl0eS5wcm9wZXJ0aWVzLmhhc1Byb3BlcnR5KGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW50aXR5LnByb3BlcnRpZXMuYWRkUHJvcGVydHkoa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eURhdGEgPSBwcm9wZXJ0aWVzRGF0YVtrZXldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KHByb3BlcnR5RGF0YSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHByb3BlcnR5RGF0YS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc1Byb3BlcnR5KGdldFByb3BlcnR5VHlwZShwcm9wZXJ0eURhdGFbaV0pLCBlbnRpdHkucHJvcGVydGllcywga2V5LCBwcm9wZXJ0eURhdGFbaV0sIHVuZGVmaW5lZCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3NQcm9wZXJ0eShnZXRQcm9wZXJ0eVR5cGUocHJvcGVydHlEYXRhKSwgZW50aXR5LnByb3BlcnRpZXMsIGtleSwgcHJvcGVydHlEYXRhLCB1bmRlZmluZWQsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHByb2Nlc3NBcnJheVBhY2tldERhdGEob2JqZWN0LCBwcm9wZXJ0eU5hbWUsIHBhY2tldERhdGEsIGVudGl0eUNvbGxlY3Rpb24pIHtcclxuICAgICAgICB2YXIgcmVmZXJlbmNlcyA9IHBhY2tldERhdGEucmVmZXJlbmNlcztcclxuICAgICAgICBpZiAoZGVmaW5lZChyZWZlcmVuY2VzKSkge1xyXG4gICAgICAgICAgICB2YXIgcHJvcGVydGllcyA9IHJlZmVyZW5jZXMubWFwKGZ1bmN0aW9uKHJlZmVyZW5jZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVJlZmVyZW5jZVByb3BlcnR5KGVudGl0eUNvbGxlY3Rpb24sIHJlZmVyZW5jZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgdmFyIGlzbzg2MDFJbnRlcnZhbCA9IHBhY2tldERhdGEuaW50ZXJ2YWw7XHJcbiAgICAgICAgICAgIGlmIChkZWZpbmVkKGlzbzg2MDFJbnRlcnZhbCkpIHtcclxuICAgICAgICAgICAgICAgIGlzbzg2MDFJbnRlcnZhbCA9IFRpbWVJbnRlcnZhbC5mcm9tSXNvODYwMShpc284NjAxSW50ZXJ2YWwpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCEob2JqZWN0W3Byb3BlcnR5TmFtZV0gaW5zdGFuY2VvZiBDb21wb3NpdGVQb3NpdGlvblByb3BlcnR5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlzbzg2MDFJbnRlcnZhbC5kYXRhID0gbmV3IFByb3BlcnR5QXJyYXkocHJvcGVydGllcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb3BlcnR5ID0gbmV3IENvbXBvc2l0ZVByb3BlcnR5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHkuaW50ZXJ2YWxzLmFkZEludGVydmFsKGlzbzg2MDFJbnRlcnZhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0W3Byb3BlcnR5TmFtZV0gPSBwcm9wZXJ0eTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG9iamVjdFtwcm9wZXJ0eU5hbWVdID0gbmV3IFByb3BlcnR5QXJyYXkocHJvcGVydGllcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBwcm9jZXNzUGFja2V0RGF0YShBcnJheSwgb2JqZWN0LCBwcm9wZXJ0eU5hbWUsIHBhY2tldERhdGEsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcHJvY2Vzc0FycmF5KG9iamVjdCwgcHJvcGVydHlOYW1lLCBwYWNrZXREYXRhLCBlbnRpdHlDb2xsZWN0aW9uKSB7XHJcbiAgICAgICAgaWYgKCFkZWZpbmVkKHBhY2tldERhdGEpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChpc0FycmF5KHBhY2tldERhdGEpKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBwYWNrZXREYXRhLmxlbmd0aDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICBwcm9jZXNzQXJyYXlQYWNrZXREYXRhKG9iamVjdCwgcHJvcGVydHlOYW1lLCBwYWNrZXREYXRhW2ldLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHByb2Nlc3NBcnJheVBhY2tldERhdGEob2JqZWN0LCBwcm9wZXJ0eU5hbWUsIHBhY2tldERhdGEsIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBwcm9jZXNzUG9zaXRpb25zUGFja2V0RGF0YShvYmplY3QsIHByb3BlcnR5TmFtZSwgcG9zaXRpb25zRGF0YSwgZW50aXR5Q29sbGVjdGlvbikge1xyXG4gICAgICAgIGlmIChkZWZpbmVkKHBvc2l0aW9uc0RhdGEucmVmZXJlbmNlcykpIHtcclxuICAgICAgICAgICAgdmFyIHByb3BlcnRpZXMgPSBwb3NpdGlvbnNEYXRhLnJlZmVyZW5jZXMubWFwKGZ1bmN0aW9uKHJlZmVyZW5jZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVJlZmVyZW5jZVByb3BlcnR5KGVudGl0eUNvbGxlY3Rpb24sIHJlZmVyZW5jZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgdmFyIGlzbzg2MDFJbnRlcnZhbCA9IHBvc2l0aW9uc0RhdGEuaW50ZXJ2YWw7XHJcbiAgICAgICAgICAgIGlmIChkZWZpbmVkKGlzbzg2MDFJbnRlcnZhbCkpIHtcclxuICAgICAgICAgICAgICAgIGlzbzg2MDFJbnRlcnZhbCA9IFRpbWVJbnRlcnZhbC5mcm9tSXNvODYwMShpc284NjAxSW50ZXJ2YWwpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCEob2JqZWN0W3Byb3BlcnR5TmFtZV0gaW5zdGFuY2VvZiBDb21wb3NpdGVQb3NpdGlvblByb3BlcnR5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlzbzg2MDFJbnRlcnZhbC5kYXRhID0gbmV3IFBvc2l0aW9uUHJvcGVydHlBcnJheShwcm9wZXJ0aWVzKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHkgPSBuZXcgQ29tcG9zaXRlUG9zaXRpb25Qcm9wZXJ0eSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5LmludGVydmFscy5hZGRJbnRlcnZhbChpc284NjAxSW50ZXJ2YWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdFtwcm9wZXJ0eU5hbWVdID0gcHJvcGVydHk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBvYmplY3RbcHJvcGVydHlOYW1lXSA9IG5ldyBQb3NpdGlvblByb3BlcnR5QXJyYXkocHJvcGVydGllcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoZGVmaW5lZChwb3NpdGlvbnNEYXRhLmNhcnRlc2lhbikpIHtcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uc0RhdGEuYXJyYXkgPSBDYXJ0ZXNpYW4zLnVucGFja0FycmF5KHBvc2l0aW9uc0RhdGEuY2FydGVzaWFuKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChkZWZpbmVkKHBvc2l0aW9uc0RhdGEuY2FydG9ncmFwaGljUmFkaWFucykpIHtcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uc0RhdGEuYXJyYXkgPSBDYXJ0ZXNpYW4zLmZyb21SYWRpYW5zQXJyYXlIZWlnaHRzKHBvc2l0aW9uc0RhdGEuY2FydG9ncmFwaGljUmFkaWFucyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGVmaW5lZChwb3NpdGlvbnNEYXRhLmNhcnRvZ3JhcGhpY0RlZ3JlZXMpKSB7XHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbnNEYXRhLmFycmF5ID0gQ2FydGVzaWFuMy5mcm9tRGVncmVlc0FycmF5SGVpZ2h0cyhwb3NpdGlvbnNEYXRhLmNhcnRvZ3JhcGhpY0RlZ3JlZXMpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoZGVmaW5lZChwb3NpdGlvbnNEYXRhLmFycmF5KSkge1xyXG4gICAgICAgICAgICAgICAgcHJvY2Vzc1BhY2tldERhdGEoQXJyYXksIG9iamVjdCwgcHJvcGVydHlOYW1lLCBwb3NpdGlvbnNEYXRhLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcHJvY2Vzc1Bvc2l0aW9ucyhvYmplY3QsIHByb3BlcnR5TmFtZSwgcG9zaXRpb25zRGF0YSwgZW50aXR5Q29sbGVjdGlvbikge1xyXG4gICAgICAgIGlmICghZGVmaW5lZChwb3NpdGlvbnNEYXRhKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaXNBcnJheShwb3NpdGlvbnNEYXRhKSkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gcG9zaXRpb25zRGF0YS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgcHJvY2Vzc1Bvc2l0aW9uc1BhY2tldERhdGEob2JqZWN0LCBwcm9wZXJ0eU5hbWUsIHBvc2l0aW9uc0RhdGFbaV0sIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcHJvY2Vzc1Bvc2l0aW9uc1BhY2tldERhdGEob2JqZWN0LCBwcm9wZXJ0eU5hbWUsIHBvc2l0aW9uc0RhdGEsIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBwcm9jZXNzQXZhaWxhYmlsaXR5KGVudGl0eSwgcGFja2V0LCBlbnRpdHlDb2xsZWN0aW9uLCBzb3VyY2VVcmkpIHtcclxuICAgICAgICB2YXIgaW50ZXJ2YWw7XHJcbiAgICAgICAgdmFyIHBhY2tldERhdGEgPSBwYWNrZXQuYXZhaWxhYmlsaXR5O1xyXG4gICAgICAgIGlmICghZGVmaW5lZChwYWNrZXREYXRhKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgaW50ZXJ2YWxzO1xyXG4gICAgICAgIGlmIChpc0FycmF5KHBhY2tldERhdGEpKSB7XHJcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBwYWNrZXREYXRhLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFkZWZpbmVkKGludGVydmFscykpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnRlcnZhbHMgPSBuZXcgVGltZUludGVydmFsQ29sbGVjdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaXNvODYwMVNjcmF0Y2guaXNvODYwMSA9IHBhY2tldERhdGFbaV07XHJcbiAgICAgICAgICAgICAgICBpbnRlcnZhbCA9IFRpbWVJbnRlcnZhbC5mcm9tSXNvODYwMShpc284NjAxU2NyYXRjaCk7XHJcbiAgICAgICAgICAgICAgICBpbnRlcnZhbHMuYWRkSW50ZXJ2YWwoaW50ZXJ2YWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaXNvODYwMVNjcmF0Y2guaXNvODYwMSA9IHBhY2tldERhdGE7XHJcbiAgICAgICAgICAgIGludGVydmFsID0gVGltZUludGVydmFsLmZyb21Jc284NjAxKGlzbzg2MDFTY3JhdGNoKTtcclxuICAgICAgICAgICAgaW50ZXJ2YWxzID0gbmV3IFRpbWVJbnRlcnZhbENvbGxlY3Rpb24oKTtcclxuICAgICAgICAgICAgaW50ZXJ2YWxzLmFkZEludGVydmFsKGludGVydmFsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZW50aXR5LmF2YWlsYWJpbGl0eSA9IGludGVydmFscztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBwcm9jZXNzQWxpZ25lZEF4aXMoYmlsbGJvYXJkLCBwYWNrZXREYXRhLCBpbnRlcnZhbCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKSB7XHJcbiAgICAgICAgaWYgKCFkZWZpbmVkKHBhY2tldERhdGEpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKFVuaXRDYXJ0ZXNpYW4zLCBiaWxsYm9hcmQsICdhbGlnbmVkQXhpcycsIHBhY2tldERhdGEsIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHByb2Nlc3NCaWxsYm9hcmQoZW50aXR5LCBwYWNrZXQsIGVudGl0eUNvbGxlY3Rpb24sIHNvdXJjZVVyaSkge1xyXG4gICAgICAgIHZhciBiaWxsYm9hcmREYXRhID0gcGFja2V0LmJpbGxib2FyZDtcclxuICAgICAgICBpZiAoIWRlZmluZWQoYmlsbGJvYXJkRGF0YSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGludGVydmFsO1xyXG4gICAgICAgIHZhciBpbnRlcnZhbFN0cmluZyA9IGJpbGxib2FyZERhdGEuaW50ZXJ2YWw7XHJcbiAgICAgICAgaWYgKGRlZmluZWQoaW50ZXJ2YWxTdHJpbmcpKSB7XHJcbiAgICAgICAgICAgIGlzbzg2MDFTY3JhdGNoLmlzbzg2MDEgPSBpbnRlcnZhbFN0cmluZztcclxuICAgICAgICAgICAgaW50ZXJ2YWwgPSBUaW1lSW50ZXJ2YWwuZnJvbUlzbzg2MDEoaXNvODYwMVNjcmF0Y2gpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGJpbGxib2FyZCA9IGVudGl0eS5iaWxsYm9hcmQ7XHJcbiAgICAgICAgaWYgKCFkZWZpbmVkKGJpbGxib2FyZCkpIHtcclxuICAgICAgICAgICAgZW50aXR5LmJpbGxib2FyZCA9IGJpbGxib2FyZCA9IG5ldyBCaWxsYm9hcmRHcmFwaGljcygpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJvY2Vzc1BhY2tldERhdGEoQm9vbGVhbiwgYmlsbGJvYXJkLCAnc2hvdycsIGJpbGxib2FyZERhdGEuc2hvdywgaW50ZXJ2YWwsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICAgICAgcHJvY2Vzc1BhY2tldERhdGEoSW1hZ2UsIGJpbGxib2FyZCwgJ2ltYWdlJywgYmlsbGJvYXJkRGF0YS5pbWFnZSwgaW50ZXJ2YWwsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICAgICAgcHJvY2Vzc1BhY2tldERhdGEoTnVtYmVyLCBiaWxsYm9hcmQsICdzY2FsZScsIGJpbGxib2FyZERhdGEuc2NhbGUsIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKENhcnRlc2lhbjIsIGJpbGxib2FyZCwgJ3BpeGVsT2Zmc2V0JywgYmlsbGJvYXJkRGF0YS5waXhlbE9mZnNldCwgaW50ZXJ2YWwsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICAgICAgcHJvY2Vzc1BhY2tldERhdGEoQ2FydGVzaWFuMywgYmlsbGJvYXJkLCAnZXllT2Zmc2V0JywgYmlsbGJvYXJkRGF0YS5leWVPZmZzZXQsIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKEhvcml6b250YWxPcmlnaW4sIGJpbGxib2FyZCwgJ2hvcml6b250YWxPcmlnaW4nLCBiaWxsYm9hcmREYXRhLmhvcml6b250YWxPcmlnaW4sIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKFZlcnRpY2FsT3JpZ2luLCBiaWxsYm9hcmQsICd2ZXJ0aWNhbE9yaWdpbicsIGJpbGxib2FyZERhdGEudmVydGljYWxPcmlnaW4sIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKEhlaWdodFJlZmVyZW5jZSwgYmlsbGJvYXJkLCAnaGVpZ2h0UmVmZXJlbmNlJywgYmlsbGJvYXJkRGF0YS5oZWlnaHRSZWZlcmVuY2UsIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKENvbG9yLCBiaWxsYm9hcmQsICdjb2xvcicsIGJpbGxib2FyZERhdGEuY29sb3IsIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKFJvdGF0aW9uLCBiaWxsYm9hcmQsICdyb3RhdGlvbicsIGJpbGxib2FyZERhdGEucm90YXRpb24sIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NBbGlnbmVkQXhpcyhiaWxsYm9hcmQsIGJpbGxib2FyZERhdGEuYWxpZ25lZEF4aXMsIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKEJvb2xlYW4sIGJpbGxib2FyZCwgJ3NpemVJbk1ldGVycycsIGJpbGxib2FyZERhdGEuc2l6ZUluTWV0ZXJzLCBpbnRlcnZhbCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgICAgICBwcm9jZXNzUGFja2V0RGF0YShOdW1iZXIsIGJpbGxib2FyZCwgJ3dpZHRoJywgYmlsbGJvYXJkRGF0YS53aWR0aCwgaW50ZXJ2YWwsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICAgICAgcHJvY2Vzc1BhY2tldERhdGEoTnVtYmVyLCBiaWxsYm9hcmQsICdoZWlnaHQnLCBiaWxsYm9hcmREYXRhLmhlaWdodCwgaW50ZXJ2YWwsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICAgICAgcHJvY2Vzc1BhY2tldERhdGEoTmVhckZhclNjYWxhciwgYmlsbGJvYXJkLCAnc2NhbGVCeURpc3RhbmNlJywgYmlsbGJvYXJkRGF0YS5zY2FsZUJ5RGlzdGFuY2UsIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKE5lYXJGYXJTY2FsYXIsIGJpbGxib2FyZCwgJ3RyYW5zbHVjZW5jeUJ5RGlzdGFuY2UnLCBiaWxsYm9hcmREYXRhLnRyYW5zbHVjZW5jeUJ5RGlzdGFuY2UsIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKE5lYXJGYXJTY2FsYXIsIGJpbGxib2FyZCwgJ3BpeGVsT2Zmc2V0U2NhbGVCeURpc3RhbmNlJywgYmlsbGJvYXJkRGF0YS5waXhlbE9mZnNldFNjYWxlQnlEaXN0YW5jZSwgaW50ZXJ2YWwsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICAgICAgcHJvY2Vzc1BhY2tldERhdGEoQm91bmRpbmdSZWN0YW5nbGUsIGJpbGxib2FyZCwgJ2ltYWdlU3ViUmVnaW9uJywgYmlsbGJvYXJkRGF0YS5pbWFnZVN1YlJlZ2lvbiwgaW50ZXJ2YWwsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICAgICAgcHJvY2Vzc1BhY2tldERhdGEoRGlzdGFuY2VEaXNwbGF5Q29uZGl0aW9uLCBiaWxsYm9hcmQsICdkaXN0YW5jZURpc3BsYXlDb25kaXRpb24nLCBiaWxsYm9hcmREYXRhLmRpc3RhbmNlRGlzcGxheUNvbmRpdGlvbiwgaW50ZXJ2YWwsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICAgICAgcHJvY2Vzc1BhY2tldERhdGEoTnVtYmVyLCBiaWxsYm9hcmQsICdkaXNhYmxlRGVwdGhUZXN0RGlzdGFuY2UnLCBiaWxsYm9hcmREYXRhLmRpc2FibGVEZXB0aFRlc3REaXN0YW5jZSwgaW50ZXJ2YWwsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcHJvY2Vzc0JveChlbnRpdHksIHBhY2tldCwgZW50aXR5Q29sbGVjdGlvbiwgc291cmNlVXJpKSB7XHJcbiAgICAgICAgdmFyIGJveERhdGEgPSBwYWNrZXQuYm94O1xyXG4gICAgICAgIGlmICghZGVmaW5lZChib3hEYXRhKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgaW50ZXJ2YWw7XHJcbiAgICAgICAgdmFyIGludGVydmFsU3RyaW5nID0gYm94RGF0YS5pbnRlcnZhbDtcclxuICAgICAgICBpZiAoZGVmaW5lZChpbnRlcnZhbFN0cmluZykpIHtcclxuICAgICAgICAgICAgaXNvODYwMVNjcmF0Y2guaXNvODYwMSA9IGludGVydmFsU3RyaW5nO1xyXG4gICAgICAgICAgICBpbnRlcnZhbCA9IFRpbWVJbnRlcnZhbC5mcm9tSXNvODYwMShpc284NjAxU2NyYXRjaCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgYm94ID0gZW50aXR5LmJveDtcclxuICAgICAgICBpZiAoIWRlZmluZWQoYm94KSkge1xyXG4gICAgICAgICAgICBlbnRpdHkuYm94ID0gYm94ID0gbmV3IEJveEdyYXBoaWNzKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcm9jZXNzUGFja2V0RGF0YShCb29sZWFuLCBib3gsICdzaG93JywgYm94RGF0YS5zaG93LCBpbnRlcnZhbCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgICAgICBwcm9jZXNzUGFja2V0RGF0YShDYXJ0ZXNpYW4zLCBib3gsICdkaW1lbnNpb25zJywgYm94RGF0YS5kaW1lbnNpb25zLCBpbnRlcnZhbCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgICAgICBwcm9jZXNzUGFja2V0RGF0YShCb29sZWFuLCBib3gsICdmaWxsJywgYm94RGF0YS5maWxsLCBpbnRlcnZhbCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgICAgICBwcm9jZXNzTWF0ZXJpYWxQYWNrZXREYXRhKGJveCwgJ21hdGVyaWFsJywgYm94RGF0YS5tYXRlcmlhbCwgaW50ZXJ2YWwsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICAgICAgcHJvY2Vzc1BhY2tldERhdGEoQm9vbGVhbiwgYm94LCAnb3V0bGluZScsIGJveERhdGEub3V0bGluZSwgaW50ZXJ2YWwsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICAgICAgcHJvY2Vzc1BhY2tldERhdGEoQ29sb3IsIGJveCwgJ291dGxpbmVDb2xvcicsIGJveERhdGEub3V0bGluZUNvbG9yLCBpbnRlcnZhbCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgICAgICBwcm9jZXNzUGFja2V0RGF0YShOdW1iZXIsIGJveCwgJ291dGxpbmVXaWR0aCcsIGJveERhdGEub3V0bGluZVdpZHRoLCBpbnRlcnZhbCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgICAgICBwcm9jZXNzUGFja2V0RGF0YShTaGFkb3dNb2RlLCBib3gsICdzaGFkb3dzJywgYm94RGF0YS5zaGFkb3dzLCBpbnRlcnZhbCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgICAgICBwcm9jZXNzUGFja2V0RGF0YShEaXN0YW5jZURpc3BsYXlDb25kaXRpb24sIGJveCwgJ2Rpc3RhbmNlRGlzcGxheUNvbmRpdGlvbicsIGJveERhdGEuZGlzdGFuY2VEaXNwbGF5Q29uZGl0aW9uLCBpbnRlcnZhbCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBwcm9jZXNzQ29ycmlkb3IoZW50aXR5LCBwYWNrZXQsIGVudGl0eUNvbGxlY3Rpb24sIHNvdXJjZVVyaSkge1xyXG4gICAgICAgIHZhciBjb3JyaWRvckRhdGEgPSBwYWNrZXQuY29ycmlkb3I7XHJcbiAgICAgICAgaWYgKCFkZWZpbmVkKGNvcnJpZG9yRGF0YSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGludGVydmFsO1xyXG4gICAgICAgIHZhciBpbnRlcnZhbFN0cmluZyA9IGNvcnJpZG9yRGF0YS5pbnRlcnZhbDtcclxuICAgICAgICBpZiAoZGVmaW5lZChpbnRlcnZhbFN0cmluZykpIHtcclxuICAgICAgICAgICAgaXNvODYwMVNjcmF0Y2guaXNvODYwMSA9IGludGVydmFsU3RyaW5nO1xyXG4gICAgICAgICAgICBpbnRlcnZhbCA9IFRpbWVJbnRlcnZhbC5mcm9tSXNvODYwMShpc284NjAxU2NyYXRjaCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgY29ycmlkb3IgPSBlbnRpdHkuY29ycmlkb3I7XHJcbiAgICAgICAgaWYgKCFkZWZpbmVkKGNvcnJpZG9yKSkge1xyXG4gICAgICAgICAgICBlbnRpdHkuY29ycmlkb3IgPSBjb3JyaWRvciA9IG5ldyBDb3JyaWRvckdyYXBoaWNzKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcm9jZXNzUGFja2V0RGF0YShCb29sZWFuLCBjb3JyaWRvciwgJ3Nob3cnLCBjb3JyaWRvckRhdGEuc2hvdywgaW50ZXJ2YWwsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICAgICAgcHJvY2Vzc1Bvc2l0aW9ucyhjb3JyaWRvciwgJ3Bvc2l0aW9ucycsIGNvcnJpZG9yRGF0YS5wb3NpdGlvbnMsIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKE51bWJlciwgY29ycmlkb3IsICd3aWR0aCcsIGNvcnJpZG9yRGF0YS53aWR0aCwgaW50ZXJ2YWwsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICAgICAgcHJvY2Vzc1BhY2tldERhdGEoTnVtYmVyLCBjb3JyaWRvciwgJ2hlaWdodCcsIGNvcnJpZG9yRGF0YS5oZWlnaHQsIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKE51bWJlciwgY29ycmlkb3IsICdleHRydWRlZEhlaWdodCcsIGNvcnJpZG9yRGF0YS5leHRydWRlZEhlaWdodCwgaW50ZXJ2YWwsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICAgICAgcHJvY2Vzc1BhY2tldERhdGEoQ29ybmVyVHlwZSwgY29ycmlkb3IsICdjb3JuZXJUeXBlJywgY29ycmlkb3JEYXRhLmNvcm5lclR5cGUsIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKE51bWJlciwgY29ycmlkb3IsICdncmFudWxhcml0eScsIGNvcnJpZG9yRGF0YS5ncmFudWxhcml0eSwgaW50ZXJ2YWwsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICAgICAgcHJvY2Vzc1BhY2tldERhdGEoQm9vbGVhbiwgY29ycmlkb3IsICdmaWxsJywgY29ycmlkb3JEYXRhLmZpbGwsIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NNYXRlcmlhbFBhY2tldERhdGEoY29ycmlkb3IsICdtYXRlcmlhbCcsIGNvcnJpZG9yRGF0YS5tYXRlcmlhbCwgaW50ZXJ2YWwsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICAgICAgcHJvY2Vzc1BhY2tldERhdGEoQm9vbGVhbiwgY29ycmlkb3IsICdvdXRsaW5lJywgY29ycmlkb3JEYXRhLm91dGxpbmUsIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKENvbG9yLCBjb3JyaWRvciwgJ291dGxpbmVDb2xvcicsIGNvcnJpZG9yRGF0YS5vdXRsaW5lQ29sb3IsIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKE51bWJlciwgY29ycmlkb3IsICdvdXRsaW5lV2lkdGgnLCBjb3JyaWRvckRhdGEub3V0bGluZVdpZHRoLCBpbnRlcnZhbCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgICAgICBwcm9jZXNzUGFja2V0RGF0YShTaGFkb3dNb2RlLCBjb3JyaWRvciwgJ3NoYWRvd3MnLCBjb3JyaWRvckRhdGEuc2hhZG93cywgaW50ZXJ2YWwsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICAgICAgcHJvY2Vzc1BhY2tldERhdGEoRGlzdGFuY2VEaXNwbGF5Q29uZGl0aW9uLCBjb3JyaWRvciwgJ2Rpc3RhbmNlRGlzcGxheUNvbmRpdGlvbicsIGNvcnJpZG9yRGF0YS5kaXN0YW5jZURpc3BsYXlDb25kaXRpb24sIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKE51bWJlciwgY29ycmlkb3IsICd6SW5kZXgnLCBjb3JyaWRvckRhdGEuekluZGV4LCBpbnRlcnZhbCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBwcm9jZXNzQ3lsaW5kZXIoZW50aXR5LCBwYWNrZXQsIGVudGl0eUNvbGxlY3Rpb24sIHNvdXJjZVVyaSkge1xyXG4gICAgICAgIHZhciBjeWxpbmRlckRhdGEgPSBwYWNrZXQuY3lsaW5kZXI7XHJcbiAgICAgICAgaWYgKCFkZWZpbmVkKGN5bGluZGVyRGF0YSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGludGVydmFsO1xyXG4gICAgICAgIHZhciBpbnRlcnZhbFN0cmluZyA9IGN5bGluZGVyRGF0YS5pbnRlcnZhbDtcclxuICAgICAgICBpZiAoZGVmaW5lZChpbnRlcnZhbFN0cmluZykpIHtcclxuICAgICAgICAgICAgaXNvODYwMVNjcmF0Y2guaXNvODYwMSA9IGludGVydmFsU3RyaW5nO1xyXG4gICAgICAgICAgICBpbnRlcnZhbCA9IFRpbWVJbnRlcnZhbC5mcm9tSXNvODYwMShpc284NjAxU2NyYXRjaCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgY3lsaW5kZXIgPSBlbnRpdHkuY3lsaW5kZXI7XHJcbiAgICAgICAgaWYgKCFkZWZpbmVkKGN5bGluZGVyKSkge1xyXG4gICAgICAgICAgICBlbnRpdHkuY3lsaW5kZXIgPSBjeWxpbmRlciA9IG5ldyBDeWxpbmRlckdyYXBoaWNzKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcm9jZXNzUGFja2V0RGF0YShCb29sZWFuLCBjeWxpbmRlciwgJ3Nob3cnLCBjeWxpbmRlckRhdGEuc2hvdywgaW50ZXJ2YWwsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICAgICAgcHJvY2Vzc1BhY2tldERhdGEoTnVtYmVyLCBjeWxpbmRlciwgJ2xlbmd0aCcsIGN5bGluZGVyRGF0YS5sZW5ndGgsIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKE51bWJlciwgY3lsaW5kZXIsICd0b3BSYWRpdXMnLCBjeWxpbmRlckRhdGEudG9wUmFkaXVzLCBpbnRlcnZhbCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgICAgICBwcm9jZXNzUGFja2V0RGF0YShOdW1iZXIsIGN5bGluZGVyLCAnYm90dG9tUmFkaXVzJywgY3lsaW5kZXJEYXRhLmJvdHRvbVJhZGl1cywgaW50ZXJ2YWwsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICAgICAgcHJvY2Vzc1BhY2tldERhdGEoQm9vbGVhbiwgY3lsaW5kZXIsICdmaWxsJywgY3lsaW5kZXJEYXRhLmZpbGwsIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NNYXRlcmlhbFBhY2tldERhdGEoY3lsaW5kZXIsICdtYXRlcmlhbCcsIGN5bGluZGVyRGF0YS5tYXRlcmlhbCwgaW50ZXJ2YWwsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICAgICAgcHJvY2Vzc1BhY2tldERhdGEoQm9vbGVhbiwgY3lsaW5kZXIsICdvdXRsaW5lJywgY3lsaW5kZXJEYXRhLm91dGxpbmUsIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKENvbG9yLCBjeWxpbmRlciwgJ291dGxpbmVDb2xvcicsIGN5bGluZGVyRGF0YS5vdXRsaW5lQ29sb3IsIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKE51bWJlciwgY3lsaW5kZXIsICdvdXRsaW5lV2lkdGgnLCBjeWxpbmRlckRhdGEub3V0bGluZVdpZHRoLCBpbnRlcnZhbCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgICAgICBwcm9jZXNzUGFja2V0RGF0YShOdW1iZXIsIGN5bGluZGVyLCAnbnVtYmVyT2ZWZXJ0aWNhbExpbmVzJywgY3lsaW5kZXJEYXRhLm51bWJlck9mVmVydGljYWxMaW5lcywgaW50ZXJ2YWwsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICAgICAgcHJvY2Vzc1BhY2tldERhdGEoTnVtYmVyLCBjeWxpbmRlciwgJ3NsaWNlcycsIGN5bGluZGVyRGF0YS5zbGljZXMsIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKFNoYWRvd01vZGUsIGN5bGluZGVyLCAnc2hhZG93cycsIGN5bGluZGVyRGF0YS5zaGFkb3dzLCBpbnRlcnZhbCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgICAgICBwcm9jZXNzUGFja2V0RGF0YShEaXN0YW5jZURpc3BsYXlDb25kaXRpb24sIGN5bGluZGVyLCAnZGlzdGFuY2VEaXNwbGF5Q29uZGl0aW9uJywgY3lsaW5kZXJEYXRhLmRpc3RhbmNlRGlzcGxheUNvbmRpdGlvbiwgaW50ZXJ2YWwsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcHJvY2Vzc0RvY3VtZW50KHBhY2tldCwgZGF0YVNvdXJjZSkge1xyXG4gICAgICAgIHZhciB2ZXJzaW9uID0gcGFja2V0LnZlcnNpb247XHJcbiAgICAgICAgaWYgKGRlZmluZWQodmVyc2lvbikpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2ZXJzaW9uID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRva2VucyA9IHZlcnNpb24uc3BsaXQoJy4nKTtcclxuICAgICAgICAgICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID09PSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2Vuc1swXSAhPT0gJzEnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3IoJ0Nlc2l1bSBvbmx5IHN1cHBvcnRzIENaTUwgdmVyc2lvbiAxLicpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBkYXRhU291cmNlLl92ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFkZWZpbmVkKGRhdGFTb3VyY2UuX3ZlcnNpb24pKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3IoJ0NaTUwgdmVyc2lvbiBpbmZvcm1hdGlvbiBpbnZhbGlkLiAgSXQgaXMgZXhwZWN0ZWQgdG8gYmUgYSBwcm9wZXJ0eSBvbiB0aGUgZG9jdW1lbnQgb2JqZWN0IGluIHRoZSA8TWFqb3I+LjxNaW5vcj4gdmVyc2lvbiBmb3JtYXQuJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgZG9jdW1lbnRQYWNrZXQgPSBkYXRhU291cmNlLl9kb2N1bWVudFBhY2tldDtcclxuXHJcbiAgICAgICAgaWYgKGRlZmluZWQocGFja2V0Lm5hbWUpKSB7XHJcbiAgICAgICAgICAgIGRvY3VtZW50UGFja2V0Lm5hbWUgPSBwYWNrZXQubmFtZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBjbG9ja1BhY2tldCA9IHBhY2tldC5jbG9jaztcclxuICAgICAgICBpZiAoZGVmaW5lZChjbG9ja1BhY2tldCkpIHtcclxuICAgICAgICAgICAgdmFyIGNsb2NrID0gZG9jdW1lbnRQYWNrZXQuY2xvY2s7XHJcbiAgICAgICAgICAgIGlmICghZGVmaW5lZChjbG9jaykpIHtcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50UGFja2V0LmNsb2NrID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGludGVydmFsIDogY2xvY2tQYWNrZXQuaW50ZXJ2YWwsXHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFRpbWUgOiBjbG9ja1BhY2tldC5jdXJyZW50VGltZSxcclxuICAgICAgICAgICAgICAgICAgICByYW5nZSA6IGNsb2NrUGFja2V0LnJhbmdlLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0ZXAgOiBjbG9ja1BhY2tldC5zdGVwLFxyXG4gICAgICAgICAgICAgICAgICAgIG11bHRpcGxpZXIgOiBjbG9ja1BhY2tldC5tdWx0aXBsaWVyXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY2xvY2suaW50ZXJ2YWwgPSBkZWZhdWx0VmFsdWUoY2xvY2tQYWNrZXQuaW50ZXJ2YWwsIGNsb2NrLmludGVydmFsKTtcclxuICAgICAgICAgICAgICAgIGNsb2NrLmN1cnJlbnRUaW1lID0gZGVmYXVsdFZhbHVlKGNsb2NrUGFja2V0LmN1cnJlbnRUaW1lLCBjbG9jay5jdXJyZW50VGltZSk7XHJcbiAgICAgICAgICAgICAgICBjbG9jay5yYW5nZSA9IGRlZmF1bHRWYWx1ZShjbG9ja1BhY2tldC5yYW5nZSwgY2xvY2sucmFuZ2UpO1xyXG4gICAgICAgICAgICAgICAgY2xvY2suc3RlcCA9IGRlZmF1bHRWYWx1ZShjbG9ja1BhY2tldC5zdGVwLCBjbG9jay5zdGVwKTtcclxuICAgICAgICAgICAgICAgIGNsb2NrLm11bHRpcGxpZXIgPSBkZWZhdWx0VmFsdWUoY2xvY2tQYWNrZXQubXVsdGlwbGllciwgY2xvY2subXVsdGlwbGllcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcHJvY2Vzc0VsbGlwc2UoZW50aXR5LCBwYWNrZXQsIGVudGl0eUNvbGxlY3Rpb24sIHNvdXJjZVVyaSkge1xyXG4gICAgICAgIHZhciBlbGxpcHNlRGF0YSA9IHBhY2tldC5lbGxpcHNlO1xyXG4gICAgICAgIGlmICghZGVmaW5lZChlbGxpcHNlRGF0YSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGludGVydmFsO1xyXG4gICAgICAgIHZhciBpbnRlcnZhbFN0cmluZyA9IGVsbGlwc2VEYXRhLmludGVydmFsO1xyXG4gICAgICAgIGlmIChkZWZpbmVkKGludGVydmFsU3RyaW5nKSkge1xyXG4gICAgICAgICAgICBpc284NjAxU2NyYXRjaC5pc284NjAxID0gaW50ZXJ2YWxTdHJpbmc7XHJcbiAgICAgICAgICAgIGludGVydmFsID0gVGltZUludGVydmFsLmZyb21Jc284NjAxKGlzbzg2MDFTY3JhdGNoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBlbGxpcHNlID0gZW50aXR5LmVsbGlwc2U7XHJcbiAgICAgICAgaWYgKCFkZWZpbmVkKGVsbGlwc2UpKSB7XHJcbiAgICAgICAgICAgIGVudGl0eS5lbGxpcHNlID0gZWxsaXBzZSA9IG5ldyBFbGxpcHNlR3JhcGhpY3MoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKEJvb2xlYW4sIGVsbGlwc2UsICdzaG93JywgZWxsaXBzZURhdGEuc2hvdywgaW50ZXJ2YWwsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICAgICAgcHJvY2Vzc1BhY2tldERhdGEoTnVtYmVyLCBlbGxpcHNlLCAnc2VtaU1ham9yQXhpcycsIGVsbGlwc2VEYXRhLnNlbWlNYWpvckF4aXMsIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKE51bWJlciwgZWxsaXBzZSwgJ3NlbWlNaW5vckF4aXMnLCBlbGxpcHNlRGF0YS5zZW1pTWlub3JBeGlzLCBpbnRlcnZhbCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgICAgICBwcm9jZXNzUGFja2V0RGF0YShOdW1iZXIsIGVsbGlwc2UsICdoZWlnaHQnLCBlbGxpcHNlRGF0YS5oZWlnaHQsIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKE51bWJlciwgZWxsaXBzZSwgJ2V4dHJ1ZGVkSGVpZ2h0JywgZWxsaXBzZURhdGEuZXh0cnVkZWRIZWlnaHQsIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKFJvdGF0aW9uLCBlbGxpcHNlLCAncm90YXRpb24nLCBlbGxpcHNlRGF0YS5yb3RhdGlvbiwgaW50ZXJ2YWwsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICAgICAgcHJvY2Vzc1BhY2tldERhdGEoUm90YXRpb24sIGVsbGlwc2UsICdzdFJvdGF0aW9uJywgZWxsaXBzZURhdGEuc3RSb3RhdGlvbiwgaW50ZXJ2YWwsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICAgICAgcHJvY2Vzc1BhY2tldERhdGEoTnVtYmVyLCBlbGxpcHNlLCAnZ3JhbnVsYXJpdHknLCBlbGxpcHNlRGF0YS5ncmFudWxhcml0eSwgaW50ZXJ2YWwsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICAgICAgcHJvY2Vzc1BhY2tldERhdGEoQm9vbGVhbiwgZWxsaXBzZSwgJ2ZpbGwnLCBlbGxpcHNlRGF0YS5maWxsLCBpbnRlcnZhbCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgICAgICBwcm9jZXNzTWF0ZXJpYWxQYWNrZXREYXRhKGVsbGlwc2UsICdtYXRlcmlhbCcsIGVsbGlwc2VEYXRhLm1hdGVyaWFsLCBpbnRlcnZhbCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgICAgICBwcm9jZXNzUGFja2V0RGF0YShCb29sZWFuLCBlbGxpcHNlLCAnb3V0bGluZScsIGVsbGlwc2VEYXRhLm91dGxpbmUsIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKENvbG9yLCBlbGxpcHNlLCAnb3V0bGluZUNvbG9yJywgZWxsaXBzZURhdGEub3V0bGluZUNvbG9yLCBpbnRlcnZhbCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgICAgICBwcm9jZXNzUGFja2V0RGF0YShOdW1iZXIsIGVsbGlwc2UsICdvdXRsaW5lV2lkdGgnLCBlbGxpcHNlRGF0YS5vdXRsaW5lV2lkdGgsIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKE51bWJlciwgZWxsaXBzZSwgJ251bWJlck9mVmVydGljYWxMaW5lcycsIGVsbGlwc2VEYXRhLm51bWJlck9mVmVydGljYWxMaW5lcywgaW50ZXJ2YWwsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICAgICAgcHJvY2Vzc1BhY2tldERhdGEoU2hhZG93TW9kZSwgZWxsaXBzZSwgJ3NoYWRvd3MnLCBlbGxpcHNlRGF0YS5zaGFkb3dzLCBpbnRlcnZhbCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgICAgICBwcm9jZXNzUGFja2V0RGF0YShEaXN0YW5jZURpc3BsYXlDb25kaXRpb24sIGVsbGlwc2UsICdkaXN0YW5jZURpc3BsYXlDb25kaXRpb24nLCBlbGxpcHNlRGF0YS5kaXN0YW5jZURpc3BsYXlDb25kaXRpb24sIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKE51bWJlciwgZWxsaXBzZSwgJ3pJbmRleCcsIGVsbGlwc2VEYXRhLnpJbmRleCwgaW50ZXJ2YWwsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcHJvY2Vzc0VsbGlwc29pZChlbnRpdHksIHBhY2tldCwgZW50aXR5Q29sbGVjdGlvbiwgc291cmNlVXJpKSB7XHJcbiAgICAgICAgdmFyIGVsbGlwc29pZERhdGEgPSBwYWNrZXQuZWxsaXBzb2lkO1xyXG4gICAgICAgIGlmICghZGVmaW5lZChlbGxpcHNvaWREYXRhKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgaW50ZXJ2YWw7XHJcbiAgICAgICAgdmFyIGludGVydmFsU3RyaW5nID0gZWxsaXBzb2lkRGF0YS5pbnRlcnZhbDtcclxuICAgICAgICBpZiAoZGVmaW5lZChpbnRlcnZhbFN0cmluZykpIHtcclxuICAgICAgICAgICAgaXNvODYwMVNjcmF0Y2guaXNvODYwMSA9IGludGVydmFsU3RyaW5nO1xyXG4gICAgICAgICAgICBpbnRlcnZhbCA9IFRpbWVJbnRlcnZhbC5mcm9tSXNvODYwMShpc284NjAxU2NyYXRjaCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgZWxsaXBzb2lkID0gZW50aXR5LmVsbGlwc29pZDtcclxuICAgICAgICBpZiAoIWRlZmluZWQoZWxsaXBzb2lkKSkge1xyXG4gICAgICAgICAgICBlbnRpdHkuZWxsaXBzb2lkID0gZWxsaXBzb2lkID0gbmV3IEVsbGlwc29pZEdyYXBoaWNzKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcm9jZXNzUGFja2V0RGF0YShCb29sZWFuLCBlbGxpcHNvaWQsICdzaG93JywgZWxsaXBzb2lkRGF0YS5zaG93LCBpbnRlcnZhbCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgICAgICBwcm9jZXNzUGFja2V0RGF0YShDYXJ0ZXNpYW4zLCBlbGxpcHNvaWQsICdyYWRpaScsIGVsbGlwc29pZERhdGEucmFkaWksIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKEJvb2xlYW4sIGVsbGlwc29pZCwgJ2ZpbGwnLCBlbGxpcHNvaWREYXRhLmZpbGwsIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NNYXRlcmlhbFBhY2tldERhdGEoZWxsaXBzb2lkLCAnbWF0ZXJpYWwnLCBlbGxpcHNvaWREYXRhLm1hdGVyaWFsLCBpbnRlcnZhbCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgICAgICBwcm9jZXNzUGFja2V0RGF0YShCb29sZWFuLCBlbGxpcHNvaWQsICdvdXRsaW5lJywgZWxsaXBzb2lkRGF0YS5vdXRsaW5lLCBpbnRlcnZhbCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgICAgICBwcm9jZXNzUGFja2V0RGF0YShDb2xvciwgZWxsaXBzb2lkLCAnb3V0bGluZUNvbG9yJywgZWxsaXBzb2lkRGF0YS5vdXRsaW5lQ29sb3IsIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKE51bWJlciwgZWxsaXBzb2lkLCAnb3V0bGluZVdpZHRoJywgZWxsaXBzb2lkRGF0YS5vdXRsaW5lV2lkdGgsIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKE51bWJlciwgZWxsaXBzb2lkLCAnc3RhY2tQYXJ0aXRpb25zJywgZWxsaXBzb2lkRGF0YS5zdGFja1BhcnRpdGlvbnMsIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKE51bWJlciwgZWxsaXBzb2lkLCAnc2xpY2VQYXJ0aXRpb25zJywgZWxsaXBzb2lkRGF0YS5zbGljZVBhcnRpdGlvbnMsIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKE51bWJlciwgZWxsaXBzb2lkLCAnc3ViZGl2aXNpb25zJywgZWxsaXBzb2lkRGF0YS5zdWJkaXZpc2lvbnMsIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKFNoYWRvd01vZGUsIGVsbGlwc29pZCwgJ3NoYWRvd3MnLCBlbGxpcHNvaWREYXRhLnNoYWRvd3MsIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKERpc3RhbmNlRGlzcGxheUNvbmRpdGlvbiwgZWxsaXBzb2lkLCAnZGlzdGFuY2VEaXNwbGF5Q29uZGl0aW9uJywgZWxsaXBzb2lkRGF0YS5kaXN0YW5jZURpc3BsYXlDb25kaXRpb24sIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHByb2Nlc3NMYWJlbChlbnRpdHksIHBhY2tldCwgZW50aXR5Q29sbGVjdGlvbiwgc291cmNlVXJpKSB7XHJcbiAgICAgICAgdmFyIGxhYmVsRGF0YSA9IHBhY2tldC5sYWJlbDtcclxuICAgICAgICBpZiAoIWRlZmluZWQobGFiZWxEYXRhKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgaW50ZXJ2YWw7XHJcbiAgICAgICAgdmFyIGludGVydmFsU3RyaW5nID0gbGFiZWxEYXRhLmludGVydmFsO1xyXG4gICAgICAgIGlmIChkZWZpbmVkKGludGVydmFsU3RyaW5nKSkge1xyXG4gICAgICAgICAgICBpc284NjAxU2NyYXRjaC5pc284NjAxID0gaW50ZXJ2YWxTdHJpbmc7XHJcbiAgICAgICAgICAgIGludGVydmFsID0gVGltZUludGVydmFsLmZyb21Jc284NjAxKGlzbzg2MDFTY3JhdGNoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBsYWJlbCA9IGVudGl0eS5sYWJlbDtcclxuICAgICAgICBpZiAoIWRlZmluZWQobGFiZWwpKSB7XHJcbiAgICAgICAgICAgIGVudGl0eS5sYWJlbCA9IGxhYmVsID0gbmV3IExhYmVsR3JhcGhpY3MoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKEJvb2xlYW4sIGxhYmVsLCAnc2hvdycsIGxhYmVsRGF0YS5zaG93LCBpbnRlcnZhbCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgICAgICBwcm9jZXNzUGFja2V0RGF0YShTdHJpbmcsIGxhYmVsLCAndGV4dCcsIGxhYmVsRGF0YS50ZXh0LCBpbnRlcnZhbCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgICAgICBwcm9jZXNzUGFja2V0RGF0YShTdHJpbmcsIGxhYmVsLCAnZm9udCcsIGxhYmVsRGF0YS5mb250LCBpbnRlcnZhbCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgICAgICBwcm9jZXNzUGFja2V0RGF0YShMYWJlbFN0eWxlLCBsYWJlbCwgJ3N0eWxlJywgbGFiZWxEYXRhLnN0eWxlLCBpbnRlcnZhbCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgICAgICBwcm9jZXNzUGFja2V0RGF0YShOdW1iZXIsIGxhYmVsLCAnc2NhbGUnLCBsYWJlbERhdGEuc2NhbGUsIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKEJvb2xlYW4sIGxhYmVsLCAnc2hvd0JhY2tncm91bmQnLCBsYWJlbERhdGEuc2hvd0JhY2tncm91bmQsIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKENvbG9yLCBsYWJlbCwgJ2JhY2tncm91bmRDb2xvcicsIGxhYmVsRGF0YS5iYWNrZ3JvdW5kQ29sb3IsIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKENhcnRlc2lhbjIsIGxhYmVsLCAnYmFja2dyb3VuZFBhZGRpbmcnLCBsYWJlbERhdGEuYmFja2dyb3VuZFBhZGRpbmcsIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKENhcnRlc2lhbjIsIGxhYmVsLCAncGl4ZWxPZmZzZXQnLCBsYWJlbERhdGEucGl4ZWxPZmZzZXQsIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKENhcnRlc2lhbjMsIGxhYmVsLCAnZXllT2Zmc2V0JywgbGFiZWxEYXRhLmV5ZU9mZnNldCwgaW50ZXJ2YWwsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICAgICAgcHJvY2Vzc1BhY2tldERhdGEoSG9yaXpvbnRhbE9yaWdpbiwgbGFiZWwsICdob3Jpem9udGFsT3JpZ2luJywgbGFiZWxEYXRhLmhvcml6b250YWxPcmlnaW4sIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKFZlcnRpY2FsT3JpZ2luLCBsYWJlbCwgJ3ZlcnRpY2FsT3JpZ2luJywgbGFiZWxEYXRhLnZlcnRpY2FsT3JpZ2luLCBpbnRlcnZhbCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgICAgICBwcm9jZXNzUGFja2V0RGF0YShIZWlnaHRSZWZlcmVuY2UsIGxhYmVsLCAnaGVpZ2h0UmVmZXJlbmNlJywgbGFiZWxEYXRhLmhlaWdodFJlZmVyZW5jZSwgaW50ZXJ2YWwsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICAgICAgcHJvY2Vzc1BhY2tldERhdGEoQ29sb3IsIGxhYmVsLCAnZmlsbENvbG9yJywgbGFiZWxEYXRhLmZpbGxDb2xvciwgaW50ZXJ2YWwsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICAgICAgcHJvY2Vzc1BhY2tldERhdGEoQ29sb3IsIGxhYmVsLCAnb3V0bGluZUNvbG9yJywgbGFiZWxEYXRhLm91dGxpbmVDb2xvciwgaW50ZXJ2YWwsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICAgICAgcHJvY2Vzc1BhY2tldERhdGEoTnVtYmVyLCBsYWJlbCwgJ291dGxpbmVXaWR0aCcsIGxhYmVsRGF0YS5vdXRsaW5lV2lkdGgsIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKE5lYXJGYXJTY2FsYXIsIGxhYmVsLCAndHJhbnNsdWNlbmN5QnlEaXN0YW5jZScsIGxhYmVsRGF0YS50cmFuc2x1Y2VuY3lCeURpc3RhbmNlLCBpbnRlcnZhbCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgICAgICBwcm9jZXNzUGFja2V0RGF0YShOZWFyRmFyU2NhbGFyLCBsYWJlbCwgJ3BpeGVsT2Zmc2V0U2NhbGVCeURpc3RhbmNlJywgbGFiZWxEYXRhLnBpeGVsT2Zmc2V0U2NhbGVCeURpc3RhbmNlLCBpbnRlcnZhbCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgICAgICBwcm9jZXNzUGFja2V0RGF0YShOZWFyRmFyU2NhbGFyLCBsYWJlbCwgJ3NjYWxlQnlEaXN0YW5jZScsIGxhYmVsRGF0YS5zY2FsZUJ5RGlzdGFuY2UsIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKERpc3RhbmNlRGlzcGxheUNvbmRpdGlvbiwgbGFiZWwsICdkaXN0YW5jZURpc3BsYXlDb25kaXRpb24nLCBsYWJlbERhdGEuZGlzdGFuY2VEaXNwbGF5Q29uZGl0aW9uLCBpbnRlcnZhbCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgICAgICBwcm9jZXNzUGFja2V0RGF0YShOdW1iZXIsIGxhYmVsLCAnZGlzYWJsZURlcHRoVGVzdERpc3RhbmNlJywgbGFiZWxEYXRhLmRpc2FibGVEZXB0aFRlc3REaXN0YW5jZSwgaW50ZXJ2YWwsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcHJvY2Vzc01vZGVsKGVudGl0eSwgcGFja2V0LCBlbnRpdHlDb2xsZWN0aW9uLCBzb3VyY2VVcmkpIHtcclxuICAgICAgICB2YXIgbW9kZWxEYXRhID0gcGFja2V0Lm1vZGVsO1xyXG4gICAgICAgIGlmICghZGVmaW5lZChtb2RlbERhdGEpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBpbnRlcnZhbDtcclxuICAgICAgICB2YXIgaW50ZXJ2YWxTdHJpbmcgPSBtb2RlbERhdGEuaW50ZXJ2YWw7XHJcbiAgICAgICAgaWYgKGRlZmluZWQoaW50ZXJ2YWxTdHJpbmcpKSB7XHJcbiAgICAgICAgICAgIGlzbzg2MDFTY3JhdGNoLmlzbzg2MDEgPSBpbnRlcnZhbFN0cmluZztcclxuICAgICAgICAgICAgaW50ZXJ2YWwgPSBUaW1lSW50ZXJ2YWwuZnJvbUlzbzg2MDEoaXNvODYwMVNjcmF0Y2gpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIG1vZGVsID0gZW50aXR5Lm1vZGVsO1xyXG4gICAgICAgIGlmICghZGVmaW5lZChtb2RlbCkpIHtcclxuICAgICAgICAgICAgZW50aXR5Lm1vZGVsID0gbW9kZWwgPSBuZXcgTW9kZWxHcmFwaGljcygpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJvY2Vzc1BhY2tldERhdGEoQm9vbGVhbiwgbW9kZWwsICdzaG93JywgbW9kZWxEYXRhLnNob3csIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKFVyaSwgbW9kZWwsICd1cmknLCBtb2RlbERhdGEuZ2x0ZiwgaW50ZXJ2YWwsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICAgICAgcHJvY2Vzc1BhY2tldERhdGEoTnVtYmVyLCBtb2RlbCwgJ3NjYWxlJywgbW9kZWxEYXRhLnNjYWxlLCBpbnRlcnZhbCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgICAgICBwcm9jZXNzUGFja2V0RGF0YShOdW1iZXIsIG1vZGVsLCAnbWluaW11bVBpeGVsU2l6ZScsIG1vZGVsRGF0YS5taW5pbXVtUGl4ZWxTaXplLCBpbnRlcnZhbCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgICAgICBwcm9jZXNzUGFja2V0RGF0YShOdW1iZXIsIG1vZGVsLCAnbWF4aW11bVNjYWxlJywgbW9kZWxEYXRhLm1heGltdW1TY2FsZSwgaW50ZXJ2YWwsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICAgICAgcHJvY2Vzc1BhY2tldERhdGEoQm9vbGVhbiwgbW9kZWwsICdpbmNyZW1lbnRhbGx5TG9hZFRleHR1cmVzJywgbW9kZWxEYXRhLmluY3JlbWVudGFsbHlMb2FkVGV4dHVyZXMsIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKEJvb2xlYW4sIG1vZGVsLCAncnVuQW5pbWF0aW9ucycsIG1vZGVsRGF0YS5ydW5BbmltYXRpb25zLCBpbnRlcnZhbCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgICAgICBwcm9jZXNzUGFja2V0RGF0YShCb29sZWFuLCBtb2RlbCwgJ2NsYW1wQW5pbWF0aW9ucycsIG1vZGVsRGF0YS5jbGFtcEFuaW1hdGlvbnMsIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKFNoYWRvd01vZGUsIG1vZGVsLCAnc2hhZG93cycsIG1vZGVsRGF0YS5zaGFkb3dzLCBpbnRlcnZhbCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgICAgICBwcm9jZXNzUGFja2V0RGF0YShIZWlnaHRSZWZlcmVuY2UsIG1vZGVsLCAnaGVpZ2h0UmVmZXJlbmNlJywgbW9kZWxEYXRhLmhlaWdodFJlZmVyZW5jZSwgaW50ZXJ2YWwsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICAgICAgcHJvY2Vzc1BhY2tldERhdGEoQ29sb3IsIG1vZGVsLCAnc2lsaG91ZXR0ZUNvbG9yJywgbW9kZWxEYXRhLnNpbGhvdWV0dGVDb2xvciwgaW50ZXJ2YWwsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICAgICAgcHJvY2Vzc1BhY2tldERhdGEoTnVtYmVyLCBtb2RlbCwgJ3NpbGhvdWV0dGVTaXplJywgbW9kZWxEYXRhLnNpbGhvdWV0dGVTaXplLCBpbnRlcnZhbCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgICAgICBwcm9jZXNzUGFja2V0RGF0YShDb2xvciwgbW9kZWwsICdjb2xvcicsIG1vZGVsRGF0YS5jb2xvciwgaW50ZXJ2YWwsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICAgICAgcHJvY2Vzc1BhY2tldERhdGEoQ29sb3JCbGVuZE1vZGUsIG1vZGVsLCAnY29sb3JCbGVuZE1vZGUnLCBtb2RlbERhdGEuY29sb3JCbGVuZE1vZGUsIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKE51bWJlciwgbW9kZWwsICdjb2xvckJsZW5kQW1vdW50JywgbW9kZWxEYXRhLmNvbG9yQmxlbmRBbW91bnQsIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKERpc3RhbmNlRGlzcGxheUNvbmRpdGlvbiwgbW9kZWwsICdkaXN0YW5jZURpc3BsYXlDb25kaXRpb24nLCBtb2RlbERhdGEuZGlzdGFuY2VEaXNwbGF5Q29uZGl0aW9uLCBpbnRlcnZhbCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuXHJcbiAgICAgICAgdmFyIG5vZGVUcmFuc2Zvcm1hdGlvbnNEYXRhID0gbW9kZWxEYXRhLm5vZGVUcmFuc2Zvcm1hdGlvbnM7XHJcbiAgICAgICAgaWYgKGRlZmluZWQobm9kZVRyYW5zZm9ybWF0aW9uc0RhdGEpKSB7XHJcbiAgICAgICAgICAgIGlmIChpc0FycmF5KG5vZGVUcmFuc2Zvcm1hdGlvbnNEYXRhKSkge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG5vZGVUcmFuc2Zvcm1hdGlvbnNEYXRhLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc05vZGVUcmFuc2Zvcm1hdGlvbnMobW9kZWwsIG5vZGVUcmFuc2Zvcm1hdGlvbnNEYXRhW2ldLCBpbnRlcnZhbCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHByb2Nlc3NOb2RlVHJhbnNmb3JtYXRpb25zKG1vZGVsLCBub2RlVHJhbnNmb3JtYXRpb25zRGF0YSwgaW50ZXJ2YWwsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcHJvY2Vzc05vZGVUcmFuc2Zvcm1hdGlvbnMobW9kZWwsIG5vZGVUcmFuc2Zvcm1hdGlvbnNEYXRhLCBjb25zdHJhaW5lZEludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pIHtcclxuICAgICAgICB2YXIgY29tYmluZWRJbnRlcnZhbDtcclxuICAgICAgICB2YXIgcGFja2V0SW50ZXJ2YWwgPSBub2RlVHJhbnNmb3JtYXRpb25zRGF0YS5pbnRlcnZhbDtcclxuICAgICAgICBpZiAoZGVmaW5lZChwYWNrZXRJbnRlcnZhbCkpIHtcclxuICAgICAgICAgICAgaXNvODYwMVNjcmF0Y2guaXNvODYwMSA9IHBhY2tldEludGVydmFsO1xyXG4gICAgICAgICAgICBjb21iaW5lZEludGVydmFsID0gVGltZUludGVydmFsLmZyb21Jc284NjAxKGlzbzg2MDFTY3JhdGNoKTtcclxuICAgICAgICAgICAgaWYgKGRlZmluZWQoY29uc3RyYWluZWRJbnRlcnZhbCkpIHtcclxuICAgICAgICAgICAgICAgIGNvbWJpbmVkSW50ZXJ2YWwgPSBUaW1lSW50ZXJ2YWwuaW50ZXJzZWN0KGNvbWJpbmVkSW50ZXJ2YWwsIGNvbnN0cmFpbmVkSW50ZXJ2YWwsIHNjcmF0Y2hUaW1lSW50ZXJ2YWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChkZWZpbmVkKGNvbnN0cmFpbmVkSW50ZXJ2YWwpKSB7XHJcbiAgICAgICAgICAgIGNvbWJpbmVkSW50ZXJ2YWwgPSBjb25zdHJhaW5lZEludGVydmFsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIG5vZGVUcmFuc2Zvcm1hdGlvbnMgPSBtb2RlbC5ub2RlVHJhbnNmb3JtYXRpb25zO1xyXG4gICAgICAgIHZhciBub2RlTmFtZXMgPSBPYmplY3Qua2V5cyhub2RlVHJhbnNmb3JtYXRpb25zRGF0YSk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG5vZGVOYW1lcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xyXG4gICAgICAgICAgICB2YXIgbm9kZU5hbWUgPSBub2RlTmFtZXNbaV07XHJcblxyXG4gICAgICAgICAgICBpZiAobm9kZU5hbWUgPT09ICdpbnRlcnZhbCcpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgbm9kZVRyYW5zZm9ybWF0aW9uRGF0YSA9IG5vZGVUcmFuc2Zvcm1hdGlvbnNEYXRhW25vZGVOYW1lXTtcclxuXHJcbiAgICAgICAgICAgIGlmICghZGVmaW5lZChub2RlVHJhbnNmb3JtYXRpb25EYXRhKSkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICghZGVmaW5lZChub2RlVHJhbnNmb3JtYXRpb25zKSkge1xyXG4gICAgICAgICAgICAgICAgbW9kZWwubm9kZVRyYW5zZm9ybWF0aW9ucyA9IG5vZGVUcmFuc2Zvcm1hdGlvbnMgPSBuZXcgUHJvcGVydHlCYWcoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCFub2RlVHJhbnNmb3JtYXRpb25zLmhhc1Byb3BlcnR5KG5vZGVOYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgbm9kZVRyYW5zZm9ybWF0aW9ucy5hZGRQcm9wZXJ0eShub2RlTmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBub2RlVHJhbnNmb3JtYXRpb24gPSBub2RlVHJhbnNmb3JtYXRpb25zW25vZGVOYW1lXTtcclxuICAgICAgICAgICAgaWYgKCFkZWZpbmVkKG5vZGVUcmFuc2Zvcm1hdGlvbikpIHtcclxuICAgICAgICAgICAgICAgIG5vZGVUcmFuc2Zvcm1hdGlvbnNbbm9kZU5hbWVdID0gbm9kZVRyYW5zZm9ybWF0aW9uID0gbmV3IE5vZGVUcmFuc2Zvcm1hdGlvblByb3BlcnR5KCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKENhcnRlc2lhbjMsIG5vZGVUcmFuc2Zvcm1hdGlvbiwgJ3RyYW5zbGF0aW9uJywgbm9kZVRyYW5zZm9ybWF0aW9uRGF0YS50cmFuc2xhdGlvbiwgY29tYmluZWRJbnRlcnZhbCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgICAgICAgICAgcHJvY2Vzc1BhY2tldERhdGEoUXVhdGVybmlvbiwgbm9kZVRyYW5zZm9ybWF0aW9uLCAncm90YXRpb24nLCBub2RlVHJhbnNmb3JtYXRpb25EYXRhLnJvdGF0aW9uLCBjb21iaW5lZEludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgICAgICBwcm9jZXNzUGFja2V0RGF0YShDYXJ0ZXNpYW4zLCBub2RlVHJhbnNmb3JtYXRpb24sICdzY2FsZScsIG5vZGVUcmFuc2Zvcm1hdGlvbkRhdGEuc2NhbGUsIGNvbWJpbmVkSW50ZXJ2YWwsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHByb2Nlc3NQYXRoKGVudGl0eSwgcGFja2V0LCBlbnRpdHlDb2xsZWN0aW9uLCBzb3VyY2VVcmkpIHtcclxuICAgICAgICB2YXIgcGF0aERhdGEgPSBwYWNrZXQucGF0aDtcclxuICAgICAgICBpZiAoIWRlZmluZWQocGF0aERhdGEpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBpbnRlcnZhbDtcclxuICAgICAgICB2YXIgaW50ZXJ2YWxTdHJpbmcgPSBwYXRoRGF0YS5pbnRlcnZhbDtcclxuICAgICAgICBpZiAoZGVmaW5lZChpbnRlcnZhbFN0cmluZykpIHtcclxuICAgICAgICAgICAgaXNvODYwMVNjcmF0Y2guaXNvODYwMSA9IGludGVydmFsU3RyaW5nO1xyXG4gICAgICAgICAgICBpbnRlcnZhbCA9IFRpbWVJbnRlcnZhbC5mcm9tSXNvODYwMShpc284NjAxU2NyYXRjaCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgcGF0aCA9IGVudGl0eS5wYXRoO1xyXG4gICAgICAgIGlmICghZGVmaW5lZChwYXRoKSkge1xyXG4gICAgICAgICAgICBlbnRpdHkucGF0aCA9IHBhdGggPSBuZXcgUGF0aEdyYXBoaWNzKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcm9jZXNzUGFja2V0RGF0YShCb29sZWFuLCBwYXRoLCAnc2hvdycsIHBhdGhEYXRhLnNob3csIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKE51bWJlciwgcGF0aCwgJ3dpZHRoJywgcGF0aERhdGEud2lkdGgsIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKE51bWJlciwgcGF0aCwgJ3Jlc29sdXRpb24nLCBwYXRoRGF0YS5yZXNvbHV0aW9uLCBpbnRlcnZhbCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgICAgICBwcm9jZXNzUGFja2V0RGF0YShOdW1iZXIsIHBhdGgsICdsZWFkVGltZScsIHBhdGhEYXRhLmxlYWRUaW1lLCBpbnRlcnZhbCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgICAgICBwcm9jZXNzUGFja2V0RGF0YShOdW1iZXIsIHBhdGgsICd0cmFpbFRpbWUnLCBwYXRoRGF0YS50cmFpbFRpbWUsIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NNYXRlcmlhbFBhY2tldERhdGEocGF0aCwgJ21hdGVyaWFsJywgcGF0aERhdGEubWF0ZXJpYWwsIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKERpc3RhbmNlRGlzcGxheUNvbmRpdGlvbiwgcGF0aCwgJ2Rpc3RhbmNlRGlzcGxheUNvbmRpdGlvbicsIHBhdGhEYXRhLmRpc3RhbmNlRGlzcGxheUNvbmRpdGlvbiwgaW50ZXJ2YWwsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcHJvY2Vzc1BvaW50KGVudGl0eSwgcGFja2V0LCBlbnRpdHlDb2xsZWN0aW9uLCBzb3VyY2VVcmkpIHtcclxuICAgICAgICB2YXIgcG9pbnREYXRhID0gcGFja2V0LnBvaW50O1xyXG4gICAgICAgIGlmICghZGVmaW5lZChwb2ludERhdGEpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBpbnRlcnZhbDtcclxuICAgICAgICB2YXIgaW50ZXJ2YWxTdHJpbmcgPSBwb2ludERhdGEuaW50ZXJ2YWw7XHJcbiAgICAgICAgaWYgKGRlZmluZWQoaW50ZXJ2YWxTdHJpbmcpKSB7XHJcbiAgICAgICAgICAgIGlzbzg2MDFTY3JhdGNoLmlzbzg2MDEgPSBpbnRlcnZhbFN0cmluZztcclxuICAgICAgICAgICAgaW50ZXJ2YWwgPSBUaW1lSW50ZXJ2YWwuZnJvbUlzbzg2MDEoaXNvODYwMVNjcmF0Y2gpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHBvaW50ID0gZW50aXR5LnBvaW50O1xyXG4gICAgICAgIGlmICghZGVmaW5lZChwb2ludCkpIHtcclxuICAgICAgICAgICAgZW50aXR5LnBvaW50ID0gcG9pbnQgPSBuZXcgUG9pbnRHcmFwaGljcygpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJvY2Vzc1BhY2tldERhdGEoQm9vbGVhbiwgcG9pbnQsICdzaG93JywgcG9pbnREYXRhLnNob3csIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKE51bWJlciwgcG9pbnQsICdwaXhlbFNpemUnLCBwb2ludERhdGEucGl4ZWxTaXplLCBpbnRlcnZhbCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgICAgICBwcm9jZXNzUGFja2V0RGF0YShIZWlnaHRSZWZlcmVuY2UsIHBvaW50LCAnaGVpZ2h0UmVmZXJlbmNlJywgcG9pbnREYXRhLmhlaWdodFJlZmVyZW5jZSwgaW50ZXJ2YWwsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICAgICAgcHJvY2Vzc1BhY2tldERhdGEoQ29sb3IsIHBvaW50LCAnY29sb3InLCBwb2ludERhdGEuY29sb3IsIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKENvbG9yLCBwb2ludCwgJ291dGxpbmVDb2xvcicsIHBvaW50RGF0YS5vdXRsaW5lQ29sb3IsIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKE51bWJlciwgcG9pbnQsICdvdXRsaW5lV2lkdGgnLCBwb2ludERhdGEub3V0bGluZVdpZHRoLCBpbnRlcnZhbCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgICAgICBwcm9jZXNzUGFja2V0RGF0YShOZWFyRmFyU2NhbGFyLCBwb2ludCwgJ3NjYWxlQnlEaXN0YW5jZScsIHBvaW50RGF0YS5zY2FsZUJ5RGlzdGFuY2UsIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKE5lYXJGYXJTY2FsYXIsIHBvaW50LCAndHJhbnNsdWNlbmN5QnlEaXN0YW5jZScsIHBvaW50RGF0YS50cmFuc2x1Y2VuY3lCeURpc3RhbmNlLCBpbnRlcnZhbCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgICAgICBwcm9jZXNzUGFja2V0RGF0YShEaXN0YW5jZURpc3BsYXlDb25kaXRpb24sIHBvaW50LCAnZGlzdGFuY2VEaXNwbGF5Q29uZGl0aW9uJywgcG9pbnREYXRhLmRpc3RhbmNlRGlzcGxheUNvbmRpdGlvbiwgaW50ZXJ2YWwsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICAgICAgcHJvY2Vzc1BhY2tldERhdGEoTnVtYmVyLCBwb2ludCwgJ2Rpc2FibGVEZXB0aFRlc3REaXN0YW5jZScsIHBvaW50RGF0YS5kaXNhYmxlRGVwdGhUZXN0RGlzdGFuY2UsIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHByb2Nlc3NQb2x5Z29uKGVudGl0eSwgcGFja2V0LCBlbnRpdHlDb2xsZWN0aW9uLCBzb3VyY2VVcmkpIHtcclxuICAgICAgICB2YXIgcG9seWdvbkRhdGEgPSBwYWNrZXQucG9seWdvbjtcclxuICAgICAgICBpZiAoIWRlZmluZWQocG9seWdvbkRhdGEpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBpbnRlcnZhbDtcclxuICAgICAgICB2YXIgaW50ZXJ2YWxTdHJpbmcgPSBwb2x5Z29uRGF0YS5pbnRlcnZhbDtcclxuICAgICAgICBpZiAoZGVmaW5lZChpbnRlcnZhbFN0cmluZykpIHtcclxuICAgICAgICAgICAgaXNvODYwMVNjcmF0Y2guaXNvODYwMSA9IGludGVydmFsU3RyaW5nO1xyXG4gICAgICAgICAgICBpbnRlcnZhbCA9IFRpbWVJbnRlcnZhbC5mcm9tSXNvODYwMShpc284NjAxU2NyYXRjaCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgcG9seWdvbiA9IGVudGl0eS5wb2x5Z29uO1xyXG4gICAgICAgIGlmICghZGVmaW5lZChwb2x5Z29uKSkge1xyXG4gICAgICAgICAgICBlbnRpdHkucG9seWdvbiA9IHBvbHlnb24gPSBuZXcgUG9seWdvbkdyYXBoaWNzKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcm9jZXNzUGFja2V0RGF0YShCb29sZWFuLCBwb2x5Z29uLCAnc2hvdycsIHBvbHlnb25EYXRhLnNob3csIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NQb3NpdGlvbnMocG9seWdvbiwgJ2hpZXJhcmNoeScsIHBvbHlnb25EYXRhLnBvc2l0aW9ucywgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICAgICAgcHJvY2Vzc1BhY2tldERhdGEoTnVtYmVyLCBwb2x5Z29uLCAnaGVpZ2h0JywgcG9seWdvbkRhdGEuaGVpZ2h0LCBpbnRlcnZhbCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgICAgICBwcm9jZXNzUGFja2V0RGF0YShOdW1iZXIsIHBvbHlnb24sICdleHRydWRlZEhlaWdodCcsIHBvbHlnb25EYXRhLmV4dHJ1ZGVkSGVpZ2h0LCBpbnRlcnZhbCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgICAgICBwcm9jZXNzUGFja2V0RGF0YShSb3RhdGlvbiwgcG9seWdvbiwgJ3N0Um90YXRpb24nLCBwb2x5Z29uRGF0YS5zdFJvdGF0aW9uLCBpbnRlcnZhbCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgICAgICBwcm9jZXNzUGFja2V0RGF0YShOdW1iZXIsIHBvbHlnb24sICdncmFudWxhcml0eScsIHBvbHlnb25EYXRhLmdyYW51bGFyaXR5LCBpbnRlcnZhbCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgICAgICBwcm9jZXNzUGFja2V0RGF0YShCb29sZWFuLCBwb2x5Z29uLCAnZmlsbCcsIHBvbHlnb25EYXRhLmZpbGwsIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NNYXRlcmlhbFBhY2tldERhdGEocG9seWdvbiwgJ21hdGVyaWFsJywgcG9seWdvbkRhdGEubWF0ZXJpYWwsIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKEJvb2xlYW4sIHBvbHlnb24sICdvdXRsaW5lJywgcG9seWdvbkRhdGEub3V0bGluZSwgaW50ZXJ2YWwsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICAgICAgcHJvY2Vzc1BhY2tldERhdGEoQ29sb3IsIHBvbHlnb24sICdvdXRsaW5lQ29sb3InLCBwb2x5Z29uRGF0YS5vdXRsaW5lQ29sb3IsIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKE51bWJlciwgcG9seWdvbiwgJ291dGxpbmVXaWR0aCcsIHBvbHlnb25EYXRhLm91dGxpbmVXaWR0aCwgaW50ZXJ2YWwsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICAgICAgcHJvY2Vzc1BhY2tldERhdGEoQm9vbGVhbiwgcG9seWdvbiwgJ3BlclBvc2l0aW9uSGVpZ2h0JywgcG9seWdvbkRhdGEucGVyUG9zaXRpb25IZWlnaHQsIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKEJvb2xlYW4sIHBvbHlnb24sICdjbG9zZVRvcCcsIHBvbHlnb25EYXRhLmNsb3NlVG9wLCBpbnRlcnZhbCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgICAgICBwcm9jZXNzUGFja2V0RGF0YShCb29sZWFuLCBwb2x5Z29uLCAnY2xvc2VCb3R0b20nLCBwb2x5Z29uRGF0YS5jbG9zZUJvdHRvbSwgaW50ZXJ2YWwsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICAgICAgcHJvY2Vzc1BhY2tldERhdGEoU2hhZG93TW9kZSwgcG9seWdvbiwgJ3NoYWRvd3MnLCBwb2x5Z29uRGF0YS5zaGFkb3dzLCBpbnRlcnZhbCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgICAgICBwcm9jZXNzUGFja2V0RGF0YShEaXN0YW5jZURpc3BsYXlDb25kaXRpb24sIHBvbHlnb24sICdkaXN0YW5jZURpc3BsYXlDb25kaXRpb24nLCBwb2x5Z29uRGF0YS5kaXN0YW5jZURpc3BsYXlDb25kaXRpb24sIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKE51bWJlciwgcG9seWdvbiwgJ3pJbmRleCcsIHBvbHlnb25EYXRhLnpJbmRleCwgaW50ZXJ2YWwsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcHJvY2Vzc1BvbHlsaW5lKGVudGl0eSwgcGFja2V0LCBlbnRpdHlDb2xsZWN0aW9uLCBzb3VyY2VVcmkpIHtcclxuICAgICAgICB2YXIgcG9seWxpbmVEYXRhID0gcGFja2V0LnBvbHlsaW5lO1xyXG4gICAgICAgIGlmICghZGVmaW5lZChwb2x5bGluZURhdGEpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBpbnRlcnZhbDtcclxuICAgICAgICB2YXIgaW50ZXJ2YWxTdHJpbmcgPSBwb2x5bGluZURhdGEuaW50ZXJ2YWw7XHJcbiAgICAgICAgaWYgKGRlZmluZWQoaW50ZXJ2YWxTdHJpbmcpKSB7XHJcbiAgICAgICAgICAgIGlzbzg2MDFTY3JhdGNoLmlzbzg2MDEgPSBpbnRlcnZhbFN0cmluZztcclxuICAgICAgICAgICAgaW50ZXJ2YWwgPSBUaW1lSW50ZXJ2YWwuZnJvbUlzbzg2MDEoaXNvODYwMVNjcmF0Y2gpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHBvbHlsaW5lID0gZW50aXR5LnBvbHlsaW5lO1xyXG4gICAgICAgIGlmICghZGVmaW5lZChwb2x5bGluZSkpIHtcclxuICAgICAgICAgICAgZW50aXR5LnBvbHlsaW5lID0gcG9seWxpbmUgPSBuZXcgUG9seWxpbmVHcmFwaGljcygpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJvY2Vzc1BhY2tldERhdGEoQm9vbGVhbiwgcG9seWxpbmUsICdzaG93JywgcG9seWxpbmVEYXRhLnNob3csIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NQb3NpdGlvbnMocG9seWxpbmUsICdwb3NpdGlvbnMnLCBwb2x5bGluZURhdGEucG9zaXRpb25zLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgICAgICBwcm9jZXNzUGFja2V0RGF0YShOdW1iZXIsIHBvbHlsaW5lLCAnd2lkdGgnLCBwb2x5bGluZURhdGEud2lkdGgsIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKE51bWJlciwgcG9seWxpbmUsICdncmFudWxhcml0eScsIHBvbHlsaW5lRGF0YS5ncmFudWxhcml0eSwgaW50ZXJ2YWwsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICAgICAgcHJvY2Vzc01hdGVyaWFsUGFja2V0RGF0YShwb2x5bGluZSwgJ21hdGVyaWFsJywgcG9seWxpbmVEYXRhLm1hdGVyaWFsLCBpbnRlcnZhbCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgICAgICBwcm9jZXNzTWF0ZXJpYWxQYWNrZXREYXRhKHBvbHlsaW5lLCAnZGVwdGhGYWlsTWF0ZXJpYWwnLCBwb2x5bGluZURhdGEuZGVwdGhGYWlsTWF0ZXJpYWwsIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKEJvb2xlYW4sIHBvbHlsaW5lLCAnZm9sbG93U3VyZmFjZScsIHBvbHlsaW5lRGF0YS5mb2xsb3dTdXJmYWNlLCBpbnRlcnZhbCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgICAgICBwcm9jZXNzUGFja2V0RGF0YShCb29sZWFuLCBwb2x5bGluZSwgJ2NsYW1wVG9Hcm91bmQnLCBwb2x5bGluZURhdGEuY2xhbXBUb0dyb3VuZCwgaW50ZXJ2YWwsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICAgICAgcHJvY2Vzc1BhY2tldERhdGEoU2hhZG93TW9kZSwgcG9seWxpbmUsICdzaGFkb3dzJywgcG9seWxpbmVEYXRhLnNoYWRvd3MsIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKERpc3RhbmNlRGlzcGxheUNvbmRpdGlvbiwgcG9seWxpbmUsICdkaXN0YW5jZURpc3BsYXlDb25kaXRpb24nLCBwb2x5bGluZURhdGEuZGlzdGFuY2VEaXNwbGF5Q29uZGl0aW9uLCBpbnRlcnZhbCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgICAgICBwcm9jZXNzUGFja2V0RGF0YShOdW1iZXIsIHBvbHlsaW5lLCAnekluZGV4JywgcG9seWxpbmVEYXRhLnpJbmRleCwgaW50ZXJ2YWwsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcHJvY2Vzc1JlY3RhbmdsZShlbnRpdHksIHBhY2tldCwgZW50aXR5Q29sbGVjdGlvbiwgc291cmNlVXJpKSB7XHJcbiAgICAgICAgdmFyIHJlY3RhbmdsZURhdGEgPSBwYWNrZXQucmVjdGFuZ2xlO1xyXG4gICAgICAgIGlmICghZGVmaW5lZChyZWN0YW5nbGVEYXRhKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgaW50ZXJ2YWw7XHJcbiAgICAgICAgdmFyIGludGVydmFsU3RyaW5nID0gcmVjdGFuZ2xlRGF0YS5pbnRlcnZhbDtcclxuICAgICAgICBpZiAoZGVmaW5lZChpbnRlcnZhbFN0cmluZykpIHtcclxuICAgICAgICAgICAgaXNvODYwMVNjcmF0Y2guaXNvODYwMSA9IGludGVydmFsU3RyaW5nO1xyXG4gICAgICAgICAgICBpbnRlcnZhbCA9IFRpbWVJbnRlcnZhbC5mcm9tSXNvODYwMShpc284NjAxU2NyYXRjaCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgcmVjdGFuZ2xlID0gZW50aXR5LnJlY3RhbmdsZTtcclxuICAgICAgICBpZiAoIWRlZmluZWQocmVjdGFuZ2xlKSkge1xyXG4gICAgICAgICAgICBlbnRpdHkucmVjdGFuZ2xlID0gcmVjdGFuZ2xlID0gbmV3IFJlY3RhbmdsZUdyYXBoaWNzKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcm9jZXNzUGFja2V0RGF0YShCb29sZWFuLCByZWN0YW5nbGUsICdzaG93JywgcmVjdGFuZ2xlRGF0YS5zaG93LCBpbnRlcnZhbCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgICAgICBwcm9jZXNzUGFja2V0RGF0YShSZWN0YW5nbGUsIHJlY3RhbmdsZSwgJ2Nvb3JkaW5hdGVzJywgcmVjdGFuZ2xlRGF0YS5jb29yZGluYXRlcywgaW50ZXJ2YWwsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICAgICAgcHJvY2Vzc1BhY2tldERhdGEoTnVtYmVyLCByZWN0YW5nbGUsICdoZWlnaHQnLCByZWN0YW5nbGVEYXRhLmhlaWdodCwgaW50ZXJ2YWwsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICAgICAgcHJvY2Vzc1BhY2tldERhdGEoTnVtYmVyLCByZWN0YW5nbGUsICdleHRydWRlZEhlaWdodCcsIHJlY3RhbmdsZURhdGEuZXh0cnVkZWRIZWlnaHQsIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKFJvdGF0aW9uLCByZWN0YW5nbGUsICdyb3RhdGlvbicsIHJlY3RhbmdsZURhdGEucm90YXRpb24sIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKFJvdGF0aW9uLCByZWN0YW5nbGUsICdzdFJvdGF0aW9uJywgcmVjdGFuZ2xlRGF0YS5zdFJvdGF0aW9uLCBpbnRlcnZhbCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgICAgICBwcm9jZXNzUGFja2V0RGF0YShOdW1iZXIsIHJlY3RhbmdsZSwgJ2dyYW51bGFyaXR5JywgcmVjdGFuZ2xlRGF0YS5ncmFudWxhcml0eSwgaW50ZXJ2YWwsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICAgICAgcHJvY2Vzc1BhY2tldERhdGEoQm9vbGVhbiwgcmVjdGFuZ2xlLCAnZmlsbCcsIHJlY3RhbmdsZURhdGEuZmlsbCwgaW50ZXJ2YWwsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICAgICAgcHJvY2Vzc01hdGVyaWFsUGFja2V0RGF0YShyZWN0YW5nbGUsICdtYXRlcmlhbCcsIHJlY3RhbmdsZURhdGEubWF0ZXJpYWwsIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKEJvb2xlYW4sIHJlY3RhbmdsZSwgJ291dGxpbmUnLCByZWN0YW5nbGVEYXRhLm91dGxpbmUsIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKENvbG9yLCByZWN0YW5nbGUsICdvdXRsaW5lQ29sb3InLCByZWN0YW5nbGVEYXRhLm91dGxpbmVDb2xvciwgaW50ZXJ2YWwsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICAgICAgcHJvY2Vzc1BhY2tldERhdGEoTnVtYmVyLCByZWN0YW5nbGUsICdvdXRsaW5lV2lkdGgnLCByZWN0YW5nbGVEYXRhLm91dGxpbmVXaWR0aCwgaW50ZXJ2YWwsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICAgICAgcHJvY2Vzc1BhY2tldERhdGEoU2hhZG93TW9kZSwgcmVjdGFuZ2xlLCAnc2hhZG93cycsIHJlY3RhbmdsZURhdGEuc2hhZG93cywgaW50ZXJ2YWwsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICAgICAgcHJvY2Vzc1BhY2tldERhdGEoRGlzdGFuY2VEaXNwbGF5Q29uZGl0aW9uLCByZWN0YW5nbGUsICdkaXN0YW5jZURpc3BsYXlDb25kaXRpb24nLCByZWN0YW5nbGVEYXRhLmRpc3RhbmNlRGlzcGxheUNvbmRpdGlvbiwgaW50ZXJ2YWwsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICAgICAgcHJvY2Vzc1BhY2tldERhdGEoTnVtYmVyLCByZWN0YW5nbGUsICd6SW5kZXgnLCByZWN0YW5nbGVEYXRhLnpJbmRleCwgaW50ZXJ2YWwsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcHJvY2Vzc1dhbGwoZW50aXR5LCBwYWNrZXQsIGVudGl0eUNvbGxlY3Rpb24sIHNvdXJjZVVyaSkge1xyXG4gICAgICAgIHZhciB3YWxsRGF0YSA9IHBhY2tldC53YWxsO1xyXG4gICAgICAgIGlmICghZGVmaW5lZCh3YWxsRGF0YSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGludGVydmFsO1xyXG4gICAgICAgIHZhciBpbnRlcnZhbFN0cmluZyA9IHdhbGxEYXRhLmludGVydmFsO1xyXG4gICAgICAgIGlmIChkZWZpbmVkKGludGVydmFsU3RyaW5nKSkge1xyXG4gICAgICAgICAgICBpc284NjAxU2NyYXRjaC5pc284NjAxID0gaW50ZXJ2YWxTdHJpbmc7XHJcbiAgICAgICAgICAgIGludGVydmFsID0gVGltZUludGVydmFsLmZyb21Jc284NjAxKGlzbzg2MDFTY3JhdGNoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciB3YWxsID0gZW50aXR5LndhbGw7XHJcbiAgICAgICAgaWYgKCFkZWZpbmVkKHdhbGwpKSB7XHJcbiAgICAgICAgICAgIGVudGl0eS53YWxsID0gd2FsbCA9IG5ldyBXYWxsR3JhcGhpY3MoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKEJvb2xlYW4sIHdhbGwsICdzaG93Jywgd2FsbERhdGEuc2hvdywgaW50ZXJ2YWwsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICAgICAgcHJvY2Vzc1Bvc2l0aW9ucyh3YWxsLCAncG9zaXRpb25zJywgd2FsbERhdGEucG9zaXRpb25zLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgICAgICBwcm9jZXNzQXJyYXkod2FsbCwgJ21pbmltdW1IZWlnaHRzJywgd2FsbERhdGEubWluaW11bUhlaWdodHMsIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NBcnJheSh3YWxsLCAnbWF4aW11bUhlaWdodHMnLCB3YWxsRGF0YS5tYXhpbXVtSGVpZ2h0cywgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICAgICAgcHJvY2Vzc1BhY2tldERhdGEoTnVtYmVyLCB3YWxsLCAnZ3JhbnVsYXJpdHknLCB3YWxsRGF0YS5ncmFudWxhcml0eSwgaW50ZXJ2YWwsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICAgICAgcHJvY2Vzc1BhY2tldERhdGEoQm9vbGVhbiwgd2FsbCwgJ2ZpbGwnLCB3YWxsRGF0YS5maWxsLCBpbnRlcnZhbCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgICAgICBwcm9jZXNzTWF0ZXJpYWxQYWNrZXREYXRhKHdhbGwsICdtYXRlcmlhbCcsIHdhbGxEYXRhLm1hdGVyaWFsLCBpbnRlcnZhbCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgICAgICBwcm9jZXNzUGFja2V0RGF0YShCb29sZWFuLCB3YWxsLCAnb3V0bGluZScsIHdhbGxEYXRhLm91dGxpbmUsIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKENvbG9yLCB3YWxsLCAnb3V0bGluZUNvbG9yJywgd2FsbERhdGEub3V0bGluZUNvbG9yLCBpbnRlcnZhbCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgICAgICBwcm9jZXNzUGFja2V0RGF0YShOdW1iZXIsIHdhbGwsICdvdXRsaW5lV2lkdGgnLCB3YWxsRGF0YS5vdXRsaW5lV2lkdGgsIGludGVydmFsLCBzb3VyY2VVcmksIGVudGl0eUNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHByb2Nlc3NQYWNrZXREYXRhKFNoYWRvd01vZGUsIHdhbGwsICdzaGFkb3dzJywgd2FsbERhdGEuc2hhZG93cywgaW50ZXJ2YWwsIHNvdXJjZVVyaSwgZW50aXR5Q29sbGVjdGlvbik7XHJcbiAgICAgICAgcHJvY2Vzc1BhY2tldERhdGEoRGlzdGFuY2VEaXNwbGF5Q29uZGl0aW9uLCB3YWxsLCAnZGlzdGFuY2VEaXNwbGF5Q29uZGl0aW9uJywgd2FsbERhdGEuZGlzdGFuY2VEaXNwbGF5Q29uZGl0aW9uLCBpbnRlcnZhbCwgc291cmNlVXJpLCBlbnRpdHlDb2xsZWN0aW9uKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBwcm9jZXNzQ3ptbFBhY2tldChwYWNrZXQsIGVudGl0eUNvbGxlY3Rpb24sIHVwZGF0ZXJGdW5jdGlvbnMsIHNvdXJjZVVyaSwgZGF0YVNvdXJjZSkge1xyXG4gICAgICAgIHZhciBvYmplY3RJZCA9IHBhY2tldC5pZDtcclxuICAgICAgICBpZiAoIWRlZmluZWQob2JqZWN0SWQpKSB7XHJcbiAgICAgICAgICAgIG9iamVjdElkID0gY3JlYXRlR3VpZCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY3VycmVudElkID0gb2JqZWN0SWQ7XHJcblxyXG4gICAgICAgIGlmICghZGVmaW5lZChkYXRhU291cmNlLl92ZXJzaW9uKSAmJiBvYmplY3RJZCAhPT0gJ2RvY3VtZW50Jykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgUnVudGltZUVycm9yKCdUaGUgZmlyc3QgQ1pNTCBwYWNrZXQgaXMgcmVxdWlyZWQgdG8gYmUgdGhlIGRvY3VtZW50IG9iamVjdC4nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChwYWNrZXRbJ2RlbGV0ZSddID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIGVudGl0eUNvbGxlY3Rpb24ucmVtb3ZlQnlJZChvYmplY3RJZCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChvYmplY3RJZCA9PT0gJ2RvY3VtZW50Jykge1xyXG4gICAgICAgICAgICBwcm9jZXNzRG9jdW1lbnQocGFja2V0LCBkYXRhU291cmNlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgZW50aXR5ID0gZW50aXR5Q29sbGVjdGlvbi5nZXRPckNyZWF0ZUVudGl0eShvYmplY3RJZCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgcGFyZW50SWQgPSBwYWNrZXQucGFyZW50O1xyXG4gICAgICAgICAgICBpZiAoZGVmaW5lZChwYXJlbnRJZCkpIHtcclxuICAgICAgICAgICAgICAgIGVudGl0eS5wYXJlbnQgPSBlbnRpdHlDb2xsZWN0aW9uLmdldE9yQ3JlYXRlRW50aXR5KHBhcmVudElkKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHVwZGF0ZXJGdW5jdGlvbnMubGVuZ3RoIC0gMTsgaSA+IC0xOyBpLS0pIHtcclxuICAgICAgICAgICAgICAgIHVwZGF0ZXJGdW5jdGlvbnNbaV0oZW50aXR5LCBwYWNrZXQsIGVudGl0eUNvbGxlY3Rpb24sIHNvdXJjZVVyaSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGN1cnJlbnRJZCA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB1cGRhdGVDbG9jayhkYXRhU291cmNlKSB7XHJcbiAgICAgICAgdmFyIGNsb2NrO1xyXG4gICAgICAgIHZhciBjbG9ja1BhY2tldCA9IGRhdGFTb3VyY2UuX2RvY3VtZW50UGFja2V0LmNsb2NrO1xyXG4gICAgICAgIGlmICghZGVmaW5lZChjbG9ja1BhY2tldCkpIHtcclxuICAgICAgICAgICAgaWYgKCFkZWZpbmVkKGRhdGFTb3VyY2UuX2Nsb2NrKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGF2YWlsYWJpbGl0eSA9IGRhdGFTb3VyY2UuX2VudGl0eUNvbGxlY3Rpb24uY29tcHV0ZUF2YWlsYWJpbGl0eSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFhdmFpbGFiaWxpdHkuc3RhcnQuZXF1YWxzKElzbzg2MDEuTUlOSU1VTV9WQUxVRSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnRUaW1lID0gYXZhaWxhYmlsaXR5LnN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdG9wVGltZSA9IGF2YWlsYWJpbGl0eS5zdG9wO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0b3RhbFNlY29uZHMgPSBKdWxpYW5EYXRlLnNlY29uZHNEaWZmZXJlbmNlKHN0b3BUaW1lLCBzdGFydFRpbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtdWx0aXBsaWVyID0gTWF0aC5yb3VuZCh0b3RhbFNlY29uZHMgLyAxMjAuMCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNsb2NrID0gbmV3IERhdGFTb3VyY2VDbG9jaygpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNsb2NrLnN0YXJ0VGltZSA9IEp1bGlhbkRhdGUuY2xvbmUoc3RhcnRUaW1lKTtcclxuICAgICAgICAgICAgICAgICAgICBjbG9jay5zdG9wVGltZSA9IEp1bGlhbkRhdGUuY2xvbmUoc3RvcFRpbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNsb2NrLmNsb2NrUmFuZ2UgPSBDbG9ja1JhbmdlLkxPT1BfU1RPUDtcclxuICAgICAgICAgICAgICAgICAgICBjbG9jay5tdWx0aXBsaWVyID0gbXVsdGlwbGllcjtcclxuICAgICAgICAgICAgICAgICAgICBjbG9jay5jdXJyZW50VGltZSA9IEp1bGlhbkRhdGUuY2xvbmUoc3RhcnRUaW1lKTtcclxuICAgICAgICAgICAgICAgICAgICBjbG9jay5jbG9ja1N0ZXAgPSBDbG9ja1N0ZXAuU1lTVEVNX0NMT0NLX01VTFRJUExJRVI7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YVNvdXJjZS5fY2xvY2sgPSBjbG9jaztcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZGVmaW5lZChkYXRhU291cmNlLl9jbG9jaykpIHtcclxuICAgICAgICAgICAgY2xvY2sgPSBkYXRhU291cmNlLl9jbG9jay5jbG9uZSgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNsb2NrID0gbmV3IERhdGFTb3VyY2VDbG9jaygpO1xyXG4gICAgICAgICAgICBjbG9jay5zdGFydFRpbWUgPSBJc284NjAxLk1JTklNVU1fVkFMVUUuY2xvbmUoKTtcclxuICAgICAgICAgICAgY2xvY2suc3RvcFRpbWUgPSBJc284NjAxLk1BWElNVU1fVkFMVUUuY2xvbmUoKTtcclxuICAgICAgICAgICAgY2xvY2suY3VycmVudFRpbWUgPSBJc284NjAxLk1JTklNVU1fVkFMVUUuY2xvbmUoKTtcclxuICAgICAgICAgICAgY2xvY2suY2xvY2tSYW5nZSA9IENsb2NrUmFuZ2UuTE9PUF9TVE9QO1xyXG4gICAgICAgICAgICBjbG9jay5jbG9ja1N0ZXAgPSBDbG9ja1N0ZXAuU1lTVEVNX0NMT0NLX01VTFRJUExJRVI7XHJcbiAgICAgICAgICAgIGNsb2NrLm11bHRpcGxpZXIgPSAxLjA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkZWZpbmVkKGNsb2NrUGFja2V0LmludGVydmFsKSkge1xyXG4gICAgICAgICAgICBpc284NjAxU2NyYXRjaC5pc284NjAxID0gY2xvY2tQYWNrZXQuaW50ZXJ2YWw7XHJcbiAgICAgICAgICAgIHZhciBpbnRlcnZhbCA9IFRpbWVJbnRlcnZhbC5mcm9tSXNvODYwMShpc284NjAxU2NyYXRjaCk7XHJcbiAgICAgICAgICAgIGNsb2NrLnN0YXJ0VGltZSA9IGludGVydmFsLnN0YXJ0O1xyXG4gICAgICAgICAgICBjbG9jay5zdG9wVGltZSA9IGludGVydmFsLnN0b3A7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkZWZpbmVkKGNsb2NrUGFja2V0LmN1cnJlbnRUaW1lKSkge1xyXG4gICAgICAgICAgICBjbG9jay5jdXJyZW50VGltZSA9IEp1bGlhbkRhdGUuZnJvbUlzbzg2MDEoY2xvY2tQYWNrZXQuY3VycmVudFRpbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGVmaW5lZChjbG9ja1BhY2tldC5yYW5nZSkpIHtcclxuICAgICAgICAgICAgY2xvY2suY2xvY2tSYW5nZSA9IGRlZmF1bHRWYWx1ZShDbG9ja1JhbmdlW2Nsb2NrUGFja2V0LnJhbmdlXSwgQ2xvY2tSYW5nZS5MT09QX1NUT1ApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGVmaW5lZChjbG9ja1BhY2tldC5zdGVwKSkge1xyXG4gICAgICAgICAgICBjbG9jay5jbG9ja1N0ZXAgPSBkZWZhdWx0VmFsdWUoQ2xvY2tTdGVwW2Nsb2NrUGFja2V0LnN0ZXBdLCBDbG9ja1N0ZXAuU1lTVEVNX0NMT0NLX01VTFRJUExJRVIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGVmaW5lZChjbG9ja1BhY2tldC5tdWx0aXBsaWVyKSkge1xyXG4gICAgICAgICAgICBjbG9jay5tdWx0aXBsaWVyID0gY2xvY2tQYWNrZXQubXVsdGlwbGllcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghY2xvY2suZXF1YWxzKGRhdGFTb3VyY2UuX2Nsb2NrKSkge1xyXG4gICAgICAgICAgICBkYXRhU291cmNlLl9jbG9jayA9IGNsb2NrLmNsb25lKGRhdGFTb3VyY2UuX2Nsb2NrKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbG9hZChkYXRhU291cmNlLCBjem1sLCBvcHRpb25zLCBjbGVhcikge1xyXG4gICAgICAgIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XHJcbiAgICAgICAgaWYgKCFkZWZpbmVkKGN6bWwpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcignY3ptbCBpcyByZXF1aXJlZC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XHJcblxyXG4gICAgICAgIG9wdGlvbnMgPSBkZWZhdWx0VmFsdWUob3B0aW9ucywgZGVmYXVsdFZhbHVlLkVNUFRZX09CSkVDVCk7XHJcblxyXG4gICAgICAgIHZhciBwcm9taXNlID0gY3ptbDtcclxuICAgICAgICB2YXIgc291cmNlVXJpID0gb3B0aW9ucy5zb3VyY2VVcmk7XHJcblxyXG4gICAgICAgIC8vIElmIHRoZSBjem1sIGlzIGEgVVJMXHJcbiAgICAgICAgaWYgKHR5cGVvZiBjem1sID09PSAnc3RyaW5nJyB8fCAoY3ptbCBpbnN0YW5jZW9mIFJlc291cmNlKSkge1xyXG4gICAgICAgICAgICBjem1sID0gUmVzb3VyY2UuY3JlYXRlSWZOZWVkZWQoY3ptbCk7XHJcbiAgICAgICAgICAgIHByb21pc2UgPSBjem1sLmZldGNoSnNvbigpO1xyXG4gICAgICAgICAgICBzb3VyY2VVcmkgPSBkZWZhdWx0VmFsdWUoc291cmNlVXJpLCBjem1sLmNsb25lKCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc291cmNlVXJpID0gUmVzb3VyY2UuY3JlYXRlSWZOZWVkZWQoc291cmNlVXJpKTtcclxuXHJcbiAgICAgICAgRGF0YVNvdXJjZS5zZXRMb2FkaW5nKGRhdGFTb3VyY2UsIHRydWUpO1xyXG5cclxuICAgICAgICByZXR1cm4gd2hlbihwcm9taXNlLCBmdW5jdGlvbihjem1sKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBsb2FkQ3ptbChkYXRhU291cmNlLCBjem1sLCBzb3VyY2VVcmksIGNsZWFyKTtcclxuICAgICAgICB9KS5vdGhlcndpc2UoZnVuY3Rpb24oZXJyb3IpIHtcclxuICAgICAgICAgICAgRGF0YVNvdXJjZS5zZXRMb2FkaW5nKGRhdGFTb3VyY2UsIGZhbHNlKTtcclxuICAgICAgICAgICAgZGF0YVNvdXJjZS5fZXJyb3IucmFpc2VFdmVudChkYXRhU291cmNlLCBlcnJvcik7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycm9yKTtcclxuICAgICAgICAgICAgcmV0dXJuIHdoZW4ucmVqZWN0KGVycm9yKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBsb2FkQ3ptbChkYXRhU291cmNlLCBjem1sLCBzb3VyY2VVcmksIGNsZWFyKSB7XHJcbiAgICAgICAgRGF0YVNvdXJjZS5zZXRMb2FkaW5nKGRhdGFTb3VyY2UsIHRydWUpO1xyXG4gICAgICAgIHZhciBlbnRpdHlDb2xsZWN0aW9uID0gZGF0YVNvdXJjZS5fZW50aXR5Q29sbGVjdGlvbjtcclxuXHJcbiAgICAgICAgaWYgKGNsZWFyKSB7XHJcbiAgICAgICAgICAgIGRhdGFTb3VyY2UuX3ZlcnNpb24gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIGRhdGFTb3VyY2UuX2RvY3VtZW50UGFja2V0ID0gbmV3IERvY3VtZW50UGFja2V0KCk7XHJcbiAgICAgICAgICAgIGVudGl0eUNvbGxlY3Rpb24ucmVtb3ZlQWxsKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBDem1sRGF0YVNvdXJjZS5fcHJvY2Vzc0N6bWwoY3ptbCwgZW50aXR5Q29sbGVjdGlvbiwgc291cmNlVXJpLCB1bmRlZmluZWQsIGRhdGFTb3VyY2UpO1xyXG5cclxuICAgICAgICB2YXIgcmFpc2VDaGFuZ2VkRXZlbnQgPSB1cGRhdGVDbG9jayhkYXRhU291cmNlKTtcclxuXHJcbiAgICAgICAgdmFyIGRvY3VtZW50UGFja2V0ID0gZGF0YVNvdXJjZS5fZG9jdW1lbnRQYWNrZXQ7XHJcbiAgICAgICAgaWYgKGRlZmluZWQoZG9jdW1lbnRQYWNrZXQubmFtZSkgJiYgZGF0YVNvdXJjZS5fbmFtZSAhPT0gZG9jdW1lbnRQYWNrZXQubmFtZSkge1xyXG4gICAgICAgICAgICBkYXRhU291cmNlLl9uYW1lID0gZG9jdW1lbnRQYWNrZXQubmFtZTtcclxuICAgICAgICAgICAgcmFpc2VDaGFuZ2VkRXZlbnQgPSB0cnVlO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoIWRlZmluZWQoZGF0YVNvdXJjZS5fbmFtZSkgJiYgZGVmaW5lZChzb3VyY2VVcmkpKSB7XHJcbiAgICAgICAgICAgIGRhdGFTb3VyY2UuX25hbWUgPSBnZXRGaWxlbmFtZUZyb21Vcmkoc291cmNlVXJpLmdldFVybENvbXBvbmVudCgpKTtcclxuICAgICAgICAgICAgcmFpc2VDaGFuZ2VkRXZlbnQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgRGF0YVNvdXJjZS5zZXRMb2FkaW5nKGRhdGFTb3VyY2UsIGZhbHNlKTtcclxuICAgICAgICBpZiAocmFpc2VDaGFuZ2VkRXZlbnQpIHtcclxuICAgICAgICAgICAgZGF0YVNvdXJjZS5fY2hhbmdlZC5yYWlzZUV2ZW50KGRhdGFTb3VyY2UpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGRhdGFTb3VyY2U7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gRG9jdW1lbnRQYWNrZXQoKSB7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuY2xvY2sgPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIHtAbGluayBEYXRhU291cmNlfSB3aGljaCBwcm9jZXNzZXMge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9BbmFseXRpY2FsR3JhcGhpY3NJbmMvY2VzaXVtL3dpa2kvQ1pNTC1HdWlkZXxDWk1MfS5cclxuICAgICAqIEBhbGlhcyBDem1sRGF0YVNvdXJjZVxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtuYW1lXSBBbiBvcHRpb25hbCBuYW1lIGZvciB0aGUgZGF0YSBzb3VyY2UuICBUaGlzIHZhbHVlIHdpbGwgYmUgb3ZlcndyaXR0ZW4gaWYgYSBsb2FkZWQgZG9jdW1lbnQgY29udGFpbnMgYSBuYW1lLlxyXG4gICAgICpcclxuICAgICAqIEBkZW1vIHtAbGluayBodHRwczovL2Nlc2l1bWpzLm9yZy9DZXNpdW0vQXBwcy9TYW5kY2FzdGxlL2luZGV4Lmh0bWw/c3JjPUNaTUwuaHRtbHxDZXNpdW0gU2FuZGNhc3RsZSBDWk1MIERlbW99XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIEN6bWxEYXRhU291cmNlKG5hbWUpIHtcclxuICAgICAgICB0aGlzLl9uYW1lID0gbmFtZTtcclxuICAgICAgICB0aGlzLl9jaGFuZ2VkID0gbmV3IEV2ZW50KCk7XHJcbiAgICAgICAgdGhpcy5fZXJyb3IgPSBuZXcgRXZlbnQoKTtcclxuICAgICAgICB0aGlzLl9pc0xvYWRpbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9sb2FkaW5nID0gbmV3IEV2ZW50KCk7XHJcbiAgICAgICAgdGhpcy5fY2xvY2sgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5fZG9jdW1lbnRQYWNrZXQgPSBuZXcgRG9jdW1lbnRQYWNrZXQoKTtcclxuICAgICAgICB0aGlzLl92ZXJzaW9uID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuX2VudGl0eUNvbGxlY3Rpb24gPSBuZXcgRW50aXR5Q29sbGVjdGlvbih0aGlzKTtcclxuICAgICAgICB0aGlzLl9lbnRpdHlDbHVzdGVyID0gbmV3IEVudGl0eUNsdXN0ZXIoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBQcm9taXNlIHRvIGEgbmV3IGluc3RhbmNlIGxvYWRlZCB3aXRoIHRoZSBwcm92aWRlZCBDWk1MIGRhdGEuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtSZXNvdXJjZXxTdHJpbmd8T2JqZWN0fSBjem1sIEEgdXJsIG9yIENaTUwgb2JqZWN0IHRvIGJlIHByb2Nlc3NlZC5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxyXG4gICAgICogQHBhcmFtIHtSZXNvdXJjZXxTdHJpbmd9IFtvcHRpb25zLnNvdXJjZVVyaV0gT3ZlcnJpZGVzIHRoZSB1cmwgdG8gdXNlIGZvciByZXNvbHZpbmcgcmVsYXRpdmUgbGlua3MuXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZS48Q3ptbERhdGFTb3VyY2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgbmV3IGluc3RhbmNlIG9uY2UgdGhlIGRhdGEgaXMgcHJvY2Vzc2VkLlxyXG4gICAgICovXHJcbiAgICBDem1sRGF0YVNvdXJjZS5sb2FkID0gZnVuY3Rpb24oY3ptbCwgb3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBuZXcgQ3ptbERhdGFTb3VyY2UoKS5sb2FkKGN6bWwsIG9wdGlvbnMpO1xyXG4gICAgfTtcclxuXHJcbiAgICBkZWZpbmVQcm9wZXJ0aWVzKEN6bWxEYXRhU291cmNlLnByb3RvdHlwZSwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgYSBodW1hbi1yZWFkYWJsZSBuYW1lIGZvciB0aGlzIGluc3RhbmNlLlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBDem1sRGF0YVNvdXJjZS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIG5hbWUgOiB7XHJcbiAgICAgICAgICAgIGdldCA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIGNsb2NrIHNldHRpbmdzIGRlZmluZWQgYnkgdGhlIGxvYWRlZCBDWk1MLiAgSWYgbm8gY2xvY2sgaXMgZXhwbGljaXRseVxyXG4gICAgICAgICAqIGRlZmluZWQgaW4gdGhlIENaTUwsIHRoZSBjb21iaW5lZCBhdmFpbGFiaWxpdHkgb2YgYWxsIG9iamVjdHMgaXMgcmV0dXJuZWQuICBJZlxyXG4gICAgICAgICAqIG9ubHkgc3RhdGljIGRhdGEgZXhpc3RzLCB0aGlzIHZhbHVlIGlzIHVuZGVmaW5lZC5cclxuICAgICAgICAgKiBAbWVtYmVyb2YgQ3ptbERhdGFTb3VyY2UucHJvdG90eXBlXHJcbiAgICAgICAgICogQHR5cGUge0RhdGFTb3VyY2VDbG9ja31cclxuICAgICAgICAgKi9cclxuICAgICAgICBjbG9jayA6IHtcclxuICAgICAgICAgICAgZ2V0IDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2xvY2s7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIGNvbGxlY3Rpb24gb2Yge0BsaW5rIEVudGl0eX0gaW5zdGFuY2VzLlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBDem1sRGF0YVNvdXJjZS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAdHlwZSB7RW50aXR5Q29sbGVjdGlvbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBlbnRpdGllcyA6IHtcclxuICAgICAgICAgICAgZ2V0IDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZW50aXR5Q29sbGVjdGlvbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBhIHZhbHVlIGluZGljYXRpbmcgaWYgdGhlIGRhdGEgc291cmNlIGlzIGN1cnJlbnRseSBsb2FkaW5nIGRhdGEuXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEN6bWxEYXRhU291cmNlLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGlzTG9hZGluZyA6IHtcclxuICAgICAgICAgICAgZ2V0IDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faXNMb2FkaW5nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIGFuIGV2ZW50IHRoYXQgd2lsbCBiZSByYWlzZWQgd2hlbiB0aGUgdW5kZXJseWluZyBkYXRhIGNoYW5nZXMuXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEN6bWxEYXRhU291cmNlLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEB0eXBlIHtFdmVudH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBjaGFuZ2VkRXZlbnQgOiB7XHJcbiAgICAgICAgICAgIGdldCA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NoYW5nZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgYW4gZXZlbnQgdGhhdCB3aWxsIGJlIHJhaXNlZCBpZiBhbiBlcnJvciBpcyBlbmNvdW50ZXJlZCBkdXJpbmcgcHJvY2Vzc2luZy5cclxuICAgICAgICAgKiBAbWVtYmVyb2YgQ3ptbERhdGFTb3VyY2UucHJvdG90eXBlXHJcbiAgICAgICAgICogQHR5cGUge0V2ZW50fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGVycm9yRXZlbnQgOiB7XHJcbiAgICAgICAgICAgIGdldCA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Vycm9yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIGFuIGV2ZW50IHRoYXQgd2lsbCBiZSByYWlzZWQgd2hlbiB0aGUgZGF0YSBzb3VyY2UgZWl0aGVyIHN0YXJ0cyBvciBzdG9wcyBsb2FkaW5nLlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBDem1sRGF0YVNvdXJjZS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAdHlwZSB7RXZlbnR9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgbG9hZGluZ0V2ZW50IDoge1xyXG4gICAgICAgICAgICBnZXQgOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb2FkaW5nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHdoZXRoZXIgb3Igbm90IHRoaXMgZGF0YSBzb3VyY2Ugc2hvdWxkIGJlIGRpc3BsYXllZC5cclxuICAgICAgICAgKiBAbWVtYmVyb2YgQ3ptbERhdGFTb3VyY2UucHJvdG90eXBlXHJcbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2hvdyA6IHtcclxuICAgICAgICAgICAgZ2V0IDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZW50aXR5Q29sbGVjdGlvbi5zaG93O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzZXQgOiBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZW50aXR5Q29sbGVjdGlvbi5zaG93ID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGNsdXN0ZXJpbmcgb3B0aW9ucyBmb3IgdGhpcyBkYXRhIHNvdXJjZS4gVGhpcyBvYmplY3QgY2FuIGJlIHNoYXJlZCBiZXR3ZWVuIG11bHRpcGxlIGRhdGEgc291cmNlcy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBDem1sRGF0YVNvdXJjZS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAdHlwZSB7RW50aXR5Q2x1c3Rlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBjbHVzdGVyaW5nIDoge1xyXG4gICAgICAgICAgICBnZXQgOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9lbnRpdHlDbHVzdGVyO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzZXQgOiBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcclxuICAgICAgICAgICAgICAgIGlmICghZGVmaW5lZCh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoJ3ZhbHVlIG11c3QgYmUgZGVmaW5lZC4nKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZW50aXR5Q2x1c3RlciA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBhcnJheSBvZiBDWk1MIHByb2Nlc3NpbmcgZnVuY3Rpb25zLlxyXG4gICAgICogQG1lbWJlcm9mIEN6bWxEYXRhU291cmNlXHJcbiAgICAgKiBAdHlwZSBBcnJheVxyXG4gICAgICovXHJcbiAgICBDem1sRGF0YVNvdXJjZS51cGRhdGVycyA9IFtcclxuICAgICAgICBwcm9jZXNzQmlsbGJvYXJkLCAvL1xyXG4gICAgICAgIHByb2Nlc3NCb3gsIC8vXHJcbiAgICAgICAgcHJvY2Vzc0NvcnJpZG9yLCAvL1xyXG4gICAgICAgIHByb2Nlc3NDeWxpbmRlciwgLy9cclxuICAgICAgICBwcm9jZXNzRWxsaXBzZSwgLy9cclxuICAgICAgICBwcm9jZXNzRWxsaXBzb2lkLCAvL1xyXG4gICAgICAgIHByb2Nlc3NMYWJlbCwgLy9cclxuICAgICAgICBwcm9jZXNzTW9kZWwsIC8vXHJcbiAgICAgICAgcHJvY2Vzc05hbWUsIC8vXHJcbiAgICAgICAgcHJvY2Vzc0Rlc2NyaXB0aW9uLCAvL1xyXG4gICAgICAgIHByb2Nlc3NQYXRoLCAvL1xyXG4gICAgICAgIHByb2Nlc3NQb2ludCwgLy9cclxuICAgICAgICBwcm9jZXNzUG9seWdvbiwgLy9cclxuICAgICAgICBwcm9jZXNzUG9seWxpbmUsIC8vXHJcbiAgICAgICAgcHJvY2Vzc1Byb3BlcnRpZXMsIC8vXHJcbiAgICAgICAgcHJvY2Vzc1JlY3RhbmdsZSwgLy9cclxuICAgICAgICBwcm9jZXNzUG9zaXRpb24sIC8vXHJcbiAgICAgICAgcHJvY2Vzc1ZpZXdGcm9tLCAvL1xyXG4gICAgICAgIHByb2Nlc3NXYWxsLCAvL1xyXG4gICAgICAgIHByb2Nlc3NPcmllbnRhdGlvbiwgLy9cclxuICAgICAgICBwcm9jZXNzQXZhaWxhYmlsaXR5XTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFByb2Nlc3NlcyB0aGUgcHJvdmlkZWQgdXJsIG9yIENaTUwgb2JqZWN0IHdpdGhvdXQgY2xlYXJpbmcgYW55IGV4aXN0aW5nIGRhdGEuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtSZXNvdXJjZXxTdHJpbmd8T2JqZWN0fSBjem1sIEEgdXJsIG9yIENaTUwgb2JqZWN0IHRvIGJlIHByb2Nlc3NlZC5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnNvdXJjZVVyaV0gT3ZlcnJpZGVzIHRoZSB1cmwgdG8gdXNlIGZvciByZXNvbHZpbmcgcmVsYXRpdmUgbGlua3MuXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZS48Q3ptbERhdGFTb3VyY2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGlzIGluc3RhbmNlcyBvbmNlIHRoZSBkYXRhIGlzIHByb2Nlc3NlZC5cclxuICAgICAqL1xyXG4gICAgQ3ptbERhdGFTb3VyY2UucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbihjem1sLCBvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIGxvYWQodGhpcywgY3ptbCwgb3B0aW9ucywgZmFsc2UpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIExvYWRzIHRoZSBwcm92aWRlZCB1cmwgb3IgQ1pNTCBvYmplY3QsIHJlcGxhY2luZyBhbnkgZXhpc3RpbmcgZGF0YS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1Jlc291cmNlfFN0cmluZ3xPYmplY3R9IGN6bWwgQSB1cmwgb3IgQ1pNTCBvYmplY3QgdG8gYmUgcHJvY2Vzc2VkLlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuc291cmNlVXJpXSBPdmVycmlkZXMgdGhlIHVybCB0byB1c2UgZm9yIHJlc29sdmluZyByZWxhdGl2ZSBsaW5rcy5cclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlLjxDem1sRGF0YVNvdXJjZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoaXMgaW5zdGFuY2VzIG9uY2UgdGhlIGRhdGEgaXMgcHJvY2Vzc2VkLlxyXG4gICAgICovXHJcbiAgICBDem1sRGF0YVNvdXJjZS5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uKGN6bWwsIG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gbG9hZCh0aGlzLCBjem1sLCBvcHRpb25zLCB0cnVlKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGhlbHBlciBmdW5jdGlvbiB1c2VkIGJ5IGN1c3RvbSBDWk1MIHVwZGF0ZXIgZnVuY3Rpb25zXHJcbiAgICAgKiB3aGljaCBjcmVhdGVzIG9yIHVwZGF0ZXMgYSB7QGxpbmsgUHJvcGVydHl9IGZyb20gYSBDWk1MIHBhY2tldC5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHR5cGUgVGhlIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIGZvciB0aGUgcHJvcGVydHkgYmVpbmcgcHJvY2Vzc2VkLlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IG9uIHdoaWNoIHRoZSBwcm9wZXJ0eSB3aWxsIGJlIGFkZGVkIG9yIHVwZGF0ZWQuXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlOYW1lIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSBvbiB0aGUgb2JqZWN0LlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhY2tldERhdGEgVGhlIENaTUwgcGFja2V0IGJlaW5nIHByb2Nlc3NlZC5cclxuICAgICAqIEBwYXJhbSB7VGltZUludGVydmFsfSBpbnRlcnZhbCBBIGNvbnN0cmFpbmluZyBpbnRlcnZhbCBmb3Igd2hpY2ggdGhlIGRhdGEgaXMgdmFsaWQuXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc291cmNlVXJpIFRoZSBvcmlnaW5hdGluZyB1cmkgb2YgdGhlIGRhdGEgYmVpbmcgcHJvY2Vzc2VkLlxyXG4gICAgICogQHBhcmFtIHtFbnRpdHlDb2xsZWN0aW9ufSBlbnRpdHlDb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIGJlaW5nIHByb2Nlc3NzZWQuXHJcbiAgICAgKi9cclxuICAgIEN6bWxEYXRhU291cmNlLnByb2Nlc3NQYWNrZXREYXRhID0gcHJvY2Vzc1BhY2tldERhdGE7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGhlbHBlciBmdW5jdGlvbiB1c2VkIGJ5IGN1c3RvbSBDWk1MIHVwZGF0ZXIgZnVuY3Rpb25zXHJcbiAgICAgKiB3aGljaCBjcmVhdGVzIG9yIHVwZGF0ZXMgYSB7QGxpbmsgUG9zaXRpb25Qcm9wZXJ0eX0gZnJvbSBhIENaTUwgcGFja2V0LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IG9uIHdoaWNoIHRoZSBwcm9wZXJ0eSB3aWxsIGJlIGFkZGVkIG9yIHVwZGF0ZWQuXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlOYW1lIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSBvbiB0aGUgb2JqZWN0LlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhY2tldERhdGEgVGhlIENaTUwgcGFja2V0IGJlaW5nIHByb2Nlc3NlZC5cclxuICAgICAqIEBwYXJhbSB7VGltZUludGVydmFsfSBpbnRlcnZhbCBBIGNvbnN0cmFpbmluZyBpbnRlcnZhbCBmb3Igd2hpY2ggdGhlIGRhdGEgaXMgdmFsaWQuXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc291cmNlVXJpIFRoZSBvcmlnaW5hdGluZyB1cmkgb2YgdGhlIGRhdGEgYmVpbmcgcHJvY2Vzc2VkLlxyXG4gICAgICogQHBhcmFtIHtFbnRpdHlDb2xsZWN0aW9ufSBlbnRpdHlDb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIGJlaW5nIHByb2Nlc3NzZWQuXHJcbiAgICAgKi9cclxuICAgIEN6bWxEYXRhU291cmNlLnByb2Nlc3NQb3NpdGlvblBhY2tldERhdGEgPSBwcm9jZXNzUG9zaXRpb25QYWNrZXREYXRhO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBoZWxwZXIgZnVuY3Rpb24gdXNlZCBieSBjdXN0b20gQ1pNTCB1cGRhdGVyIGZ1bmN0aW9uc1xyXG4gICAgICogd2hpY2ggY3JlYXRlcyBvciB1cGRhdGVzIGEge0BsaW5rIE1hdGVyaWFsUHJvcGVydHl9IGZyb20gYSBDWk1MIHBhY2tldC5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCBvbiB3aGljaCB0aGUgcHJvcGVydHkgd2lsbCBiZSBhZGRlZCBvciB1cGRhdGVkLlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5TmFtZSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgb24gdGhlIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXREYXRhIFRoZSBDWk1MIHBhY2tldCBiZWluZyBwcm9jZXNzZWQuXHJcbiAgICAgKiBAcGFyYW0ge1RpbWVJbnRlcnZhbH0gaW50ZXJ2YWwgQSBjb25zdHJhaW5pbmcgaW50ZXJ2YWwgZm9yIHdoaWNoIHRoZSBkYXRhIGlzIHZhbGlkLlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNvdXJjZVVyaSBUaGUgb3JpZ2luYXRpbmcgdXJpIG9mIHRoZSBkYXRhIGJlaW5nIHByb2Nlc3NlZC5cclxuICAgICAqIEBwYXJhbSB7RW50aXR5Q29sbGVjdGlvbn0gZW50aXR5Q29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiBiZWluZyBwcm9jZXNzc2VkLlxyXG4gICAgICovXHJcbiAgICBDem1sRGF0YVNvdXJjZS5wcm9jZXNzTWF0ZXJpYWxQYWNrZXREYXRhID0gcHJvY2Vzc01hdGVyaWFsUGFja2V0RGF0YTtcclxuXHJcbiAgICBDem1sRGF0YVNvdXJjZS5fcHJvY2Vzc0N6bWwgPSBmdW5jdGlvbihjem1sLCBlbnRpdHlDb2xsZWN0aW9uLCBzb3VyY2VVcmksIHVwZGF0ZXJGdW5jdGlvbnMsIGRhdGFTb3VyY2UpIHtcclxuICAgICAgICB1cGRhdGVyRnVuY3Rpb25zID0gZGVmaW5lZCh1cGRhdGVyRnVuY3Rpb25zKSA/IHVwZGF0ZXJGdW5jdGlvbnMgOiBDem1sRGF0YVNvdXJjZS51cGRhdGVycztcclxuXHJcbiAgICAgICAgaWYgKGlzQXJyYXkoY3ptbCkpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGN6bWwubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHByb2Nlc3NDem1sUGFja2V0KGN6bWxbaV0sIGVudGl0eUNvbGxlY3Rpb24sIHVwZGF0ZXJGdW5jdGlvbnMsIHNvdXJjZVVyaSwgZGF0YVNvdXJjZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBwcm9jZXNzQ3ptbFBhY2tldChjem1sLCBlbnRpdHlDb2xsZWN0aW9uLCB1cGRhdGVyRnVuY3Rpb25zLCBzb3VyY2VVcmksIGRhdGFTb3VyY2UpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIEN6bWxEYXRhU291cmNlO1xyXG59KTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvdGVycmlhanMtY2VzaXVtL1NvdXJjZS9EYXRhU291cmNlcy9Dem1sRGF0YVNvdXJjZS5qc1xuLy8gbW9kdWxlIGlkID0gNTQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImRlZmluZShbXHJcbiAgICAgICAgJy4uL0NvcmUvQXNzb2NpYXRpdmVBcnJheScsXHJcbiAgICAgICAgJy4uL0NvcmUvQm91bmRpbmdSZWN0YW5nbGUnLFxyXG4gICAgICAgICcuLi9Db3JlL0NhcnRlc2lhbjInLFxyXG4gICAgICAgICcuLi9Db3JlL0NhcnRlc2lhbjMnLFxyXG4gICAgICAgICcuLi9Db3JlL0NhcnRvZ3JhcGhpYycsXHJcbiAgICAgICAgJy4uL0NvcmUvQ2xvY2tSYW5nZScsXHJcbiAgICAgICAgJy4uL0NvcmUvQ2xvY2tTdGVwJyxcclxuICAgICAgICAnLi4vQ29yZS9Db2xvcicsXHJcbiAgICAgICAgJy4uL0NvcmUvY3JlYXRlR3VpZCcsXHJcbiAgICAgICAgJy4uL0NvcmUvZGVmYXVsdFZhbHVlJyxcclxuICAgICAgICAnLi4vQ29yZS9kZWZpbmVkJyxcclxuICAgICAgICAnLi4vQ29yZS9kZWZpbmVQcm9wZXJ0aWVzJyxcclxuICAgICAgICAnLi4vQ29yZS9EZXZlbG9wZXJFcnJvcicsXHJcbiAgICAgICAgJy4uL0NvcmUvRWxsaXBzb2lkJyxcclxuICAgICAgICAnLi4vQ29yZS9FdmVudCcsXHJcbiAgICAgICAgJy4uL0NvcmUvZ2V0RXh0ZW5zaW9uRnJvbVVyaScsXHJcbiAgICAgICAgJy4uL0NvcmUvZ2V0RmlsZW5hbWVGcm9tVXJpJyxcclxuICAgICAgICAnLi4vQ29yZS9IZWFkaW5nUGl0Y2hSYW5nZScsXHJcbiAgICAgICAgJy4uL0NvcmUvSGVhZGluZ1BpdGNoUm9sbCcsXHJcbiAgICAgICAgJy4uL0NvcmUvSXNvODYwMScsXHJcbiAgICAgICAgJy4uL0NvcmUvSnVsaWFuRGF0ZScsXHJcbiAgICAgICAgJy4uL0NvcmUvTWF0aCcsXHJcbiAgICAgICAgJy4uL0NvcmUvTmVhckZhclNjYWxhcicsXHJcbiAgICAgICAgJy4uL0NvcmUvb2JqZWN0VG9RdWVyeScsXHJcbiAgICAgICAgJy4uL0NvcmUvb25lVGltZVdhcm5pbmcnLFxyXG4gICAgICAgICcuLi9Db3JlL1BpbkJ1aWxkZXInLFxyXG4gICAgICAgICcuLi9Db3JlL1BvbHlnb25IaWVyYXJjaHknLFxyXG4gICAgICAgICcuLi9Db3JlL3F1ZXJ5VG9PYmplY3QnLFxyXG4gICAgICAgICcuLi9Db3JlL1JlY3RhbmdsZScsXHJcbiAgICAgICAgJy4uL0NvcmUvUmVzb3VyY2UnLFxyXG4gICAgICAgICcuLi9Db3JlL1J1bnRpbWVFcnJvcicsXHJcbiAgICAgICAgJy4uL0NvcmUvVGltZUludGVydmFsJyxcclxuICAgICAgICAnLi4vQ29yZS9UaW1lSW50ZXJ2YWxDb2xsZWN0aW9uJyxcclxuICAgICAgICAnLi4vU2NlbmUvSGVpZ2h0UmVmZXJlbmNlJyxcclxuICAgICAgICAnLi4vU2NlbmUvSG9yaXpvbnRhbE9yaWdpbicsXHJcbiAgICAgICAgJy4uL1NjZW5lL0xhYmVsU3R5bGUnLFxyXG4gICAgICAgICcuLi9TY2VuZS9TY2VuZU1vZGUnLFxyXG4gICAgICAgICcuLi9UaGlyZFBhcnR5L0F1dG9saW5rZXInLFxyXG4gICAgICAgICcuLi9UaGlyZFBhcnR5L1VyaScsXHJcbiAgICAgICAgJy4uL1RoaXJkUGFydHkvd2hlbicsXHJcbiAgICAgICAgJy4uL1RoaXJkUGFydHkvemlwJyxcclxuICAgICAgICAnLi9CaWxsYm9hcmRHcmFwaGljcycsXHJcbiAgICAgICAgJy4vQ29tcG9zaXRlUG9zaXRpb25Qcm9wZXJ0eScsXHJcbiAgICAgICAgJy4vRGF0YVNvdXJjZScsXHJcbiAgICAgICAgJy4vRGF0YVNvdXJjZUNsb2NrJyxcclxuICAgICAgICAnLi9FbnRpdHknLFxyXG4gICAgICAgICcuL0VudGl0eUNsdXN0ZXInLFxyXG4gICAgICAgICcuL0VudGl0eUNvbGxlY3Rpb24nLFxyXG4gICAgICAgICcuL0ttbENhbWVyYScsXHJcbiAgICAgICAgJy4vS21sTG9va0F0JyxcclxuICAgICAgICAnLi9LbWxUb3VyJyxcclxuICAgICAgICAnLi9LbWxUb3VyRmx5VG8nLFxyXG4gICAgICAgICcuL0ttbFRvdXJXYWl0JyxcclxuICAgICAgICAnLi9MYWJlbEdyYXBoaWNzJyxcclxuICAgICAgICAnLi9QYXRoR3JhcGhpY3MnLFxyXG4gICAgICAgICcuL1BvbHlnb25HcmFwaGljcycsXHJcbiAgICAgICAgJy4vUG9seWxpbmVHcmFwaGljcycsXHJcbiAgICAgICAgJy4vUG9zaXRpb25Qcm9wZXJ0eUFycmF5JyxcclxuICAgICAgICAnLi9SZWN0YW5nbGVHcmFwaGljcycsXHJcbiAgICAgICAgJy4vUmVmZXJlbmNlUHJvcGVydHknLFxyXG4gICAgICAgICcuL1NhbXBsZWRQb3NpdGlvblByb3BlcnR5JyxcclxuICAgICAgICAnLi9TY2FsZWRQb3NpdGlvblByb3BlcnR5JyxcclxuICAgICAgICAnLi9UaW1lSW50ZXJ2YWxDb2xsZWN0aW9uUHJvcGVydHknLFxyXG4gICAgICAgICcuL1dhbGxHcmFwaGljcydcclxuICAgIF0sIGZ1bmN0aW9uKFxyXG4gICAgICAgIEFzc29jaWF0aXZlQXJyYXksXHJcbiAgICAgICAgQm91bmRpbmdSZWN0YW5nbGUsXHJcbiAgICAgICAgQ2FydGVzaWFuMixcclxuICAgICAgICBDYXJ0ZXNpYW4zLFxyXG4gICAgICAgIENhcnRvZ3JhcGhpYyxcclxuICAgICAgICBDbG9ja1JhbmdlLFxyXG4gICAgICAgIENsb2NrU3RlcCxcclxuICAgICAgICBDb2xvcixcclxuICAgICAgICBjcmVhdGVHdWlkLFxyXG4gICAgICAgIGRlZmF1bHRWYWx1ZSxcclxuICAgICAgICBkZWZpbmVkLFxyXG4gICAgICAgIGRlZmluZVByb3BlcnRpZXMsXHJcbiAgICAgICAgRGV2ZWxvcGVyRXJyb3IsXHJcbiAgICAgICAgRWxsaXBzb2lkLFxyXG4gICAgICAgIEV2ZW50LFxyXG4gICAgICAgIGdldEV4dGVuc2lvbkZyb21VcmksXHJcbiAgICAgICAgZ2V0RmlsZW5hbWVGcm9tVXJpLFxyXG4gICAgICAgIEhlYWRpbmdQaXRjaFJhbmdlLFxyXG4gICAgICAgIEhlYWRpbmdQaXRjaFJvbGwsXHJcbiAgICAgICAgSXNvODYwMSxcclxuICAgICAgICBKdWxpYW5EYXRlLFxyXG4gICAgICAgIENlc2l1bU1hdGgsXHJcbiAgICAgICAgTmVhckZhclNjYWxhcixcclxuICAgICAgICBvYmplY3RUb1F1ZXJ5LFxyXG4gICAgICAgIG9uZVRpbWVXYXJuaW5nLFxyXG4gICAgICAgIFBpbkJ1aWxkZXIsXHJcbiAgICAgICAgUG9seWdvbkhpZXJhcmNoeSxcclxuICAgICAgICBxdWVyeVRvT2JqZWN0LFxyXG4gICAgICAgIFJlY3RhbmdsZSxcclxuICAgICAgICBSZXNvdXJjZSxcclxuICAgICAgICBSdW50aW1lRXJyb3IsXHJcbiAgICAgICAgVGltZUludGVydmFsLFxyXG4gICAgICAgIFRpbWVJbnRlcnZhbENvbGxlY3Rpb24sXHJcbiAgICAgICAgSGVpZ2h0UmVmZXJlbmNlLFxyXG4gICAgICAgIEhvcml6b250YWxPcmlnaW4sXHJcbiAgICAgICAgTGFiZWxTdHlsZSxcclxuICAgICAgICBTY2VuZU1vZGUsXHJcbiAgICAgICAgQXV0b2xpbmtlcixcclxuICAgICAgICBVcmksXHJcbiAgICAgICAgd2hlbixcclxuICAgICAgICB6aXAsXHJcbiAgICAgICAgQmlsbGJvYXJkR3JhcGhpY3MsXHJcbiAgICAgICAgQ29tcG9zaXRlUG9zaXRpb25Qcm9wZXJ0eSxcclxuICAgICAgICBEYXRhU291cmNlLFxyXG4gICAgICAgIERhdGFTb3VyY2VDbG9jayxcclxuICAgICAgICBFbnRpdHksXHJcbiAgICAgICAgRW50aXR5Q2x1c3RlcixcclxuICAgICAgICBFbnRpdHlDb2xsZWN0aW9uLFxyXG4gICAgICAgIEttbENhbWVyYSxcclxuICAgICAgICBLbWxMb29rQXQsXHJcbiAgICAgICAgS21sVG91cixcclxuICAgICAgICBLbWxUb3VyRmx5VG8sXHJcbiAgICAgICAgS21sVG91cldhaXQsXHJcbiAgICAgICAgTGFiZWxHcmFwaGljcyxcclxuICAgICAgICBQYXRoR3JhcGhpY3MsXHJcbiAgICAgICAgUG9seWdvbkdyYXBoaWNzLFxyXG4gICAgICAgIFBvbHlsaW5lR3JhcGhpY3MsXHJcbiAgICAgICAgUG9zaXRpb25Qcm9wZXJ0eUFycmF5LFxyXG4gICAgICAgIFJlY3RhbmdsZUdyYXBoaWNzLFxyXG4gICAgICAgIFJlZmVyZW5jZVByb3BlcnR5LFxyXG4gICAgICAgIFNhbXBsZWRQb3NpdGlvblByb3BlcnR5LFxyXG4gICAgICAgIFNjYWxlZFBvc2l0aW9uUHJvcGVydHksXHJcbiAgICAgICAgVGltZUludGVydmFsQ29sbGVjdGlvblByb3BlcnR5LFxyXG4gICAgICAgIFdhbGxHcmFwaGljcykge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICAgIC8vIElFIDggZG9lc24ndCBoYXZlIGEgRE9NIHBhcnNlciBhbmQgY2FuJ3QgcnVuIENlc2l1bSBhbnl3YXksIHNvIGp1c3QgYmFpbC5cclxuICAgIGlmICh0eXBlb2YgRE9NUGFyc2VyID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJldHVybiB7fTtcclxuICAgIH1cclxuXHJcbiAgICAvL1RoaXMgaXMgYnkgbm8gbWVhbnMgYW4gZXhoYXVzdGl2ZSBsaXN0IG9mIE1JTUUgdHlwZXMuXHJcbiAgICAvL1RoZSBwdXJwb3NlIG9mIHRoaXMgbGlzdCBpcyB0byBiZSBhYmxlIHRvIGFjY3VyYXRlbHkgaWRlbnRpZnkgY29udGVudCBlbWJlZGRlZFxyXG4gICAgLy9pbiBLTVogZmlsZXMuIEV2ZW50dWFsbHksIHdlIGNhbiBtYWtlIHRoaXMgY29uZmlndXJhYmxlIGJ5IHRoZSBlbmQgdXNlciBzbyB0aGV5IGNhbiBhZGRcclxuICAgIC8vdGhlcmUgb3duIGNvbnRlbnQgdHlwZXMgaWYgdGhleSBoYXZlIEtNWiBmaWxlcyB0aGF0IHJlcXVpcmUgaXQuXHJcbiAgICB2YXIgTWltZVR5cGVzID0ge1xyXG4gICAgICAgIGF2aSA6ICd2aWRlby94LW1zdmlkZW8nLFxyXG4gICAgICAgIGJtcCA6ICdpbWFnZS9ibXAnLFxyXG4gICAgICAgIGJ6MiA6ICdhcHBsaWNhdGlvbi94LWJ6aXAyJyxcclxuICAgICAgICBjaG0gOiAnYXBwbGljYXRpb24vdm5kLm1zLWh0bWxoZWxwJyxcclxuICAgICAgICBjc3MgOiAndGV4dC9jc3MnLFxyXG4gICAgICAgIGNzdiA6ICd0ZXh0L2NzdicsXHJcbiAgICAgICAgZG9jIDogJ2FwcGxpY2F0aW9uL21zd29yZCcsXHJcbiAgICAgICAgZHZpIDogJ2FwcGxpY2F0aW9uL3gtZHZpJyxcclxuICAgICAgICBlcHMgOiAnYXBwbGljYXRpb24vcG9zdHNjcmlwdCcsXHJcbiAgICAgICAgZmx2IDogJ3ZpZGVvL3gtZmx2JyxcclxuICAgICAgICBnaWYgOiAnaW1hZ2UvZ2lmJyxcclxuICAgICAgICBneiA6ICdhcHBsaWNhdGlvbi94LWd6aXAnLFxyXG4gICAgICAgIGh0bSA6ICd0ZXh0L2h0bWwnLFxyXG4gICAgICAgIGh0bWwgOiAndGV4dC9odG1sJyxcclxuICAgICAgICBpY28gOiAnaW1hZ2Uvdm5kLm1pY3Jvc29mdC5pY29uJyxcclxuICAgICAgICBqbmxwIDogJ2FwcGxpY2F0aW9uL3gtamF2YS1qbmxwLWZpbGUnLFxyXG4gICAgICAgIGpwZWcgOiAnaW1hZ2UvanBlZycsXHJcbiAgICAgICAganBnIDogJ2ltYWdlL2pwZWcnLFxyXG4gICAgICAgIG0zdSA6ICdhdWRpby94LW1wZWd1cmwnLFxyXG4gICAgICAgIG00diA6ICd2aWRlby9tcDQnLFxyXG4gICAgICAgIG1hdGhtbCA6ICdhcHBsaWNhdGlvbi9tYXRobWwreG1sJyxcclxuICAgICAgICBtaWQgOiAnYXVkaW8vbWlkaScsXHJcbiAgICAgICAgbWlkaSA6ICdhdWRpby9taWRpJyxcclxuICAgICAgICBtb3YgOiAndmlkZW8vcXVpY2t0aW1lJyxcclxuICAgICAgICBtcDMgOiAnYXVkaW8vbXBlZycsXHJcbiAgICAgICAgbXA0IDogJ3ZpZGVvL21wNCcsXHJcbiAgICAgICAgbXA0diA6ICd2aWRlby9tcDQnLFxyXG4gICAgICAgIG1wZWcgOiAndmlkZW8vbXBlZycsXHJcbiAgICAgICAgbXBnIDogJ3ZpZGVvL21wZWcnLFxyXG4gICAgICAgIG9kcCA6ICdhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LnByZXNlbnRhdGlvbicsXHJcbiAgICAgICAgb2RzIDogJ2FwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQuc3ByZWFkc2hlZXQnLFxyXG4gICAgICAgIG9kdCA6ICdhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LnRleHQnLFxyXG4gICAgICAgIG9nZyA6ICdhcHBsaWNhdGlvbi9vZ2cnLFxyXG4gICAgICAgIHBkZiA6ICdhcHBsaWNhdGlvbi9wZGYnLFxyXG4gICAgICAgIHBuZyA6ICdpbWFnZS9wbmcnLFxyXG4gICAgICAgIHBwcyA6ICdhcHBsaWNhdGlvbi92bmQubXMtcG93ZXJwb2ludCcsXHJcbiAgICAgICAgcHB0IDogJ2FwcGxpY2F0aW9uL3ZuZC5tcy1wb3dlcnBvaW50JyxcclxuICAgICAgICBwcyA6ICdhcHBsaWNhdGlvbi9wb3N0c2NyaXB0JyxcclxuICAgICAgICBxdCA6ICd2aWRlby9xdWlja3RpbWUnLFxyXG4gICAgICAgIHJkZiA6ICdhcHBsaWNhdGlvbi9yZGYreG1sJyxcclxuICAgICAgICByc3MgOiAnYXBwbGljYXRpb24vcnNzK3htbCcsXHJcbiAgICAgICAgcnRmIDogJ2FwcGxpY2F0aW9uL3J0ZicsXHJcbiAgICAgICAgc3ZnIDogJ2ltYWdlL3N2Zyt4bWwnLFxyXG4gICAgICAgIHN3ZiA6ICdhcHBsaWNhdGlvbi94LXNob2Nrd2F2ZS1mbGFzaCcsXHJcbiAgICAgICAgdGV4dCA6ICd0ZXh0L3BsYWluJyxcclxuICAgICAgICB0aWYgOiAnaW1hZ2UvdGlmZicsXHJcbiAgICAgICAgdGlmZiA6ICdpbWFnZS90aWZmJyxcclxuICAgICAgICB0eHQgOiAndGV4dC9wbGFpbicsXHJcbiAgICAgICAgd2F2IDogJ2F1ZGlvL3gtd2F2JyxcclxuICAgICAgICB3bWEgOiAnYXVkaW8veC1tcy13bWEnLFxyXG4gICAgICAgIHdtdiA6ICd2aWRlby94LW1zLXdtdicsXHJcbiAgICAgICAgeG1sIDogJ2FwcGxpY2F0aW9uL3htbCcsXHJcbiAgICAgICAgemlwIDogJ2FwcGxpY2F0aW9uL3ppcCcsXHJcblxyXG4gICAgICAgIGRldGVjdEZyb21GaWxlbmFtZSA6IGZ1bmN0aW9uKGZpbGVuYW1lKSB7XHJcbiAgICAgICAgICAgIHZhciBleHQgPSBmaWxlbmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICBleHQgPSBnZXRFeHRlbnNpb25Gcm9tVXJpKGV4dCk7XHJcbiAgICAgICAgICAgIHJldHVybiBNaW1lVHlwZXNbZXh0XTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XHJcbiAgICB2YXIgYXV0b2xpbmtlciA9IG5ldyBBdXRvbGlua2VyKHtcclxuICAgICAgICBzdHJpcFByZWZpeCA6IGZhbHNlLFxyXG4gICAgICAgIHR3aXR0ZXIgOiBmYWxzZSxcclxuICAgICAgICBlbWFpbCA6IGZhbHNlLFxyXG4gICAgICAgIHJlcGxhY2VGbiA6IGZ1bmN0aW9uKGxpbmtlciwgbWF0Y2gpIHtcclxuICAgICAgICAgICAgaWYgKCFtYXRjaC5wcm90b2NvbFVybE1hdGNoKSB7XHJcbiAgICAgICAgICAgICAgICAvL1ByZXZlbnQgbWF0Y2hpbmcgb2Ygbm9uLWV4cGxpY2l0IHVybHMuXHJcbiAgICAgICAgICAgICAgICAvL2kuZS4gZm9vLmlkIHdvbid0IG1hdGNoIGJ1dCBodHRwOi8vZm9vLmlkIHdpbGxcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHZhciBCSUxMQk9BUkRfU0laRSA9IDMyO1xyXG5cclxuICAgIHZhciBCSUxMQk9BUkRfTkVBUl9ESVNUQU5DRSA9IDI0MTQwMTY7XHJcbiAgICB2YXIgQklMTEJPQVJEX05FQVJfUkFUSU8gPSAxLjA7XHJcbiAgICB2YXIgQklMTEJPQVJEX0ZBUl9ESVNUQU5DRSA9IDEuNjA5M2UrNztcclxuICAgIHZhciBCSUxMQk9BUkRfRkFSX1JBVElPID0gMC4xO1xyXG5cclxuICAgIGZ1bmN0aW9uIGlzWmlwRmlsZShibG9iKSB7XHJcbiAgICAgICAgdmFyIG1hZ2ljQmxvYiA9IGJsb2Iuc2xpY2UoMCwgTWF0aC5taW4oNCwgYmxvYi5zaXplKSk7XHJcbiAgICAgICAgdmFyIGRlZmVycmVkID0gd2hlbi5kZWZlcigpO1xyXG4gICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xyXG4gICAgICAgIHJlYWRlci5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUobmV3IERhdGFWaWV3KHJlYWRlci5yZXN1bHQpLmdldFVpbnQzMigwLCBmYWxzZSkgPT09IDB4NTA0YjAzMDQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJlYWRlci5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QocmVhZGVyLmVycm9yKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIobWFnaWNCbG9iKTtcclxuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByZWFkQmxvYkFzVGV4dChibG9iKSB7XHJcbiAgICAgICAgdmFyIGRlZmVycmVkID0gd2hlbi5kZWZlcigpO1xyXG4gICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xyXG4gICAgICAgIHJlYWRlci5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUocmVhZGVyLnJlc3VsdCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmVhZGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChyZWFkZXIuZXJyb3IpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJlYWRlci5yZWFkQXNUZXh0KGJsb2IpO1xyXG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGluc2VydE5hbWVzcGFjZXModGV4dCkge1xyXG4gICAgICAgIHZhciBuYW1lc3BhY2VNYXAgPSB7XHJcbiAgICAgICAgICAgIHhzaSA6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAxL1hNTFNjaGVtYS1pbnN0YW5jZSdcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciBmaXJzdFBhcnQsIGxhc3RQYXJ0LCByZWcsIGRlY2xhcmF0aW9uO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gbmFtZXNwYWNlTWFwKSB7XHJcbiAgICAgICAgICAgIGlmIChuYW1lc3BhY2VNYXAuaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgcmVnID0gUmVnRXhwKCdbPCBdJyArIGtleSArICc6Jyk7XHJcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbiA9ICd4bWxuczonICsga2V5ICsgJz0nO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlZy50ZXN0KHRleHQpICYmIHRleHQuaW5kZXhPZihkZWNsYXJhdGlvbikgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkZWZpbmVkKGZpcnN0UGFydCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RQYXJ0ID0gdGV4dC5zdWJzdHIoMCwgdGV4dC5pbmRleE9mKCc8a21sJykgKyA0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFBhcnQgPSB0ZXh0LnN1YnN0cihmaXJzdFBhcnQubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RQYXJ0ICs9ICcgJyArIGRlY2xhcmF0aW9uICsgJ1wiJyArIG5hbWVzcGFjZU1hcFtrZXldICsgJ1wiJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGRlZmluZWQoZmlyc3RQYXJ0KSkge1xyXG4gICAgICAgICAgICB0ZXh0ID0gZmlyc3RQYXJ0ICsgbGFzdFBhcnQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGV4dDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByZW1vdmVEdXBsaWNhdGVOYW1lc3BhY2VzKHRleHQpIHtcclxuICAgICAgICB2YXIgaW5kZXggPSB0ZXh0LmluZGV4T2YoJ3htbG5zOicpO1xyXG4gICAgICAgIHZhciBlbmREZWNsYXJhdGlvbiA9IHRleHQuaW5kZXhPZignPicsIGluZGV4KTtcclxuICAgICAgICB2YXIgbmFtZXNwYWNlLCBzdGFydEluZGV4LCBlbmRJbmRleDtcclxuXHJcbiAgICAgICAgd2hpbGUgKChpbmRleCAhPT0gLTEpICYmIChpbmRleCA8IGVuZERlY2xhcmF0aW9uKSkge1xyXG4gICAgICAgICAgICBuYW1lc3BhY2UgPSB0ZXh0LnNsaWNlKGluZGV4LCB0ZXh0LmluZGV4T2YoJ1xcXCInLCBpbmRleCkpO1xyXG4gICAgICAgICAgICBzdGFydEluZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgICAgIGluZGV4ID0gdGV4dC5pbmRleE9mKG5hbWVzcGFjZSwgaW5kZXggKyAxKTtcclxuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgZW5kSW5kZXggPSB0ZXh0LmluZGV4T2YoJ1xcXCInLCAodGV4dC5pbmRleE9mKCdcXFwiJywgaW5kZXgpICsgMSkpO1xyXG4gICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc2xpY2UoMCwgaW5kZXggLTEpICsgdGV4dC5zbGljZShlbmRJbmRleCArIDEsIHRleHQubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIGluZGV4ID0gdGV4dC5pbmRleE9mKCd4bWxuczonLCBzdGFydEluZGV4IC0gMSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpbmRleCA9IHRleHQuaW5kZXhPZigneG1sbnM6Jywgc3RhcnRJbmRleCArIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGV4dDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBsb2FkWG1sRnJvbVppcChlbnRyeSwgdXJpUmVzb2x2ZXIsIGRlZmVycmVkKSB7XHJcbiAgICAgICAgZW50cnkuZ2V0RGF0YShuZXcgemlwLlRleHRXcml0ZXIoKSwgZnVuY3Rpb24odGV4dCkge1xyXG4gICAgICAgICAgICB0ZXh0ID0gaW5zZXJ0TmFtZXNwYWNlcyh0ZXh0KTtcclxuICAgICAgICAgICAgdGV4dCA9IHJlbW92ZUR1cGxpY2F0ZU5hbWVzcGFjZXModGV4dCk7XHJcbiAgICAgICAgICAgIHVyaVJlc29sdmVyLmttbCA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcodGV4dCwgJ2FwcGxpY2F0aW9uL3htbCcpO1xyXG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbG9hZERhdGFVcmlGcm9tWmlwKGVudHJ5LCB1cmlSZXNvbHZlciwgZGVmZXJyZWQpIHtcclxuICAgICAgICB2YXIgbWltZVR5cGUgPSBkZWZhdWx0VmFsdWUoTWltZVR5cGVzLmRldGVjdEZyb21GaWxlbmFtZShlbnRyeS5maWxlbmFtZSksICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nKTtcclxuICAgICAgICBlbnRyeS5nZXREYXRhKG5ldyB6aXAuRGF0YTY0VVJJV3JpdGVyKG1pbWVUeXBlKSwgZnVuY3Rpb24oZGF0YVVyaSkge1xyXG4gICAgICAgICAgICB1cmlSZXNvbHZlcltlbnRyeS5maWxlbmFtZV0gPSBkYXRhVXJpO1xyXG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZW1iZWREYXRhVXJpcyhkaXYsIGVsZW1lbnRUeXBlLCBhdHRyaWJ1dGVOYW1lLCB1cmlSZXNvbHZlcikge1xyXG4gICAgICAgIHZhciBrZXlzID0gdXJpUmVzb2x2ZXIua2V5cztcclxuICAgICAgICB2YXIgYmFzZVVyaSA9IG5ldyBVcmkoJy4nKTtcclxuICAgICAgICB2YXIgZWxlbWVudHMgPSBkaXYucXVlcnlTZWxlY3RvckFsbChlbGVtZW50VHlwZSk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IGVsZW1lbnRzW2ldO1xyXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTtcclxuICAgICAgICAgICAgdmFyIHVyaSA9IG5ldyBVcmkodmFsdWUpLnJlc29sdmUoYmFzZVVyaSkudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0ga2V5cy5pbmRleE9mKHVyaSk7XHJcbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2luZGV4XTtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsIHVyaVJlc29sdmVyW2tleV0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRUeXBlID09PSAnYScgJiYgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2Rvd25sb2FkJykgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnZG93bmxvYWQnLCBrZXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGFwcGx5QmFzZVBhdGgoZGl2LCBlbGVtZW50VHlwZSwgYXR0cmlidXRlTmFtZSwgc291cmNlUmVzb3VyY2UpIHtcclxuICAgICAgICB2YXIgZWxlbWVudHMgPSBkaXYucXVlcnlTZWxlY3RvckFsbChlbGVtZW50VHlwZSk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IGVsZW1lbnRzW2ldO1xyXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTtcclxuICAgICAgICAgICAgdmFyIHJlc291cmNlID0gcmVzb2x2ZUhyZWYodmFsdWUsIHNvdXJjZVJlc291cmNlKTtcclxuICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSwgcmVzb3VyY2UudXJsKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gYW4gb3B0aW9uYWwgY29udGV4dCBpcyBwYXNzZWQgdG8gYWxsb3cgZm9yIHNvbWUgbWFsZm9ybWVkIGttbHMgKHRob3NlIHdpdGggbXVsdGlwbGUgZ2VvbWV0cmllcyB3aXRoIHNhbWUgaWRzKSB0byBzdGlsbCBwYXJzZVxyXG4gICAgLy8gY29ycmVjdGx5LCBhcyB0aGV5IGRvIGluIEdvb2dsZSBFYXJ0aC5cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZUVudGl0eShub2RlLCBlbnRpdHlDb2xsZWN0aW9uLCBjb250ZXh0KSB7XHJcbiAgICAgICAgdmFyIGlkID0gcXVlcnlTdHJpbmdBdHRyaWJ1dGUobm9kZSwgJ2lkJyk7XHJcbiAgICAgICAgaWQgPSBkZWZpbmVkKGlkKSAmJiBpZC5sZW5ndGggIT09IDAgPyBpZCA6IGNyZWF0ZUd1aWQoKTtcclxuICAgICAgICBpZiAoZGVmaW5lZChjb250ZXh0KSkge1xyXG4gICAgICAgICAgICBpZCA9IGNvbnRleHQgKyBpZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIElmIHdlIGhhdmUgYSBkdXBsaWNhdGUgSUQganVzdCBnZW5lcmF0ZSBvbmUuXHJcbiAgICAgICAgLy8gVGhpcyBpc24ndCB2YWxpZCBLTUwgYnV0IEdvb2dsZSBFYXJ0aCBoYW5kbGVzIHRoaXMgY2FzZS5cclxuICAgICAgICB2YXIgZW50aXR5ID0gZW50aXR5Q29sbGVjdGlvbi5nZXRCeUlkKGlkKTtcclxuICAgICAgICBpZiAoZGVmaW5lZChlbnRpdHkpKSB7XHJcbiAgICAgICAgICAgIGlkID0gY3JlYXRlR3VpZCgpO1xyXG4gICAgICAgICAgICBpZiAoZGVmaW5lZChjb250ZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgaWQgPSBjb250ZXh0ICsgaWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGVudGl0eSA9IGVudGl0eUNvbGxlY3Rpb24uYWRkKG5ldyBFbnRpdHkoe2lkIDogaWR9KSk7XHJcbiAgICAgICAgaWYgKCFkZWZpbmVkKGVudGl0eS5rbWwpKSB7XHJcbiAgICAgICAgICAgIGVudGl0eS5hZGRQcm9wZXJ0eSgna21sJyk7XHJcbiAgICAgICAgICAgIGVudGl0eS5rbWwgPSBuZXcgS21sRmVhdHVyZURhdGEoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGVudGl0eTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBpc0V4dHJ1ZGFibGUoYWx0aXR1ZGVNb2RlLCBneEFsdGl0dWRlTW9kZSkge1xyXG4gICAgICAgIHJldHVybiBhbHRpdHVkZU1vZGUgPT09ICdhYnNvbHV0ZScgfHwgYWx0aXR1ZGVNb2RlID09PSAncmVsYXRpdmVUb0dyb3VuZCcgfHwgZ3hBbHRpdHVkZU1vZGUgPT09ICdyZWxhdGl2ZVRvU2VhRmxvb3InO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJlYWRDb29yZGluYXRlKHZhbHVlLCBlbGxpcHNvaWQpIHtcclxuICAgICAgICAvL0dvb2dsZSBFYXJ0aCB0cmVhdHMgZW1wdHkgb3IgbWlzc2luZyBjb29yZGluYXRlcyBhcyAwLlxyXG4gICAgICAgIGlmICghZGVmaW5lZCh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIENhcnRlc2lhbjMuZnJvbURlZ3JlZXMoMCwgMCwgMCwgZWxsaXBzb2lkKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBkaWdpdHMgPSB2YWx1ZS5tYXRjaCgvW15cXHMsXFxuXSsvZyk7XHJcbiAgICAgICAgaWYgKCFkZWZpbmVkKGRpZ2l0cykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIENhcnRlc2lhbjMuZnJvbURlZ3JlZXMoMCwgMCwgMCwgZWxsaXBzb2lkKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBsb25naXR1ZGUgPSBwYXJzZUZsb2F0KGRpZ2l0c1swXSk7XHJcbiAgICAgICAgdmFyIGxhdGl0dWRlID0gcGFyc2VGbG9hdChkaWdpdHNbMV0pO1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSBwYXJzZUZsb2F0KGRpZ2l0c1syXSk7XHJcblxyXG4gICAgICAgIGxvbmdpdHVkZSA9IGlzTmFOKGxvbmdpdHVkZSkgPyAwLjAgOiBsb25naXR1ZGU7XHJcbiAgICAgICAgbGF0aXR1ZGUgPSBpc05hTihsYXRpdHVkZSkgPyAwLjAgOiBsYXRpdHVkZTtcclxuICAgICAgICBoZWlnaHQgPSBpc05hTihoZWlnaHQpID8gMC4wIDogaGVpZ2h0O1xyXG5cclxuICAgICAgICByZXR1cm4gQ2FydGVzaWFuMy5mcm9tRGVncmVlcyhsb25naXR1ZGUsIGxhdGl0dWRlLCBoZWlnaHQsIGVsbGlwc29pZCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcmVhZENvb3JkaW5hdGVzKGVsZW1lbnQsIGVsbGlwc29pZCkge1xyXG4gICAgICAgIGlmICghZGVmaW5lZChlbGVtZW50KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHR1cGxlcyA9IGVsZW1lbnQudGV4dENvbnRlbnQubWF0Y2goL1teXFxzXFxuXSsvZyk7XHJcbiAgICAgICAgaWYgKCFkZWZpbmVkKHR1cGxlcykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBsZW5ndGggPSB0dXBsZXMubGVuZ3RoO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgQXJyYXkobGVuZ3RoKTtcclxuICAgICAgICB2YXIgcmVzdWx0SW5kZXggPSAwO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdEluZGV4KytdID0gcmVhZENvb3JkaW5hdGUodHVwbGVzW2ldLCBlbGxpcHNvaWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBrbWxOYW1lc3BhY2VzID0gW251bGwsIHVuZGVmaW5lZCwgJ2h0dHA6Ly93d3cub3Blbmdpcy5uZXQva21sLzIuMicsICdodHRwOi8vZWFydGguZ29vZ2xlLmNvbS9rbWwvMi4yJywgJ2h0dHA6Ly9lYXJ0aC5nb29nbGUuY29tL2ttbC8yLjEnLCAnaHR0cDovL2VhcnRoLmdvb2dsZS5jb20va21sLzIuMCddO1xyXG4gICAgdmFyIGd4TmFtZXNwYWNlcyA9IFsnaHR0cDovL3d3dy5nb29nbGUuY29tL2ttbC9leHQvMi4yJ107XHJcbiAgICB2YXIgYXRvbU5hbWVzcGFjZXMgPSBbJ2h0dHA6Ly93d3cudzMub3JnLzIwMDUvQXRvbSddO1xyXG4gICAgdmFyIG5hbWVzcGFjZXMgPSB7XHJcbiAgICAgICAga21sIDoga21sTmFtZXNwYWNlcyxcclxuICAgICAgICBneCA6IGd4TmFtZXNwYWNlcyxcclxuICAgICAgICBhdG9tIDogYXRvbU5hbWVzcGFjZXMsXHJcbiAgICAgICAga21sZ3ggOiBrbWxOYW1lc3BhY2VzLmNvbmNhdChneE5hbWVzcGFjZXMpXHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIHF1ZXJ5TnVtZXJpY0F0dHJpYnV0ZShub2RlLCBhdHRyaWJ1dGVOYW1lKSB7XHJcbiAgICAgICAgaWYgKCFkZWZpbmVkKG5vZGUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgdmFsdWUgPSBub2RlLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTtcclxuICAgICAgICBpZiAodmFsdWUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHBhcnNlRmxvYXQodmFsdWUpO1xyXG4gICAgICAgICAgICByZXR1cm4gIWlzTmFOKHJlc3VsdCkgPyByZXN1bHQgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcXVlcnlTdHJpbmdBdHRyaWJ1dGUobm9kZSwgYXR0cmlidXRlTmFtZSkge1xyXG4gICAgICAgIGlmICghZGVmaW5lZChub2RlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdmFsdWUgPSBub2RlLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTtcclxuICAgICAgICByZXR1cm4gdmFsdWUgIT09IG51bGwgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBxdWVyeUZpcnN0Tm9kZShub2RlLCB0YWdOYW1lLCBuYW1lc3BhY2UpIHtcclxuICAgICAgICBpZiAoIWRlZmluZWQobm9kZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGNoaWxkTm9kZXMgPSBub2RlLmNoaWxkTm9kZXM7XHJcbiAgICAgICAgdmFyIGxlbmd0aCA9IGNoaWxkTm9kZXMubGVuZ3RoO1xyXG4gICAgICAgIGZvciAodmFyIHEgPSAwOyBxIDwgbGVuZ3RoOyBxKyspIHtcclxuICAgICAgICAgICAgdmFyIGNoaWxkID0gY2hpbGROb2Rlc1txXTtcclxuICAgICAgICAgICAgaWYgKGNoaWxkLmxvY2FsTmFtZSA9PT0gdGFnTmFtZSAmJiBuYW1lc3BhY2UuaW5kZXhPZihjaGlsZC5uYW1lc3BhY2VVUkkpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcXVlcnlOb2Rlcyhub2RlLCB0YWdOYW1lLCBuYW1lc3BhY2UpIHtcclxuICAgICAgICBpZiAoIWRlZmluZWQobm9kZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gICAgICAgIHZhciBjaGlsZE5vZGVzID0gbm9kZS5nZXRFbGVtZW50c0J5VGFnTmFtZU5TKCcqJywgdGFnTmFtZSk7XHJcbiAgICAgICAgdmFyIGxlbmd0aCA9IGNoaWxkTm9kZXMubGVuZ3RoO1xyXG4gICAgICAgIGZvciAodmFyIHEgPSAwOyBxIDwgbGVuZ3RoOyBxKyspIHtcclxuICAgICAgICAgICAgdmFyIGNoaWxkID0gY2hpbGROb2Rlc1txXTtcclxuICAgICAgICAgICAgaWYgKGNoaWxkLmxvY2FsTmFtZSA9PT0gdGFnTmFtZSAmJiBuYW1lc3BhY2UuaW5kZXhPZihjaGlsZC5uYW1lc3BhY2VVUkkpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY2hpbGQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcXVlcnlDaGlsZE5vZGVzKG5vZGUsIHRhZ05hbWUsIG5hbWVzcGFjZSkge1xyXG4gICAgICAgIGlmICghZGVmaW5lZChub2RlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcclxuICAgICAgICB2YXIgY2hpbGROb2RlcyA9IG5vZGUuY2hpbGROb2RlcztcclxuICAgICAgICB2YXIgbGVuZ3RoID0gY2hpbGROb2Rlcy5sZW5ndGg7XHJcbiAgICAgICAgZm9yICh2YXIgcSA9IDA7IHEgPCBsZW5ndGg7IHErKykge1xyXG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZE5vZGVzW3FdO1xyXG4gICAgICAgICAgICBpZiAoY2hpbGQubG9jYWxOYW1lID09PSB0YWdOYW1lICYmIG5hbWVzcGFjZS5pbmRleE9mKGNoaWxkLm5hbWVzcGFjZVVSSSkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjaGlsZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBxdWVyeU51bWVyaWNWYWx1ZShub2RlLCB0YWdOYW1lLCBuYW1lc3BhY2UpIHtcclxuICAgICAgICB2YXIgcmVzdWx0Tm9kZSA9IHF1ZXJ5Rmlyc3ROb2RlKG5vZGUsIHRhZ05hbWUsIG5hbWVzcGFjZSk7XHJcbiAgICAgICAgaWYgKGRlZmluZWQocmVzdWx0Tm9kZSkpIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHBhcnNlRmxvYXQocmVzdWx0Tm9kZS50ZXh0Q29udGVudCk7XHJcbiAgICAgICAgICAgIHJldHVybiAhaXNOYU4ocmVzdWx0KSA/IHJlc3VsdCA6IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBxdWVyeVN0cmluZ1ZhbHVlKG5vZGUsIHRhZ05hbWUsIG5hbWVzcGFjZSkge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBxdWVyeUZpcnN0Tm9kZShub2RlLCB0YWdOYW1lLCBuYW1lc3BhY2UpO1xyXG4gICAgICAgIGlmIChkZWZpbmVkKHJlc3VsdCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC50ZXh0Q29udGVudC50cmltKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcXVlcnlCb29sZWFuVmFsdWUobm9kZSwgdGFnTmFtZSwgbmFtZXNwYWNlKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHF1ZXJ5Rmlyc3ROb2RlKG5vZGUsIHRhZ05hbWUsIG5hbWVzcGFjZSk7XHJcbiAgICAgICAgaWYgKGRlZmluZWQocmVzdWx0KSkge1xyXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudGV4dENvbnRlbnQudHJpbSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPT09ICcxJyB8fCAvXnRydWUkL2kudGVzdCh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcmVzb2x2ZUhyZWYoaHJlZiwgc291cmNlUmVzb3VyY2UsIHVyaVJlc29sdmVyKSB7XHJcbiAgICAgICAgaWYgKCFkZWZpbmVkKGhyZWYpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgcmVzb3VyY2U7XHJcbiAgICAgICAgaWYgKGRlZmluZWQodXJpUmVzb2x2ZXIpKSB7XHJcbiAgICAgICAgICAgIHZhciBibG9iID0gdXJpUmVzb2x2ZXJbaHJlZl07XHJcbiAgICAgICAgICAgIGlmIChkZWZpbmVkKGJsb2IpKSB7XHJcbiAgICAgICAgICAgICAgICByZXNvdXJjZSA9IG5ldyBSZXNvdXJjZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBibG9iXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIE5lZWRlZCBmb3IgbXVsdGlwbGUgbGV2ZWxzIG9mIEtNTCBmaWxlcyBpbiBhIEtNWlxyXG4gICAgICAgICAgICAgICAgdmFyIGJhc2VVcmkgPSBuZXcgVXJpKHNvdXJjZVJlc291cmNlLmdldFVybENvbXBvbmVudCgpKTtcclxuICAgICAgICAgICAgICAgIHZhciB1cmkgPSBuZXcgVXJpKGhyZWYpO1xyXG4gICAgICAgICAgICAgICAgYmxvYiA9IHVyaVJlc29sdmVyW3VyaS5yZXNvbHZlKGJhc2VVcmkpXTtcclxuICAgICAgICAgICAgICAgIGlmIChkZWZpbmVkKGJsb2IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2UgPSBuZXcgUmVzb3VyY2Uoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6IGJsb2JcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFkZWZpbmVkKHJlc291cmNlKSkge1xyXG4gICAgICAgICAgICByZXNvdXJjZSA9IHNvdXJjZVJlc291cmNlLmdldERlcml2ZWRSZXNvdXJjZSh7XHJcbiAgICAgICAgICAgICAgICB1cmw6IGhyZWZcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcmVzb3VyY2U7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGNvbG9yT3B0aW9ucyA9IHtcclxuICAgICAgICBtYXhpbXVtUmVkIDogdW5kZWZpbmVkLFxyXG4gICAgICAgIHJlZCA6IHVuZGVmaW5lZCxcclxuICAgICAgICBtYXhpbXVtR3JlZW4gOiB1bmRlZmluZWQsXHJcbiAgICAgICAgZ3JlZW4gOiB1bmRlZmluZWQsXHJcbiAgICAgICAgbWF4aW11bUJsdWUgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgYmx1ZSA6IHVuZGVmaW5lZFxyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBwYXJzZUNvbG9yU3RyaW5nKHZhbHVlLCBpc1JhbmRvbSkge1xyXG4gICAgICAgIGlmICghZGVmaW5lZCh2YWx1ZSkgfHwgL15cXHMqJC9nbS50ZXN0KHZhbHVlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHZhbHVlWzBdID09PSAnIycpIHtcclxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoMSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgYWxwaGEgPSBwYXJzZUludCh2YWx1ZS5zdWJzdHJpbmcoMCwgMiksIDE2KSAvIDI1NS4wO1xyXG4gICAgICAgIHZhciBibHVlID0gcGFyc2VJbnQodmFsdWUuc3Vic3RyaW5nKDIsIDQpLCAxNikgLyAyNTUuMDtcclxuICAgICAgICB2YXIgZ3JlZW4gPSBwYXJzZUludCh2YWx1ZS5zdWJzdHJpbmcoNCwgNiksIDE2KSAvIDI1NS4wO1xyXG4gICAgICAgIHZhciByZWQgPSBwYXJzZUludCh2YWx1ZS5zdWJzdHJpbmcoNiwgOCksIDE2KSAvIDI1NS4wO1xyXG5cclxuICAgICAgICBpZiAoIWlzUmFuZG9tKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IocmVkLCBncmVlbiwgYmx1ZSwgYWxwaGEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHJlZCA+IDApIHtcclxuICAgICAgICAgICAgY29sb3JPcHRpb25zLm1heGltdW1SZWQgPSByZWQ7XHJcbiAgICAgICAgICAgIGNvbG9yT3B0aW9ucy5yZWQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29sb3JPcHRpb25zLm1heGltdW1SZWQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIGNvbG9yT3B0aW9ucy5yZWQgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZ3JlZW4gPiAwKSB7XHJcbiAgICAgICAgICAgIGNvbG9yT3B0aW9ucy5tYXhpbXVtR3JlZW4gPSBncmVlbjtcclxuICAgICAgICAgICAgY29sb3JPcHRpb25zLmdyZWVuID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbG9yT3B0aW9ucy5tYXhpbXVtR3JlZW4gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIGNvbG9yT3B0aW9ucy5ncmVlbiA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChibHVlID4gMCkge1xyXG4gICAgICAgICAgICBjb2xvck9wdGlvbnMubWF4aW11bUJsdWUgPSBibHVlO1xyXG4gICAgICAgICAgICBjb2xvck9wdGlvbnMuYmx1ZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb2xvck9wdGlvbnMubWF4aW11bUJsdWUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIGNvbG9yT3B0aW9ucy5ibHVlID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29sb3JPcHRpb25zLmFscGhhID0gYWxwaGE7XHJcbiAgICAgICAgcmV0dXJuIENvbG9yLmZyb21SYW5kb20oY29sb3JPcHRpb25zKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBxdWVyeUNvbG9yVmFsdWUobm9kZSwgdGFnTmFtZSwgbmFtZXNwYWNlKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gcXVlcnlTdHJpbmdWYWx1ZShub2RlLCB0YWdOYW1lLCBuYW1lc3BhY2UpO1xyXG4gICAgICAgIGlmICghZGVmaW5lZCh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBhcnNlQ29sb3JTdHJpbmcodmFsdWUsIHF1ZXJ5U3RyaW5nVmFsdWUobm9kZSwgJ2NvbG9yTW9kZScsIG5hbWVzcGFjZSkgPT09ICdyYW5kb20nKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBwcm9jZXNzVGltZVN0YW1wKGZlYXR1cmVOb2RlKSB7XHJcbiAgICAgICAgdmFyIG5vZGUgPSBxdWVyeUZpcnN0Tm9kZShmZWF0dXJlTm9kZSwgJ1RpbWVTdGFtcCcsIG5hbWVzcGFjZXMua21sZ3gpO1xyXG4gICAgICAgIHZhciB3aGVuU3RyaW5nID0gcXVlcnlTdHJpbmdWYWx1ZShub2RlLCAnd2hlbicsIG5hbWVzcGFjZXMua21sZ3gpO1xyXG5cclxuICAgICAgICBpZiAoIWRlZmluZWQobm9kZSkgfHwgIWRlZmluZWQod2hlblN0cmluZykgfHwgd2hlblN0cmluZy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vQWNjb3JkaW5nIHRvIHRoZSBLTUwgc3BlYywgYSBUaW1lU3RhbXAgcmVwcmVzZW50cyBhIFwic2luZ2xlIG1vbWVudCBpbiB0aW1lXCJcclxuICAgICAgICAvL0hvd2V2ZXIsIHNpbmNlIENlc2l1bSBhbmltYXRlcyBtdWNoIGRpZmZlcmVudGx5IHRoYW4gR29vZ2xlIEVhcnRoLCB0aGF0IGRvZXNuJ3RcclxuICAgICAgICAvL01ha2UgbXVjaCBzZW5zZSBoZXJlLiAgSW5zdGVhZCwgd2UgdXNlIHRoZSBUaW1lU3RhbXAgYXMgdGhlIG1vbWVudCB0aGUgZmVhdHVyZVxyXG4gICAgICAgIC8vY29tZXMgaW50byBleGlzdGVuY2UuICBUaGlzIHdvcmtzIG11Y2ggYmV0dGVyIGFuZCBnaXZlcyBhIHNpbWlsYXIgZmVlbCB0b1xyXG4gICAgICAgIC8vR0UncyBleHBlcmllbmNlLlxyXG4gICAgICAgIHZhciB3aGVuID0gSnVsaWFuRGF0ZS5mcm9tSXNvODYwMSh3aGVuU3RyaW5nKTtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IFRpbWVJbnRlcnZhbENvbGxlY3Rpb24oKTtcclxuICAgICAgICByZXN1bHQuYWRkSW50ZXJ2YWwobmV3IFRpbWVJbnRlcnZhbCh7XHJcbiAgICAgICAgICAgIHN0YXJ0IDogd2hlbixcclxuICAgICAgICAgICAgc3RvcCA6IElzbzg2MDEuTUFYSU1VTV9WQUxVRVxyXG4gICAgICAgIH0pKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHByb2Nlc3NUaW1lU3BhbihmZWF0dXJlTm9kZSkge1xyXG4gICAgICAgIHZhciBub2RlID0gcXVlcnlGaXJzdE5vZGUoZmVhdHVyZU5vZGUsICdUaW1lU3BhbicsIG5hbWVzcGFjZXMua21sZ3gpO1xyXG4gICAgICAgIGlmICghZGVmaW5lZChub2RlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmVzdWx0O1xyXG5cclxuICAgICAgICB2YXIgYmVnaW5Ob2RlID0gcXVlcnlGaXJzdE5vZGUobm9kZSwgJ2JlZ2luJywgbmFtZXNwYWNlcy5rbWxneCk7XHJcbiAgICAgICAgdmFyIGJlZ2luRGF0ZSA9IGRlZmluZWQoYmVnaW5Ob2RlKSA/IEp1bGlhbkRhdGUuZnJvbUlzbzg2MDEoYmVnaW5Ob2RlLnRleHRDb250ZW50KSA6IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgdmFyIGVuZE5vZGUgPSBxdWVyeUZpcnN0Tm9kZShub2RlLCAnZW5kJywgbmFtZXNwYWNlcy5rbWxneCk7XHJcbiAgICAgICAgdmFyIGVuZERhdGUgPSBkZWZpbmVkKGVuZE5vZGUpID8gSnVsaWFuRGF0ZS5mcm9tSXNvODYwMShlbmROb2RlLnRleHRDb250ZW50KSA6IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgaWYgKGRlZmluZWQoYmVnaW5EYXRlKSAmJiBkZWZpbmVkKGVuZERhdGUpKSB7XHJcbiAgICAgICAgICAgIGlmIChKdWxpYW5EYXRlLmxlc3NUaGFuKGVuZERhdGUsIGJlZ2luRGF0ZSkpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0bXAgPSBiZWdpbkRhdGU7XHJcbiAgICAgICAgICAgICAgICBiZWdpbkRhdGUgPSBlbmREYXRlO1xyXG4gICAgICAgICAgICAgICAgZW5kRGF0ZSA9IHRtcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXN1bHQgPSBuZXcgVGltZUludGVydmFsQ29sbGVjdGlvbigpO1xyXG4gICAgICAgICAgICByZXN1bHQuYWRkSW50ZXJ2YWwobmV3IFRpbWVJbnRlcnZhbCh7XHJcbiAgICAgICAgICAgICAgICBzdGFydCA6IGJlZ2luRGF0ZSxcclxuICAgICAgICAgICAgICAgIHN0b3AgOiBlbmREYXRlXHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGRlZmluZWQoYmVnaW5EYXRlKSkge1xyXG4gICAgICAgICAgICByZXN1bHQgPSBuZXcgVGltZUludGVydmFsQ29sbGVjdGlvbigpO1xyXG4gICAgICAgICAgICByZXN1bHQuYWRkSW50ZXJ2YWwobmV3IFRpbWVJbnRlcnZhbCh7XHJcbiAgICAgICAgICAgICAgICBzdGFydCA6IGJlZ2luRGF0ZSxcclxuICAgICAgICAgICAgICAgIHN0b3AgOiBJc284NjAxLk1BWElNVU1fVkFMVUVcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZGVmaW5lZChlbmREYXRlKSkge1xyXG4gICAgICAgICAgICByZXN1bHQgPSBuZXcgVGltZUludGVydmFsQ29sbGVjdGlvbigpO1xyXG4gICAgICAgICAgICByZXN1bHQuYWRkSW50ZXJ2YWwobmV3IFRpbWVJbnRlcnZhbCh7XHJcbiAgICAgICAgICAgICAgICBzdGFydCA6IElzbzg2MDEuTUlOSU1VTV9WQUxVRSxcclxuICAgICAgICAgICAgICAgIHN0b3AgOiBlbmREYXRlXHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY3JlYXRlRGVmYXVsdEJpbGxib2FyZCgpIHtcclxuICAgICAgICB2YXIgYmlsbGJvYXJkID0gbmV3IEJpbGxib2FyZEdyYXBoaWNzKCk7XHJcbiAgICAgICAgYmlsbGJvYXJkLndpZHRoID0gQklMTEJPQVJEX1NJWkU7XHJcbiAgICAgICAgYmlsbGJvYXJkLmhlaWdodCA9IEJJTExCT0FSRF9TSVpFO1xyXG4gICAgICAgIGJpbGxib2FyZC5zY2FsZUJ5RGlzdGFuY2UgPSBuZXcgTmVhckZhclNjYWxhcihCSUxMQk9BUkRfTkVBUl9ESVNUQU5DRSwgQklMTEJPQVJEX05FQVJfUkFUSU8sIEJJTExCT0FSRF9GQVJfRElTVEFOQ0UsIEJJTExCT0FSRF9GQVJfUkFUSU8pO1xyXG4gICAgICAgIGJpbGxib2FyZC5waXhlbE9mZnNldFNjYWxlQnlEaXN0YW5jZSA9IG5ldyBOZWFyRmFyU2NhbGFyKEJJTExCT0FSRF9ORUFSX0RJU1RBTkNFLCBCSUxMQk9BUkRfTkVBUl9SQVRJTywgQklMTEJPQVJEX0ZBUl9ESVNUQU5DRSwgQklMTEJPQVJEX0ZBUl9SQVRJTyk7XHJcbiAgICAgICAgcmV0dXJuIGJpbGxib2FyZDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVEZWZhdWx0UG9seWdvbigpIHtcclxuICAgICAgICB2YXIgcG9seWdvbiA9IG5ldyBQb2x5Z29uR3JhcGhpY3MoKTtcclxuICAgICAgICBwb2x5Z29uLm91dGxpbmUgPSB0cnVlO1xyXG4gICAgICAgIHBvbHlnb24ub3V0bGluZUNvbG9yID0gQ29sb3IuV0hJVEU7XHJcbiAgICAgICAgcmV0dXJuIHBvbHlnb247XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY3JlYXRlRGVmYXVsdExhYmVsKCkge1xyXG4gICAgICAgIHZhciBsYWJlbCA9IG5ldyBMYWJlbEdyYXBoaWNzKCk7XHJcbiAgICAgICAgbGFiZWwudHJhbnNsdWNlbmN5QnlEaXN0YW5jZSA9IG5ldyBOZWFyRmFyU2NhbGFyKDMwMDAwMDAsIDEuMCwgNTAwMDAwMCwgMC4wKTtcclxuICAgICAgICBsYWJlbC5waXhlbE9mZnNldCA9IG5ldyBDYXJ0ZXNpYW4yKDE3LCAwKTtcclxuICAgICAgICBsYWJlbC5ob3Jpem9udGFsT3JpZ2luID0gSG9yaXpvbnRhbE9yaWdpbi5MRUZUO1xyXG4gICAgICAgIGxhYmVsLmZvbnQgPSAnMTZweCBzYW5zLXNlcmlmJztcclxuICAgICAgICBsYWJlbC5zdHlsZSA9IExhYmVsU3R5bGUuRklMTF9BTkRfT1VUTElORTtcclxuICAgICAgICByZXR1cm4gbGFiZWw7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0SWNvbkhyZWYoaWNvbk5vZGUsIGRhdGFTb3VyY2UsIHNvdXJjZVJlc291cmNlLCB1cmlSZXNvbHZlciwgY2FuUmVmcmVzaCkge1xyXG4gICAgICAgIHZhciBocmVmID0gcXVlcnlTdHJpbmdWYWx1ZShpY29uTm9kZSwgJ2hyZWYnLCBuYW1lc3BhY2VzLmttbCk7XHJcbiAgICAgICAgaWYgKCFkZWZpbmVkKGhyZWYpIHx8IChocmVmLmxlbmd0aCA9PT0gMCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChocmVmLmluZGV4T2YoJ3Jvb3Q6Ly9pY29ucy9wYWxldHRlLScpID09PSAwKSB7XHJcbiAgICAgICAgICAgIHZhciBwYWxldHRlID0gaHJlZi5jaGFyQXQoMjEpO1xyXG5cclxuICAgICAgICAgICAgLy8gR2V0IHRoZSBpY29uIG51bWJlclxyXG4gICAgICAgICAgICB2YXIgeCA9IGRlZmF1bHRWYWx1ZShxdWVyeU51bWVyaWNWYWx1ZShpY29uTm9kZSwgJ3gnLCBuYW1lc3BhY2VzLmd4KSwgMCk7XHJcbiAgICAgICAgICAgIHZhciB5ID0gZGVmYXVsdFZhbHVlKHF1ZXJ5TnVtZXJpY1ZhbHVlKGljb25Ob2RlLCAneScsIG5hbWVzcGFjZXMuZ3gpLCAwKTtcclxuICAgICAgICAgICAgeCA9IE1hdGgubWluKHggLyAzMiwgNyk7XHJcbiAgICAgICAgICAgIHkgPSA3IC0gTWF0aC5taW4oeSAvIDMyLCA3KTtcclxuICAgICAgICAgICAgdmFyIGljb25OdW0gPSAoOCAqIHkpICsgeDtcclxuXHJcbiAgICAgICAgICAgIGhyZWYgPSAnaHR0cHM6Ly9tYXBzLmdvb2dsZS5jb20vbWFwZmlsZXMva21sL3BhbCcgKyBwYWxldHRlICsgJy9pY29uJyArIGljb25OdW0gKyAnLnBuZyc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgaHJlZlJlc291cmNlID0gcmVzb2x2ZUhyZWYoaHJlZiwgc291cmNlUmVzb3VyY2UsIHVyaVJlc29sdmVyKTtcclxuXHJcbiAgICAgICAgaWYgKGNhblJlZnJlc2gpIHtcclxuICAgICAgICAgICAgdmFyIHJlZnJlc2hNb2RlID0gcXVlcnlTdHJpbmdWYWx1ZShpY29uTm9kZSwgJ3JlZnJlc2hNb2RlJywgbmFtZXNwYWNlcy5rbWwpO1xyXG4gICAgICAgICAgICB2YXIgdmlld1JlZnJlc2hNb2RlID0gcXVlcnlTdHJpbmdWYWx1ZShpY29uTm9kZSwgJ3ZpZXdSZWZyZXNoTW9kZScsIG5hbWVzcGFjZXMua21sKTtcclxuICAgICAgICAgICAgaWYgKHJlZnJlc2hNb2RlID09PSAnb25JbnRlcnZhbCcgfHwgcmVmcmVzaE1vZGUgPT09ICdvbkV4cGlyZScpIHtcclxuICAgICAgICAgICAgICAgIG9uZVRpbWVXYXJuaW5nKCdrbWwtcmVmcmVzaE1vZGUtJyArIHJlZnJlc2hNb2RlLCAnS01MIC0gVW5zdXBwb3J0ZWQgSWNvbiByZWZyZXNoTW9kZTogJyArIHJlZnJlc2hNb2RlKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh2aWV3UmVmcmVzaE1vZGUgPT09ICdvblN0b3AnIHx8IHZpZXdSZWZyZXNoTW9kZSA9PT0gJ29uUmVnaW9uJykge1xyXG4gICAgICAgICAgICAgICAgb25lVGltZVdhcm5pbmcoJ2ttbC1yZWZyZXNoTW9kZS0nICsgdmlld1JlZnJlc2hNb2RlLCAnS01MIC0gVW5zdXBwb3J0ZWQgSWNvbiB2aWV3UmVmcmVzaE1vZGU6ICcgKyB2aWV3UmVmcmVzaE1vZGUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgdmlld0JvdW5kU2NhbGUgPSBkZWZhdWx0VmFsdWUocXVlcnlTdHJpbmdWYWx1ZShpY29uTm9kZSwgJ3ZpZXdCb3VuZFNjYWxlJywgbmFtZXNwYWNlcy5rbWwpLCAxLjApO1xyXG4gICAgICAgICAgICB2YXIgZGVmYXVsdFZpZXdGb3JtYXQgPSAodmlld1JlZnJlc2hNb2RlID09PSAnb25TdG9wJykgPyAnQkJPWD1bYmJveFdlc3RdLFtiYm94U291dGhdLFtiYm94RWFzdF0sW2Jib3hOb3J0aF0nIDogJyc7XHJcbiAgICAgICAgICAgIHZhciB2aWV3Rm9ybWF0ID0gZGVmYXVsdFZhbHVlKHF1ZXJ5U3RyaW5nVmFsdWUoaWNvbk5vZGUsICd2aWV3Rm9ybWF0JywgbmFtZXNwYWNlcy5rbWwpLCBkZWZhdWx0Vmlld0Zvcm1hdCk7XHJcbiAgICAgICAgICAgIHZhciBodHRwUXVlcnkgPSBxdWVyeVN0cmluZ1ZhbHVlKGljb25Ob2RlLCAnaHR0cFF1ZXJ5JywgbmFtZXNwYWNlcy5rbWwpO1xyXG4gICAgICAgICAgICBpZiAoZGVmaW5lZCh2aWV3Rm9ybWF0KSkge1xyXG4gICAgICAgICAgICAgICAgaHJlZlJlc291cmNlLnNldFF1ZXJ5UGFyYW1ldGVycyhxdWVyeVRvT2JqZWN0KGNsZWFudXBTdHJpbmcodmlld0Zvcm1hdCkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZGVmaW5lZChodHRwUXVlcnkpKSB7XHJcbiAgICAgICAgICAgICAgICBocmVmUmVzb3VyY2Uuc2V0UXVlcnlQYXJhbWV0ZXJzKHF1ZXJ5VG9PYmplY3QoY2xlYW51cFN0cmluZyhodHRwUXVlcnkpKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBlbGxpcHNvaWQgPSBkYXRhU291cmNlLl9lbGxpcHNvaWQ7XHJcbiAgICAgICAgICAgIHByb2Nlc3NOZXR3b3JrTGlua1F1ZXJ5U3RyaW5nKGhyZWZSZXNvdXJjZSwgZGF0YVNvdXJjZS5fY2FtZXJhLCBkYXRhU291cmNlLl9jYW52YXMsIHZpZXdCb3VuZFNjYWxlLCBkYXRhU291cmNlLl9sYXN0Q2FtZXJhVmlldy5iYm94LCBlbGxpcHNvaWQpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGhyZWZSZXNvdXJjZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBocmVmUmVzb3VyY2U7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcHJvY2Vzc0JpbGxib2FyZEljb24oZGF0YVNvdXJjZSwgbm9kZSwgdGFyZ2V0RW50aXR5LCBzb3VyY2VSZXNvdXJjZSwgdXJpUmVzb2x2ZXIpIHtcclxuICAgICAgICB2YXIgc2NhbGUgPSBxdWVyeU51bWVyaWNWYWx1ZShub2RlLCAnc2NhbGUnLCBuYW1lc3BhY2VzLmttbCk7XHJcbiAgICAgICAgdmFyIGhlYWRpbmcgPSBxdWVyeU51bWVyaWNWYWx1ZShub2RlLCAnaGVhZGluZycsIG5hbWVzcGFjZXMua21sKTtcclxuICAgICAgICB2YXIgY29sb3IgPSBxdWVyeUNvbG9yVmFsdWUobm9kZSwgJ2NvbG9yJywgbmFtZXNwYWNlcy5rbWwpO1xyXG5cclxuICAgICAgICB2YXIgaWNvbk5vZGUgPSBxdWVyeUZpcnN0Tm9kZShub2RlLCAnSWNvbicsIG5hbWVzcGFjZXMua21sKTtcclxuICAgICAgICB2YXIgaWNvbiA9IGdldEljb25IcmVmKGljb25Ob2RlLCBkYXRhU291cmNlLCBzb3VyY2VSZXNvdXJjZSwgdXJpUmVzb2x2ZXIsIGZhbHNlKTtcclxuXHJcbiAgICAgICAgLy8gSWYgaWNvbiB0YWdzIGFyZSBwcmVzZW50IGJ1dCBibGFuaywgd2UgZG8gbm90IHdhbnQgdG8gc2hvdyBhbiBpY29uXHJcbiAgICAgICAgaWYgKGRlZmluZWQoaWNvbk5vZGUpICYmICFkZWZpbmVkKGljb24pKSB7XHJcbiAgICAgICAgICAgIGljb24gPSBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciB4ID0gcXVlcnlOdW1lcmljVmFsdWUoaWNvbk5vZGUsICd4JywgbmFtZXNwYWNlcy5neCk7XHJcbiAgICAgICAgdmFyIHkgPSBxdWVyeU51bWVyaWNWYWx1ZShpY29uTm9kZSwgJ3knLCBuYW1lc3BhY2VzLmd4KTtcclxuICAgICAgICB2YXIgdyA9IHF1ZXJ5TnVtZXJpY1ZhbHVlKGljb25Ob2RlLCAndycsIG5hbWVzcGFjZXMuZ3gpO1xyXG4gICAgICAgIHZhciBoID0gcXVlcnlOdW1lcmljVmFsdWUoaWNvbk5vZGUsICdoJywgbmFtZXNwYWNlcy5neCk7XHJcblxyXG4gICAgICAgIHZhciBob3RTcG90Tm9kZSA9IHF1ZXJ5Rmlyc3ROb2RlKG5vZGUsICdob3RTcG90JywgbmFtZXNwYWNlcy5rbWwpO1xyXG4gICAgICAgIHZhciBob3RTcG90WCA9IHF1ZXJ5TnVtZXJpY0F0dHJpYnV0ZShob3RTcG90Tm9kZSwgJ3gnKTtcclxuICAgICAgICB2YXIgaG90U3BvdFkgPSBxdWVyeU51bWVyaWNBdHRyaWJ1dGUoaG90U3BvdE5vZGUsICd5Jyk7XHJcbiAgICAgICAgdmFyIGhvdFNwb3RYVW5pdCA9IHF1ZXJ5U3RyaW5nQXR0cmlidXRlKGhvdFNwb3ROb2RlLCAneHVuaXRzJyk7XHJcbiAgICAgICAgdmFyIGhvdFNwb3RZVW5pdCA9IHF1ZXJ5U3RyaW5nQXR0cmlidXRlKGhvdFNwb3ROb2RlLCAneXVuaXRzJyk7XHJcblxyXG4gICAgICAgIHZhciBiaWxsYm9hcmQgPSB0YXJnZXRFbnRpdHkuYmlsbGJvYXJkO1xyXG4gICAgICAgIGlmICghZGVmaW5lZChiaWxsYm9hcmQpKSB7XHJcbiAgICAgICAgICAgIGJpbGxib2FyZCA9IGNyZWF0ZURlZmF1bHRCaWxsYm9hcmQoKTtcclxuICAgICAgICAgICAgdGFyZ2V0RW50aXR5LmJpbGxib2FyZCA9IGJpbGxib2FyZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGJpbGxib2FyZC5pbWFnZSA9IGljb247XHJcbiAgICAgICAgYmlsbGJvYXJkLnNjYWxlID0gc2NhbGU7XHJcbiAgICAgICAgYmlsbGJvYXJkLmNvbG9yID0gY29sb3I7XHJcblxyXG4gICAgICAgIGlmIChkZWZpbmVkKHgpIHx8IGRlZmluZWQoeSkgfHwgZGVmaW5lZCh3KSB8fCBkZWZpbmVkKGgpKSB7XHJcbiAgICAgICAgICAgIGJpbGxib2FyZC5pbWFnZVN1YlJlZ2lvbiA9IG5ldyBCb3VuZGluZ1JlY3RhbmdsZSh4LCB5LCB3LCBoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vR0UgdHJlYXRzIGEgaGVhZGluZyBvZiB6ZXJvIGFzIG5vIGhlYWRpbmdcclxuICAgICAgICAvL1lvdSBjYW4gc3RpbGwgcG9pbnQgbm9ydGggdXNpbmcgYSAzNjAgZGVncmVlIGFuZ2xlIChvciBhbnkgbXVsdGlwbGUgb2YgMzYwKVxyXG4gICAgICAgIGlmIChkZWZpbmVkKGhlYWRpbmcpICYmIGhlYWRpbmcgIT09IDApIHtcclxuICAgICAgICAgICAgYmlsbGJvYXJkLnJvdGF0aW9uID0gQ2VzaXVtTWF0aC50b1JhZGlhbnMoLWhlYWRpbmcpO1xyXG4gICAgICAgICAgICBiaWxsYm9hcmQuYWxpZ25lZEF4aXMgPSBDYXJ0ZXNpYW4zLlVOSVRfWjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vSG90cG90IGlzIHRoZSBLTUwgZXF1aXZhbGVudCBvZiBwaXhlbCBvZmZzZXRcclxuICAgICAgICAvL1RoZSBob3RzcG90IG9yaWdpbiBpcyB0aGUgbG93ZXIgbGVmdCwgYnV0IHdlIGxlYXZlXHJcbiAgICAgICAgLy9vdXIgYmlsbGJvYXJkIG9yaWdpbiBhdCB0aGUgY2VudGVyIGFuZCBzaW1wbHlcclxuICAgICAgICAvL21vZGlmeSB0aGUgcGl4ZWwgb2Zmc2V0IHRvIHRha2UgdGhpcyBpbnRvIGFjY291bnRcclxuICAgICAgICBzY2FsZSA9IGRlZmF1bHRWYWx1ZShzY2FsZSwgMS4wKTtcclxuXHJcbiAgICAgICAgdmFyIHhPZmZzZXQ7XHJcbiAgICAgICAgdmFyIHlPZmZzZXQ7XHJcbiAgICAgICAgaWYgKGRlZmluZWQoaG90U3BvdFgpKSB7XHJcbiAgICAgICAgICAgIGlmIChob3RTcG90WFVuaXQgPT09ICdwaXhlbHMnKSB7XHJcbiAgICAgICAgICAgICAgICB4T2Zmc2V0ID0gLWhvdFNwb3RYICogc2NhbGU7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG90U3BvdFhVbml0ID09PSAnaW5zZXRQaXhlbHMnKSB7XHJcbiAgICAgICAgICAgICAgICB4T2Zmc2V0ID0gKGhvdFNwb3RYIC0gQklMTEJPQVJEX1NJWkUpICogc2NhbGU7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG90U3BvdFhVbml0ID09PSAnZnJhY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICB4T2Zmc2V0ID0gLWhvdFNwb3RYICogQklMTEJPQVJEX1NJWkUgKiBzY2FsZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB4T2Zmc2V0ICs9IEJJTExCT0FSRF9TSVpFICogMC41ICogc2NhbGU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZGVmaW5lZChob3RTcG90WSkpIHtcclxuICAgICAgICAgICAgaWYgKGhvdFNwb3RZVW5pdCA9PT0gJ3BpeGVscycpIHtcclxuICAgICAgICAgICAgICAgIHlPZmZzZXQgPSBob3RTcG90WSAqIHNjYWxlO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhvdFNwb3RZVW5pdCA9PT0gJ2luc2V0UGl4ZWxzJykge1xyXG4gICAgICAgICAgICAgICAgeU9mZnNldCA9ICgtaG90U3BvdFkgKyBCSUxMQk9BUkRfU0laRSkgKiBzY2FsZTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChob3RTcG90WVVuaXQgPT09ICdmcmFjdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIHlPZmZzZXQgPSBob3RTcG90WSAqIEJJTExCT0FSRF9TSVpFICogc2NhbGU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHlPZmZzZXQgLT0gQklMTEJPQVJEX1NJWkUgKiAwLjUgKiBzY2FsZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChkZWZpbmVkKHhPZmZzZXQpIHx8IGRlZmluZWQoeU9mZnNldCkpIHtcclxuICAgICAgICAgICAgYmlsbGJvYXJkLnBpeGVsT2Zmc2V0ID0gbmV3IENhcnRlc2lhbjIoeE9mZnNldCwgeU9mZnNldCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGFwcGx5U3R5bGUoZGF0YVNvdXJjZSwgc3R5bGVOb2RlLCB0YXJnZXRFbnRpdHksIHNvdXJjZVJlc291cmNlLCB1cmlSZXNvbHZlcikge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzdHlsZU5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgbm9kZSA9IHN0eWxlTm9kZS5jaGlsZE5vZGVzLml0ZW0oaSk7XHJcbiAgICAgICAgICAgIGlmIChub2RlLmxvY2FsTmFtZSA9PT0gJ0ljb25TdHlsZScpIHtcclxuICAgICAgICAgICAgICAgIHByb2Nlc3NCaWxsYm9hcmRJY29uKGRhdGFTb3VyY2UsIG5vZGUsIHRhcmdldEVudGl0eSwgc291cmNlUmVzb3VyY2UsIHVyaVJlc29sdmVyKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLmxvY2FsTmFtZSA9PT0gJ0xhYmVsU3R5bGUnKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGFiZWwgPSB0YXJnZXRFbnRpdHkubGFiZWw7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWRlZmluZWQobGFiZWwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwgPSBjcmVhdGVEZWZhdWx0TGFiZWwoKTtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRFbnRpdHkubGFiZWwgPSBsYWJlbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxhYmVsLnNjYWxlID0gZGVmYXVsdFZhbHVlKHF1ZXJ5TnVtZXJpY1ZhbHVlKG5vZGUsICdzY2FsZScsIG5hbWVzcGFjZXMua21sKSwgbGFiZWwuc2NhbGUpO1xyXG4gICAgICAgICAgICAgICAgbGFiZWwuZmlsbENvbG9yID0gZGVmYXVsdFZhbHVlKHF1ZXJ5Q29sb3JWYWx1ZShub2RlLCAnY29sb3InLCBuYW1lc3BhY2VzLmttbCksIGxhYmVsLmZpbGxDb2xvcik7XHJcbiAgICAgICAgICAgICAgICBsYWJlbC50ZXh0ID0gdGFyZ2V0RW50aXR5Lm5hbWU7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZS5sb2NhbE5hbWUgPT09ICdMaW5lU3R5bGUnKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG9seWxpbmUgPSB0YXJnZXRFbnRpdHkucG9seWxpbmU7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWRlZmluZWQocG9seWxpbmUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9seWxpbmUgPSBuZXcgUG9seWxpbmVHcmFwaGljcygpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldEVudGl0eS5wb2x5bGluZSA9IHBvbHlsaW5lO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcG9seWxpbmUud2lkdGggPSBxdWVyeU51bWVyaWNWYWx1ZShub2RlLCAnd2lkdGgnLCBuYW1lc3BhY2VzLmttbCk7XHJcbiAgICAgICAgICAgICAgICBwb2x5bGluZS5tYXRlcmlhbCA9IHF1ZXJ5Q29sb3JWYWx1ZShub2RlLCAnY29sb3InLCBuYW1lc3BhY2VzLmttbCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGVmaW5lZChxdWVyeUNvbG9yVmFsdWUobm9kZSwgJ291dGVyQ29sb3InLCBuYW1lc3BhY2VzLmd4KSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBvbmVUaW1lV2FybmluZygna21sLWd4Om91dGVyQ29sb3InLCAnS01MIC0gZ3g6b3V0ZXJDb2xvciBpcyBub3Qgc3VwcG9ydGVkIGluIGEgTGluZVN0eWxlJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZGVmaW5lZChxdWVyeU51bWVyaWNWYWx1ZShub2RlLCAnb3V0ZXJXaWR0aCcsIG5hbWVzcGFjZXMuZ3gpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9uZVRpbWVXYXJuaW5nKCdrbWwtZ3g6b3V0ZXJXaWR0aCcsICdLTUwgLSBneDpvdXRlcldpZHRoIGlzIG5vdCBzdXBwb3J0ZWQgaW4gYSBMaW5lU3R5bGUnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChkZWZpbmVkKHF1ZXJ5TnVtZXJpY1ZhbHVlKG5vZGUsICdwaHlzaWNhbFdpZHRoJywgbmFtZXNwYWNlcy5neCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb25lVGltZVdhcm5pbmcoJ2ttbC1neDpwaHlzaWNhbFdpZHRoJywgJ0tNTCAtIGd4OnBoeXNpY2FsV2lkdGggaXMgbm90IHN1cHBvcnRlZCBpbiBhIExpbmVTdHlsZScpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGRlZmluZWQocXVlcnlCb29sZWFuVmFsdWUobm9kZSwgJ2xhYmVsVmlzaWJpbGl0eScsIG5hbWVzcGFjZXMuZ3gpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9uZVRpbWVXYXJuaW5nKCdrbWwtZ3g6bGFiZWxWaXNpYmlsaXR5JywgJ0tNTCAtIGd4OmxhYmVsVmlzaWJpbGl0eSBpcyBub3Qgc3VwcG9ydGVkIGluIGEgTGluZVN0eWxlJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZS5sb2NhbE5hbWUgPT09ICdQb2x5U3R5bGUnKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG9seWdvbiA9IHRhcmdldEVudGl0eS5wb2x5Z29uO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFkZWZpbmVkKHBvbHlnb24pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9seWdvbiA9IGNyZWF0ZURlZmF1bHRQb2x5Z29uKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RW50aXR5LnBvbHlnb24gPSBwb2x5Z29uO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcG9seWdvbi5tYXRlcmlhbCA9IGRlZmF1bHRWYWx1ZShxdWVyeUNvbG9yVmFsdWUobm9kZSwgJ2NvbG9yJywgbmFtZXNwYWNlcy5rbWwpLCBwb2x5Z29uLm1hdGVyaWFsKTtcclxuICAgICAgICAgICAgICAgIHBvbHlnb24uZmlsbCA9IGRlZmF1bHRWYWx1ZShxdWVyeUJvb2xlYW5WYWx1ZShub2RlLCAnZmlsbCcsIG5hbWVzcGFjZXMua21sKSwgcG9seWdvbi5maWxsKTtcclxuICAgICAgICAgICAgICAgIHBvbHlnb24ub3V0bGluZSA9IGRlZmF1bHRWYWx1ZShxdWVyeUJvb2xlYW5WYWx1ZShub2RlLCAnb3V0bGluZScsIG5hbWVzcGFjZXMua21sKSwgcG9seWdvbi5vdXRsaW5lKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLmxvY2FsTmFtZSA9PT0gJ0JhbGxvb25TdHlsZScpIHtcclxuICAgICAgICAgICAgICAgIHZhciBiZ0NvbG9yID0gZGVmYXVsdFZhbHVlKHBhcnNlQ29sb3JTdHJpbmcocXVlcnlTdHJpbmdWYWx1ZShub2RlLCAnYmdDb2xvcicsIG5hbWVzcGFjZXMua21sKSksIENvbG9yLldISVRFKTtcclxuICAgICAgICAgICAgICAgIHZhciB0ZXh0Q29sb3IgPSBkZWZhdWx0VmFsdWUocGFyc2VDb2xvclN0cmluZyhxdWVyeVN0cmluZ1ZhbHVlKG5vZGUsICd0ZXh0Q29sb3InLCBuYW1lc3BhY2VzLmttbCkpLCBDb2xvci5CTEFDSyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGV4dCA9IHF1ZXJ5U3RyaW5nVmFsdWUobm9kZSwgJ3RleHQnLCBuYW1lc3BhY2VzLmttbCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9UaGlzIGlzIHB1cmVseSBhbiBpbnRlcm5hbCBwcm9wZXJ0eSB1c2VkIGluIHN0eWxlIHByb2Nlc3NpbmcsXHJcbiAgICAgICAgICAgICAgICAvL2l0IG5ldmVyIGVuZHMgdXAgb24gdGhlIGZpbmFsIGVudGl0eS5cclxuICAgICAgICAgICAgICAgIHRhcmdldEVudGl0eS5hZGRQcm9wZXJ0eSgnYmFsbG9vblN0eWxlJyk7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXRFbnRpdHkuYmFsbG9vblN0eWxlID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGJnQ29sb3IgOiBiZ0NvbG9yLFxyXG4gICAgICAgICAgICAgICAgICAgIHRleHRDb2xvciA6IHRleHRDb2xvcixcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0IDogdGV4dFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLmxvY2FsTmFtZSA9PT0gJ0xpc3RTdHlsZScpIHtcclxuICAgICAgICAgICAgICAgIHZhciBsaXN0SXRlbVR5cGUgPSBxdWVyeVN0cmluZ1ZhbHVlKG5vZGUsICdsaXN0SXRlbVR5cGUnLCBuYW1lc3BhY2VzLmttbCk7XHJcbiAgICAgICAgICAgICAgICBpZiAobGlzdEl0ZW1UeXBlID09PSAncmFkaW9Gb2xkZXInIHx8IGxpc3RJdGVtVHlwZSA9PT0gJ2NoZWNrT2ZmT25seScpIHtcclxuICAgICAgICAgICAgICAgICAgICBvbmVUaW1lV2FybmluZygna21sLWxpc3RTdHlsZS0nICsgbGlzdEl0ZW1UeXBlLCAnS01MIC0gVW5zdXBwb3J0ZWQgTGlzdFN0eWxlIHdpdGggbGlzdEl0ZW1UeXBlOiAnICsgbGlzdEl0ZW1UeXBlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvL1Byb2Nlc3NlcyBhbmQgbWVyZ2VzIGFueSBpbmxpbmUgc3R5bGVzIGZvciB0aGUgcHJvdmlkZWQgbm9kZSBpbnRvIHRoZSBwcm92aWRlZCBlbnRpdHkuXHJcbiAgICBmdW5jdGlvbiBjb21wdXRlRmluYWxTdHlsZShkYXRhU291cmNlLCBwbGFjZU1hcmssIHN0eWxlQ29sbGVjdGlvbiwgc291cmNlUmVzb3VyY2UsIHVyaVJlc29sdmVyKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBFbnRpdHkoKTtcclxuICAgICAgICB2YXIgc3R5bGVFbnRpdHk7XHJcblxyXG4gICAgICAgIC8vR29vZ2xlIGVhcnRoIHNlZW1zIHRvIGFsd2F5cyB1c2UgdGhlIGxhc3QgaW5saW5lIFN0eWxlL1N0eWxlTWFwIG9ubHlcclxuICAgICAgICB2YXIgc3R5bGVJbmRleCA9IC0xO1xyXG4gICAgICAgIHZhciBjaGlsZE5vZGVzID0gcGxhY2VNYXJrLmNoaWxkTm9kZXM7XHJcbiAgICAgICAgdmFyIGxlbmd0aCA9IGNoaWxkTm9kZXMubGVuZ3RoO1xyXG4gICAgICAgIGZvciAodmFyIHEgPSAwOyBxIDwgbGVuZ3RoOyBxKyspIHtcclxuICAgICAgICAgICAgdmFyIGNoaWxkID0gY2hpbGROb2Rlc1txXTtcclxuICAgICAgICAgICAgaWYgKGNoaWxkLmxvY2FsTmFtZSA9PT0gJ1N0eWxlJyB8fCBjaGlsZC5sb2NhbE5hbWUgPT09ICdTdHlsZU1hcCcpIHtcclxuICAgICAgICAgICAgICAgIHN0eWxlSW5kZXggPSBxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoc3R5bGVJbmRleCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgdmFyIGlubGluZVN0eWxlTm9kZSA9IGNoaWxkTm9kZXNbc3R5bGVJbmRleF07XHJcbiAgICAgICAgICAgIGlmIChpbmxpbmVTdHlsZU5vZGUubG9jYWxOYW1lID09PSAnU3R5bGUnKSB7XHJcbiAgICAgICAgICAgICAgICBhcHBseVN0eWxlKGRhdGFTb3VyY2UsIGlubGluZVN0eWxlTm9kZSwgcmVzdWx0LCBzb3VyY2VSZXNvdXJjZSwgdXJpUmVzb2x2ZXIpO1xyXG4gICAgICAgICAgICB9IGVsc2UgeyAvLyBTdHlsZU1hcFxyXG4gICAgICAgICAgICAgICAgdmFyIHBhaXJzID0gcXVlcnlDaGlsZE5vZGVzKGlubGluZVN0eWxlTm9kZSwgJ1BhaXInLCBuYW1lc3BhY2VzLmttbCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBwID0gMDsgcCA8IHBhaXJzLmxlbmd0aDsgcCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhaXIgPSBwYWlyc1twXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gcXVlcnlTdHJpbmdWYWx1ZShwYWlyLCAna2V5JywgbmFtZXNwYWNlcy5rbWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT09ICdub3JtYWwnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdHlsZVVybCA9IHF1ZXJ5U3RyaW5nVmFsdWUocGFpciwgJ3N0eWxlVXJsJywgbmFtZXNwYWNlcy5rbWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVmaW5lZChzdHlsZVVybCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlRW50aXR5ID0gc3R5bGVDb2xsZWN0aW9uLmdldEJ5SWQoc3R5bGVVcmwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkZWZpbmVkKHN0eWxlRW50aXR5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlRW50aXR5ID0gc3R5bGVDb2xsZWN0aW9uLmdldEJ5SWQoJyMnICsgc3R5bGVVcmwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlZmluZWQoc3R5bGVFbnRpdHkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lm1lcmdlKHN0eWxlRW50aXR5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub2RlID0gcXVlcnlGaXJzdE5vZGUocGFpciwgJ1N0eWxlJywgbmFtZXNwYWNlcy5rbWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHlTdHlsZShkYXRhU291cmNlLCBub2RlLCByZXN1bHQsIHNvdXJjZVJlc291cmNlLCB1cmlSZXNvbHZlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbmVUaW1lV2FybmluZygna21sLXN0eWxlTWFwLScgKyBrZXksICdLTUwgLSBVbnN1cHBvcnRlZCBTdHlsZU1hcCBrZXk6ICcgKyBrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9Hb29nbGUgZWFydGggc2VlbXMgdG8gYWx3YXlzIHVzZSB0aGUgZmlyc3QgZXh0ZXJuYWwgc3R5bGUgb25seS5cclxuICAgICAgICB2YXIgZXh0ZXJuYWxTdHlsZSA9IHF1ZXJ5U3RyaW5nVmFsdWUocGxhY2VNYXJrLCAnc3R5bGVVcmwnLCBuYW1lc3BhY2VzLmttbCk7XHJcbiAgICAgICAgaWYgKGRlZmluZWQoZXh0ZXJuYWxTdHlsZSkpIHtcclxuICAgICAgICAgICAgdmFyIGlkID0gZXh0ZXJuYWxTdHlsZTtcclxuICAgICAgICAgICAgaWYgKGV4dGVybmFsU3R5bGVbMF0gIT09ICcjJyAmJiBleHRlcm5hbFN0eWxlLmluZGV4T2YoJyMnKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0b2tlbnMgPSBleHRlcm5hbFN0eWxlLnNwbGl0KCcjJyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgdXJpID0gdG9rZW5zWzBdO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlc291cmNlID0gc291cmNlUmVzb3VyY2UuZ2V0RGVyaXZlZFJlc291cmNlKHtcclxuICAgICAgICAgICAgICAgICAgICB1cmw6IHVyaVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWQgPSByZXNvdXJjZS5nZXRVcmxDb21wb25lbnQoKSArICcjJyArIHRva2Vuc1sxXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgc3R5bGVFbnRpdHkgPSBzdHlsZUNvbGxlY3Rpb24uZ2V0QnlJZChpZCk7XHJcbiAgICAgICAgICAgIGlmICghZGVmaW5lZChzdHlsZUVudGl0eSkpIHtcclxuICAgICAgICAgICAgICAgIHN0eWxlRW50aXR5ID0gc3R5bGVDb2xsZWN0aW9uLmdldEJ5SWQoJyMnICsgaWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkZWZpbmVkKHN0eWxlRW50aXR5KSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0Lm1lcmdlKHN0eWxlRW50aXR5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvL0FzeW5jaHJvbm91c2x5IHByb2Nlc3NlcyBhbiBleHRlcm5hbCBzdHlsZSBmaWxlLlxyXG4gICAgZnVuY3Rpb24gcHJvY2Vzc0V4dGVybmFsU3R5bGVzKGRhdGFTb3VyY2UsIHJlc291cmNlLCBzdHlsZUNvbGxlY3Rpb24pIHtcclxuICAgICAgICByZXR1cm4gcmVzb3VyY2UuZmV0Y2hYTUwoKS50aGVuKGZ1bmN0aW9uKHN0eWxlS21sKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm9jZXNzU3R5bGVzKGRhdGFTb3VyY2UsIHN0eWxlS21sLCBzdHlsZUNvbGxlY3Rpb24sIHJlc291cmNlLCB0cnVlKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvL1Byb2Nlc3NlcyBhbGwgc2hhcmVkIGFuZCBleHRlcm5hbCBzdHlsZXMgYW5kIHN0b3Jlc1xyXG4gICAgLy90aGVpciBpZCBpbnRvIHRoZSBwcm92aWRlZCBzdHlsZUNvbGxlY3Rpb24uXHJcbiAgICAvL1JldHVybnMgYW4gYXJyYXkgb2YgcHJvbWlzZXMgdGhhdCB3aWxsIHJlc29sdmUgd2hlblxyXG4gICAgLy9lYWNoIHN0eWxlIGlzIGxvYWRlZC5cclxuICAgIGZ1bmN0aW9uIHByb2Nlc3NTdHlsZXMoZGF0YVNvdXJjZSwga21sLCBzdHlsZUNvbGxlY3Rpb24sIHNvdXJjZVJlc291cmNlLCBpc0V4dGVybmFsLCB1cmlSZXNvbHZlcikge1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHZhciBpZDtcclxuICAgICAgICB2YXIgc3R5bGVFbnRpdHk7XHJcblxyXG4gICAgICAgIHZhciBub2RlO1xyXG4gICAgICAgIHZhciBzdHlsZU5vZGVzID0gcXVlcnlOb2RlcyhrbWwsICdTdHlsZScsIG5hbWVzcGFjZXMua21sKTtcclxuICAgICAgICBpZiAoZGVmaW5lZChzdHlsZU5vZGVzKSkge1xyXG4gICAgICAgICAgICB2YXIgc3R5bGVOb2Rlc0xlbmd0aCA9IHN0eWxlTm9kZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc3R5bGVOb2Rlc0xlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBub2RlID0gc3R5bGVOb2Rlc1tpXTtcclxuICAgICAgICAgICAgICAgIGlkID0gcXVlcnlTdHJpbmdBdHRyaWJ1dGUobm9kZSwgJ2lkJyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGVmaW5lZChpZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZCA9ICcjJyArIGlkO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0V4dGVybmFsICYmIGRlZmluZWQoc291cmNlUmVzb3VyY2UpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkID0gc291cmNlUmVzb3VyY2UuZ2V0VXJsQ29tcG9uZW50KCkgKyBpZDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkZWZpbmVkKHN0eWxlQ29sbGVjdGlvbi5nZXRCeUlkKGlkKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVFbnRpdHkgPSBuZXcgRW50aXR5KHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkIDogaWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlQ29sbGVjdGlvbi5hZGQoc3R5bGVFbnRpdHkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcHBseVN0eWxlKGRhdGFTb3VyY2UsIG5vZGUsIHN0eWxlRW50aXR5LCBzb3VyY2VSZXNvdXJjZSwgdXJpUmVzb2x2ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHN0eWxlTWFwcyA9IHF1ZXJ5Tm9kZXMoa21sLCAnU3R5bGVNYXAnLCBuYW1lc3BhY2VzLmttbCk7XHJcbiAgICAgICAgaWYgKGRlZmluZWQoc3R5bGVNYXBzKSkge1xyXG4gICAgICAgICAgICB2YXIgc3R5bGVNYXBzTGVuZ3RoID0gc3R5bGVNYXBzLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHN0eWxlTWFwc0xlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3R5bGVNYXAgPSBzdHlsZU1hcHNbaV07XHJcbiAgICAgICAgICAgICAgICBpZCA9IHF1ZXJ5U3RyaW5nQXR0cmlidXRlKHN0eWxlTWFwLCAnaWQnKTtcclxuICAgICAgICAgICAgICAgIGlmIChkZWZpbmVkKGlkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYWlycyA9IHF1ZXJ5Q2hpbGROb2RlcyhzdHlsZU1hcCwgJ1BhaXInLCBuYW1lc3BhY2VzLmttbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgcCA9IDA7IHAgPCBwYWlycy5sZW5ndGg7IHArKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFpciA9IHBhaXJzW3BdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gcXVlcnlTdHJpbmdWYWx1ZShwYWlyLCAna2V5JywgbmFtZXNwYWNlcy5rbWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSAnbm9ybWFsJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQgPSAnIycgKyBpZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0V4dGVybmFsICYmIGRlZmluZWQoc291cmNlUmVzb3VyY2UpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQgPSBzb3VyY2VSZXNvdXJjZS5nZXRVcmxDb21wb25lbnQoKSArIGlkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkZWZpbmVkKHN0eWxlQ29sbGVjdGlvbi5nZXRCeUlkKGlkKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZUVudGl0eSA9IHN0eWxlQ29sbGVjdGlvbi5nZXRPckNyZWF0ZUVudGl0eShpZCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdHlsZVVybCA9IHF1ZXJ5U3RyaW5nVmFsdWUocGFpciwgJ3N0eWxlVXJsJywgbmFtZXNwYWNlcy5rbWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWZpbmVkKHN0eWxlVXJsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3R5bGVVcmxbMF0gIT09ICcjJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVVcmwgPSAnIycgKyBzdHlsZVVybDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRXh0ZXJuYWwgJiYgZGVmaW5lZChzb3VyY2VSZXNvdXJjZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlVXJsID0gc291cmNlUmVzb3VyY2UuZ2V0VXJsQ29tcG9uZW50KCkgKyBzdHlsZVVybDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYmFzZSA9IHN0eWxlQ29sbGVjdGlvbi5nZXRCeUlkKHN0eWxlVXJsKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWZpbmVkKGJhc2UpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZUVudGl0eS5tZXJnZShiYXNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBxdWVyeUZpcnN0Tm9kZShwYWlyLCAnU3R5bGUnLCBuYW1lc3BhY2VzLmttbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcGx5U3R5bGUoZGF0YVNvdXJjZSwgbm9kZSwgc3R5bGVFbnRpdHksIHNvdXJjZVJlc291cmNlLCB1cmlSZXNvbHZlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25lVGltZVdhcm5pbmcoJ2ttbC1zdHlsZU1hcC0nICsga2V5LCAnS01MIC0gVW5zdXBwb3J0ZWQgU3R5bGVNYXAga2V5OiAnICsga2V5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHByb21pc2VzID0gW107XHJcbiAgICAgICAgdmFyIHN0eWxlVXJsTm9kZXMgPSBrbWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3N0eWxlVXJsJyk7XHJcbiAgICAgICAgdmFyIHN0eWxlVXJsTm9kZXNMZW5ndGggPSBzdHlsZVVybE5vZGVzLmxlbmd0aDtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc3R5bGVVcmxOb2Rlc0xlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBzdHlsZVJlZmVyZW5jZSA9IHN0eWxlVXJsTm9kZXNbaV0udGV4dENvbnRlbnQ7XHJcbiAgICAgICAgICAgIGlmIChzdHlsZVJlZmVyZW5jZVswXSAhPT0gJyMnKSB7XHJcbiAgICAgICAgICAgICAgICAvL0FjY29yZGluZyB0byB0aGUgc3BlYywgYWxsIGxvY2FsIHN0eWxlcyBzaG91bGQgc3RhcnQgd2l0aCBhICNcclxuICAgICAgICAgICAgICAgIC8vYW5kIGV2ZXJ5dGhpbmcgZWxzZSBpcyBhbiBleHRlcm5hbCBzdHlsZSB0aGF0IGhhcyBhICMgc2VwZXJhdGluZ1xyXG4gICAgICAgICAgICAgICAgLy90aGUgVVJMIG9mIHRoZSBkb2N1bWVudCBhbmQgdGhlIHN0eWxlLiAgSG93ZXZlciwgR29vZ2xlIEVhcnRoXHJcbiAgICAgICAgICAgICAgICAvL2Fsc28gYWNjZXB0cyBzdHlsZVVybHMgd2l0aG91dCBhICMgYXMgbWVhbmluZyBhIGxvY2FsIHN0eWxlLlxyXG4gICAgICAgICAgICAgICAgdmFyIHRva2VucyA9IHN0eWxlUmVmZXJlbmNlLnNwbGl0KCcjJyk7XHJcbiAgICAgICAgICAgICAgICBpZiAodG9rZW5zLmxlbmd0aCA9PT0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB1cmkgPSB0b2tlbnNbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc291cmNlID0gc291cmNlUmVzb3VyY2UuZ2V0RGVyaXZlZFJlc291cmNlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiB1cmlcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChwcm9jZXNzRXh0ZXJuYWxTdHlsZXMoZGF0YVNvdXJjZSwgcmVzb3VyY2UsIHN0eWxlQ29sbGVjdGlvbikpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcHJvbWlzZXM7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY3JlYXRlRHJvcExpbmUoZW50aXR5Q29sbGVjdGlvbiwgZW50aXR5LCBzdHlsZUVudGl0eSkge1xyXG4gICAgICAgIHZhciBlbnRpdHlQb3NpdGlvbiA9IG5ldyBSZWZlcmVuY2VQcm9wZXJ0eShlbnRpdHlDb2xsZWN0aW9uLCBlbnRpdHkuaWQsIFsncG9zaXRpb24nXSk7XHJcbiAgICAgICAgdmFyIHN1cmZhY2VQb3NpdGlvbiA9IG5ldyBTY2FsZWRQb3NpdGlvblByb3BlcnR5KGVudGl0eS5wb3NpdGlvbik7XHJcbiAgICAgICAgZW50aXR5LnBvbHlsaW5lID0gZGVmaW5lZChzdHlsZUVudGl0eS5wb2x5bGluZSkgPyBzdHlsZUVudGl0eS5wb2x5bGluZS5jbG9uZSgpIDogbmV3IFBvbHlsaW5lR3JhcGhpY3MoKTtcclxuICAgICAgICBlbnRpdHkucG9seWxpbmUucG9zaXRpb25zID0gbmV3IFBvc2l0aW9uUHJvcGVydHlBcnJheShbZW50aXR5UG9zaXRpb24sIHN1cmZhY2VQb3NpdGlvbl0pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGhlaWdodFJlZmVyZW5jZUZyb21BbHRpdHVkZU1vZGUoYWx0aXR1ZGVNb2RlLCBneEFsdGl0dWRlTW9kZSkge1xyXG4gICAgICAgIGlmICghZGVmaW5lZChhbHRpdHVkZU1vZGUpICYmICFkZWZpbmVkKGd4QWx0aXR1ZGVNb2RlKSB8fCBhbHRpdHVkZU1vZGUgPT09ICdjbGFtcFRvR3JvdW5kJykge1xyXG4gICAgICAgICAgICByZXR1cm4gSGVpZ2h0UmVmZXJlbmNlLkNMQU1QX1RPX0dST1VORDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChhbHRpdHVkZU1vZGUgPT09ICdyZWxhdGl2ZVRvR3JvdW5kJykge1xyXG4gICAgICAgICAgICByZXR1cm4gSGVpZ2h0UmVmZXJlbmNlLlJFTEFUSVZFX1RPX0dST1VORDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChhbHRpdHVkZU1vZGUgPT09ICdhYnNvbHV0ZScpIHtcclxuICAgICAgICAgICAgcmV0dXJuIEhlaWdodFJlZmVyZW5jZS5OT05FO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGd4QWx0aXR1ZGVNb2RlID09PSAnY2xhbXBUb1NlYUZsb29yJykge1xyXG4gICAgICAgICAgICBvbmVUaW1lV2FybmluZygna21sLWd4OmFsdGl0dWRlTW9kZS1jbGFtcFRvU2VhRmxvb3InLCAnS01MIC0gPGd4OmFsdGl0dWRlTW9kZT46Y2xhbXBUb1NlYUZsb29yIGlzIGN1cnJlbnRseSBub3Qgc3VwcG9ydGVkLCB1c2luZyA8a21sOmFsdGl0dWRlTW9kZT46Y2xhbXBUb0dyb3VuZC4nKTtcclxuICAgICAgICAgICAgcmV0dXJuIEhlaWdodFJlZmVyZW5jZS5DTEFNUF9UT19HUk9VTkQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZ3hBbHRpdHVkZU1vZGUgPT09ICdyZWxhdGl2ZVRvU2VhRmxvb3InKSB7XHJcbiAgICAgICAgICAgIG9uZVRpbWVXYXJuaW5nKCdrbWwtZ3g6YWx0aXR1ZGVNb2RlLXJlbGF0aXZlVG9TZWFGbG9vcicsICdLTUwgLSA8Z3g6YWx0aXR1ZGVNb2RlPjpyZWxhdGl2ZVRvU2VhRmxvb3IgaXMgY3VycmVudGx5IG5vdCBzdXBwb3J0ZWQsIHVzaW5nIDxrbWw6YWx0aXR1ZGVNb2RlPjpyZWxhdGl2ZVRvR3JvdW5kLicpO1xyXG4gICAgICAgICAgICByZXR1cm4gSGVpZ2h0UmVmZXJlbmNlLlJFTEFUSVZFX1RPX0dST1VORDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChkZWZpbmVkKGFsdGl0dWRlTW9kZSkpIHtcclxuICAgICAgICAgICAgb25lVGltZVdhcm5pbmcoJ2ttbC1hbHRpdHVkZU1vZGUtdW5rbm93bicsICdLTUwgLSBVbmtub3duIDxrbWw6YWx0aXR1ZGVNb2RlPjonICsgYWx0aXR1ZGVNb2RlICsgJywgdXNpbmcgPGttbDphbHRpdHVkZU1vZGU+OkNMQU1QX1RPX0dST1VORC4nKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBvbmVUaW1lV2FybmluZygna21sLWd4OmFsdGl0dWRlTW9kZS11bmtub3duJywgJ0tNTCAtIFVua25vd24gPGd4OmFsdGl0dWRlTW9kZT46JyArIGd4QWx0aXR1ZGVNb2RlICsgJywgdXNpbmcgPGttbDphbHRpdHVkZU1vZGU+OkNMQU1QX1RPX0dST1VORC4nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENsYW1wIHRvIGdyb3VuZCBpcyB0aGUgZGVmYXVsdFxyXG4gICAgICAgIHJldHVybiBIZWlnaHRSZWZlcmVuY2UuQ0xBTVBfVE9fR1JPVU5EO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZVBvc2l0aW9uUHJvcGVydHlGcm9tQWx0aXR1ZGVNb2RlKHByb3BlcnR5LCBhbHRpdHVkZU1vZGUsIGd4QWx0aXR1ZGVNb2RlKSB7XHJcbiAgICAgICAgaWYgKGd4QWx0aXR1ZGVNb2RlID09PSAncmVsYXRpdmVUb1NlYUZsb29yJyB8fCBhbHRpdHVkZU1vZGUgPT09ICdhYnNvbHV0ZScgfHwgYWx0aXR1ZGVNb2RlID09PSAncmVsYXRpdmVUb0dyb3VuZCcpIHtcclxuICAgICAgICAgICAgLy9KdXN0IHJldHVybiB0aGUgZWxsaXBzb2lkIHJlZmVyZW5jZWQgcHJvcGVydHkgdW50aWwgd2Ugc3VwcG9ydCBNU0xcclxuICAgICAgICAgICAgcmV0dXJuIHByb3BlcnR5O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKChkZWZpbmVkKGFsdGl0dWRlTW9kZSkgJiYgYWx0aXR1ZGVNb2RlICE9PSAnY2xhbXBUb0dyb3VuZCcpIHx8IC8vXHJcbiAgICAgICAgICAgIChkZWZpbmVkKGd4QWx0aXR1ZGVNb2RlKSAmJiBneEFsdGl0dWRlTW9kZSAhPT0gJ2NsYW1wVG9TZWFGbG9vcicpKSB7XHJcbiAgICAgICAgICAgIG9uZVRpbWVXYXJuaW5nKCdrbWwtYWx0aXR1ZGVNb2RlLXVua25vd24nLCAnS01MIC0gVW5rbm93biBhbHRpdHVkZU1vZGU6ICcgKyBkZWZhdWx0VmFsdWUoYWx0aXR1ZGVNb2RlLCBneEFsdGl0dWRlTW9kZSkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ2xhbXAgdG8gZ3JvdW5kIGlzIHRoZSBkZWZhdWx0XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTY2FsZWRQb3NpdGlvblByb3BlcnR5KHByb3BlcnR5KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVQb3NpdGlvblByb3BlcnR5QXJyYXlGcm9tQWx0aXR1ZGVNb2RlKHByb3BlcnRpZXMsIGFsdGl0dWRlTW9kZSwgZ3hBbHRpdHVkZU1vZGUsIGVsbGlwc29pZCkge1xyXG4gICAgICAgIGlmICghZGVmaW5lZChwcm9wZXJ0aWVzKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGd4QWx0aXR1ZGVNb2RlID09PSAncmVsYXRpdmVUb1NlYUZsb29yJyB8fCBhbHRpdHVkZU1vZGUgPT09ICdhYnNvbHV0ZScgfHwgYWx0aXR1ZGVNb2RlID09PSAncmVsYXRpdmVUb0dyb3VuZCcpIHtcclxuICAgICAgICAgICAgLy9KdXN0IHJldHVybiB0aGUgZWxsaXBzb2lkIHJlZmVyZW5jZWQgcHJvcGVydHkgdW50aWwgd2Ugc3VwcG9ydCBNU0xcclxuICAgICAgICAgICAgcmV0dXJuIHByb3BlcnRpZXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoKGRlZmluZWQoYWx0aXR1ZGVNb2RlKSAmJiBhbHRpdHVkZU1vZGUgIT09ICdjbGFtcFRvR3JvdW5kJykgfHwgLy9cclxuICAgICAgICAgICAgKGRlZmluZWQoZ3hBbHRpdHVkZU1vZGUpICYmIGd4QWx0aXR1ZGVNb2RlICE9PSAnY2xhbXBUb1NlYUZsb29yJykpIHtcclxuICAgICAgICAgICAgb25lVGltZVdhcm5pbmcoJ2ttbC1hbHRpdHVkZU1vZGUtdW5rbm93bicsICdLTUwgLSBVbmtub3duIGFsdGl0dWRlTW9kZTogJyArIGRlZmF1bHRWYWx1ZShhbHRpdHVkZU1vZGUsIGd4QWx0aXR1ZGVNb2RlKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDbGFtcCB0byBncm91bmQgaXMgdGhlIGRlZmF1bHRcclxuICAgICAgICB2YXIgcHJvcGVydGllc0xlbmd0aCA9IHByb3BlcnRpZXMubGVuZ3RoO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcGVydGllc0xlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0eSA9IHByb3BlcnRpZXNbaV07XHJcbiAgICAgICAgICAgIGVsbGlwc29pZC5zY2FsZVRvR2VvZGV0aWNTdXJmYWNlKHByb3BlcnR5LCBwcm9wZXJ0eSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwcm9wZXJ0aWVzO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHByb2Nlc3NQb3NpdGlvbkdyYXBoaWNzKGRhdGFTb3VyY2UsIGVudGl0eSwgc3R5bGVFbnRpdHksIGhlaWdodFJlZmVyZW5jZSkge1xyXG4gICAgICAgIHZhciBsYWJlbCA9IGVudGl0eS5sYWJlbDtcclxuICAgICAgICBpZiAoIWRlZmluZWQobGFiZWwpKSB7XHJcbiAgICAgICAgICAgIGxhYmVsID0gZGVmaW5lZChzdHlsZUVudGl0eS5sYWJlbCkgPyBzdHlsZUVudGl0eS5sYWJlbC5jbG9uZSgpIDogY3JlYXRlRGVmYXVsdExhYmVsKCk7XHJcbiAgICAgICAgICAgIGVudGl0eS5sYWJlbCA9IGxhYmVsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsYWJlbC50ZXh0ID0gZW50aXR5Lm5hbWU7XHJcblxyXG4gICAgICAgIHZhciBiaWxsYm9hcmQgPSBlbnRpdHkuYmlsbGJvYXJkO1xyXG4gICAgICAgIGlmICghZGVmaW5lZChiaWxsYm9hcmQpKSB7XHJcbiAgICAgICAgICAgIGJpbGxib2FyZCA9IGRlZmluZWQoc3R5bGVFbnRpdHkuYmlsbGJvYXJkKSA/IHN0eWxlRW50aXR5LmJpbGxib2FyZC5jbG9uZSgpIDogY3JlYXRlRGVmYXVsdEJpbGxib2FyZCgpO1xyXG4gICAgICAgICAgICBlbnRpdHkuYmlsbGJvYXJkID0gYmlsbGJvYXJkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFkZWZpbmVkKGJpbGxib2FyZC5pbWFnZSkpIHtcclxuICAgICAgICAgICAgYmlsbGJvYXJkLmltYWdlID0gZGF0YVNvdXJjZS5fcGluQnVpbGRlci5mcm9tQ29sb3IoQ29sb3IuWUVMTE9XLCA2NCk7XHJcblxyXG4gICAgICAgIC8vIElmIHRoZXJlIHdlcmUgZW1wdHkgPEljb24+IHRhZ3MgaW4gdGhlIEtNTCwgdGhlbiBiaWxsYm9hcmQuaW1hZ2Ugd2FzIHNldCB0byBmYWxzZSBhYm92ZVxyXG4gICAgICAgIC8vIEhvd2V2ZXIsIGluIHRoaXMgY2FzZSwgdGhlIGZhbHNlIHZhbHVlIHdvdWxkIGhhdmUgYmVlbiBjb252ZXJ0ZWQgdG8gYSBwcm9wZXJ0eSBhZnRlcndhcmRzXHJcbiAgICAgICAgLy8gVGh1cywgd2UgY2hlY2sgaWYgYmlsbGJvYXJkLmltYWdlIGlzIGRlZmluZWQgd2l0aCB2YWx1ZSBvZiBmYWxzZVxyXG4gICAgICAgIH0gZWxzZSBpZiAoIWJpbGxib2FyZC5pbWFnZS5nZXRWYWx1ZSgpKSB7XHJcbiAgICAgICAgICAgIGJpbGxib2FyZC5pbWFnZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBzY2FsZSA9IDEuMDtcclxuICAgICAgICBpZiAoZGVmaW5lZChiaWxsYm9hcmQuc2NhbGUpKSB7XHJcbiAgICAgICAgICAgIHNjYWxlID0gYmlsbGJvYXJkLnNjYWxlLmdldFZhbHVlKCk7XHJcbiAgICAgICAgICAgIGlmIChzY2FsZSAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgbGFiZWwucGl4ZWxPZmZzZXQgPSBuZXcgQ2FydGVzaWFuMigoc2NhbGUgKiAxNikgKyAxLCAwKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vTWlub3IgdHdlYWtzIHRvIGJldHRlciBtYXRjaCBHb29nbGUgRWFydGguXHJcbiAgICAgICAgICAgICAgICBsYWJlbC5waXhlbE9mZnNldCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIGxhYmVsLmhvcml6b250YWxPcmlnaW4gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChkZWZpbmVkKGhlaWdodFJlZmVyZW5jZSkgJiYgZGF0YVNvdXJjZS5fY2xhbXBUb0dyb3VuZCkge1xyXG4gICAgICAgICAgICBiaWxsYm9hcmQuaGVpZ2h0UmVmZXJlbmNlID0gaGVpZ2h0UmVmZXJlbmNlO1xyXG4gICAgICAgICAgICBsYWJlbC5oZWlnaHRSZWZlcmVuY2UgPSBoZWlnaHRSZWZlcmVuY2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHByb2Nlc3NQYXRoR3JhcGhpY3MoZW50aXR5LCBzdHlsZUVudGl0eSkge1xyXG4gICAgICAgIHZhciBwYXRoID0gZW50aXR5LnBhdGg7XHJcbiAgICAgICAgaWYgKCFkZWZpbmVkKHBhdGgpKSB7XHJcbiAgICAgICAgICAgIHBhdGggPSBuZXcgUGF0aEdyYXBoaWNzKCk7XHJcbiAgICAgICAgICAgIHBhdGgubGVhZFRpbWUgPSAwO1xyXG4gICAgICAgICAgICBlbnRpdHkucGF0aCA9IHBhdGg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgcG9seWxpbmUgPSBzdHlsZUVudGl0eS5wb2x5bGluZTtcclxuICAgICAgICBpZiAoZGVmaW5lZChwb2x5bGluZSkpIHtcclxuICAgICAgICAgICAgcGF0aC5tYXRlcmlhbCA9IHBvbHlsaW5lLm1hdGVyaWFsO1xyXG4gICAgICAgICAgICBwYXRoLndpZHRoID0gcG9seWxpbmUud2lkdGg7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHByb2Nlc3NQb2ludChkYXRhU291cmNlLCBlbnRpdHlDb2xsZWN0aW9uLCBnZW9tZXRyeU5vZGUsIGVudGl0eSwgc3R5bGVFbnRpdHkpIHtcclxuICAgICAgICB2YXIgY29vcmRpbmF0ZXNTdHJpbmcgPSBxdWVyeVN0cmluZ1ZhbHVlKGdlb21ldHJ5Tm9kZSwgJ2Nvb3JkaW5hdGVzJywgbmFtZXNwYWNlcy5rbWwpO1xyXG4gICAgICAgIHZhciBhbHRpdHVkZU1vZGUgPSBxdWVyeVN0cmluZ1ZhbHVlKGdlb21ldHJ5Tm9kZSwgJ2FsdGl0dWRlTW9kZScsIG5hbWVzcGFjZXMua21sKTtcclxuICAgICAgICB2YXIgZ3hBbHRpdHVkZU1vZGUgPSBxdWVyeVN0cmluZ1ZhbHVlKGdlb21ldHJ5Tm9kZSwgJ2FsdGl0dWRlTW9kZScsIG5hbWVzcGFjZXMuZ3gpO1xyXG4gICAgICAgIHZhciBleHRydWRlID0gcXVlcnlCb29sZWFuVmFsdWUoZ2VvbWV0cnlOb2RlLCAnZXh0cnVkZScsIG5hbWVzcGFjZXMua21sKTtcclxuICAgICAgICB2YXIgZWxsaXBzb2lkID0gZGF0YVNvdXJjZS5fZWxsaXBzb2lkO1xyXG4gICAgICAgIHZhciBwb3NpdGlvbiA9IHJlYWRDb29yZGluYXRlKGNvb3JkaW5hdGVzU3RyaW5nLCBlbGxpcHNvaWQpO1xyXG5cclxuICAgICAgICBlbnRpdHkucG9zaXRpb24gPSBwb3NpdGlvbjtcclxuICAgICAgICBwcm9jZXNzUG9zaXRpb25HcmFwaGljcyhkYXRhU291cmNlLCBlbnRpdHksIHN0eWxlRW50aXR5LCBoZWlnaHRSZWZlcmVuY2VGcm9tQWx0aXR1ZGVNb2RlKGFsdGl0dWRlTW9kZSwgZ3hBbHRpdHVkZU1vZGUpKTtcclxuXHJcbiAgICAgICAgaWYgKGV4dHJ1ZGUgJiYgaXNFeHRydWRhYmxlKGFsdGl0dWRlTW9kZSwgZ3hBbHRpdHVkZU1vZGUpKSB7XHJcbiAgICAgICAgICAgIGNyZWF0ZURyb3BMaW5lKGVudGl0eUNvbGxlY3Rpb24sIGVudGl0eSwgc3R5bGVFbnRpdHkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcHJvY2Vzc0xpbmVTdHJpbmdPckxpbmVhclJpbmcoZGF0YVNvdXJjZSwgZW50aXR5Q29sbGVjdGlvbiwgZ2VvbWV0cnlOb2RlLCBlbnRpdHksIHN0eWxlRW50aXR5KSB7XHJcbiAgICAgICAgdmFyIGNvb3JkaW5hdGVzTm9kZSA9IHF1ZXJ5Rmlyc3ROb2RlKGdlb21ldHJ5Tm9kZSwgJ2Nvb3JkaW5hdGVzJywgbmFtZXNwYWNlcy5rbWwpO1xyXG4gICAgICAgIHZhciBhbHRpdHVkZU1vZGUgPSBxdWVyeVN0cmluZ1ZhbHVlKGdlb21ldHJ5Tm9kZSwgJ2FsdGl0dWRlTW9kZScsIG5hbWVzcGFjZXMua21sKTtcclxuICAgICAgICB2YXIgZ3hBbHRpdHVkZU1vZGUgPSBxdWVyeVN0cmluZ1ZhbHVlKGdlb21ldHJ5Tm9kZSwgJ2FsdGl0dWRlTW9kZScsIG5hbWVzcGFjZXMuZ3gpO1xyXG4gICAgICAgIHZhciBleHRydWRlID0gcXVlcnlCb29sZWFuVmFsdWUoZ2VvbWV0cnlOb2RlLCAnZXh0cnVkZScsIG5hbWVzcGFjZXMua21sKTtcclxuICAgICAgICB2YXIgdGVzc2VsbGF0ZSA9IHF1ZXJ5Qm9vbGVhblZhbHVlKGdlb21ldHJ5Tm9kZSwgJ3Rlc3NlbGxhdGUnLCBuYW1lc3BhY2VzLmttbCk7XHJcbiAgICAgICAgdmFyIGNhbkV4dHJ1ZGUgPSBpc0V4dHJ1ZGFibGUoYWx0aXR1ZGVNb2RlLCBneEFsdGl0dWRlTW9kZSk7XHJcbiAgICAgICAgdmFyIHpJbmRleCA9IHF1ZXJ5TnVtZXJpY1ZhbHVlKGdlb21ldHJ5Tm9kZSwgJ2RyYXdPcmRlcicsIG5hbWVzcGFjZXMuZ3gpO1xyXG5cclxuICAgICAgICB2YXIgZWxsaXBzb2lkID0gZGF0YVNvdXJjZS5fZWxsaXBzb2lkO1xyXG4gICAgICAgIHZhciBjb29yZGluYXRlcyA9IHJlYWRDb29yZGluYXRlcyhjb29yZGluYXRlc05vZGUsIGVsbGlwc29pZCk7XHJcbiAgICAgICAgdmFyIHBvbHlsaW5lID0gc3R5bGVFbnRpdHkucG9seWxpbmU7XHJcbiAgICAgICAgaWYgKGNhbkV4dHJ1ZGUgJiYgZXh0cnVkZSkge1xyXG4gICAgICAgICAgICB2YXIgd2FsbCA9IG5ldyBXYWxsR3JhcGhpY3MoKTtcclxuICAgICAgICAgICAgZW50aXR5LndhbGwgPSB3YWxsO1xyXG4gICAgICAgICAgICB3YWxsLnBvc2l0aW9ucyA9IGNvb3JkaW5hdGVzO1xyXG4gICAgICAgICAgICB2YXIgcG9seWdvbiA9IHN0eWxlRW50aXR5LnBvbHlnb247XHJcblxyXG4gICAgICAgICAgICBpZiAoZGVmaW5lZChwb2x5Z29uKSkge1xyXG4gICAgICAgICAgICAgICAgd2FsbC5maWxsID0gcG9seWdvbi5maWxsO1xyXG4gICAgICAgICAgICAgICAgd2FsbC5tYXRlcmlhbCA9IHBvbHlnb24ubWF0ZXJpYWw7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vQWx3YXlzIG91dGxpbmUgd2FsbHMgc28gdGhleSBzaG93IHVwIGluIDJELlxyXG4gICAgICAgICAgICB3YWxsLm91dGxpbmUgPSB0cnVlO1xyXG4gICAgICAgICAgICBpZiAoZGVmaW5lZChwb2x5bGluZSkpIHtcclxuICAgICAgICAgICAgICAgIHdhbGwub3V0bGluZUNvbG9yID0gZGVmaW5lZChwb2x5bGluZS5tYXRlcmlhbCkgPyBwb2x5bGluZS5tYXRlcmlhbC5jb2xvciA6IENvbG9yLldISVRFO1xyXG4gICAgICAgICAgICAgICAgd2FsbC5vdXRsaW5lV2lkdGggPSBwb2x5bGluZS53aWR0aDtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChkZWZpbmVkKHBvbHlnb24pKSB7XHJcbiAgICAgICAgICAgICAgICB3YWxsLm91dGxpbmVDb2xvciA9IGRlZmluZWQocG9seWdvbi5tYXRlcmlhbCkgPyBwb2x5Z29uLm1hdGVyaWFsLmNvbG9yIDogQ29sb3IuV0hJVEU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKGRhdGFTb3VyY2UuX2NsYW1wVG9Hcm91bmQgJiYgIWNhbkV4dHJ1ZGUgJiYgdGVzc2VsbGF0ZSkge1xyXG4gICAgICAgICAgICB2YXIgcG9seWxpbmVHcmFwaGljcyA9IG5ldyBQb2x5bGluZUdyYXBoaWNzKCk7XHJcbiAgICAgICAgICAgIHBvbHlsaW5lR3JhcGhpY3MuY2xhbXBUb0dyb3VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgIGVudGl0eS5wb2x5bGluZSA9IHBvbHlsaW5lR3JhcGhpY3M7XHJcbiAgICAgICAgICAgIHBvbHlsaW5lR3JhcGhpY3MucG9zaXRpb25zID0gY29vcmRpbmF0ZXM7XHJcbiAgICAgICAgICAgIGlmIChkZWZpbmVkKHBvbHlsaW5lKSkge1xyXG4gICAgICAgICAgICAgICAgcG9seWxpbmVHcmFwaGljcy5tYXRlcmlhbCA9IGRlZmluZWQocG9seWxpbmUubWF0ZXJpYWwpID8gcG9seWxpbmUubWF0ZXJpYWwuY29sb3IuZ2V0VmFsdWUoSXNvODYwMS5NSU5JTVVNX1ZBTFVFKSA6IENvbG9yLldISVRFO1xyXG4gICAgICAgICAgICAgICAgcG9seWxpbmVHcmFwaGljcy53aWR0aCA9IGRlZmF1bHRWYWx1ZShwb2x5bGluZS53aWR0aCwgMS4wKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHBvbHlsaW5lR3JhcGhpY3MubWF0ZXJpYWwgPSBDb2xvci5XSElURTtcclxuICAgICAgICAgICAgICAgIHBvbHlsaW5lR3JhcGhpY3Mud2lkdGggPSAxLjA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcG9seWxpbmVHcmFwaGljcy56SW5kZXggPSB6SW5kZXg7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGRlZmluZWQoekluZGV4KSkge1xyXG4gICAgICAgICAgICAgICAgb25lVGltZVdhcm5pbmcoJ2ttbC1neDpkcmF3T3JkZXInLCAnS01MIC0gZ3g6ZHJhd09yZGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gTGluZVN0cmluZ3Mgd2hlbiBjbGFtcFRvR3JvdW5kIGlzIGZhbHNlJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHBvbHlsaW5lID0gZGVmaW5lZChwb2x5bGluZSkgPyBwb2x5bGluZS5jbG9uZSgpIDogbmV3IFBvbHlsaW5lR3JhcGhpY3MoKTtcclxuICAgICAgICAgICAgZW50aXR5LnBvbHlsaW5lID0gcG9seWxpbmU7XHJcbiAgICAgICAgICAgIHBvbHlsaW5lLnBvc2l0aW9ucyA9IGNyZWF0ZVBvc2l0aW9uUHJvcGVydHlBcnJheUZyb21BbHRpdHVkZU1vZGUoY29vcmRpbmF0ZXMsIGFsdGl0dWRlTW9kZSwgZ3hBbHRpdHVkZU1vZGUsIGVsbGlwc29pZCk7XHJcbiAgICAgICAgICAgIGlmICghdGVzc2VsbGF0ZSB8fCBjYW5FeHRydWRlKSB7XHJcbiAgICAgICAgICAgICAgICBwb2x5bGluZS5mb2xsb3dTdXJmYWNlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHByb2Nlc3NQb2x5Z29uKGRhdGFTb3VyY2UsIGVudGl0eUNvbGxlY3Rpb24sIGdlb21ldHJ5Tm9kZSwgZW50aXR5LCBzdHlsZUVudGl0eSkge1xyXG4gICAgICAgIHZhciBvdXRlckJvdW5kYXJ5SXNOb2RlID0gcXVlcnlGaXJzdE5vZGUoZ2VvbWV0cnlOb2RlLCAnb3V0ZXJCb3VuZGFyeUlzJywgbmFtZXNwYWNlcy5rbWwpO1xyXG4gICAgICAgIHZhciBsaW5lYXJSaW5nTm9kZSA9IHF1ZXJ5Rmlyc3ROb2RlKG91dGVyQm91bmRhcnlJc05vZGUsICdMaW5lYXJSaW5nJywgbmFtZXNwYWNlcy5rbWwpO1xyXG4gICAgICAgIHZhciBjb29yZGluYXRlc05vZGUgPSBxdWVyeUZpcnN0Tm9kZShsaW5lYXJSaW5nTm9kZSwgJ2Nvb3JkaW5hdGVzJywgbmFtZXNwYWNlcy5rbWwpO1xyXG4gICAgICAgIHZhciBlbGxpcHNvaWQgPSBkYXRhU291cmNlLl9lbGxpcHNvaWQ7XHJcbiAgICAgICAgdmFyIGNvb3JkaW5hdGVzID0gcmVhZENvb3JkaW5hdGVzKGNvb3JkaW5hdGVzTm9kZSwgZWxsaXBzb2lkKTtcclxuICAgICAgICB2YXIgZXh0cnVkZSA9IHF1ZXJ5Qm9vbGVhblZhbHVlKGdlb21ldHJ5Tm9kZSwgJ2V4dHJ1ZGUnLCBuYW1lc3BhY2VzLmttbCk7XHJcbiAgICAgICAgdmFyIGFsdGl0dWRlTW9kZSA9IHF1ZXJ5U3RyaW5nVmFsdWUoZ2VvbWV0cnlOb2RlLCAnYWx0aXR1ZGVNb2RlJywgbmFtZXNwYWNlcy5rbWwpO1xyXG4gICAgICAgIHZhciBneEFsdGl0dWRlTW9kZSA9IHF1ZXJ5U3RyaW5nVmFsdWUoZ2VvbWV0cnlOb2RlLCAnYWx0aXR1ZGVNb2RlJywgbmFtZXNwYWNlcy5neCk7XHJcbiAgICAgICAgdmFyIGNhbkV4dHJ1ZGUgPSBpc0V4dHJ1ZGFibGUoYWx0aXR1ZGVNb2RlLCBneEFsdGl0dWRlTW9kZSk7XHJcblxyXG4gICAgICAgIHZhciBwb2x5Z29uID0gZGVmaW5lZChzdHlsZUVudGl0eS5wb2x5Z29uKSA/IHN0eWxlRW50aXR5LnBvbHlnb24uY2xvbmUoKSA6IGNyZWF0ZURlZmF1bHRQb2x5Z29uKCk7XHJcblxyXG4gICAgICAgIHZhciBwb2x5bGluZSA9IHN0eWxlRW50aXR5LnBvbHlsaW5lO1xyXG4gICAgICAgIGlmIChkZWZpbmVkKHBvbHlsaW5lKSkge1xyXG4gICAgICAgICAgICBwb2x5Z29uLm91dGxpbmVDb2xvciA9IGRlZmluZWQocG9seWxpbmUubWF0ZXJpYWwpID8gcG9seWxpbmUubWF0ZXJpYWwuY29sb3IgOiBDb2xvci5XSElURTtcclxuICAgICAgICAgICAgcG9seWdvbi5vdXRsaW5lV2lkdGggPSBwb2x5bGluZS53aWR0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZW50aXR5LnBvbHlnb24gPSBwb2x5Z29uO1xyXG5cclxuICAgICAgICBpZiAoY2FuRXh0cnVkZSkge1xyXG4gICAgICAgICAgICBwb2x5Z29uLnBlclBvc2l0aW9uSGVpZ2h0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgcG9seWdvbi5leHRydWRlZEhlaWdodCA9IGV4dHJ1ZGUgPyAwIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoIWRhdGFTb3VyY2UuX2NsYW1wVG9Hcm91bmQpIHtcclxuICAgICAgICAgICAgcG9seWdvbi5oZWlnaHQgPSAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGRlZmluZWQoY29vcmRpbmF0ZXMpKSB7XHJcbiAgICAgICAgICAgIHZhciBoaWVyYXJjaHkgPSBuZXcgUG9seWdvbkhpZXJhcmNoeShjb29yZGluYXRlcyk7XHJcbiAgICAgICAgICAgIHZhciBpbm5lckJvdW5kYXJ5SXNOb2RlcyA9IHF1ZXJ5Q2hpbGROb2RlcyhnZW9tZXRyeU5vZGUsICdpbm5lckJvdW5kYXJ5SXMnLCBuYW1lc3BhY2VzLmttbCk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaW5uZXJCb3VuZGFyeUlzTm9kZXMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIGxpbmVhclJpbmdOb2RlID0gcXVlcnlDaGlsZE5vZGVzKGlubmVyQm91bmRhcnlJc05vZGVzW2pdLCAnTGluZWFyUmluZycsIG5hbWVzcGFjZXMua21sKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgbGluZWFyUmluZ05vZGUubGVuZ3RoOyBrKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBjb29yZGluYXRlc05vZGUgPSBxdWVyeUZpcnN0Tm9kZShsaW5lYXJSaW5nTm9kZVtrXSwgJ2Nvb3JkaW5hdGVzJywgbmFtZXNwYWNlcy5rbWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVzID0gcmVhZENvb3JkaW5hdGVzKGNvb3JkaW5hdGVzTm9kZSwgZWxsaXBzb2lkKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGVmaW5lZChjb29yZGluYXRlcykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGllcmFyY2h5LmhvbGVzLnB1c2gobmV3IFBvbHlnb25IaWVyYXJjaHkoY29vcmRpbmF0ZXMpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcG9seWdvbi5oaWVyYXJjaHkgPSBoaWVyYXJjaHk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBwcm9jZXNzVHJhY2soZGF0YVNvdXJjZSwgZW50aXR5Q29sbGVjdGlvbiwgZ2VvbWV0cnlOb2RlLCBlbnRpdHksIHN0eWxlRW50aXR5KSB7XHJcbiAgICAgICAgdmFyIGFsdGl0dWRlTW9kZSA9IHF1ZXJ5U3RyaW5nVmFsdWUoZ2VvbWV0cnlOb2RlLCAnYWx0aXR1ZGVNb2RlJywgbmFtZXNwYWNlcy5rbWwpO1xyXG4gICAgICAgIHZhciBneEFsdGl0dWRlTW9kZSA9IHF1ZXJ5U3RyaW5nVmFsdWUoZ2VvbWV0cnlOb2RlLCAnYWx0aXR1ZGVNb2RlJywgbmFtZXNwYWNlcy5neCk7XHJcbiAgICAgICAgdmFyIGNvb3JkTm9kZXMgPSBxdWVyeUNoaWxkTm9kZXMoZ2VvbWV0cnlOb2RlLCAnY29vcmQnLCBuYW1lc3BhY2VzLmd4KTtcclxuICAgICAgICB2YXIgYW5nbGVOb2RlcyA9IHF1ZXJ5Q2hpbGROb2RlcyhnZW9tZXRyeU5vZGUsICdhbmdsZXMnLCBuYW1lc3BhY2VzLmd4KTtcclxuICAgICAgICB2YXIgdGltZU5vZGVzID0gcXVlcnlDaGlsZE5vZGVzKGdlb21ldHJ5Tm9kZSwgJ3doZW4nLCBuYW1lc3BhY2VzLmttbCk7XHJcbiAgICAgICAgdmFyIGV4dHJ1ZGUgPSBxdWVyeUJvb2xlYW5WYWx1ZShnZW9tZXRyeU5vZGUsICdleHRydWRlJywgbmFtZXNwYWNlcy5rbWwpO1xyXG4gICAgICAgIHZhciBjYW5FeHRydWRlID0gaXNFeHRydWRhYmxlKGFsdGl0dWRlTW9kZSwgZ3hBbHRpdHVkZU1vZGUpO1xyXG4gICAgICAgIHZhciBlbGxpcHNvaWQgPSBkYXRhU291cmNlLl9lbGxpcHNvaWQ7XHJcblxyXG4gICAgICAgIGlmIChhbmdsZU5vZGVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgb25lVGltZVdhcm5pbmcoJ2ttbC1neDphbmdsZXMnLCAnS01MIC0gZ3g6YW5nbGVzIGFyZSBub3Qgc3VwcG9ydGVkIGluIGd4OlRyYWNrcycpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGxlbmd0aCA9IE1hdGgubWluKGNvb3JkTm9kZXMubGVuZ3RoLCB0aW1lTm9kZXMubGVuZ3RoKTtcclxuICAgICAgICB2YXIgY29vcmRpbmF0ZXMgPSBbXTtcclxuICAgICAgICB2YXIgdGltZXMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IHJlYWRDb29yZGluYXRlKGNvb3JkTm9kZXNbaV0udGV4dENvbnRlbnQsIGVsbGlwc29pZCk7XHJcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzLnB1c2gocG9zaXRpb24pO1xyXG4gICAgICAgICAgICB0aW1lcy5wdXNoKEp1bGlhbkRhdGUuZnJvbUlzbzg2MDEodGltZU5vZGVzW2ldLnRleHRDb250ZW50KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBwcm9wZXJ0eSA9IG5ldyBTYW1wbGVkUG9zaXRpb25Qcm9wZXJ0eSgpO1xyXG4gICAgICAgIHByb3BlcnR5LmFkZFNhbXBsZXModGltZXMsIGNvb3JkaW5hdGVzKTtcclxuICAgICAgICBlbnRpdHkucG9zaXRpb24gPSBwcm9wZXJ0eTtcclxuICAgICAgICBwcm9jZXNzUG9zaXRpb25HcmFwaGljcyhkYXRhU291cmNlLCBlbnRpdHksIHN0eWxlRW50aXR5LCBoZWlnaHRSZWZlcmVuY2VGcm9tQWx0aXR1ZGVNb2RlKGFsdGl0dWRlTW9kZSwgZ3hBbHRpdHVkZU1vZGUpKTtcclxuICAgICAgICBwcm9jZXNzUGF0aEdyYXBoaWNzKGVudGl0eSwgc3R5bGVFbnRpdHkpO1xyXG5cclxuICAgICAgICBlbnRpdHkuYXZhaWxhYmlsaXR5ID0gbmV3IFRpbWVJbnRlcnZhbENvbGxlY3Rpb24oKTtcclxuXHJcbiAgICAgICAgaWYgKHRpbWVOb2Rlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGVudGl0eS5hdmFpbGFiaWxpdHkuYWRkSW50ZXJ2YWwobmV3IFRpbWVJbnRlcnZhbCh7XHJcbiAgICAgICAgICAgICAgICBzdGFydCA6IHRpbWVzWzBdLFxyXG4gICAgICAgICAgICAgICAgc3RvcCA6IHRpbWVzW3RpbWVzLmxlbmd0aCAtIDFdXHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChjYW5FeHRydWRlICYmIGV4dHJ1ZGUpIHtcclxuICAgICAgICAgICAgY3JlYXRlRHJvcExpbmUoZW50aXR5Q29sbGVjdGlvbiwgZW50aXR5LCBzdHlsZUVudGl0eSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhZGRUb011bHRpVHJhY2sodGltZXMsIHBvc2l0aW9ucywgY29tcG9zaXRlLCBhdmFpbGFiaWxpdHksIGRyb3BTaG93UHJvcGVydHksIGV4dHJ1ZGUsIGFsdGl0dWRlTW9kZSwgZ3hBbHRpdHVkZU1vZGUsIGluY2x1ZGVFbmRQb2ludHMpIHtcclxuICAgICAgICB2YXIgc3RhcnQgPSB0aW1lc1swXTtcclxuICAgICAgICB2YXIgc3RvcCA9IHRpbWVzW3RpbWVzLmxlbmd0aCAtIDFdO1xyXG5cclxuICAgICAgICB2YXIgZGF0YSA9IG5ldyBTYW1wbGVkUG9zaXRpb25Qcm9wZXJ0eSgpO1xyXG4gICAgICAgIGRhdGEuYWRkU2FtcGxlcyh0aW1lcywgcG9zaXRpb25zKTtcclxuXHJcbiAgICAgICAgY29tcG9zaXRlLmludGVydmFscy5hZGRJbnRlcnZhbChuZXcgVGltZUludGVydmFsKHtcclxuICAgICAgICAgICAgc3RhcnQgOiBzdGFydCxcclxuICAgICAgICAgICAgc3RvcCA6IHN0b3AsXHJcbiAgICAgICAgICAgIGlzU3RhcnRJbmNsdWRlZCA6IGluY2x1ZGVFbmRQb2ludHMsXHJcbiAgICAgICAgICAgIGlzU3RvcEluY2x1ZGVkIDogaW5jbHVkZUVuZFBvaW50cyxcclxuICAgICAgICAgICAgZGF0YSA6IGNyZWF0ZVBvc2l0aW9uUHJvcGVydHlGcm9tQWx0aXR1ZGVNb2RlKGRhdGEsIGFsdGl0dWRlTW9kZSwgZ3hBbHRpdHVkZU1vZGUpXHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIGF2YWlsYWJpbGl0eS5hZGRJbnRlcnZhbChuZXcgVGltZUludGVydmFsKHtcclxuICAgICAgICAgICAgc3RhcnQgOiBzdGFydCxcclxuICAgICAgICAgICAgc3RvcCA6IHN0b3AsXHJcbiAgICAgICAgICAgIGlzU3RhcnRJbmNsdWRlZCA6IGluY2x1ZGVFbmRQb2ludHMsXHJcbiAgICAgICAgICAgIGlzU3RvcEluY2x1ZGVkIDogaW5jbHVkZUVuZFBvaW50c1xyXG4gICAgICAgIH0pKTtcclxuICAgICAgICBkcm9wU2hvd1Byb3BlcnR5LmludGVydmFscy5hZGRJbnRlcnZhbChuZXcgVGltZUludGVydmFsKHtcclxuICAgICAgICAgICAgc3RhcnQgOiBzdGFydCxcclxuICAgICAgICAgICAgc3RvcCA6IHN0b3AsXHJcbiAgICAgICAgICAgIGlzU3RhcnRJbmNsdWRlZCA6IGluY2x1ZGVFbmRQb2ludHMsXHJcbiAgICAgICAgICAgIGlzU3RvcEluY2x1ZGVkIDogaW5jbHVkZUVuZFBvaW50cyxcclxuICAgICAgICAgICAgZGF0YSA6IGV4dHJ1ZGVcclxuICAgICAgICB9KSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcHJvY2Vzc011bHRpVHJhY2soZGF0YVNvdXJjZSwgZW50aXR5Q29sbGVjdGlvbiwgZ2VvbWV0cnlOb2RlLCBlbnRpdHksIHN0eWxlRW50aXR5KSB7XHJcbiAgICAgICAgLy8gTXVsdGl0cmFjayBvcHRpb25zIGRvIG5vdCB3b3JrIGluIEdFIGFzIGRldGFpbGVkIGluIHRoZSBzcGVjLFxyXG4gICAgICAgIC8vIHJhdGhlciB0aGFuIGFsdGl0dWRlTW9kZSBiZWluZyBhdCB0aGUgTXVsdGlUcmFjayBsZXZlbCxcclxuICAgICAgICAvLyBHRSBqdXN0IGRlZmVycyBhbGwgc2V0dGluZ3MgdG8gdGhlIHVuZGVybHlpbmcgdHJhY2suXHJcblxyXG4gICAgICAgIHZhciBpbnRlcnBvbGF0ZSA9IHF1ZXJ5Qm9vbGVhblZhbHVlKGdlb21ldHJ5Tm9kZSwgJ2ludGVycG9sYXRlJywgbmFtZXNwYWNlcy5neCk7XHJcbiAgICAgICAgdmFyIHRyYWNrTm9kZXMgPSBxdWVyeUNoaWxkTm9kZXMoZ2VvbWV0cnlOb2RlLCAnVHJhY2snLCBuYW1lc3BhY2VzLmd4KTtcclxuXHJcbiAgICAgICAgdmFyIHRpbWVzO1xyXG4gICAgICAgIHZhciBsYXN0U3RvcDtcclxuICAgICAgICB2YXIgbGFzdFN0b3BQb3NpdGlvbjtcclxuICAgICAgICB2YXIgbmVlZERyb3BMaW5lID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIGRyb3BTaG93UHJvcGVydHkgPSBuZXcgVGltZUludGVydmFsQ29sbGVjdGlvblByb3BlcnR5KCk7XHJcbiAgICAgICAgdmFyIGF2YWlsYWJpbGl0eSA9IG5ldyBUaW1lSW50ZXJ2YWxDb2xsZWN0aW9uKCk7XHJcbiAgICAgICAgdmFyIGNvbXBvc2l0ZSA9IG5ldyBDb21wb3NpdGVQb3NpdGlvblByb3BlcnR5KCk7XHJcbiAgICAgICAgdmFyIGVsbGlwc29pZCA9IGRhdGFTb3VyY2UuX2VsbGlwc29pZDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdHJhY2tOb2Rlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgdHJhY2tOb2RlID0gdHJhY2tOb2Rlc1tpXTtcclxuICAgICAgICAgICAgdmFyIHRpbWVOb2RlcyA9IHF1ZXJ5Q2hpbGROb2Rlcyh0cmFja05vZGUsICd3aGVuJywgbmFtZXNwYWNlcy5rbWwpO1xyXG4gICAgICAgICAgICB2YXIgY29vcmROb2RlcyA9IHF1ZXJ5Q2hpbGROb2Rlcyh0cmFja05vZGUsICdjb29yZCcsIG5hbWVzcGFjZXMuZ3gpO1xyXG4gICAgICAgICAgICB2YXIgYWx0aXR1ZGVNb2RlID0gcXVlcnlTdHJpbmdWYWx1ZSh0cmFja05vZGUsICdhbHRpdHVkZU1vZGUnLCBuYW1lc3BhY2VzLmttbCk7XHJcbiAgICAgICAgICAgIHZhciBneEFsdGl0dWRlTW9kZSA9IHF1ZXJ5U3RyaW5nVmFsdWUodHJhY2tOb2RlLCAnYWx0aXR1ZGVNb2RlJywgbmFtZXNwYWNlcy5neCk7XHJcbiAgICAgICAgICAgIHZhciBjYW5FeHRydWRlID0gaXNFeHRydWRhYmxlKGFsdGl0dWRlTW9kZSwgZ3hBbHRpdHVkZU1vZGUpO1xyXG4gICAgICAgICAgICB2YXIgZXh0cnVkZSA9IHF1ZXJ5Qm9vbGVhblZhbHVlKHRyYWNrTm9kZSwgJ2V4dHJ1ZGUnLCBuYW1lc3BhY2VzLmttbCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gTWF0aC5taW4oY29vcmROb2Rlcy5sZW5ndGgsIHRpbWVOb2Rlcy5sZW5ndGgpO1xyXG5cclxuICAgICAgICAgICAgdmFyIHBvc2l0aW9ucyA9IFtdO1xyXG4gICAgICAgICAgICB0aW1lcyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IGxlbmd0aDsgeCsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb24gPSByZWFkQ29vcmRpbmF0ZShjb29yZE5vZGVzW3hdLnRleHRDb250ZW50LCBlbGxpcHNvaWQpO1xyXG4gICAgICAgICAgICAgICAgcG9zaXRpb25zLnB1c2gocG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgdGltZXMucHVzaChKdWxpYW5EYXRlLmZyb21Jc284NjAxKHRpbWVOb2Rlc1t4XS50ZXh0Q29udGVudCkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoaW50ZXJwb2xhdGUpIHtcclxuICAgICAgICAgICAgICAgIC8vSWYgd2UgYXJlIGludGVycG9sYXRpbmcsIHRoZW4gd2UgbmVlZCB0byBmaWxsIGluIHRoZSBlbmQgb2ZcclxuICAgICAgICAgICAgICAgIC8vdGhlIGxhc3QgdHJhY2sgYW5kIHRoZSBiZWdpbm5pbmcgb2YgdGhpcyBvbmUgd2l0aCBhIHNhbXBsZWRcclxuICAgICAgICAgICAgICAgIC8vcHJvcGVydHkuICBGcm9tIHRlc3RpbmcgaW4gR29vZ2xlIEVhcnRoLCB0aGlzIHByb3BlcnR5XHJcbiAgICAgICAgICAgICAgICAvL2lzIG5ldmVyIGV4dHJ1ZGVkIGFuZCBhbHdheXMgYWJzb2x1dGUuXHJcbiAgICAgICAgICAgICAgICBpZiAoZGVmaW5lZChsYXN0U3RvcCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBhZGRUb011bHRpVHJhY2soW2xhc3RTdG9wLCB0aW1lc1swXV0sIFtsYXN0U3RvcFBvc2l0aW9uLCBwb3NpdGlvbnNbMF1dLCBjb21wb3NpdGUsIGF2YWlsYWJpbGl0eSwgZHJvcFNob3dQcm9wZXJ0eSwgZmFsc2UsICdhYnNvbHV0ZScsIHVuZGVmaW5lZCwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGFzdFN0b3AgPSB0aW1lc1tsZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgICAgIGxhc3RTdG9wUG9zaXRpb24gPSBwb3NpdGlvbnNbcG9zaXRpb25zLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBhZGRUb011bHRpVHJhY2sodGltZXMsIHBvc2l0aW9ucywgY29tcG9zaXRlLCBhdmFpbGFiaWxpdHksIGRyb3BTaG93UHJvcGVydHksIGNhbkV4dHJ1ZGUgJiYgZXh0cnVkZSwgYWx0aXR1ZGVNb2RlLCBneEFsdGl0dWRlTW9kZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIG5lZWREcm9wTGluZSA9IG5lZWREcm9wTGluZSB8fCAoY2FuRXh0cnVkZSAmJiBleHRydWRlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGVudGl0eS5hdmFpbGFiaWxpdHkgPSBhdmFpbGFiaWxpdHk7XHJcbiAgICAgICAgZW50aXR5LnBvc2l0aW9uID0gY29tcG9zaXRlO1xyXG4gICAgICAgIHByb2Nlc3NQb3NpdGlvbkdyYXBoaWNzKGRhdGFTb3VyY2UsIGVudGl0eSwgc3R5bGVFbnRpdHkpO1xyXG4gICAgICAgIHByb2Nlc3NQYXRoR3JhcGhpY3MoZW50aXR5LCBzdHlsZUVudGl0eSk7XHJcbiAgICAgICAgaWYgKG5lZWREcm9wTGluZSkge1xyXG4gICAgICAgICAgICBjcmVhdGVEcm9wTGluZShlbnRpdHlDb2xsZWN0aW9uLCBlbnRpdHksIHN0eWxlRW50aXR5KTtcclxuICAgICAgICAgICAgZW50aXR5LnBvbHlsaW5lLnNob3cgPSBkcm9wU2hvd1Byb3BlcnR5O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGdlb21ldHJ5VHlwZXMgPSB7XHJcbiAgICAgICAgUG9pbnQgOiBwcm9jZXNzUG9pbnQsXHJcbiAgICAgICAgTGluZVN0cmluZyA6IHByb2Nlc3NMaW5lU3RyaW5nT3JMaW5lYXJSaW5nLFxyXG4gICAgICAgIExpbmVhclJpbmcgOiBwcm9jZXNzTGluZVN0cmluZ09yTGluZWFyUmluZyxcclxuICAgICAgICBQb2x5Z29uIDogcHJvY2Vzc1BvbHlnb24sXHJcbiAgICAgICAgVHJhY2sgOiBwcm9jZXNzVHJhY2ssXHJcbiAgICAgICAgTXVsdGlUcmFjayA6IHByb2Nlc3NNdWx0aVRyYWNrLFxyXG4gICAgICAgIE11bHRpR2VvbWV0cnkgOiBwcm9jZXNzTXVsdGlHZW9tZXRyeSxcclxuICAgICAgICBNb2RlbCA6IHByb2Nlc3NVbnN1cHBvcnRlZEdlb21ldHJ5XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIHByb2Nlc3NNdWx0aUdlb21ldHJ5KGRhdGFTb3VyY2UsIGVudGl0eUNvbGxlY3Rpb24sIGdlb21ldHJ5Tm9kZSwgZW50aXR5LCBzdHlsZUVudGl0eSwgY29udGV4dCkge1xyXG4gICAgICAgIHZhciBjaGlsZE5vZGVzID0gZ2VvbWV0cnlOb2RlLmNoaWxkTm9kZXM7XHJcbiAgICAgICAgdmFyIGhhc0dlb21ldHJ5ID0gZmFsc2U7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNoaWxkTm9kZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGNoaWxkTm9kZSA9IGNoaWxkTm9kZXMuaXRlbShpKTtcclxuICAgICAgICAgICAgdmFyIGdlb21ldHJ5UHJvY2Vzc29yID0gZ2VvbWV0cnlUeXBlc1tjaGlsZE5vZGUubG9jYWxOYW1lXTtcclxuICAgICAgICAgICAgaWYgKGRlZmluZWQoZ2VvbWV0cnlQcm9jZXNzb3IpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRFbnRpdHkgPSBjcmVhdGVFbnRpdHkoY2hpbGROb2RlLCBlbnRpdHlDb2xsZWN0aW9uLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgIGNoaWxkRW50aXR5LnBhcmVudCA9IGVudGl0eTtcclxuICAgICAgICAgICAgICAgIGNoaWxkRW50aXR5Lm5hbWUgPSBlbnRpdHkubmFtZTtcclxuICAgICAgICAgICAgICAgIGNoaWxkRW50aXR5LmF2YWlsYWJpbGl0eSA9IGVudGl0eS5hdmFpbGFiaWxpdHk7XHJcbiAgICAgICAgICAgICAgICBjaGlsZEVudGl0eS5kZXNjcmlwdGlvbiA9IGVudGl0eS5kZXNjcmlwdGlvbjtcclxuICAgICAgICAgICAgICAgIGNoaWxkRW50aXR5LmttbCA9IGVudGl0eS5rbWw7XHJcbiAgICAgICAgICAgICAgICBpZiAoZ2VvbWV0cnlQcm9jZXNzb3IoZGF0YVNvdXJjZSwgZW50aXR5Q29sbGVjdGlvbiwgY2hpbGROb2RlLCBjaGlsZEVudGl0eSwgc3R5bGVFbnRpdHkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFzR2VvbWV0cnkgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gaGFzR2VvbWV0cnk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcHJvY2Vzc1Vuc3VwcG9ydGVkR2VvbWV0cnkoZGF0YVNvdXJjZSwgZW50aXR5Q29sbGVjdGlvbiwgZ2VvbWV0cnlOb2RlLCBlbnRpdHksIHN0eWxlRW50aXR5KSB7XHJcbiAgICAgICAgb25lVGltZVdhcm5pbmcoJ2ttbC11bnN1cHBvcnRlZEdlb21ldHJ5JywgJ0tNTCAtIFVuc3VwcG9ydGVkIGdlb21ldHJ5OiAnICsgZ2VvbWV0cnlOb2RlLmxvY2FsTmFtZSk7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHByb2Nlc3NFeHRlbmRlZERhdGEobm9kZSwgZW50aXR5KSB7XHJcbiAgICAgICAgdmFyIGV4dGVuZGVkRGF0YU5vZGUgPSBxdWVyeUZpcnN0Tm9kZShub2RlLCAnRXh0ZW5kZWREYXRhJywgbmFtZXNwYWNlcy5rbWwpO1xyXG5cclxuICAgICAgICBpZiAoIWRlZmluZWQoZXh0ZW5kZWREYXRhTm9kZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChkZWZpbmVkKHF1ZXJ5Rmlyc3ROb2RlKGV4dGVuZGVkRGF0YU5vZGUsICdTY2hlbWFEYXRhJywgbmFtZXNwYWNlcy5rbWwpKSkge1xyXG4gICAgICAgICAgICBvbmVUaW1lV2FybmluZygna21sLXNjaGVtYURhdGEnLCAnS01MIC0gU2NoZW1hRGF0YSBpcyB1bnN1cHBvcnRlZCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGVmaW5lZChxdWVyeVN0cmluZ0F0dHJpYnV0ZShleHRlbmRlZERhdGFOb2RlLCAneG1sbnM6cHJlZml4JykpKSB7XHJcbiAgICAgICAgICAgIG9uZVRpbWVXYXJuaW5nKCdrbWwtZXh0ZW5kZWREYXRhJywgJ0tNTCAtIEV4dGVuZGVkRGF0YSB3aXRoIHhtbG5zOnByZWZpeCBpcyB1bnN1cHBvcnRlZCcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgICAgIHZhciBkYXRhTm9kZXMgPSBxdWVyeUNoaWxkTm9kZXMoZXh0ZW5kZWREYXRhTm9kZSwgJ0RhdGEnLCBuYW1lc3BhY2VzLmttbCk7XHJcbiAgICAgICAgaWYgKGRlZmluZWQoZGF0YU5vZGVzKSkge1xyXG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gZGF0YU5vZGVzLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRhdGFOb2RlID0gZGF0YU5vZGVzW2ldO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBxdWVyeVN0cmluZ0F0dHJpYnV0ZShkYXRhTm9kZSwgJ25hbWUnKTtcclxuICAgICAgICAgICAgICAgIGlmIChkZWZpbmVkKG5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W25hbWVdID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5TmFtZSA6IHF1ZXJ5U3RyaW5nVmFsdWUoZGF0YU5vZGUsICdkaXNwbGF5TmFtZScsIG5hbWVzcGFjZXMua21sKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgOiBxdWVyeVN0cmluZ1ZhbHVlKGRhdGFOb2RlLCAndmFsdWUnLCBuYW1lc3BhY2VzLmttbClcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVudGl0eS5rbWwuZXh0ZW5kZWREYXRhID0gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBzY3JhdGNoRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcblxyXG4gICAgZnVuY3Rpb24gcHJvY2Vzc0Rlc2NyaXB0aW9uKG5vZGUsIGVudGl0eSwgc3R5bGVFbnRpdHksIHVyaVJlc29sdmVyLCBzb3VyY2VSZXNvdXJjZSkge1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHZhciBrZXk7XHJcbiAgICAgICAgdmFyIGtleXM7XHJcblxyXG4gICAgICAgIHZhciBrbWxEYXRhID0gZW50aXR5LmttbDtcclxuICAgICAgICB2YXIgZXh0ZW5kZWREYXRhID0ga21sRGF0YS5leHRlbmRlZERhdGE7XHJcbiAgICAgICAgdmFyIGRlc2NyaXB0aW9uID0gcXVlcnlTdHJpbmdWYWx1ZShub2RlLCAnZGVzY3JpcHRpb24nLCBuYW1lc3BhY2VzLmttbCk7XHJcblxyXG4gICAgICAgIHZhciBiYWxsb29uU3R5bGUgPSBkZWZhdWx0VmFsdWUoZW50aXR5LmJhbGxvb25TdHlsZSwgc3R5bGVFbnRpdHkuYmFsbG9vblN0eWxlKTtcclxuXHJcbiAgICAgICAgdmFyIGJhY2tncm91bmQgPSBDb2xvci5XSElURTtcclxuICAgICAgICB2YXIgZm9yZWdyb3VuZCA9IENvbG9yLkJMQUNLO1xyXG4gICAgICAgIHZhciB0ZXh0ID0gZGVzY3JpcHRpb247XHJcblxyXG4gICAgICAgIGlmIChkZWZpbmVkKGJhbGxvb25TdHlsZSkpIHtcclxuICAgICAgICAgICAgYmFja2dyb3VuZCA9IGRlZmF1bHRWYWx1ZShiYWxsb29uU3R5bGUuYmdDb2xvciwgQ29sb3IuV0hJVEUpO1xyXG4gICAgICAgICAgICBmb3JlZ3JvdW5kID0gZGVmYXVsdFZhbHVlKGJhbGxvb25TdHlsZS50ZXh0Q29sb3IsIENvbG9yLkJMQUNLKTtcclxuICAgICAgICAgICAgdGV4dCA9IGRlZmF1bHRWYWx1ZShiYWxsb29uU3R5bGUudGV4dCwgZGVzY3JpcHRpb24pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHZhbHVlO1xyXG4gICAgICAgIGlmIChkZWZpbmVkKHRleHQpKSB7XHJcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoJyRbbmFtZV0nLCBkZWZhdWx0VmFsdWUoZW50aXR5Lm5hbWUsICcnKSk7XHJcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoJyRbZGVzY3JpcHRpb25dJywgZGVmYXVsdFZhbHVlKGRlc2NyaXB0aW9uLCAnJykpO1xyXG4gICAgICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKCckW2FkZHJlc3NdJywgZGVmYXVsdFZhbHVlKGttbERhdGEuYWRkcmVzcywgJycpKTtcclxuICAgICAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgnJFtTbmlwcGV0XScsIGRlZmF1bHRWYWx1ZShrbWxEYXRhLnNuaXBwZXQsICcnKSk7XHJcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoJyRbaWRdJywgZW50aXR5LmlkKTtcclxuXHJcbiAgICAgICAgICAgIC8vV2hpbGUgbm90IGV4cGxpY2l0bHkgZGVmaW5lZCBieSB0aGUgT0dDIHNwZWMsIGluIEdvb2dsZSBFYXJ0aFxyXG4gICAgICAgICAgICAvL1RoZSBhcHBlYXJhbmNlIG9mIGdlRGlyZWN0aW9ucyBhZGRzIHRoZSBkaXJlY3Rpb25zIHRvL2Zyb20gbGlua3NcclxuICAgICAgICAgICAgLy9XZSBzaW1wbHkgcmVwbGFjZSB0aGlzIHN0cmluZyB3aXRoIG5vdGhpbmcuXHJcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoJyRbZ2VEaXJlY3Rpb25zXScsICcnKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChkZWZpbmVkKGV4dGVuZGVkRGF0YSkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBtYXRjaGVzID0gdGV4dC5tYXRjaCgvXFwkXFxbLis/XFxdL2cpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZXMgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbWF0Y2hlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG9rZW4gPSBtYXRjaGVzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHlOYW1lID0gdG9rZW4uc3Vic3RyKDIsIHRva2VuLmxlbmd0aCAtIDMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXNEaXNwbGF5TmFtZSA9IC9cXC9kaXNwbGF5TmFtZSQvLnRlc3QocHJvcGVydHlOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHlOYW1lID0gcHJvcGVydHlOYW1lLnJlcGxhY2UoL1xcL2Rpc3BsYXlOYW1lJC8sICcnKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZXh0ZW5kZWREYXRhW3Byb3BlcnR5TmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWZpbmVkKHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBpc0Rpc3BsYXlOYW1lID8gdmFsdWUuZGlzcGxheU5hbWUgOiB2YWx1ZS52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVmaW5lZCh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UodG9rZW4sIGRlZmF1bHRWYWx1ZSh2YWx1ZSwgJycpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAoZGVmaW5lZChleHRlbmRlZERhdGEpKSB7XHJcbiAgICAgICAgICAgIC8vSWYgbm8gZGVzY3JpcHRpb24gZXhpc3RzLCBidWlsZCBhIHRhYmxlIG91dCBvZiB0aGUgZXh0ZW5kZWQgZGF0YVxyXG4gICAgICAgICAgICBrZXlzID0gT2JqZWN0LmtleXMoZXh0ZW5kZWREYXRhKTtcclxuICAgICAgICAgICAgaWYgKGtleXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdGV4dCA9ICc8dGFibGUgY2xhc3M9XCJjZXNpdW0taW5mb0JveC1kZWZhdWx0VGFibGUgY2VzaXVtLWluZm9Cb3gtZGVmYXVsdFRhYmxlLWxpZ2h0ZXJcIj48dGJvZHk+JztcclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAga2V5ID0ga2V5c1tpXTtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGV4dGVuZGVkRGF0YVtrZXldO1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHQgKz0gJzx0cj48dGg+JyArIGRlZmF1bHRWYWx1ZSh2YWx1ZS5kaXNwbGF5TmFtZSwga2V5KSArICc8L3RoPjx0ZD4nICsgZGVmYXVsdFZhbHVlKHZhbHVlLnZhbHVlLCAnJykgKyAnPC90ZD48L3RyPic7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0ZXh0ICs9ICc8L3Rib2R5PjwvdGFibGU+JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFkZWZpbmVkKHRleHQpKSB7XHJcbiAgICAgICAgICAgIC8vTm8gZGVzY3JpcHRpb25cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9UdXJucyBub24tZXhwbGljaXQgbGlua3MgaW50byBjbGlja2FibGUgbGlua3MuXHJcbiAgICAgICAgdGV4dCA9IGF1dG9saW5rZXIubGluayh0ZXh0KTtcclxuXHJcbiAgICAgICAgLy9Vc2UgYSB0ZW1wb3JhcnkgZGl2IHRvIG1hbmlwdWxhdGUgdGhlIGxpbmtzXHJcbiAgICAgICAgLy9zbyB0aGF0IHRoZXkgb3BlbiBpbiBhIG5ldyB3aW5kb3cuXHJcbiAgICAgICAgc2NyYXRjaERpdi5pbm5lckhUTUwgPSB0ZXh0O1xyXG4gICAgICAgIHZhciBsaW5rcyA9IHNjcmF0Y2hEaXYucXVlcnlTZWxlY3RvckFsbCgnYScpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsaW5rcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBsaW5rc1tpXS5zZXRBdHRyaWJ1dGUoJ3RhcmdldCcsICdfYmxhbmsnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vUmV3cml0ZSBhbnkgS01aIGVtYmVkZGVkIHVybHNcclxuICAgICAgICBpZiAoZGVmaW5lZCh1cmlSZXNvbHZlcikgJiYgdXJpUmVzb2x2ZXIua2V5cy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIGVtYmVkRGF0YVVyaXMoc2NyYXRjaERpdiwgJ2EnLCAnaHJlZicsIHVyaVJlc29sdmVyKTtcclxuICAgICAgICAgICAgZW1iZWREYXRhVXJpcyhzY3JhdGNoRGl2LCAnaW1nJywgJ3NyYycsIHVyaVJlc29sdmVyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vTWFrZSByZWxhdGl2ZSB1cmxzIGFic29sdXRlIHVzaW5nIHRoZSBzb3VyY2VSZXNvdXJjZVxyXG4gICAgICAgIGFwcGx5QmFzZVBhdGgoc2NyYXRjaERpdiwgJ2EnLCAnaHJlZicsIHNvdXJjZVJlc291cmNlKTtcclxuICAgICAgICBhcHBseUJhc2VQYXRoKHNjcmF0Y2hEaXYsICdpbWcnLCAnc3JjJywgc291cmNlUmVzb3VyY2UpO1xyXG5cclxuICAgICAgICB2YXIgdG1wID0gJzxkaXYgY2xhc3M9XCJjZXNpdW0taW5mb0JveC1kZXNjcmlwdGlvbi1saWdodGVyXCIgc3R5bGU9XCInO1xyXG4gICAgICAgIHRtcCArPSAnb3ZlcmZsb3c6YXV0bzsnO1xyXG4gICAgICAgIHRtcCArPSAnd29yZC13cmFwOmJyZWFrLXdvcmQ7JztcclxuICAgICAgICB0bXAgKz0gJ2JhY2tncm91bmQtY29sb3I6JyArIGJhY2tncm91bmQudG9Dc3NDb2xvclN0cmluZygpICsgJzsnO1xyXG4gICAgICAgIHRtcCArPSAnY29sb3I6JyArIGZvcmVncm91bmQudG9Dc3NDb2xvclN0cmluZygpICsgJzsnO1xyXG4gICAgICAgIHRtcCArPSAnXCI+JztcclxuICAgICAgICB0bXAgKz0gc2NyYXRjaERpdi5pbm5lckhUTUwgKyAnPC9kaXY+JztcclxuICAgICAgICBzY3JhdGNoRGl2LmlubmVySFRNTCA9ICcnO1xyXG5cclxuICAgICAgICAvL1NldCB0aGUgZmluYWwgSFRNTCBhcyB0aGUgZGVzY3JpcHRpb24uXHJcbiAgICAgICAgZW50aXR5LmRlc2NyaXB0aW9uID0gdG1wO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHByb2Nlc3NGZWF0dXJlKGRhdGFTb3VyY2UsIHBhcmVudCwgZmVhdHVyZU5vZGUsIGVudGl0eUNvbGxlY3Rpb24sIHN0eWxlQ29sbGVjdGlvbiwgc291cmNlUmVzb3VyY2UsIHVyaVJlc29sdmVyLCBwcm9taXNlcywgY29udGV4dCkge1xyXG4gICAgICAgIHZhciBlbnRpdHkgPSBjcmVhdGVFbnRpdHkoZmVhdHVyZU5vZGUsIGVudGl0eUNvbGxlY3Rpb24sIGNvbnRleHQpO1xyXG4gICAgICAgIHZhciBrbWxEYXRhID0gZW50aXR5LmttbDtcclxuICAgICAgICB2YXIgc3R5bGVFbnRpdHkgPSBjb21wdXRlRmluYWxTdHlsZShkYXRhU291cmNlLCBmZWF0dXJlTm9kZSwgc3R5bGVDb2xsZWN0aW9uLCBzb3VyY2VSZXNvdXJjZSwgdXJpUmVzb2x2ZXIpO1xyXG5cclxuICAgICAgICB2YXIgbmFtZSA9IHF1ZXJ5U3RyaW5nVmFsdWUoZmVhdHVyZU5vZGUsICduYW1lJywgbmFtZXNwYWNlcy5rbWwpO1xyXG4gICAgICAgIGVudGl0eS5uYW1lID0gbmFtZTtcclxuICAgICAgICBlbnRpdHkucGFyZW50ID0gcGFyZW50O1xyXG5cclxuICAgICAgICB2YXIgYXZhaWxhYmlsaXR5ID0gcHJvY2Vzc1RpbWVTcGFuKGZlYXR1cmVOb2RlKTtcclxuICAgICAgICBpZiAoIWRlZmluZWQoYXZhaWxhYmlsaXR5KSkge1xyXG4gICAgICAgICAgICBhdmFpbGFiaWxpdHkgPSBwcm9jZXNzVGltZVN0YW1wKGZlYXR1cmVOb2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZW50aXR5LmF2YWlsYWJpbGl0eSA9IGF2YWlsYWJpbGl0eTtcclxuXHJcbiAgICAgICAgbWVyZ2VBdmFpbGFiaWxpdHlXaXRoUGFyZW50KGVudGl0eSk7XHJcblxyXG4gICAgICAgIC8vIFBlciBLTUwgc3BlYyBcIkEgRmVhdHVyZSBpcyB2aXNpYmxlIG9ubHkgaWYgaXQgYW5kIGFsbCBpdHMgYW5jZXN0b3JzIGFyZSB2aXNpYmxlLlwiXHJcbiAgICAgICAgZnVuY3Rpb24gYW5jZXN0cnlJc1Zpc2libGUocGFyZW50RW50aXR5KSB7XHJcbiAgICAgICAgICAgIGlmICghcGFyZW50RW50aXR5KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcGFyZW50RW50aXR5LnNob3cgJiYgYW5jZXN0cnlJc1Zpc2libGUocGFyZW50RW50aXR5LnBhcmVudCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgdmlzaWJpbGl0eSA9IHF1ZXJ5Qm9vbGVhblZhbHVlKGZlYXR1cmVOb2RlLCAndmlzaWJpbGl0eScsIG5hbWVzcGFjZXMua21sKTtcclxuICAgICAgICBlbnRpdHkuc2hvdyA9IGFuY2VzdHJ5SXNWaXNpYmxlKHBhcmVudCkgJiYgZGVmYXVsdFZhbHVlKHZpc2liaWxpdHksIHRydWUpO1xyXG4gICAgICAgIC8vdmFyIG9wZW4gPSBxdWVyeUJvb2xlYW5WYWx1ZShmZWF0dXJlTm9kZSwgJ29wZW4nLCBuYW1lc3BhY2VzLmttbCk7XHJcblxyXG4gICAgICAgIHZhciBhdXRob3JOb2RlID0gcXVlcnlGaXJzdE5vZGUoZmVhdHVyZU5vZGUsICdhdXRob3InLCBuYW1lc3BhY2VzLmF0b20pO1xyXG4gICAgICAgIHZhciBhdXRob3IgPSBrbWxEYXRhLmF1dGhvcjtcclxuICAgICAgICBhdXRob3IubmFtZSA9IHF1ZXJ5U3RyaW5nVmFsdWUoYXV0aG9yTm9kZSwgJ25hbWUnLCBuYW1lc3BhY2VzLmF0b20pO1xyXG4gICAgICAgIGF1dGhvci51cmkgPSBxdWVyeVN0cmluZ1ZhbHVlKGF1dGhvck5vZGUsICd1cmknLCBuYW1lc3BhY2VzLmF0b20pO1xyXG4gICAgICAgIGF1dGhvci5lbWFpbCA9IHF1ZXJ5U3RyaW5nVmFsdWUoYXV0aG9yTm9kZSwgJ2VtYWlsJywgbmFtZXNwYWNlcy5hdG9tKTtcclxuXHJcbiAgICAgICAgdmFyIGxpbmtOb2RlID0gcXVlcnlGaXJzdE5vZGUoZmVhdHVyZU5vZGUsICdsaW5rJywgbmFtZXNwYWNlcy5hdG9tKTtcclxuICAgICAgICB2YXIgbGluayA9IGttbERhdGEubGluaztcclxuICAgICAgICBsaW5rLmhyZWYgPSBxdWVyeVN0cmluZ0F0dHJpYnV0ZShsaW5rTm9kZSwgJ2hyZWYnKTtcclxuICAgICAgICBsaW5rLmhyZWZsYW5nID0gcXVlcnlTdHJpbmdBdHRyaWJ1dGUobGlua05vZGUsICdocmVmbGFuZycpO1xyXG4gICAgICAgIGxpbmsucmVsID0gcXVlcnlTdHJpbmdBdHRyaWJ1dGUobGlua05vZGUsICdyZWwnKTtcclxuICAgICAgICBsaW5rLnR5cGUgPSBxdWVyeVN0cmluZ0F0dHJpYnV0ZShsaW5rTm9kZSwgJ3R5cGUnKTtcclxuICAgICAgICBsaW5rLnRpdGxlID0gcXVlcnlTdHJpbmdBdHRyaWJ1dGUobGlua05vZGUsICd0aXRsZScpO1xyXG4gICAgICAgIGxpbmsubGVuZ3RoID0gcXVlcnlTdHJpbmdBdHRyaWJ1dGUobGlua05vZGUsICdsZW5ndGgnKTtcclxuXHJcbiAgICAgICAga21sRGF0YS5hZGRyZXNzID0gcXVlcnlTdHJpbmdWYWx1ZShmZWF0dXJlTm9kZSwgJ2FkZHJlc3MnLCBuYW1lc3BhY2VzLmttbCk7XHJcbiAgICAgICAga21sRGF0YS5waG9uZU51bWJlciA9IHF1ZXJ5U3RyaW5nVmFsdWUoZmVhdHVyZU5vZGUsICdwaG9uZU51bWJlcicsIG5hbWVzcGFjZXMua21sKTtcclxuICAgICAgICBrbWxEYXRhLnNuaXBwZXQgPSBxdWVyeVN0cmluZ1ZhbHVlKGZlYXR1cmVOb2RlLCAnU25pcHBldCcsIG5hbWVzcGFjZXMua21sKTtcclxuXHJcbiAgICAgICAgcHJvY2Vzc0V4dGVuZGVkRGF0YShmZWF0dXJlTm9kZSwgZW50aXR5KTtcclxuICAgICAgICBwcm9jZXNzRGVzY3JpcHRpb24oZmVhdHVyZU5vZGUsIGVudGl0eSwgc3R5bGVFbnRpdHksIHVyaVJlc29sdmVyLCBzb3VyY2VSZXNvdXJjZSk7XHJcblxyXG4gICAgICAgIHZhciBlbGxpcHNvaWQgPSBkYXRhU291cmNlLl9lbGxpcHNvaWQ7XHJcbiAgICAgICAgcHJvY2Vzc0xvb2tBdChmZWF0dXJlTm9kZSwgZW50aXR5LCBlbGxpcHNvaWQpO1xyXG4gICAgICAgIHByb2Nlc3NDYW1lcmEoZmVhdHVyZU5vZGUsIGVudGl0eSwgZWxsaXBzb2lkKTtcclxuXHJcbiAgICAgICAgaWYgKGRlZmluZWQocXVlcnlGaXJzdE5vZGUoZmVhdHVyZU5vZGUsICdSZWdpb24nLCBuYW1lc3BhY2VzLmttbCkpKSB7XHJcbiAgICAgICAgICAgIG9uZVRpbWVXYXJuaW5nKCdrbWwtcmVnaW9uJywgJ0tNTCAtIFBsYWNlbWFyayBSZWdpb25zIGFyZSB1bnN1cHBvcnRlZCcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZW50aXR5IDogZW50aXR5LFxyXG4gICAgICAgICAgICBzdHlsZUVudGl0eSA6IHN0eWxlRW50aXR5XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBFbnN1cmUgU3BlY3MvRGF0YS9LTUwvdW5zdXBwb3J0ZWQua21sIGlzIGtlcHQgdXAgdG8gZGF0ZSB3aXRoIHRoZXNlIHN1cHBvcnRlZCB0eXBlc1xyXG4gICAgdmFyIGZlYXR1cmVUeXBlcyA9IHtcclxuICAgICAgICBEb2N1bWVudCA6IHByb2Nlc3NEb2N1bWVudCxcclxuICAgICAgICBGb2xkZXIgOiBwcm9jZXNzRm9sZGVyLFxyXG4gICAgICAgIFBsYWNlbWFyayA6IHByb2Nlc3NQbGFjZW1hcmssXHJcbiAgICAgICAgTmV0d29ya0xpbmsgOiBwcm9jZXNzTmV0d29ya0xpbmssXHJcbiAgICAgICAgR3JvdW5kT3ZlcmxheSA6IHByb2Nlc3NHcm91bmRPdmVybGF5LFxyXG4gICAgICAgIFBob3RvT3ZlcmxheSA6IHByb2Nlc3NVbnN1cHBvcnRlZEZlYXR1cmUsXHJcbiAgICAgICAgU2NyZWVuT3ZlcmxheSA6IHByb2Nlc3NVbnN1cHBvcnRlZEZlYXR1cmUsXHJcbiAgICAgICAgVG91ciA6IHByb2Nlc3NUb3VyXHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIHByb2Nlc3NEb2N1bWVudChkYXRhU291cmNlLCBwYXJlbnQsIG5vZGUsIGVudGl0eUNvbGxlY3Rpb24sIHN0eWxlQ29sbGVjdGlvbiwgc291cmNlUmVzb3VyY2UsIHVyaVJlc29sdmVyLCBwcm9taXNlcywgY29udGV4dCkge1xyXG4gICAgICAgIHZhciBmZWF0dXJlVHlwZU5hbWVzID0gT2JqZWN0LmtleXMoZmVhdHVyZVR5cGVzKTtcclxuICAgICAgICB2YXIgZmVhdHVyZVR5cGVOYW1lc0xlbmd0aCA9IGZlYXR1cmVUeXBlTmFtZXMubGVuZ3RoO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZlYXR1cmVUeXBlTmFtZXNMZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgZmVhdHVyZU5hbWUgPSBmZWF0dXJlVHlwZU5hbWVzW2ldO1xyXG4gICAgICAgICAgICB2YXIgcHJvY2Vzc0ZlYXR1cmVOb2RlID0gZmVhdHVyZVR5cGVzW2ZlYXR1cmVOYW1lXTtcclxuXHJcbiAgICAgICAgICAgIHZhciBjaGlsZE5vZGVzID0gbm9kZS5jaGlsZE5vZGVzO1xyXG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gY2hpbGROb2Rlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAodmFyIHEgPSAwOyBxIDwgbGVuZ3RoOyBxKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkTm9kZXNbcV07XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQubG9jYWxOYW1lID09PSBmZWF0dXJlTmFtZSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICgobmFtZXNwYWNlcy5rbWwuaW5kZXhPZihjaGlsZC5uYW1lc3BhY2VVUkkpICE9PSAtMSkgfHwgKG5hbWVzcGFjZXMuZ3guaW5kZXhPZihjaGlsZC5uYW1lc3BhY2VVUkkpICE9PSAtMSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0ZlYXR1cmVOb2RlKGRhdGFTb3VyY2UsIHBhcmVudCwgY2hpbGQsIGVudGl0eUNvbGxlY3Rpb24sIHN0eWxlQ29sbGVjdGlvbiwgc291cmNlUmVzb3VyY2UsIHVyaVJlc29sdmVyLCBwcm9taXNlcywgY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcHJvY2Vzc0ZvbGRlcihkYXRhU291cmNlLCBwYXJlbnQsIG5vZGUsIGVudGl0eUNvbGxlY3Rpb24sIHN0eWxlQ29sbGVjdGlvbiwgc291cmNlUmVzb3VyY2UsIHVyaVJlc29sdmVyLCBwcm9taXNlcywgY29udGV4dCkge1xyXG4gICAgICAgIHZhciByID0gcHJvY2Vzc0ZlYXR1cmUoZGF0YVNvdXJjZSwgcGFyZW50LCBub2RlLCBlbnRpdHlDb2xsZWN0aW9uLCBzdHlsZUNvbGxlY3Rpb24sIHNvdXJjZVJlc291cmNlLCB1cmlSZXNvbHZlciwgcHJvbWlzZXMsIGNvbnRleHQpO1xyXG4gICAgICAgIHByb2Nlc3NEb2N1bWVudChkYXRhU291cmNlLCByLmVudGl0eSwgbm9kZSwgZW50aXR5Q29sbGVjdGlvbiwgc3R5bGVDb2xsZWN0aW9uLCBzb3VyY2VSZXNvdXJjZSwgdXJpUmVzb2x2ZXIsIHByb21pc2VzLCBjb250ZXh0KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBwcm9jZXNzUGxhY2VtYXJrKGRhdGFTb3VyY2UsIHBhcmVudCwgcGxhY2VtYXJrLCBlbnRpdHlDb2xsZWN0aW9uLCBzdHlsZUNvbGxlY3Rpb24sIHNvdXJjZVJlc291cmNlLCB1cmlSZXNvbHZlciwgcHJvbWlzZXMsIGNvbnRleHQpIHtcclxuICAgICAgICB2YXIgciA9IHByb2Nlc3NGZWF0dXJlKGRhdGFTb3VyY2UsIHBhcmVudCwgcGxhY2VtYXJrLCBlbnRpdHlDb2xsZWN0aW9uLCBzdHlsZUNvbGxlY3Rpb24sIHNvdXJjZVJlc291cmNlLCB1cmlSZXNvbHZlciwgcHJvbWlzZXMsIGNvbnRleHQpO1xyXG4gICAgICAgIHZhciBlbnRpdHkgPSByLmVudGl0eTtcclxuICAgICAgICB2YXIgc3R5bGVFbnRpdHkgPSByLnN0eWxlRW50aXR5O1xyXG5cclxuICAgICAgICB2YXIgaGFzR2VvbWV0cnkgPSBmYWxzZTtcclxuICAgICAgICB2YXIgY2hpbGROb2RlcyA9IHBsYWNlbWFyay5jaGlsZE5vZGVzO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGxlbiAmJiAhaGFzR2VvbWV0cnk7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgY2hpbGROb2RlID0gY2hpbGROb2Rlcy5pdGVtKGkpO1xyXG4gICAgICAgICAgICB2YXIgZ2VvbWV0cnlQcm9jZXNzb3IgPSBnZW9tZXRyeVR5cGVzW2NoaWxkTm9kZS5sb2NhbE5hbWVdO1xyXG4gICAgICAgICAgICBpZiAoZGVmaW5lZChnZW9tZXRyeVByb2Nlc3NvcikpIHtcclxuICAgICAgICAgICAgICAgIC8vIHBhc3MgdGhlIHBsYWNlbWFyayBlbnRpdHkgaWQgYXMgYSBjb250ZXh0IGZvciBjYXNlIG9mIGRlZmluaW5nIG11bHRpcGxlIGNoaWxkIGVudGl0aWVzIHRvZ2V0aGVyIHRvIGhhbmRsZSBjYXNlXHJcbiAgICAgICAgICAgICAgICAvLyB3aGVyZSBzb21lIG1hbGZvcm1lZCBrbWxzIHJldXNlIHRoZSBzYW1lIGlkIGFjcm9zcyBwbGFjZW1hcmtzLCB3aGljaCB3b3JrcyBpbiBHRSwgYnV0IGlzIG5vdCB0ZWNobmljYWxseSB0byBzcGVjLlxyXG4gICAgICAgICAgICAgICAgZ2VvbWV0cnlQcm9jZXNzb3IoZGF0YVNvdXJjZSwgZW50aXR5Q29sbGVjdGlvbiwgY2hpbGROb2RlLCBlbnRpdHksIHN0eWxlRW50aXR5LCBlbnRpdHkuaWQpO1xyXG4gICAgICAgICAgICAgICAgaGFzR2VvbWV0cnkgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWhhc0dlb21ldHJ5KSB7XHJcbiAgICAgICAgICAgIGVudGl0eS5tZXJnZShzdHlsZUVudGl0eSk7XHJcbiAgICAgICAgICAgIHByb2Nlc3NQb3NpdGlvbkdyYXBoaWNzKGRhdGFTb3VyY2UsIGVudGl0eSwgc3R5bGVFbnRpdHkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgcGxheWxpc3ROb2RlUHJvY2Vzc29ycyA9IHtcclxuICAgICAgICBGbHlUbzogcHJvY2Vzc1RvdXJGbHlUbyxcclxuICAgICAgICBXYWl0OiBwcm9jZXNzVG91cldhaXQsXHJcbiAgICAgICAgU291bmRDdWU6IHByb2Nlc3NUb3VyVW5zdXBwb3J0ZWROb2RlLFxyXG4gICAgICAgIEFuaW1hdGVkVXBkYXRlOiBwcm9jZXNzVG91clVuc3VwcG9ydGVkTm9kZSxcclxuICAgICAgICBUb3VyQ29udHJvbDogcHJvY2Vzc1RvdXJVbnN1cHBvcnRlZE5vZGVcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gcHJvY2Vzc1RvdXIoZGF0YVNvdXJjZSwgcGFyZW50LCBub2RlLCBlbnRpdHlDb2xsZWN0aW9uLCBzdHlsZUNvbGxlY3Rpb24sIHNvdXJjZVJlc291cmNlLCB1cmlSZXNvbHZlciwgcHJvbWlzZXMsIGNvbnRleHQpIHtcclxuICAgICAgICB2YXIgbmFtZSA9IHF1ZXJ5U3RyaW5nVmFsdWUobm9kZSwgJ25hbWUnLCBuYW1lc3BhY2VzLmttbCk7XHJcbiAgICAgICAgdmFyIGlkID0gcXVlcnlTdHJpbmdBdHRyaWJ1dGUobm9kZSwgJ2lkJyk7XHJcbiAgICAgICAgdmFyIHRvdXIgPSBuZXcgS21sVG91cihuYW1lLCBpZCk7XHJcblxyXG4gICAgICAgIHZhciBwbGF5bGlzdE5vZGUgPSBxdWVyeUZpcnN0Tm9kZShub2RlLCAnUGxheWxpc3QnLCBuYW1lc3BhY2VzLmd4KTtcclxuICAgICAgICBpZihwbGF5bGlzdE5vZGUpIHtcclxuICAgICAgICAgICAgdmFyIGVsbGlwc29pZCA9IGRhdGFTb3VyY2UuX2VsbGlwc29pZDtcclxuICAgICAgICAgICAgdmFyIGNoaWxkTm9kZXMgPSBwbGF5bGlzdE5vZGUuY2hpbGROb2RlcztcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBlbnRyeU5vZGUgPSBjaGlsZE5vZGVzW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKGVudHJ5Tm9kZS5sb2NhbE5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGxheWxpc3ROb2RlUHJvY2Vzc29yID0gcGxheWxpc3ROb2RlUHJvY2Vzc29yc1tlbnRyeU5vZGUubG9jYWxOYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocGxheWxpc3ROb2RlUHJvY2Vzc29yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYXlsaXN0Tm9kZVByb2Nlc3Nvcih0b3VyLCBlbnRyeU5vZGUsIGVsbGlwc29pZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnVW5rbm93biBLTUwgVG91ciBwbGF5bGlzdCBlbnRyeSB0eXBlICcgKyBlbnRyeU5vZGUubG9jYWxOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghZGVmaW5lZChkYXRhU291cmNlLmttbFRvdXJzKSkge1xyXG4gICAgICAgICAgICBkYXRhU291cmNlLmttbFRvdXJzID0gW107XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBkYXRhU291cmNlLmttbFRvdXJzLnB1c2godG91cik7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcHJvY2Vzc1RvdXJVbnN1cHBvcnRlZE5vZGUodG91ciwgZW50cnlOb2RlKSB7XHJcbiAgICAgICAgb25lVGltZVdhcm5pbmcoJ0tNTCBUb3VyIHVuc3VwcG9ydGVkIG5vZGUgJyArIGVudHJ5Tm9kZS5sb2NhbE5hbWUpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHByb2Nlc3NUb3VyV2FpdCh0b3VyLCBlbnRyeU5vZGUpIHtcclxuICAgICAgICB2YXIgZHVyYXRpb24gPSBxdWVyeU51bWVyaWNWYWx1ZShlbnRyeU5vZGUsICdkdXJhdGlvbicsIG5hbWVzcGFjZXMuZ3gpO1xyXG4gICAgICAgIHRvdXIuYWRkUGxheWxpc3RFbnRyeShuZXcgS21sVG91cldhaXQoZHVyYXRpb24pKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBwcm9jZXNzVG91ckZseVRvKHRvdXIsIGVudHJ5Tm9kZSwgZWxsaXBzb2lkKSB7XHJcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gcXVlcnlOdW1lcmljVmFsdWUoZW50cnlOb2RlLCAnZHVyYXRpb24nLCBuYW1lc3BhY2VzLmd4KTtcclxuICAgICAgICB2YXIgZmx5VG9Nb2RlID0gcXVlcnlTdHJpbmdWYWx1ZShlbnRyeU5vZGUsICdmbHlUb01vZGUnLCBuYW1lc3BhY2VzLmd4KTtcclxuXHJcbiAgICAgICAgdmFyIHQgPSB7a21sOiB7fX07XHJcblxyXG4gICAgICAgIHByb2Nlc3NMb29rQXQoZW50cnlOb2RlLCB0LCBlbGxpcHNvaWQpO1xyXG4gICAgICAgIHByb2Nlc3NDYW1lcmEoZW50cnlOb2RlLCB0LCBlbGxpcHNvaWQpO1xyXG5cclxuICAgICAgICB2YXIgdmlldyA9IHQua21sLmxvb2tBdCB8fCB0LmttbC5jYW1lcmE7XHJcblxyXG4gICAgICAgIHZhciBmbHl0byA9IG5ldyBLbWxUb3VyRmx5VG8oZHVyYXRpb24sIGZseVRvTW9kZSwgdmlldyk7XHJcbiAgICAgICAgdG91ci5hZGRQbGF5bGlzdEVudHJ5KGZseXRvKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBwcm9jZXNzQ2FtZXJhKGZlYXR1cmVOb2RlLCBlbnRpdHksIGVsbGlwc29pZCkge1xyXG4gICAgICAgIHZhciBjYW1lcmEgPSBxdWVyeUZpcnN0Tm9kZShmZWF0dXJlTm9kZSwgJ0NhbWVyYScsIG5hbWVzcGFjZXMua21sKTtcclxuICAgICAgICBpZihkZWZpbmVkKGNhbWVyYSkpIHtcclxuICAgICAgICAgICAgdmFyIGxvbiA9IGRlZmF1bHRWYWx1ZShxdWVyeU51bWVyaWNWYWx1ZShjYW1lcmEsICdsb25naXR1ZGUnLCBuYW1lc3BhY2VzLmttbCksIDAuMCk7XHJcbiAgICAgICAgICAgIHZhciBsYXQgPSBkZWZhdWx0VmFsdWUocXVlcnlOdW1lcmljVmFsdWUoY2FtZXJhLCAnbGF0aXR1ZGUnLCBuYW1lc3BhY2VzLmttbCksIDAuMCk7XHJcbiAgICAgICAgICAgIHZhciBhbHRpdHVkZSA9IGRlZmF1bHRWYWx1ZShxdWVyeU51bWVyaWNWYWx1ZShjYW1lcmEsICdhbHRpdHVkZScsIG5hbWVzcGFjZXMua21sKSwgMC4wKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBoZWFkaW5nID0gZGVmYXVsdFZhbHVlKHF1ZXJ5TnVtZXJpY1ZhbHVlKGNhbWVyYSwgJ2hlYWRpbmcnLCBuYW1lc3BhY2VzLmttbCksIDAuMCk7XHJcbiAgICAgICAgICAgIHZhciB0aWx0ID0gZGVmYXVsdFZhbHVlKHF1ZXJ5TnVtZXJpY1ZhbHVlKGNhbWVyYSwgJ3RpbHQnLCBuYW1lc3BhY2VzLmttbCksIDAuMCk7XHJcbiAgICAgICAgICAgIHZhciByb2xsID0gZGVmYXVsdFZhbHVlKHF1ZXJ5TnVtZXJpY1ZhbHVlKGNhbWVyYSwgJ3JvbGwnLCBuYW1lc3BhY2VzLmttbCksIDAuMCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgcG9zaXRpb24gPSBDYXJ0ZXNpYW4zLmZyb21EZWdyZWVzKGxvbiwgbGF0LCBhbHRpdHVkZSwgZWxsaXBzb2lkKTtcclxuICAgICAgICAgICAgdmFyIGhwciA9IEhlYWRpbmdQaXRjaFJvbGwuZnJvbURlZ3JlZXMoaGVhZGluZywgdGlsdCAtIDkwLjAsIHJvbGwpO1xyXG5cclxuICAgICAgICAgICAgZW50aXR5LmttbC5jYW1lcmEgPSBuZXcgS21sQ2FtZXJhKHBvc2l0aW9uLCBocHIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBwcm9jZXNzTG9va0F0KGZlYXR1cmVOb2RlLCBlbnRpdHksIGVsbGlwc29pZCkge1xyXG4gICAgICAgIHZhciBsb29rQXQgPSBxdWVyeUZpcnN0Tm9kZShmZWF0dXJlTm9kZSwgJ0xvb2tBdCcsIG5hbWVzcGFjZXMua21sKTtcclxuICAgICAgICBpZihkZWZpbmVkKGxvb2tBdCkpIHtcclxuICAgICAgICAgICAgdmFyIGxvbiA9IGRlZmF1bHRWYWx1ZShxdWVyeU51bWVyaWNWYWx1ZShsb29rQXQsICdsb25naXR1ZGUnLCBuYW1lc3BhY2VzLmttbCksIDAuMCk7XHJcbiAgICAgICAgICAgIHZhciBsYXQgPSBkZWZhdWx0VmFsdWUocXVlcnlOdW1lcmljVmFsdWUobG9va0F0LCAnbGF0aXR1ZGUnLCBuYW1lc3BhY2VzLmttbCksIDAuMCk7XHJcbiAgICAgICAgICAgIHZhciBhbHRpdHVkZSA9IGRlZmF1bHRWYWx1ZShxdWVyeU51bWVyaWNWYWx1ZShsb29rQXQsICdhbHRpdHVkZScsIG5hbWVzcGFjZXMua21sKSwgMC4wKTtcclxuICAgICAgICAgICAgdmFyIGhlYWRpbmcgPSBxdWVyeU51bWVyaWNWYWx1ZShsb29rQXQsICdoZWFkaW5nJywgbmFtZXNwYWNlcy5rbWwpO1xyXG4gICAgICAgICAgICB2YXIgdGlsdCA9IHF1ZXJ5TnVtZXJpY1ZhbHVlKGxvb2tBdCwgJ3RpbHQnLCBuYW1lc3BhY2VzLmttbCk7XHJcbiAgICAgICAgICAgIHZhciByYW5nZSA9IGRlZmF1bHRWYWx1ZShxdWVyeU51bWVyaWNWYWx1ZShsb29rQXQsICdyYW5nZScsIG5hbWVzcGFjZXMua21sKSwgMC4wKTtcclxuXHJcbiAgICAgICAgICAgIHRpbHQgPSBDZXNpdW1NYXRoLnRvUmFkaWFucyhkZWZhdWx0VmFsdWUodGlsdCwgMC4wKSk7XHJcbiAgICAgICAgICAgIGhlYWRpbmcgPSBDZXNpdW1NYXRoLnRvUmFkaWFucyhkZWZhdWx0VmFsdWUoaGVhZGluZywgMC4wKSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgaHByID0gbmV3IEhlYWRpbmdQaXRjaFJhbmdlKGhlYWRpbmcsIHRpbHQgLSBDZXNpdW1NYXRoLlBJX09WRVJfVFdPLCByYW5nZSk7XHJcbiAgICAgICAgICAgIHZhciB2aWV3UG9pbnQgPSBDYXJ0ZXNpYW4zLmZyb21EZWdyZWVzKGxvbiwgbGF0LCBhbHRpdHVkZSwgZWxsaXBzb2lkKTtcclxuXHJcbiAgICAgICAgICAgIGVudGl0eS5rbWwubG9va0F0ID0gbmV3IEttbExvb2tBdCh2aWV3UG9pbnQsIGhwcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHByb2Nlc3NHcm91bmRPdmVybGF5KGRhdGFTb3VyY2UsIHBhcmVudCwgZ3JvdW5kT3ZlcmxheSwgZW50aXR5Q29sbGVjdGlvbiwgc3R5bGVDb2xsZWN0aW9uLCBzb3VyY2VSZXNvdXJjZSwgdXJpUmVzb2x2ZXIsIHByb21pc2VzLCBjb250ZXh0KSB7XHJcbiAgICAgICAgdmFyIHIgPSBwcm9jZXNzRmVhdHVyZShkYXRhU291cmNlLCBwYXJlbnQsIGdyb3VuZE92ZXJsYXksIGVudGl0eUNvbGxlY3Rpb24sIHN0eWxlQ29sbGVjdGlvbiwgc291cmNlUmVzb3VyY2UsIHVyaVJlc29sdmVyLCBwcm9taXNlcywgY29udGV4dCk7XHJcbiAgICAgICAgdmFyIGVudGl0eSA9IHIuZW50aXR5O1xyXG5cclxuICAgICAgICB2YXIgZ2VvbWV0cnk7XHJcbiAgICAgICAgdmFyIGlzTGF0TG9uUXVhZCA9IGZhbHNlO1xyXG5cclxuICAgICAgICB2YXIgZWxsaXBzb2lkID0gZGF0YVNvdXJjZS5fZWxsaXBzb2lkO1xyXG4gICAgICAgIHZhciBwb3NpdGlvbnMgPSByZWFkQ29vcmRpbmF0ZXMocXVlcnlGaXJzdE5vZGUoZ3JvdW5kT3ZlcmxheSwgJ0xhdExvblF1YWQnLCBuYW1lc3BhY2VzLmd4KSwgZWxsaXBzb2lkKTtcclxuICAgICAgICB2YXIgekluZGV4ID0gcXVlcnlOdW1lcmljVmFsdWUoZ3JvdW5kT3ZlcmxheSwgJ2RyYXdPcmRlcicsIG5hbWVzcGFjZXMua21sKTtcclxuICAgICAgICBpZiAoZGVmaW5lZChwb3NpdGlvbnMpKSB7XHJcbiAgICAgICAgICAgIGdlb21ldHJ5ID0gY3JlYXRlRGVmYXVsdFBvbHlnb24oKTtcclxuICAgICAgICAgICAgZ2VvbWV0cnkuaGllcmFyY2h5ID0gbmV3IFBvbHlnb25IaWVyYXJjaHkocG9zaXRpb25zKTtcclxuICAgICAgICAgICAgZ2VvbWV0cnkuekluZGV4ID0gekluZGV4O1xyXG4gICAgICAgICAgICBlbnRpdHkucG9seWdvbiA9IGdlb21ldHJ5O1xyXG4gICAgICAgICAgICBpc0xhdExvblF1YWQgPSB0cnVlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGdlb21ldHJ5ID0gbmV3IFJlY3RhbmdsZUdyYXBoaWNzKCk7XHJcbiAgICAgICAgICAgIGdlb21ldHJ5LnpJbmRleCA9IHpJbmRleDtcclxuICAgICAgICAgICAgZW50aXR5LnJlY3RhbmdsZSA9IGdlb21ldHJ5O1xyXG5cclxuICAgICAgICAgICAgdmFyIGxhdExvbkJveCA9IHF1ZXJ5Rmlyc3ROb2RlKGdyb3VuZE92ZXJsYXksICdMYXRMb25Cb3gnLCBuYW1lc3BhY2VzLmttbCk7XHJcbiAgICAgICAgICAgIGlmIChkZWZpbmVkKGxhdExvbkJveCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciB3ZXN0ID0gcXVlcnlOdW1lcmljVmFsdWUobGF0TG9uQm94LCAnd2VzdCcsIG5hbWVzcGFjZXMua21sKTtcclxuICAgICAgICAgICAgICAgIHZhciBzb3V0aCA9IHF1ZXJ5TnVtZXJpY1ZhbHVlKGxhdExvbkJveCwgJ3NvdXRoJywgbmFtZXNwYWNlcy5rbWwpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGVhc3QgPSBxdWVyeU51bWVyaWNWYWx1ZShsYXRMb25Cb3gsICdlYXN0JywgbmFtZXNwYWNlcy5rbWwpO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5vcnRoID0gcXVlcnlOdW1lcmljVmFsdWUobGF0TG9uQm94LCAnbm9ydGgnLCBuYW1lc3BhY2VzLmttbCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGRlZmluZWQod2VzdCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB3ZXN0ID0gQ2VzaXVtTWF0aC5uZWdhdGl2ZVBpVG9QaShDZXNpdW1NYXRoLnRvUmFkaWFucyh3ZXN0KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZGVmaW5lZChzb3V0aCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBzb3V0aCA9IENlc2l1bU1hdGguY2xhbXBUb0xhdGl0dWRlUmFuZ2UoQ2VzaXVtTWF0aC50b1JhZGlhbnMoc291dGgpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChkZWZpbmVkKGVhc3QpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWFzdCA9IENlc2l1bU1hdGgubmVnYXRpdmVQaVRvUGkoQ2VzaXVtTWF0aC50b1JhZGlhbnMoZWFzdCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGRlZmluZWQobm9ydGgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9ydGggPSBDZXNpdW1NYXRoLmNsYW1wVG9MYXRpdHVkZVJhbmdlKENlc2l1bU1hdGgudG9SYWRpYW5zKG5vcnRoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBnZW9tZXRyeS5jb29yZGluYXRlcyA9IG5ldyBSZWN0YW5nbGUod2VzdCwgc291dGgsIGVhc3QsIG5vcnRoKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgcm90YXRpb24gPSBxdWVyeU51bWVyaWNWYWx1ZShsYXRMb25Cb3gsICdyb3RhdGlvbicsIG5hbWVzcGFjZXMua21sKTtcclxuICAgICAgICAgICAgICAgIGlmIChkZWZpbmVkKHJvdGF0aW9uKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByb3RhdGlvblJhZGlhbnMgPSBDZXNpdW1NYXRoLnRvUmFkaWFucyhyb3RhdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkucm90YXRpb24gPSByb3RhdGlvblJhZGlhbnM7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkuc3RSb3RhdGlvbiA9IHJvdGF0aW9uUmFkaWFucztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGljb25Ob2RlID0gcXVlcnlGaXJzdE5vZGUoZ3JvdW5kT3ZlcmxheSwgJ0ljb24nLCBuYW1lc3BhY2VzLmttbCk7XHJcbiAgICAgICAgdmFyIGhyZWYgPSBnZXRJY29uSHJlZihpY29uTm9kZSwgZGF0YVNvdXJjZSwgc291cmNlUmVzb3VyY2UsIHVyaVJlc29sdmVyLCB0cnVlKTtcclxuICAgICAgICBpZiAoZGVmaW5lZChocmVmKSkge1xyXG4gICAgICAgICAgICBpZiAoaXNMYXRMb25RdWFkKSB7XHJcbiAgICAgICAgICAgICAgICBvbmVUaW1lV2FybmluZygna21sLWd4OkxhdExvblF1YWQnLCAnS01MIC0gZ3g6TGF0TG9uUXVhZCBJY29uIGRvZXMgbm90IHN1cHBvcnQgdGV4dHVyZSBwcm9qZWN0aW9uLicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB4ID0gcXVlcnlOdW1lcmljVmFsdWUoaWNvbk5vZGUsICd4JywgbmFtZXNwYWNlcy5neCk7XHJcbiAgICAgICAgICAgIHZhciB5ID0gcXVlcnlOdW1lcmljVmFsdWUoaWNvbk5vZGUsICd5JywgbmFtZXNwYWNlcy5neCk7XHJcbiAgICAgICAgICAgIHZhciB3ID0gcXVlcnlOdW1lcmljVmFsdWUoaWNvbk5vZGUsICd3JywgbmFtZXNwYWNlcy5neCk7XHJcbiAgICAgICAgICAgIHZhciBoID0gcXVlcnlOdW1lcmljVmFsdWUoaWNvbk5vZGUsICdoJywgbmFtZXNwYWNlcy5neCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoZGVmaW5lZCh4KSB8fCBkZWZpbmVkKHkpIHx8IGRlZmluZWQodykgfHwgZGVmaW5lZChoKSkge1xyXG4gICAgICAgICAgICAgICAgb25lVGltZVdhcm5pbmcoJ2ttbC1ncm91bmRPdmVybGF5LXh5d2gnLCAnS01MIC0gZ3g6eCwgZ3g6eSwgZ3g6dywgZ3g6aCBhcmVuXFwndCBzdXBwb3J0ZWQgZm9yIEdyb3VuZE92ZXJsYXlzJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGdlb21ldHJ5Lm1hdGVyaWFsID0gaHJlZjtcclxuICAgICAgICAgICAgZ2VvbWV0cnkubWF0ZXJpYWwuY29sb3IgPSBxdWVyeUNvbG9yVmFsdWUoZ3JvdW5kT3ZlcmxheSwgJ2NvbG9yJywgbmFtZXNwYWNlcy5rbWwpO1xyXG4gICAgICAgICAgICBnZW9tZXRyeS5tYXRlcmlhbC50cmFuc3BhcmVudCA9IHRydWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZ2VvbWV0cnkubWF0ZXJpYWwgPSBxdWVyeUNvbG9yVmFsdWUoZ3JvdW5kT3ZlcmxheSwgJ2NvbG9yJywgbmFtZXNwYWNlcy5rbWwpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGFsdGl0dWRlTW9kZSA9IHF1ZXJ5U3RyaW5nVmFsdWUoZ3JvdW5kT3ZlcmxheSwgJ2FsdGl0dWRlTW9kZScsIG5hbWVzcGFjZXMua21sKTtcclxuXHJcbiAgICAgICAgaWYgKGRlZmluZWQoYWx0aXR1ZGVNb2RlKSkge1xyXG4gICAgICAgICAgICBpZiAoYWx0aXR1ZGVNb2RlID09PSAnYWJzb2x1dGUnKSB7XHJcbiAgICAgICAgICAgICAgICAvL1VzZSBoZWlnaHQgYWJvdmUgZWxsaXBzb2lkIHVudGlsIHdlIHN1cHBvcnQgTVNMLlxyXG4gICAgICAgICAgICAgICAgZ2VvbWV0cnkuaGVpZ2h0ID0gcXVlcnlOdW1lcmljVmFsdWUoZ3JvdW5kT3ZlcmxheSwgJ2FsdGl0dWRlJywgbmFtZXNwYWNlcy5rbWwpO1xyXG4gICAgICAgICAgICAgICAgZ2VvbWV0cnkuekluZGV4ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFsdGl0dWRlTW9kZSAhPT0gJ2NsYW1wVG9Hcm91bmQnKSB7XHJcbiAgICAgICAgICAgICAgICBvbmVUaW1lV2FybmluZygna21sLWFsdGl0dWRlTW9kZS11bmtub3duJywgJ0tNTCAtIFVua25vd24gYWx0aXR1ZGVNb2RlOiAnICsgYWx0aXR1ZGVNb2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBlbHNlIGp1c3QgdXNlIHRoZSBkZWZhdWx0IG9mIDAgdW50aWwgd2Ugc3VwcG9ydCAnY2xhbXBUb0dyb3VuZCdcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBhbHRpdHVkZU1vZGUgPSBxdWVyeVN0cmluZ1ZhbHVlKGdyb3VuZE92ZXJsYXksICdhbHRpdHVkZU1vZGUnLCBuYW1lc3BhY2VzLmd4KTtcclxuICAgICAgICAgICAgaWYgKGFsdGl0dWRlTW9kZSA9PT0gJ3JlbGF0aXZlVG9TZWFGbG9vcicpIHtcclxuICAgICAgICAgICAgICAgIG9uZVRpbWVXYXJuaW5nKCdrbWwtYWx0aXR1ZGVNb2RlLXJlbGF0aXZlVG9TZWFGbG9vcicsICdLTUwgLSBhbHRpdHVkZU1vZGUgcmVsYXRpdmVUb1NlYUZsb29yIGlzIGN1cnJlbnRseSBub3Qgc3VwcG9ydGVkLCB0cmVhdGluZyBhcyBhYnNvbHV0ZS4nKTtcclxuICAgICAgICAgICAgICAgIGdlb21ldHJ5LmhlaWdodCA9IHF1ZXJ5TnVtZXJpY1ZhbHVlKGdyb3VuZE92ZXJsYXksICdhbHRpdHVkZScsIG5hbWVzcGFjZXMua21sKTtcclxuICAgICAgICAgICAgICAgIGdlb21ldHJ5LnpJbmRleCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChhbHRpdHVkZU1vZGUgPT09ICdjbGFtcFRvU2VhRmxvb3InKSB7XHJcbiAgICAgICAgICAgICAgICBvbmVUaW1lV2FybmluZygna21sLWFsdGl0dWRlTW9kZS1jbGFtcFRvU2VhRmxvb3InLCAnS01MIC0gYWx0aXR1ZGVNb2RlIGNsYW1wVG9TZWFGbG9vciBpcyBjdXJyZW50bHkgbm90IHN1cHBvcnRlZCwgdHJlYXRpbmcgYXMgY2xhbXBUb0dyb3VuZC4nKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChkZWZpbmVkKGFsdGl0dWRlTW9kZSkpIHtcclxuICAgICAgICAgICAgICAgIG9uZVRpbWVXYXJuaW5nKCdrbWwtYWx0aXR1ZGVNb2RlLXVua25vd24nLCAnS01MIC0gVW5rbm93biBhbHRpdHVkZU1vZGU6ICcgKyBhbHRpdHVkZU1vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHByb2Nlc3NVbnN1cHBvcnRlZEZlYXR1cmUoZGF0YVNvdXJjZSwgcGFyZW50LCBub2RlLCBlbnRpdHlDb2xsZWN0aW9uLCBzdHlsZUNvbGxlY3Rpb24sIHNvdXJjZVJlc291cmNlLCB1cmlSZXNvbHZlciwgcHJvbWlzZXMsIGNvbnRleHQpIHtcclxuICAgICAgICBkYXRhU291cmNlLl91bnN1cHBvcnRlZE5vZGUucmFpc2VFdmVudChkYXRhU291cmNlLCBwYXJlbnQsIG5vZGUsIGVudGl0eUNvbGxlY3Rpb24sIHN0eWxlQ29sbGVjdGlvbiwgc291cmNlUmVzb3VyY2UsIHVyaVJlc29sdmVyKTtcclxuICAgICAgICBvbmVUaW1lV2FybmluZygna21sLXVuc3VwcG9ydGVkRmVhdHVyZS0nICsgbm9kZS5ub2RlTmFtZSwgJ0tNTCAtIFVuc3VwcG9ydGVkIGZlYXR1cmU6ICcgKyBub2RlLm5vZGVOYW1lKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgUmVmcmVzaE1vZGUgPSB7XHJcbiAgICAgICAgSU5URVJWQUwgOiAwLFxyXG4gICAgICAgIEVYUElSRSA6IDEsXHJcbiAgICAgICAgU1RPUCA6IDJcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gY2xlYW51cFN0cmluZyhzKSB7XHJcbiAgICAgICAgaWYgKCFkZWZpbmVkKHMpIHx8IHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBzRmlyc3QgPSBzWzBdO1xyXG4gICAgICAgIGlmIChzRmlyc3QgPT09ICcmJyB8fCBzRmlyc3QgPT09ICc/Jykge1xyXG4gICAgICAgICAgICBzID0gcy5zdWJzdHJpbmcoMSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcztcclxuICAgIH1cclxuXHJcbiAgICB2YXIgemVyb1JlY3RhbmdsZSA9IG5ldyBSZWN0YW5nbGUoKTtcclxuICAgIHZhciBzY3JhdGNoQ2FydG9ncmFwaGljID0gbmV3IENhcnRvZ3JhcGhpYygpO1xyXG4gICAgdmFyIHNjcmF0Y2hDYXJ0ZXNpYW4yID0gbmV3IENhcnRlc2lhbjIoKTtcclxuICAgIHZhciBzY3JhdGNoQ2FydGVzaWFuMyA9IG5ldyBDYXJ0ZXNpYW4zKCk7XHJcblxyXG4gICAgZnVuY3Rpb24gcHJvY2Vzc05ldHdvcmtMaW5rUXVlcnlTdHJpbmcocmVzb3VyY2UsIGNhbWVyYSwgY2FudmFzLCB2aWV3Qm91bmRTY2FsZSwgYmJveCwgZWxsaXBzb2lkKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZml4TGF0aXR1ZGUodmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlIDwgLUNlc2l1bU1hdGguUElfT1ZFUl9UV08pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAtQ2VzaXVtTWF0aC5QSV9PVkVSX1RXTztcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA+IENlc2l1bU1hdGguUElfT1ZFUl9UV08pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBDZXNpdW1NYXRoLlBJX09WRVJfVFdPO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGZpeExvbmdpdHVkZSh2YWx1ZSkge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgPiBDZXNpdW1NYXRoLlBJKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgLSBDZXNpdW1NYXRoLlRXT19QSTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA8IC1DZXNpdW1NYXRoLlBJKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgKyBDZXNpdW1NYXRoLlRXT19QSTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHF1ZXJ5U3RyaW5nID0gb2JqZWN0VG9RdWVyeShyZXNvdXJjZS5xdWVyeVBhcmFtZXRlcnMpO1xyXG5cclxuICAgICAgICAvLyBvYmplY3RUb1F1ZXJ5IGVzY2FwZXMgWyBhbmQgXSwgc28gZml4IHRoYXRcclxuICAgICAgICBxdWVyeVN0cmluZyA9IHF1ZXJ5U3RyaW5nLnJlcGxhY2UoLyU1Qi9nLCAnWycpLnJlcGxhY2UoLyU1RC9nLCAnXScpO1xyXG5cclxuICAgICAgICBpZiAoZGVmaW5lZChjYW1lcmEpICYmIGNhbWVyYS5fbW9kZSAhPT0gU2NlbmVNb2RlLk1PUlBISU5HKSB7XHJcbiAgICAgICAgICAgIHZhciBjZW50ZXJDYXJ0ZXNpYW47XHJcbiAgICAgICAgICAgIHZhciBjZW50ZXJDYXJ0b2dyYXBoaWM7XHJcblxyXG4gICAgICAgICAgICBiYm94ID0gZGVmYXVsdFZhbHVlKGJib3gsIHplcm9SZWN0YW5nbGUpO1xyXG4gICAgICAgICAgICBpZiAoZGVmaW5lZChjYW52YXMpKSB7XHJcbiAgICAgICAgICAgICAgICBzY3JhdGNoQ2FydGVzaWFuMi54ID0gY2FudmFzLmNsaWVudFdpZHRoICogMC41O1xyXG4gICAgICAgICAgICAgICAgc2NyYXRjaENhcnRlc2lhbjIueSA9IGNhbnZhcy5jbGllbnRIZWlnaHQgKiAwLjU7XHJcbiAgICAgICAgICAgICAgICBjZW50ZXJDYXJ0ZXNpYW4gPSBjYW1lcmEucGlja0VsbGlwc29pZChzY3JhdGNoQ2FydGVzaWFuMiwgZWxsaXBzb2lkLCBzY3JhdGNoQ2FydGVzaWFuMyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChkZWZpbmVkKGNlbnRlckNhcnRlc2lhbikpIHtcclxuICAgICAgICAgICAgICAgIGNlbnRlckNhcnRvZ3JhcGhpYyA9IGVsbGlwc29pZC5jYXJ0ZXNpYW5Ub0NhcnRvZ3JhcGhpYyhjZW50ZXJDYXJ0ZXNpYW4sIHNjcmF0Y2hDYXJ0b2dyYXBoaWMpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY2VudGVyQ2FydG9ncmFwaGljID0gUmVjdGFuZ2xlLmNlbnRlcihiYm94LCBzY3JhdGNoQ2FydG9ncmFwaGljKTtcclxuICAgICAgICAgICAgICAgIGNlbnRlckNhcnRlc2lhbiA9IGVsbGlwc29pZC5jYXJ0b2dyYXBoaWNUb0NhcnRlc2lhbihjZW50ZXJDYXJ0b2dyYXBoaWMpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoZGVmaW5lZCh2aWV3Qm91bmRTY2FsZSkgJiYgIUNlc2l1bU1hdGguZXF1YWxzRXBzaWxvbih2aWV3Qm91bmRTY2FsZSwgMS4wLCBDZXNpdW1NYXRoLkVQU0lMT045KSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5ld0hhbGZXaWR0aCA9IGJib3gud2lkdGggKiB2aWV3Qm91bmRTY2FsZSAqIDAuNTtcclxuICAgICAgICAgICAgICAgIHZhciBuZXdIYWxmSGVpZ2h0ID0gYmJveC5oZWlnaHQgKiB2aWV3Qm91bmRTY2FsZSAqIDAuNTtcclxuICAgICAgICAgICAgICAgIGJib3ggPSBuZXcgUmVjdGFuZ2xlKGZpeExvbmdpdHVkZShjZW50ZXJDYXJ0b2dyYXBoaWMubG9uZ2l0dWRlIC0gbmV3SGFsZldpZHRoKSxcclxuICAgICAgICAgICAgICAgICAgICBmaXhMYXRpdHVkZShjZW50ZXJDYXJ0b2dyYXBoaWMubGF0aXR1ZGUgLSBuZXdIYWxmSGVpZ2h0KSxcclxuICAgICAgICAgICAgICAgICAgICBmaXhMb25naXR1ZGUoY2VudGVyQ2FydG9ncmFwaGljLmxvbmdpdHVkZSArIG5ld0hhbGZXaWR0aCksXHJcbiAgICAgICAgICAgICAgICAgICAgZml4TGF0aXR1ZGUoY2VudGVyQ2FydG9ncmFwaGljLmxhdGl0dWRlICsgbmV3SGFsZkhlaWdodClcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHF1ZXJ5U3RyaW5nID0gcXVlcnlTdHJpbmcucmVwbGFjZSgnW2Jib3hXZXN0XScsIENlc2l1bU1hdGgudG9EZWdyZWVzKGJib3gud2VzdCkudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgIHF1ZXJ5U3RyaW5nID0gcXVlcnlTdHJpbmcucmVwbGFjZSgnW2Jib3hTb3V0aF0nLCBDZXNpdW1NYXRoLnRvRGVncmVlcyhiYm94LnNvdXRoKS50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgcXVlcnlTdHJpbmcgPSBxdWVyeVN0cmluZy5yZXBsYWNlKCdbYmJveEVhc3RdJywgQ2VzaXVtTWF0aC50b0RlZ3JlZXMoYmJveC5lYXN0KS50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgcXVlcnlTdHJpbmcgPSBxdWVyeVN0cmluZy5yZXBsYWNlKCdbYmJveE5vcnRoXScsIENlc2l1bU1hdGgudG9EZWdyZWVzKGJib3gubm9ydGgpLnRvU3RyaW5nKCkpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGxvbiA9IENlc2l1bU1hdGgudG9EZWdyZWVzKGNlbnRlckNhcnRvZ3JhcGhpYy5sb25naXR1ZGUpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIHZhciBsYXQgPSBDZXNpdW1NYXRoLnRvRGVncmVlcyhjZW50ZXJDYXJ0b2dyYXBoaWMubGF0aXR1ZGUpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIHF1ZXJ5U3RyaW5nID0gcXVlcnlTdHJpbmcucmVwbGFjZSgnW2xvb2thdExvbl0nLCBsb24pO1xyXG4gICAgICAgICAgICBxdWVyeVN0cmluZyA9IHF1ZXJ5U3RyaW5nLnJlcGxhY2UoJ1tsb29rYXRMYXRdJywgbGF0KTtcclxuICAgICAgICAgICAgcXVlcnlTdHJpbmcgPSBxdWVyeVN0cmluZy5yZXBsYWNlKCdbbG9va2F0VGlsdF0nLCBDZXNpdW1NYXRoLnRvRGVncmVlcyhjYW1lcmEucGl0Y2gpLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICBxdWVyeVN0cmluZyA9IHF1ZXJ5U3RyaW5nLnJlcGxhY2UoJ1tsb29rYXRIZWFkaW5nXScsIENlc2l1bU1hdGgudG9EZWdyZWVzKGNhbWVyYS5oZWFkaW5nKS50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgcXVlcnlTdHJpbmcgPSBxdWVyeVN0cmluZy5yZXBsYWNlKCdbbG9va2F0UmFuZ2VdJywgQ2FydGVzaWFuMy5kaXN0YW5jZShjYW1lcmEucG9zaXRpb25XQywgY2VudGVyQ2FydGVzaWFuKSk7XHJcbiAgICAgICAgICAgIHF1ZXJ5U3RyaW5nID0gcXVlcnlTdHJpbmcucmVwbGFjZSgnW2xvb2thdFRlcnJhaW5Mb25dJywgbG9uKTtcclxuICAgICAgICAgICAgcXVlcnlTdHJpbmcgPSBxdWVyeVN0cmluZy5yZXBsYWNlKCdbbG9va2F0VGVycmFpbkxhdF0nLCBsYXQpO1xyXG4gICAgICAgICAgICBxdWVyeVN0cmluZyA9IHF1ZXJ5U3RyaW5nLnJlcGxhY2UoJ1tsb29rYXRUZXJyYWluQWx0XScsIGNlbnRlckNhcnRvZ3JhcGhpYy5oZWlnaHQudG9TdHJpbmcoKSk7XHJcblxyXG4gICAgICAgICAgICBlbGxpcHNvaWQuY2FydGVzaWFuVG9DYXJ0b2dyYXBoaWMoY2FtZXJhLnBvc2l0aW9uV0MsIHNjcmF0Y2hDYXJ0b2dyYXBoaWMpO1xyXG4gICAgICAgICAgICBxdWVyeVN0cmluZyA9IHF1ZXJ5U3RyaW5nLnJlcGxhY2UoJ1tjYW1lcmFMb25dJywgQ2VzaXVtTWF0aC50b0RlZ3JlZXMoc2NyYXRjaENhcnRvZ3JhcGhpYy5sb25naXR1ZGUpLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICBxdWVyeVN0cmluZyA9IHF1ZXJ5U3RyaW5nLnJlcGxhY2UoJ1tjYW1lcmFMYXRdJywgQ2VzaXVtTWF0aC50b0RlZ3JlZXMoc2NyYXRjaENhcnRvZ3JhcGhpYy5sYXRpdHVkZSkudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgIHF1ZXJ5U3RyaW5nID0gcXVlcnlTdHJpbmcucmVwbGFjZSgnW2NhbWVyYUFsdF0nLCBDZXNpdW1NYXRoLnRvRGVncmVlcyhzY3JhdGNoQ2FydG9ncmFwaGljLmhlaWdodCkudG9TdHJpbmcoKSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgZnJ1c3R1bSA9IGNhbWVyYS5mcnVzdHVtO1xyXG4gICAgICAgICAgICB2YXIgYXNwZWN0UmF0aW8gPSBmcnVzdHVtLmFzcGVjdFJhdGlvO1xyXG4gICAgICAgICAgICB2YXIgaG9yaXpGb3YgPSAnJztcclxuICAgICAgICAgICAgdmFyIHZlcnRGb3YgPSAnJztcclxuICAgICAgICAgICAgaWYgKGRlZmluZWQoYXNwZWN0UmF0aW8pKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZm92ID0gQ2VzaXVtTWF0aC50b0RlZ3JlZXMoZnJ1c3R1bS5mb3YpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFzcGVjdFJhdGlvID4gMS4wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaG9yaXpGb3YgPSBmb3Y7XHJcbiAgICAgICAgICAgICAgICAgICAgdmVydEZvdiA9IGZvdiAvIGFzcGVjdFJhdGlvO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2ZXJ0Rm92ID0gZm92O1xyXG4gICAgICAgICAgICAgICAgICAgIGhvcml6Rm92ID0gZm92ICogYXNwZWN0UmF0aW87XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcXVlcnlTdHJpbmcgPSBxdWVyeVN0cmluZy5yZXBsYWNlKCdbaG9yaXpGb3ZdJywgaG9yaXpGb3YudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgIHF1ZXJ5U3RyaW5nID0gcXVlcnlTdHJpbmcucmVwbGFjZSgnW3ZlcnRGb3ZdJywgdmVydEZvdi50b1N0cmluZygpKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBxdWVyeVN0cmluZyA9IHF1ZXJ5U3RyaW5nLnJlcGxhY2UoJ1tiYm94V2VzdF0nLCAnLTE4MCcpO1xyXG4gICAgICAgICAgICBxdWVyeVN0cmluZyA9IHF1ZXJ5U3RyaW5nLnJlcGxhY2UoJ1tiYm94U291dGhdJywgJy05MCcpO1xyXG4gICAgICAgICAgICBxdWVyeVN0cmluZyA9IHF1ZXJ5U3RyaW5nLnJlcGxhY2UoJ1tiYm94RWFzdF0nLCAnMTgwJyk7XHJcbiAgICAgICAgICAgIHF1ZXJ5U3RyaW5nID0gcXVlcnlTdHJpbmcucmVwbGFjZSgnW2Jib3hOb3J0aF0nLCAnOTAnKTtcclxuXHJcbiAgICAgICAgICAgIHF1ZXJ5U3RyaW5nID0gcXVlcnlTdHJpbmcucmVwbGFjZSgnW2xvb2thdExvbl0nLCAnJyk7XHJcbiAgICAgICAgICAgIHF1ZXJ5U3RyaW5nID0gcXVlcnlTdHJpbmcucmVwbGFjZSgnW2xvb2thdExhdF0nLCAnJyk7XHJcbiAgICAgICAgICAgIHF1ZXJ5U3RyaW5nID0gcXVlcnlTdHJpbmcucmVwbGFjZSgnW2xvb2thdFJhbmdlXScsICcnKTtcclxuICAgICAgICAgICAgcXVlcnlTdHJpbmcgPSBxdWVyeVN0cmluZy5yZXBsYWNlKCdbbG9va2F0VGlsdF0nLCAnJyk7XHJcbiAgICAgICAgICAgIHF1ZXJ5U3RyaW5nID0gcXVlcnlTdHJpbmcucmVwbGFjZSgnW2xvb2thdEhlYWRpbmddJywgJycpO1xyXG4gICAgICAgICAgICBxdWVyeVN0cmluZyA9IHF1ZXJ5U3RyaW5nLnJlcGxhY2UoJ1tsb29rYXRUZXJyYWluTG9uXScsICcnKTtcclxuICAgICAgICAgICAgcXVlcnlTdHJpbmcgPSBxdWVyeVN0cmluZy5yZXBsYWNlKCdbbG9va2F0VGVycmFpbkxhdF0nLCAnJyk7XHJcbiAgICAgICAgICAgIHF1ZXJ5U3RyaW5nID0gcXVlcnlTdHJpbmcucmVwbGFjZSgnW2xvb2thdFRlcnJhaW5BbHRdJywgJycpO1xyXG5cclxuICAgICAgICAgICAgcXVlcnlTdHJpbmcgPSBxdWVyeVN0cmluZy5yZXBsYWNlKCdbY2FtZXJhTG9uXScsICcnKTtcclxuICAgICAgICAgICAgcXVlcnlTdHJpbmcgPSBxdWVyeVN0cmluZy5yZXBsYWNlKCdbY2FtZXJhTGF0XScsICcnKTtcclxuICAgICAgICAgICAgcXVlcnlTdHJpbmcgPSBxdWVyeVN0cmluZy5yZXBsYWNlKCdbY2FtZXJhQWx0XScsICcnKTtcclxuICAgICAgICAgICAgcXVlcnlTdHJpbmcgPSBxdWVyeVN0cmluZy5yZXBsYWNlKCdbaG9yaXpGb3ZdJywgJycpO1xyXG4gICAgICAgICAgICBxdWVyeVN0cmluZyA9IHF1ZXJ5U3RyaW5nLnJlcGxhY2UoJ1t2ZXJ0Rm92XScsICcnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChkZWZpbmVkKGNhbnZhcykpIHtcclxuICAgICAgICAgICAgcXVlcnlTdHJpbmcgPSBxdWVyeVN0cmluZy5yZXBsYWNlKCdbaG9yaXpQaXhlbHNdJywgY2FudmFzLmNsaWVudFdpZHRoKTtcclxuICAgICAgICAgICAgcXVlcnlTdHJpbmcgPSBxdWVyeVN0cmluZy5yZXBsYWNlKCdbdmVydFBpeGVsc10nLCBjYW52YXMuY2xpZW50SGVpZ2h0KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBxdWVyeVN0cmluZyA9IHF1ZXJ5U3RyaW5nLnJlcGxhY2UoJ1tob3JpelBpeGVsc10nLCAnJyk7XHJcbiAgICAgICAgICAgIHF1ZXJ5U3RyaW5nID0gcXVlcnlTdHJpbmcucmVwbGFjZSgnW3ZlcnRQaXhlbHNdJywgJycpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcXVlcnlTdHJpbmcgPSBxdWVyeVN0cmluZy5yZXBsYWNlKCdbdGVycmFpbkVuYWJsZWRdJywgJzEnKTtcclxuICAgICAgICBxdWVyeVN0cmluZyA9IHF1ZXJ5U3RyaW5nLnJlcGxhY2UoJ1tjbGllbnRWZXJzaW9uXScsICcxJyk7XHJcbiAgICAgICAgcXVlcnlTdHJpbmcgPSBxdWVyeVN0cmluZy5yZXBsYWNlKCdba21sVmVyc2lvbl0nLCAnMi4yJyk7XHJcbiAgICAgICAgcXVlcnlTdHJpbmcgPSBxdWVyeVN0cmluZy5yZXBsYWNlKCdbY2xpZW50TmFtZV0nLCAnQ2VzaXVtJyk7XHJcbiAgICAgICAgcXVlcnlTdHJpbmcgPSBxdWVyeVN0cmluZy5yZXBsYWNlKCdbbGFuZ3VhZ2VdJywgJ0VuZ2xpc2gnKTtcclxuXHJcbiAgICAgICAgcmVzb3VyY2Uuc2V0UXVlcnlQYXJhbWV0ZXJzKHF1ZXJ5VG9PYmplY3QocXVlcnlTdHJpbmcpKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBwcm9jZXNzTmV0d29ya0xpbmsoZGF0YVNvdXJjZSwgcGFyZW50LCBub2RlLCBlbnRpdHlDb2xsZWN0aW9uLCBzdHlsZUNvbGxlY3Rpb24sIHNvdXJjZVJlc291cmNlLCB1cmlSZXNvbHZlciwgcHJvbWlzZXMsIGNvbnRleHQpIHtcclxuICAgICAgICB2YXIgciA9IHByb2Nlc3NGZWF0dXJlKGRhdGFTb3VyY2UsIHBhcmVudCwgbm9kZSwgZW50aXR5Q29sbGVjdGlvbiwgc3R5bGVDb2xsZWN0aW9uLCBzb3VyY2VSZXNvdXJjZSwgdXJpUmVzb2x2ZXIsIHByb21pc2VzLCBjb250ZXh0KTtcclxuICAgICAgICB2YXIgbmV0d29ya0VudGl0eSA9IHIuZW50aXR5O1xyXG5cclxuICAgICAgICB2YXIgbGluayA9IHF1ZXJ5Rmlyc3ROb2RlKG5vZGUsICdMaW5rJywgbmFtZXNwYWNlcy5rbWwpO1xyXG5cclxuICAgICAgICBpZiAoIWRlZmluZWQobGluaykpIHtcclxuICAgICAgICAgICAgbGluayA9IHF1ZXJ5Rmlyc3ROb2RlKG5vZGUsICdVcmwnLCBuYW1lc3BhY2VzLmttbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkZWZpbmVkKGxpbmspKSB7XHJcbiAgICAgICAgICAgIHZhciBocmVmID0gcXVlcnlTdHJpbmdWYWx1ZShsaW5rLCAnaHJlZicsIG5hbWVzcGFjZXMua21sKTtcclxuICAgICAgICAgICAgdmFyIHZpZXdSZWZyZXNoTW9kZTtcclxuICAgICAgICAgICAgdmFyIHZpZXdCb3VuZFNjYWxlO1xyXG4gICAgICAgICAgICBpZiAoZGVmaW5lZChocmVmKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5ld1NvdXJjZVVyaSA9IGhyZWY7XHJcbiAgICAgICAgICAgICAgICBocmVmID0gcmVzb2x2ZUhyZWYoaHJlZiwgc291cmNlUmVzb3VyY2UsIHVyaVJlc29sdmVyKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIHBhc3MgaW4gdGhlIG9yaWdpbmFsIHBhdGggaWYgcmVzb2x2ZUhyZWYgcmV0dXJucyBhIGRhdGEgdXJpIGJlY2F1c2UgdGhlIG5ldHdvcmsgbGlua1xyXG4gICAgICAgICAgICAgICAgLy8gIHJlZmVyZW5jZXMgYSBkb2N1bWVudCBpbiBhIEtNWiBhcmNoaXZlXHJcbiAgICAgICAgICAgICAgICBpZiAoL15kYXRhOi8udGVzdChocmVmLmdldFVybENvbXBvbmVudCgpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNvIGlmIHNvdXJjZVVyaSBpc24ndCB0aGUga216IGZpbGUsIHRoZW4gaXRzIGFub3RoZXIga21sIGluIHRoZSBhcmNoaXZlLCBzbyByZXNvbHZlIGl0XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEvXFwua216L2kudGVzdChzb3VyY2VSZXNvdXJjZS5nZXRVcmxDb21wb25lbnQoKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3U291cmNlVXJpID0gc291cmNlUmVzb3VyY2UuZ2V0RGVyaXZlZFJlc291cmNlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogbmV3U291cmNlVXJpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3U291cmNlVXJpID0gaHJlZi5jbG9uZSgpOyAvLyBOb3QgYSBkYXRhIHVyaSBzbyB1c2UgdGhlIGZ1bGx5IHF1YWxpZmllZCB1cmlcclxuICAgICAgICAgICAgICAgICAgICB2aWV3UmVmcmVzaE1vZGUgPSBxdWVyeVN0cmluZ1ZhbHVlKGxpbmssICd2aWV3UmVmcmVzaE1vZGUnLCBuYW1lc3BhY2VzLmttbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmlld0JvdW5kU2NhbGUgPSBkZWZhdWx0VmFsdWUocXVlcnlTdHJpbmdWYWx1ZShsaW5rLCAndmlld0JvdW5kU2NhbGUnLCBuYW1lc3BhY2VzLmttbCksIDEuMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlZmF1bHRWaWV3Rm9ybWF0ID0gKHZpZXdSZWZyZXNoTW9kZSA9PT0gJ29uU3RvcCcpID8gJ0JCT1g9W2Jib3hXZXN0XSxbYmJveFNvdXRoXSxbYmJveEVhc3RdLFtiYm94Tm9ydGhdJyA6ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2aWV3Rm9ybWF0ID0gZGVmYXVsdFZhbHVlKHF1ZXJ5U3RyaW5nVmFsdWUobGluaywgJ3ZpZXdGb3JtYXQnLCBuYW1lc3BhY2VzLmttbCksIGRlZmF1bHRWaWV3Rm9ybWF0KTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaHR0cFF1ZXJ5ID0gcXVlcnlTdHJpbmdWYWx1ZShsaW5rLCAnaHR0cFF1ZXJ5JywgbmFtZXNwYWNlcy5rbWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWZpbmVkKHZpZXdGb3JtYXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhyZWYuc2V0UXVlcnlQYXJhbWV0ZXJzKHF1ZXJ5VG9PYmplY3QoY2xlYW51cFN0cmluZyh2aWV3Rm9ybWF0KSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGVmaW5lZChodHRwUXVlcnkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhyZWYuc2V0UXVlcnlQYXJhbWV0ZXJzKHF1ZXJ5VG9PYmplY3QoY2xlYW51cFN0cmluZyhodHRwUXVlcnkpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgZWxsaXBzb2lkID0gZGF0YVNvdXJjZS5fZWxsaXBzb2lkO1xyXG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NOZXR3b3JrTGlua1F1ZXJ5U3RyaW5nKGhyZWYsIGRhdGFTb3VyY2UuX2NhbWVyYSwgZGF0YVNvdXJjZS5fY2FudmFzLCB2aWV3Qm91bmRTY2FsZSwgZGF0YVNvdXJjZS5fbGFzdENhbWVyYVZpZXcuYmJveCwgZWxsaXBzb2lkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgICAgICAgICBzb3VyY2VVcmkgOiBuZXdTb3VyY2VVcmksXHJcbiAgICAgICAgICAgICAgICAgICAgdXJpUmVzb2x2ZXIgOiB1cmlSZXNvbHZlcixcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0IDogbmV0d29ya0VudGl0eS5pZFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHZhciBuZXR3b3JrTGlua0NvbGxlY3Rpb24gPSBuZXcgRW50aXR5Q29sbGVjdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSBsb2FkKGRhdGFTb3VyY2UsIG5ldHdvcmtMaW5rQ29sbGVjdGlvbiwgaHJlZiwgb3B0aW9ucykudGhlbihmdW5jdGlvbihyb290RWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbnRpdGllcyA9IGRhdGFTb3VyY2UuX2VudGl0eUNvbGxlY3Rpb247XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0VudGl0aWVzID0gbmV0d29ya0xpbmtDb2xsZWN0aW9uLnZhbHVlcztcclxuICAgICAgICAgICAgICAgICAgICBlbnRpdGllcy5zdXNwZW5kRXZlbnRzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdFbnRpdGllcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3RW50aXR5ID0gbmV3RW50aXRpZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZGVmaW5lZChuZXdFbnRpdHkucGFyZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3RW50aXR5LnBhcmVudCA9IG5ldHdvcmtFbnRpdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXJnZUF2YWlsYWJpbGl0eVdpdGhQYXJlbnQobmV3RW50aXR5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZW50aXRpZXMuYWRkKG5ld0VudGl0eSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVudGl0aWVzLnJlc3VtZUV2ZW50cygpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgbmV0d29yayBsaW5rcyB0byBhIGxpc3QgaWYgd2UgbmVlZCB0aGV5IHdpbGwgbmVlZCB0byBiZSB1cGRhdGVkXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlZnJlc2hNb2RlID0gcXVlcnlTdHJpbmdWYWx1ZShsaW5rLCAncmVmcmVzaE1vZGUnLCBuYW1lc3BhY2VzLmttbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlZnJlc2hJbnRlcnZhbCA9IGRlZmF1bHRWYWx1ZShxdWVyeU51bWVyaWNWYWx1ZShsaW5rLCAncmVmcmVzaEludGVydmFsJywgbmFtZXNwYWNlcy5rbWwpLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHJlZnJlc2hNb2RlID09PSAnb25JbnRlcnZhbCcgJiYgcmVmcmVzaEludGVydmFsID4gMCApIHx8IChyZWZyZXNoTW9kZSA9PT0gJ29uRXhwaXJlJykgfHwgKHZpZXdSZWZyZXNoTW9kZSA9PT0gJ29uU3RvcCcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXR3b3JrTGlua0NvbnRyb2wgPSBxdWVyeUZpcnN0Tm9kZShyb290RWxlbWVudCwgJ05ldHdvcmtMaW5rQ29udHJvbCcsIG5hbWVzcGFjZXMua21sKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhhc05ldHdvcmtMaW5rQ29udHJvbCA9IGRlZmluZWQobmV0d29ya0xpbmtDb250cm9sKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub3cgPSBKdWxpYW5EYXRlLm5vdygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV0d29ya0xpbmtJbmZvID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQgOiBjcmVhdGVHdWlkKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBocmVmIDogaHJlZixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb2tpZSA6IHt9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFVwZGF0ZWQgOiBub3csXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGluZyA6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50aXR5IDogbmV0d29ya0VudGl0eSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdCb3VuZFNjYWxlIDogdmlld0JvdW5kU2NhbGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZWVkc1VwZGF0ZSA6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FtZXJhVXBkYXRlVGltZSA6IG5vd1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1pblJlZnJlc2hQZXJpb2QgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzTmV0d29ya0xpbmtDb250cm9sKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXR3b3JrTGlua0luZm8uY29va2llID0gcXVlcnlUb09iamVjdChkZWZhdWx0VmFsdWUocXVlcnlTdHJpbmdWYWx1ZShuZXR3b3JrTGlua0NvbnRyb2wsICdjb29raWUnLCBuYW1lc3BhY2VzLmttbCksICcnKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5SZWZyZXNoUGVyaW9kID0gZGVmYXVsdFZhbHVlKHF1ZXJ5TnVtZXJpY1ZhbHVlKG5ldHdvcmtMaW5rQ29udHJvbCwgJ21pblJlZnJlc2hQZXJpb2QnLCBuYW1lc3BhY2VzLmttbCksIDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVmcmVzaE1vZGUgPT09ICdvbkludGVydmFsJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc05ldHdvcmtMaW5rQ29udHJvbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hJbnRlcnZhbCA9IE1hdGgubWF4KG1pblJlZnJlc2hQZXJpb2QsIHJlZnJlc2hJbnRlcnZhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXR3b3JrTGlua0luZm8ucmVmcmVzaE1vZGUgPSBSZWZyZXNoTW9kZS5JTlRFUlZBTDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldHdvcmtMaW5rSW5mby50aW1lID0gcmVmcmVzaEludGVydmFsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJlZnJlc2hNb2RlID09PSAnb25FeHBpcmUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXhwaXJlcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNOZXR3b3JrTGlua0NvbnRyb2wpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBpcmVzID0gcXVlcnlTdHJpbmdWYWx1ZShuZXR3b3JrTGlua0NvbnRyb2wsICdleHBpcmVzJywgbmFtZXNwYWNlcy5rbWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlZmluZWQoZXhwaXJlcykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0ZSA9IEp1bGlhbkRhdGUuZnJvbUlzbzg2MDEoZXhwaXJlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkaWZmID0gSnVsaWFuRGF0ZS5zZWNvbmRzRGlmZmVyZW5jZShkYXRlLCBub3cpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlmZiA+IDAgJiYgZGlmZiA8IG1pblJlZnJlc2hQZXJpb2QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEp1bGlhbkRhdGUuYWRkU2Vjb25kcyhub3csIG1pblJlZnJlc2hQZXJpb2QsIGRhdGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldHdvcmtMaW5rSW5mby5yZWZyZXNoTW9kZSA9IFJlZnJlc2hNb2RlLkVYUElSRTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV0d29ya0xpbmtJbmZvLnRpbWUgPSBkYXRlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25lVGltZVdhcm5pbmcoJ2ttbC1yZWZyZXNoTW9kZS1vbkludGVydmFsLW9uRXhwaXJlJywgJ0tNTCAtIE5ldHdvcmtMaW5rQ29udHJvbCBleHBpcmVzIGlzIG5vdCBhIHZhbGlkIGRhdGUnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uZVRpbWVXYXJuaW5nKCdrbWwtcmVmcmVzaE1vZGUtb25FeHBpcmUnLCAnS01MIC0gcmVmcmVzaE1vZGUgb2Ygb25FeHBpcmUgcmVxdWlyZXMgdGhlIE5ldHdvcmtMaW5rQ29udHJvbCB0byBoYXZlIGFuIGV4cGlyZXMgZWxlbWVudCcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGRhdGFTb3VyY2UuX2NhbWVyYSkgeyAvLyBPbmx5IGFsbG93IG9uU3RvcCByZWZyZXNoZXMgaWYgd2UgaGF2ZSBhIGNhbWVyYVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV0d29ya0xpbmtJbmZvLnJlZnJlc2hNb2RlID0gUmVmcmVzaE1vZGUuU1RPUDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldHdvcmtMaW5rSW5mby50aW1lID0gZGVmYXVsdFZhbHVlKHF1ZXJ5TnVtZXJpY1ZhbHVlKGxpbmssICd2aWV3UmVmcmVzaFRpbWUnLCBuYW1lc3BhY2VzLmttbCksIDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25lVGltZVdhcm5pbmcoJ2ttbC1yZWZyZWhNb2RlLW9uU3RvcC1ub0NhbWVyYScsICdBIE5ldHdvcmtMaW5rIHdpdGggdmlld1JlZnJlc2hNb2RlPW9uU3RvcCByZXF1aXJlcyBhIGNhbWVyYSBiZSBwYXNzZWQgaW4gd2hlbiBjcmVhdGluZyB0aGUgS21sRGF0YVNvdXJjZScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVmaW5lZChuZXR3b3JrTGlua0luZm8ucmVmcmVzaE1vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhU291cmNlLl9uZXR3b3JrTGlua3Muc2V0KG5ldHdvcmtMaW5rSW5mby5pZCwgbmV0d29ya0xpbmtJbmZvKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodmlld1JlZnJlc2hNb2RlID09PSAnb25SZWdpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uZVRpbWVXYXJuaW5nKCdrbWwtcmVmcmVoTW9kZS1vblJlZ2lvbicsICdLTUwgLSBVbnN1cHBvcnRlZCB2aWV3UmVmcmVzaE1vZGU6IG9uUmVnaW9uJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSkub3RoZXJ3aXNlKGZ1bmN0aW9uKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb25lVGltZVdhcm5pbmcoJ0FuIGVycm9yIG9jY3VyZWQgZHVyaW5nIGxvYWRpbmcgJyArIGhyZWYudXJsKTtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhU291cmNlLl9lcnJvci5yYWlzZUV2ZW50KGRhdGFTb3VyY2UsIGVycm9yKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2gocHJvbWlzZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcHJvY2Vzc0ZlYXR1cmVOb2RlKGRhdGFTb3VyY2UsIG5vZGUsIHBhcmVudCwgZW50aXR5Q29sbGVjdGlvbiwgc3R5bGVDb2xsZWN0aW9uLCBzb3VyY2VSZXNvdXJjZSwgdXJpUmVzb2x2ZXIsIHByb21pc2VzLCBjb250ZXh0KSB7XHJcbiAgICAgICAgdmFyIGZlYXR1cmVQcm9jZXNzb3IgPSBmZWF0dXJlVHlwZXNbbm9kZS5sb2NhbE5hbWVdO1xyXG4gICAgICAgIGlmIChkZWZpbmVkKGZlYXR1cmVQcm9jZXNzb3IpKSB7XHJcbiAgICAgICAgICAgIGZlYXR1cmVQcm9jZXNzb3IoZGF0YVNvdXJjZSwgcGFyZW50LCBub2RlLCBlbnRpdHlDb2xsZWN0aW9uLCBzdHlsZUNvbGxlY3Rpb24sIHNvdXJjZVJlc291cmNlLCB1cmlSZXNvbHZlciwgcHJvbWlzZXMsIGNvbnRleHQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHByb2Nlc3NVbnN1cHBvcnRlZEZlYXR1cmUoZGF0YVNvdXJjZSwgcGFyZW50LCBub2RlLCBlbnRpdHlDb2xsZWN0aW9uLCBzdHlsZUNvbGxlY3Rpb24sIHNvdXJjZVJlc291cmNlLCB1cmlSZXNvbHZlciwgcHJvbWlzZXMsIGNvbnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBsb2FkS21sKGRhdGFTb3VyY2UsIGVudGl0eUNvbGxlY3Rpb24sIGttbCwgc291cmNlUmVzb3VyY2UsIHVyaVJlc29sdmVyLCBjb250ZXh0KSB7XHJcbiAgICAgICAgZW50aXR5Q29sbGVjdGlvbi5yZW1vdmVBbGwoKTtcclxuXHJcbiAgICAgICAgdmFyIHByb21pc2VzID0gW107XHJcbiAgICAgICAgdmFyIGRvY3VtZW50RWxlbWVudCA9IGttbC5kb2N1bWVudEVsZW1lbnQ7XHJcbiAgICAgICAgdmFyIGRvY3VtZW50ID0gZG9jdW1lbnRFbGVtZW50LmxvY2FsTmFtZSA9PT0gJ0RvY3VtZW50JyA/IGRvY3VtZW50RWxlbWVudCA6IHF1ZXJ5Rmlyc3ROb2RlKGRvY3VtZW50RWxlbWVudCwgJ0RvY3VtZW50JywgbmFtZXNwYWNlcy5rbWwpO1xyXG4gICAgICAgIHZhciBuYW1lID0gcXVlcnlTdHJpbmdWYWx1ZShkb2N1bWVudCwgJ25hbWUnLCBuYW1lc3BhY2VzLmttbCk7XHJcbiAgICAgICAgaWYgKCFkZWZpbmVkKG5hbWUpKSB7XHJcbiAgICAgICAgICAgIG5hbWUgPSBnZXRGaWxlbmFtZUZyb21Vcmkoc291cmNlUmVzb3VyY2UuZ2V0VXJsQ29tcG9uZW50KCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gT25seSBzZXQgdGhlIG5hbWUgZnJvbSB0aGUgcm9vdCBkb2N1bWVudFxyXG4gICAgICAgIGlmICghZGVmaW5lZChkYXRhU291cmNlLl9uYW1lKSkge1xyXG4gICAgICAgICAgICBkYXRhU291cmNlLl9uYW1lID0gbmFtZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBzdHlsZUNvbGxlY3Rpb24gPSBuZXcgRW50aXR5Q29sbGVjdGlvbihkYXRhU291cmNlKTtcclxuICAgICAgICByZXR1cm4gd2hlbi5hbGwocHJvY2Vzc1N0eWxlcyhkYXRhU291cmNlLCBrbWwsIHN0eWxlQ29sbGVjdGlvbiwgc291cmNlUmVzb3VyY2UsIGZhbHNlLCB1cmlSZXNvbHZlcikpLnRoZW4oZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0ga21sLmRvY3VtZW50RWxlbWVudDtcclxuICAgICAgICAgICAgaWYgKGVsZW1lbnQubG9jYWxOYW1lID09PSAna21sJykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkTm9kZXMgPSBlbGVtZW50LmNoaWxkTm9kZXM7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdG1wID0gY2hpbGROb2Rlc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGVmaW5lZChmZWF0dXJlVHlwZXNbdG1wLmxvY2FsTmFtZV0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSB0bXA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbnRpdHlDb2xsZWN0aW9uLnN1c3BlbmRFdmVudHMoKTtcclxuICAgICAgICAgICAgcHJvY2Vzc0ZlYXR1cmVOb2RlKGRhdGFTb3VyY2UsIGVsZW1lbnQsIHVuZGVmaW5lZCwgZW50aXR5Q29sbGVjdGlvbiwgc3R5bGVDb2xsZWN0aW9uLCBzb3VyY2VSZXNvdXJjZSwgdXJpUmVzb2x2ZXIsIHByb21pc2VzLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgZW50aXR5Q29sbGVjdGlvbi5yZXN1bWVFdmVudHMoKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB3aGVuLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBrbWwuZG9jdW1lbnRFbGVtZW50O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBsb2FkS216KGRhdGFTb3VyY2UsIGVudGl0eUNvbGxlY3Rpb24sIGJsb2IsIHNvdXJjZVJlc291cmNlKSB7XHJcbiAgICAgICAgdmFyIGRlZmVycmVkID0gd2hlbi5kZWZlcigpO1xyXG4gICAgICAgIHppcC5jcmVhdGVSZWFkZXIobmV3IHppcC5CbG9iUmVhZGVyKGJsb2IpLCBmdW5jdGlvbihyZWFkZXIpIHtcclxuICAgICAgICAgICAgcmVhZGVyLmdldEVudHJpZXMoZnVuY3Rpb24oZW50cmllcykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHByb21pc2VzID0gW107XHJcbiAgICAgICAgICAgICAgICB2YXIgdXJpUmVzb2x2ZXIgPSB7fTtcclxuICAgICAgICAgICAgICAgIHZhciBkb2NFbnRyeTtcclxuICAgICAgICAgICAgICAgIHZhciBkb2NEZWZlcjtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW50cmllcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlbnRyeS5kaXJlY3RvcnkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlubmVyRGVmZXIgPSB3aGVuLmRlZmVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goaW5uZXJEZWZlci5wcm9taXNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC9cXC5rbWwkL2kudGVzdChlbnRyeS5maWxlbmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIHVzZSB0aGUgZmlyc3QgS01MIGRvY3VtZW50IHdlIGNvbWUgYWNyb3NzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20va21sL2RvY3VtZW50YXRpb24va216YXJjaGl2ZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVubGVzcyB3ZSBjb21lIGFjcm9zcyBhIC5rbWwgZmlsZSBhdCB0aGUgcm9vdCBvZiB0aGUgYXJjaGl2ZSBiZWNhdXNlIEdFIGRvZXMgdGhpc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkZWZpbmVkKGRvY0VudHJ5KSB8fCAhL1xcLy9pLnRlc3QoZW50cnkuZmlsZW5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlZmluZWQoZG9jRW50cnkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGZvdW5kIG9uZSBhdCB0aGUgcm9vdCBzbyBsb2FkIHRoZSBpbml0aWFsIGttbCBhcyBhIGRhdGEgdXJpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvYWREYXRhVXJpRnJvbVppcChkb2NFbnRyeSwgdXJpUmVzb2x2ZXIsIGRvY0RlZmVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jRW50cnkgPSBlbnRyeTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2NEZWZlciA9IGlubmVyRGVmZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdhc24ndCB0aGUgZmlyc3Qga21sIGFuZCB3YXNuJ3QgYXQgdGhlIHJvb3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2FkRGF0YVVyaUZyb21aaXAoZW50cnksIHVyaVJlc29sdmVyLCBpbm5lckRlZmVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvYWREYXRhVXJpRnJvbVppcChlbnRyeSwgdXJpUmVzb2x2ZXIsIGlubmVyRGVmZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIE5vdyBsb2FkIHRoZSByb290IEtNTCBkb2N1bWVudFxyXG4gICAgICAgICAgICAgICAgaWYgKGRlZmluZWQoZG9jRW50cnkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9hZFhtbEZyb21aaXAoZG9jRW50cnksIHVyaVJlc29sdmVyLCBkb2NEZWZlcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB3aGVuLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuY2xvc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWRlZmluZWQodXJpUmVzb2x2ZXIua21sKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QobmV3IFJ1bnRpbWVFcnJvcignS01aIGZpbGUgZG9lcyBub3QgY29udGFpbiBhIEtNTCBkb2N1bWVudC4nKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdXJpUmVzb2x2ZXIua2V5cyA9IE9iamVjdC5rZXlzKHVyaVJlc29sdmVyKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9hZEttbChkYXRhU291cmNlLCBlbnRpdHlDb2xsZWN0aW9uLCB1cmlSZXNvbHZlci5rbWwsIHNvdXJjZVJlc291cmNlLCB1cmlSZXNvbHZlcik7XHJcbiAgICAgICAgICAgICAgICB9KS50aGVuKGRlZmVycmVkLnJlc29sdmUpLm90aGVyd2lzZShkZWZlcnJlZC5yZWplY3QpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChlKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbG9hZChkYXRhU291cmNlLCBlbnRpdHlDb2xsZWN0aW9uLCBkYXRhLCBvcHRpb25zKSB7XHJcbiAgICAgICAgb3B0aW9ucyA9IGRlZmF1bHRWYWx1ZShvcHRpb25zLCBkZWZhdWx0VmFsdWUuRU1QVFlfT0JKRUNUKTtcclxuICAgICAgICB2YXIgc291cmNlVXJpID0gb3B0aW9ucy5zb3VyY2VVcmk7XHJcbiAgICAgICAgdmFyIHVyaVJlc29sdmVyID0gb3B0aW9ucy51cmlSZXNvbHZlcjtcclxuICAgICAgICB2YXIgY29udGV4dCA9IG9wdGlvbnMuY29udGV4dDtcclxuXHJcbiAgICAgICAgdmFyIHByb21pc2UgPSBkYXRhO1xyXG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycgfHwgKGRhdGEgaW5zdGFuY2VvZiBSZXNvdXJjZSkpIHtcclxuICAgICAgICAgICAgZGF0YSA9IFJlc291cmNlLmNyZWF0ZUlmTmVlZGVkKGRhdGEpO1xyXG4gICAgICAgICAgICBwcm9taXNlID0gZGF0YS5mZXRjaEJsb2IoKTtcclxuICAgICAgICAgICAgc291cmNlVXJpID0gZGVmYXVsdFZhbHVlKHNvdXJjZVVyaSwgZGF0YS5jbG9uZSgpKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzb3VyY2VVcmkgPSBkZWZhdWx0VmFsdWUoc291cmNlVXJpLCBSZXNvdXJjZS5ERUZBVUxULmNsb25lKCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc291cmNlVXJpID0gUmVzb3VyY2UuY3JlYXRlSWZOZWVkZWQoc291cmNlVXJpKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHdoZW4ocHJvbWlzZSlcclxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oZGF0YVRvTG9hZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRhdGFUb0xvYWQgaW5zdGFuY2VvZiBCbG9iKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzWmlwRmlsZShkYXRhVG9Mb2FkKS50aGVuKGZ1bmN0aW9uKGlzWmlwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1ppcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvYWRLbXooZGF0YVNvdXJjZSwgZW50aXR5Q29sbGVjdGlvbiwgZGF0YVRvTG9hZCwgc291cmNlVXJpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVhZEJsb2JBc1RleHQoZGF0YVRvTG9hZCkudGhlbihmdW5jdGlvbih0ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RoZXJlJ3Mgbm8gb2ZmaWNpYWwgd2F5IHRvIHZhbGlkYXRlIGlmIGEgcGFyc2Ugd2FzIHN1Y2Nlc3NmdWwuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RoZSBmb2xsb3dpbmcgY2hlY2sgZGV0ZWN0cyB0aGUgZXJyb3Igb24gdmFyaW91cyBicm93c2Vycy5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL0luc2VydCBtaXNzaW5nIG5hbWVzcGFjZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgPSBpbnNlcnROYW1lc3BhY2VzKHRleHQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vUmVtb3ZlIER1cGxpY2F0ZSBOYW1lc3BhY2VzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gcmVtb3ZlRHVwbGljYXRlTmFtZXNwYWNlcyh0ZXh0KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL0lFIHJhaXNlcyBhbiBleGNlcHRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrbWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGttbCA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcodGV4dCwgJ2FwcGxpY2F0aW9uL3htbCcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gZS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vVGhlIHBhcnNlIHN1Y2NlZWRzIG9uIENocm9tZSBhbmQgRmlyZWZveCwgYnV0IHRoZSBlcnJvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9oYW5kbGluZyBpcyBkaWZmZXJlbnQgaW4gZWFjaC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWZpbmVkKGVycm9yKSB8fCBrbWwuYm9keSB8fCBrbWwuZG9jdW1lbnRFbGVtZW50LnRhZ05hbWUgPT09ICdwYXJzZXJlcnJvcicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL0ZpcmVmb3ggaGFzIGVycm9yIGluZm9ybWF0aW9uIGFzIHRoZSBmaXJzdENoaWxkIG5vZGVWYWx1ZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbXNnID0gZGVmaW5lZChlcnJvcikgPyBlcnJvciA6IGttbC5kb2N1bWVudEVsZW1lbnQuZmlyc3RDaGlsZC5ub2RlVmFsdWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vQ2hyb21lIGhhcyBpdCBpbiB0aGUgYm9keSB0ZXh0LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbXNnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1zZyA9IGttbC5ib2R5LmlubmVyVGV4dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vUmV0dXJuIHRoZSBlcnJvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3IobXNnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2FkS21sKGRhdGFTb3VyY2UsIGVudGl0eUNvbGxlY3Rpb24sIGttbCwgc291cmNlVXJpLCB1cmlSZXNvbHZlciwgY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvYWRLbWwoZGF0YVNvdXJjZSwgZW50aXR5Q29sbGVjdGlvbiwgZGF0YVRvTG9hZCwgc291cmNlVXJpLCB1cmlSZXNvbHZlciwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5vdGhlcndpc2UoZnVuY3Rpb24oZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGRhdGFTb3VyY2UuX2Vycm9yLnJhaXNlRXZlbnQoZGF0YVNvdXJjZSwgZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHdoZW4ucmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIHtAbGluayBEYXRhU291cmNlfSB3aGljaCBwcm9jZXNzZXMgS2V5aG9sZSBNYXJrdXAgTGFuZ3VhZ2UgMi4yIChLTUwpLlxyXG4gICAgICogPHA+XHJcbiAgICAgKiBLTUwgc3VwcG9ydCBpbiBDZXNpdW0gaXMgaW5jb21wbGV0ZSwgYnV0IGEgbGFyZ2UgYW1vdW50IG9mIHRoZSBzdGFuZGFyZCxcclxuICAgICAqIGFzIHdlbGwgYXMgR29vZ2xlJ3MgPGNvZGU+Z3g8L2NvZGU+IGV4dGVuc2lvbiBuYW1lc3BhY2UsIGlzIHN1cHBvcnRlZC4gU2VlIEdpdGh1YiBpc3N1ZVxyXG4gICAgICoge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9BbmFseXRpY2FsR3JhcGhpY3NJbmMvY2VzaXVtL2lzc3Vlcy84NzN8Izg3M30gZm9yIGFcclxuICAgICAqIGRldGFpbGVkIGxpc3Qgb2Ygd2hhdCBpcyBhbmQgaXNuJ3Qgc3VwcG9ydC4gQ2VzaXVtIHdpbGwgYWxzbyB3cml0ZSBpbmZvcm1hdGlvbiB0byB0aGVcclxuICAgICAqIGNvbnNvbGUgd2hlbiBpdCBlbmNvdW50ZXJzIG1vc3QgdW5zdXBwb3J0ZWQgZmVhdHVyZXMuXHJcbiAgICAgKiA8L3A+XHJcbiAgICAgKiA8cD5cclxuICAgICAqIE5vbiB2aXN1YWwgZmVhdHVyZSBkYXRhLCBzdWNoIGFzIDxjb2RlPmF0b206YXV0aG9yPC9jb2RlPiBhbmQgPGNvZGU+RXh0ZW5kZWREYXRhPC9jb2RlPlxyXG4gICAgICogaXMgZXhwb3NlZCB2aWEgYW4gaW5zdGFuY2Ugb2Yge0BsaW5rIEttbEZlYXR1cmVEYXRhfSwgd2hpY2ggaXMgYWRkZWQgdG8gZWFjaCB7QGxpbmsgRW50aXR5fVxyXG4gICAgICogdW5kZXIgdGhlIDxjb2RlPmttbDwvY29kZT4gcHJvcGVydHkuXHJcbiAgICAgKiA8L3A+XHJcbiAgICAgKlxyXG4gICAgICogQGFsaWFzIEttbERhdGFTb3VyY2VcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIEFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcclxuICAgICAqIEBwYXJhbSB7Q2FtZXJhfSBvcHRpb25zLmNhbWVyYSBUaGUgY2FtZXJhIHRoYXQgaXMgdXNlZCBmb3Igdmlld1JlZnJlc2hNb2RlcyBhbmQgc2VuZGluZyBjYW1lcmEgcHJvcGVydGllcyB0byBuZXR3b3JrIGxpbmtzLlxyXG4gICAgICogQHBhcmFtIHtDYW52YXN9IG9wdGlvbnMuY2FudmFzIFRoZSBjYW52YXMgdGhhdCBpcyB1c2VkIGZvciBzZW5kaW5nIHZpZXdlciBwcm9wZXJ0aWVzIHRvIG5ldHdvcmsgbGlua3MuXHJcbiAgICAgKiBAcGFyYW0ge0VsbGlwc29pZH0gW29wdGlvbnMuZWxsaXBzb2lkPUVsbGlwc29pZC5XR1M4NF0gVGhlIGdsb2JhbCBlbGxpcHNvaWQgdXNlZCBmb3IgZ2VvZ3JhcGhpY2FsIGNhbGN1bGF0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwOi8vd3d3Lm9wZW5nZW9zcGF0aWFsLm9yZy9zdGFuZGFyZHMva21sL3xPcGVuIEdlb3NwYXRpYWwgQ29uc29ydGl1bSBLTUwgU3RhbmRhcmR9XHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9rbWwvfEdvb2dsZSBLTUwgRG9jdW1lbnRhdGlvbn1cclxuICAgICAqXHJcbiAgICAgKiBAZGVtbyB7QGxpbmsgaHR0cHM6Ly9jZXNpdW1qcy5vcmcvQ2VzaXVtL0FwcHMvU2FuZGNhc3RsZS9pbmRleC5odG1sP3NyYz1LTUwuaHRtbHxDZXNpdW0gU2FuZGNhc3RsZSBLTUwgRGVtb31cclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogdmFyIHZpZXdlciA9IG5ldyBDZXNpdW0uVmlld2VyKCdjZXNpdW1Db250YWluZXInKTtcclxuICAgICAqIHZpZXdlci5kYXRhU291cmNlcy5hZGQoQ2VzaXVtLkttbERhdGFTb3VyY2UubG9hZCgnLi4vLi4vU2FtcGxlRGF0YS9mYWNpbGl0aWVzLmtteicsXHJcbiAgICAgKiAgICAgIHtcclxuICAgICAqICAgICAgICAgICBjYW1lcmE6IHZpZXdlci5zY2VuZS5jYW1lcmEsXHJcbiAgICAgKiAgICAgICAgICAgY2FudmFzOiB2aWV3ZXIuc2NlbmUuY2FudmFzXHJcbiAgICAgKiAgICAgIH0pXHJcbiAgICAgKiApO1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBLbWxEYXRhU291cmNlKG9wdGlvbnMpIHtcclxuICAgICAgICBvcHRpb25zID0gZGVmYXVsdFZhbHVlKG9wdGlvbnMsIHt9KTtcclxuICAgICAgICB2YXIgY2FtZXJhID0gb3B0aW9ucy5jYW1lcmE7XHJcbiAgICAgICAgdmFyIGNhbnZhcyA9IG9wdGlvbnMuY2FudmFzO1xyXG5cclxuICAgICAgICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xyXG4gICAgICAgIGlmICghZGVmaW5lZChjYW1lcmEpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcignb3B0aW9ucy5jYW1lcmEgaXMgcmVxdWlyZWQuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghZGVmaW5lZChjYW52YXMpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcignb3B0aW9ucy5jYW52YXMgaXMgcmVxdWlyZWQuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xyXG5cclxuICAgICAgICB0aGlzLl9jaGFuZ2VkID0gbmV3IEV2ZW50KCk7XHJcbiAgICAgICAgdGhpcy5fZXJyb3IgPSBuZXcgRXZlbnQoKTtcclxuICAgICAgICB0aGlzLl9sb2FkaW5nID0gbmV3IEV2ZW50KCk7XHJcbiAgICAgICAgdGhpcy5fcmVmcmVzaCA9IG5ldyBFdmVudCgpO1xyXG4gICAgICAgIHRoaXMuX3Vuc3VwcG9ydGVkTm9kZSA9IG5ldyBFdmVudCgpO1xyXG5cclxuICAgICAgICB0aGlzLl9jbG9jayA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLl9lbnRpdHlDb2xsZWN0aW9uID0gbmV3IEVudGl0eUNvbGxlY3Rpb24odGhpcyk7XHJcbiAgICAgICAgdGhpcy5fbmFtZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLl9pc0xvYWRpbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9waW5CdWlsZGVyID0gbmV3IFBpbkJ1aWxkZXIoKTtcclxuICAgICAgICB0aGlzLl9uZXR3b3JrTGlua3MgPSBuZXcgQXNzb2NpYXRpdmVBcnJheSgpO1xyXG4gICAgICAgIHRoaXMuX2VudGl0eUNsdXN0ZXIgPSBuZXcgRW50aXR5Q2x1c3RlcigpO1xyXG5cclxuICAgICAgICB0aGlzLl9jYW52YXMgPSBjYW52YXM7XHJcbiAgICAgICAgdGhpcy5fY2FtZXJhID0gY2FtZXJhO1xyXG4gICAgICAgIHRoaXMuX2xhc3RDYW1lcmFWaWV3ID0ge1xyXG4gICAgICAgICAgICBwb3NpdGlvbiA6IGRlZmluZWQoY2FtZXJhKSA/IENhcnRlc2lhbjMuY2xvbmUoY2FtZXJhLnBvc2l0aW9uV0MpIDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBkaXJlY3Rpb24gOiBkZWZpbmVkKGNhbWVyYSkgPyBDYXJ0ZXNpYW4zLmNsb25lKGNhbWVyYS5kaXJlY3Rpb25XQykgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIHVwIDogZGVmaW5lZChjYW1lcmEpID8gQ2FydGVzaWFuMy5jbG9uZShjYW1lcmEudXBXQykgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIGJib3ggOiBkZWZpbmVkKGNhbWVyYSkgPyBjYW1lcmEuY29tcHV0ZVZpZXdSZWN0YW5nbGUoKSA6IFJlY3RhbmdsZS5jbG9uZShSZWN0YW5nbGUuTUFYX1ZBTFVFKVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRoaXMuX2VsbGlwc29pZCA9IGRlZmF1bHRWYWx1ZShvcHRpb25zLmVsbGlwc29pZCwgRWxsaXBzb2lkLldHUzg0KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBQcm9taXNlIHRvIGEgbmV3IGluc3RhbmNlIGxvYWRlZCB3aXRoIHRoZSBwcm92aWRlZCBLTUwgZGF0YS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1Jlc291cmNlfFN0cmluZ3xEb2N1bWVudHxCbG9ifSBkYXRhIEEgdXJsLCBwYXJzZWQgS01MIGRvY3VtZW50LCBvciBCbG9iIGNvbnRhaW5pbmcgYmluYXJ5IEtNWiBkYXRhIG9yIGEgcGFyc2VkIEtNTCBkb2N1bWVudC5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIEFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcclxuICAgICAqIEBwYXJhbSB7Q2FtZXJhfSBvcHRpb25zLmNhbWVyYSBUaGUgY2FtZXJhIHRoYXQgaXMgdXNlZCBmb3Igdmlld1JlZnJlc2hNb2RlcyBhbmQgc2VuZGluZyBjYW1lcmEgcHJvcGVydGllcyB0byBuZXR3b3JrIGxpbmtzLlxyXG4gICAgICogQHBhcmFtIHtDYW52YXN9IG9wdGlvbnMuY2FudmFzIFRoZSBjYW52YXMgdGhhdCBpcyB1c2VkIGZvciBzZW5kaW5nIHZpZXdlciBwcm9wZXJ0aWVzIHRvIG5ldHdvcmsgbGlua3MuXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuc291cmNlVXJpXSBPdmVycmlkZXMgdGhlIHVybCB0byB1c2UgZm9yIHJlc29sdmluZyByZWxhdGl2ZSBsaW5rcyBhbmQgb3RoZXIgS01MIG5ldHdvcmsgZmVhdHVyZXMuXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNsYW1wVG9Hcm91bmQ9ZmFsc2VdIHRydWUgaWYgd2Ugd2FudCB0aGUgZ2VvbWV0cnkgZmVhdHVyZXMgKFBvbHlnb25zLCBMaW5lU3RyaW5ncyBhbmQgTGluZWFyUmluZ3MpIGNsYW1wZWQgdG8gdGhlIGdyb3VuZC5cclxuICAgICAqIEBwYXJhbSB7RWxsaXBzb2lkfSBbb3B0aW9ucy5lbGxpcHNvaWQ9RWxsaXBzb2lkLldHUzg0XSBUaGUgZ2xvYmFsIGVsbGlwc29pZCB1c2VkIGZvciBnZW9ncmFwaGljYWwgY2FsY3VsYXRpb25zLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlLjxLbWxEYXRhU291cmNlPn0gQSBwcm9taXNlIHRoYXQgd2lsbCByZXNvbHZlIHRvIGEgbmV3IEttbERhdGFTb3VyY2UgaW5zdGFuY2Ugb25jZSB0aGUgS01MIGlzIGxvYWRlZC5cclxuICAgICAqL1xyXG4gICAgS21sRGF0YVNvdXJjZS5sb2FkID0gZnVuY3Rpb24oZGF0YSwgb3B0aW9ucykge1xyXG4gICAgICAgIG9wdGlvbnMgPSBkZWZhdWx0VmFsdWUob3B0aW9ucywgZGVmYXVsdFZhbHVlLkVNUFRZX09CSkVDVCk7XHJcbiAgICAgICAgdmFyIGRhdGFTb3VyY2UgPSBuZXcgS21sRGF0YVNvdXJjZShvcHRpb25zKTtcclxuICAgICAgICByZXR1cm4gZGF0YVNvdXJjZS5sb2FkKGRhdGEsIG9wdGlvbnMpO1xyXG4gICAgfTtcclxuXHJcbiAgICBkZWZpbmVQcm9wZXJ0aWVzKEttbERhdGFTb3VyY2UucHJvdG90eXBlLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBvciBzZXRzIGEgaHVtYW4tcmVhZGFibGUgbmFtZSBmb3IgdGhpcyBpbnN0YW5jZS5cclxuICAgICAgICAgKiBUaGlzIHdpbGwgYmUgYXV0b21hdGljYWxseSBiZSBzZXQgdG8gdGhlIEtNTCBkb2N1bWVudCBuYW1lIG9uIGxvYWQuXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEttbERhdGFTb3VyY2UucHJvdG90eXBlXHJcbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cclxuICAgICAgICAgKi9cclxuICAgICAgICBuYW1lIDoge1xyXG4gICAgICAgICAgICBnZXQgOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzZXQgOiBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX25hbWUgIT09IHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbmFtZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZWQucmFpc2VFdmVudCh0aGlzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgY2xvY2sgc2V0dGluZ3MgZGVmaW5lZCBieSB0aGUgbG9hZGVkIEtNTC4gVGhpcyByZXByZXNlbnRzIHRoZSB0b3RhbFxyXG4gICAgICAgICAqIGF2YWlsYWJpbGl0eSBpbnRlcnZhbCBmb3IgYWxsIHRpbWUtZHluYW1pYyBkYXRhLiBJZiB0aGUgS01MIGRvZXMgbm90IGNvbnRhaW5cclxuICAgICAgICAgKiB0aW1lLWR5bmFtaWMgZGF0YSwgdGhpcyB2YWx1ZSBpcyB1bmRlZmluZWQuXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEttbERhdGFTb3VyY2UucHJvdG90eXBlXHJcbiAgICAgICAgICogQHR5cGUge0RhdGFTb3VyY2VDbG9ja31cclxuICAgICAgICAgKi9cclxuICAgICAgICBjbG9jayA6IHtcclxuICAgICAgICAgICAgZ2V0IDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2xvY2s7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIGNvbGxlY3Rpb24gb2Yge0BsaW5rIEVudGl0eX0gaW5zdGFuY2VzLlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBLbWxEYXRhU291cmNlLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEB0eXBlIHtFbnRpdHlDb2xsZWN0aW9ufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGVudGl0aWVzIDoge1xyXG4gICAgICAgICAgICBnZXQgOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9lbnRpdHlDb2xsZWN0aW9uO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIGEgdmFsdWUgaW5kaWNhdGluZyBpZiB0aGUgZGF0YSBzb3VyY2UgaXMgY3VycmVudGx5IGxvYWRpbmcgZGF0YS5cclxuICAgICAgICAgKiBAbWVtYmVyb2YgS21sRGF0YVNvdXJjZS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBpc0xvYWRpbmcgOiB7XHJcbiAgICAgICAgICAgIGdldCA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzTG9hZGluZztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBhbiBldmVudCB0aGF0IHdpbGwgYmUgcmFpc2VkIHdoZW4gdGhlIHVuZGVybHlpbmcgZGF0YSBjaGFuZ2VzLlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBLbWxEYXRhU291cmNlLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEB0eXBlIHtFdmVudH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBjaGFuZ2VkRXZlbnQgOiB7XHJcbiAgICAgICAgICAgIGdldCA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NoYW5nZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgYW4gZXZlbnQgdGhhdCB3aWxsIGJlIHJhaXNlZCBpZiBhbiBlcnJvciBpcyBlbmNvdW50ZXJlZCBkdXJpbmcgcHJvY2Vzc2luZy5cclxuICAgICAgICAgKiBAbWVtYmVyb2YgS21sRGF0YVNvdXJjZS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAdHlwZSB7RXZlbnR9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZXJyb3JFdmVudCA6IHtcclxuICAgICAgICAgICAgZ2V0IDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZXJyb3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgYW4gZXZlbnQgdGhhdCB3aWxsIGJlIHJhaXNlZCB3aGVuIHRoZSBkYXRhIHNvdXJjZSBlaXRoZXIgc3RhcnRzIG9yIHN0b3BzIGxvYWRpbmcuXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEttbERhdGFTb3VyY2UucHJvdG90eXBlXHJcbiAgICAgICAgICogQHR5cGUge0V2ZW50fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGxvYWRpbmdFdmVudCA6IHtcclxuICAgICAgICAgICAgZ2V0IDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9hZGluZztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBhbiBldmVudCB0aGF0IHdpbGwgYmUgcmFpc2VkIHdoZW4gdGhlIGRhdGEgc291cmNlIHJlZnJlc2hlcyBhIG5ldHdvcmsgbGluay5cclxuICAgICAgICAgKiBAbWVtYmVyb2YgS21sRGF0YVNvdXJjZS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAdHlwZSB7RXZlbnR9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcmVmcmVzaEV2ZW50IDoge1xyXG4gICAgICAgICAgICBnZXQgOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWZyZXNoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIGFuIGV2ZW50IHRoYXQgd2lsbCBiZSByYWlzZWQgd2hlbiB0aGUgZGF0YSBzb3VyY2UgZmluZHMgYW4gdW5zdXBwb3J0ZWQgbm9kZSB0eXBlLlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBLbWxEYXRhU291cmNlLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEB0eXBlIHtFdmVudH1cclxuICAgICAgICAgKi9cclxuICAgICAgICB1bnN1cHBvcnRlZE5vZGVFdmVudCA6IHtcclxuICAgICAgICAgICAgZ2V0IDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdW5zdXBwb3J0ZWROb2RlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHdoZXRoZXIgb3Igbm90IHRoaXMgZGF0YSBzb3VyY2Ugc2hvdWxkIGJlIGRpc3BsYXllZC5cclxuICAgICAgICAgKiBAbWVtYmVyb2YgS21sRGF0YVNvdXJjZS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBzaG93IDoge1xyXG4gICAgICAgICAgICBnZXQgOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9lbnRpdHlDb2xsZWN0aW9uLnNob3c7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNldCA6IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9lbnRpdHlDb2xsZWN0aW9uLnNob3cgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgY2x1c3RlcmluZyBvcHRpb25zIGZvciB0aGlzIGRhdGEgc291cmNlLiBUaGlzIG9iamVjdCBjYW4gYmUgc2hhcmVkIGJldHdlZW4gbXVsdGlwbGUgZGF0YSBzb3VyY2VzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEttbERhdGFTb3VyY2UucHJvdG90eXBlXHJcbiAgICAgICAgICogQHR5cGUge0VudGl0eUNsdXN0ZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2x1c3RlcmluZyA6IHtcclxuICAgICAgICAgICAgZ2V0IDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZW50aXR5Q2x1c3RlcjtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2V0IDogZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWRlZmluZWQodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKCd2YWx1ZSBtdXN0IGJlIGRlZmluZWQuJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2VudGl0eUNsdXN0ZXIgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXN5bmNocm9ub3VzbHkgbG9hZHMgdGhlIHByb3ZpZGVkIEtNTCBkYXRhLCByZXBsYWNpbmcgYW55IGV4aXN0aW5nIGRhdGEuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtSZXNvdXJjZXxTdHJpbmd8RG9jdW1lbnR8QmxvYn0gZGF0YSBBIHVybCwgcGFyc2VkIEtNTCBkb2N1bWVudCwgb3IgQmxvYiBjb250YWluaW5nIGJpbmFyeSBLTVogZGF0YSBvciBhIHBhcnNlZCBLTUwgZG9jdW1lbnQuXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcclxuICAgICAqIEBwYXJhbSB7UmVzb3VyY2V8U3RyaW5nfSBbb3B0aW9ucy5zb3VyY2VVcmldIE92ZXJyaWRlcyB0aGUgdXJsIHRvIHVzZSBmb3IgcmVzb2x2aW5nIHJlbGF0aXZlIGxpbmtzIGFuZCBvdGhlciBLTUwgbmV0d29yayBmZWF0dXJlcy5cclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY2xhbXBUb0dyb3VuZD1mYWxzZV0gdHJ1ZSBpZiB3ZSB3YW50IHRoZSBnZW9tZXRyeSBmZWF0dXJlcyAoUG9seWdvbnMsIExpbmVTdHJpbmdzIGFuZCBMaW5lYXJSaW5ncykgY2xhbXBlZCB0byB0aGUgZ3JvdW5kLiBJZiB0cnVlLCBsaW5lcyB3aWxsIHVzZSBjb3JyaWRvcnMgc28gdXNlIEVudGl0eS5jb3JyaWRvciBpbnN0ZWFkIG9mIEVudGl0eS5wb2x5bGluZS5cclxuICAgICAqIEBwYXJhbSB7RWxsaXBzb2lkfSBbb3B0aW9ucy5lbGxpcHNvaWQ9RWxsaXBzb2lkLldHUzg0XSBUaGUgZ2xvYmFsIGVsbGlwc29pZCB1c2VkIGZvciBnZW9ncmFwaGljYWwgY2FsY3VsYXRpb25zLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlLjxLbWxEYXRhU291cmNlPn0gQSBwcm9taXNlIHRoYXQgd2lsbCByZXNvbHZlIHRvIHRoaXMgaW5zdGFuY2VzIG9uY2UgdGhlIEtNTCBpcyBsb2FkZWQuXHJcbiAgICAgKi9cclxuICAgIEttbERhdGFTb3VyY2UucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbihkYXRhLCBvcHRpb25zKSB7XHJcbiAgICAgICAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcclxuICAgICAgICBpZiAoIWRlZmluZWQoZGF0YSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKCdkYXRhIGlzIHJlcXVpcmVkLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcclxuXHJcbiAgICAgICAgb3B0aW9ucyA9IGRlZmF1bHRWYWx1ZShvcHRpb25zLCB7fSk7XHJcbiAgICAgICAgRGF0YVNvdXJjZS5zZXRMb2FkaW5nKHRoaXMsIHRydWUpO1xyXG5cclxuICAgICAgICB2YXIgb2xkTmFtZSA9IHRoaXMuX25hbWU7XHJcbiAgICAgICAgdGhpcy5fbmFtZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLl9jbGFtcFRvR3JvdW5kID0gZGVmYXVsdFZhbHVlKG9wdGlvbnMuY2xhbXBUb0dyb3VuZCwgZmFsc2UpO1xyXG5cclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIGxvYWQodGhpcywgdGhpcy5fZW50aXR5Q29sbGVjdGlvbiwgZGF0YSwgb3B0aW9ucykudGhlbihmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIGNsb2NrO1xyXG5cclxuICAgICAgICAgICAgdmFyIGF2YWlsYWJpbGl0eSA9IHRoYXQuX2VudGl0eUNvbGxlY3Rpb24uY29tcHV0ZUF2YWlsYWJpbGl0eSgpO1xyXG5cclxuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gYXZhaWxhYmlsaXR5LnN0YXJ0O1xyXG4gICAgICAgICAgICB2YXIgc3RvcCA9IGF2YWlsYWJpbGl0eS5zdG9wO1xyXG4gICAgICAgICAgICB2YXIgaXNNaW5TdGFydCA9IEp1bGlhbkRhdGUuZXF1YWxzKHN0YXJ0LCBJc284NjAxLk1JTklNVU1fVkFMVUUpO1xyXG4gICAgICAgICAgICB2YXIgaXNNYXhTdG9wID0gSnVsaWFuRGF0ZS5lcXVhbHMoc3RvcCwgSXNvODYwMS5NQVhJTVVNX1ZBTFVFKTtcclxuICAgICAgICAgICAgaWYgKCFpc01pblN0YXJ0IHx8ICFpc01heFN0b3ApIHtcclxuICAgICAgICAgICAgICAgIHZhciBkYXRlO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vSWYgc3RhcnQgaXMgbWluIHRpbWUganVzdCBzdGFydCBhdCBtaWRuaWdodCB0aGlzIG1vcm5pbmcsIGxvY2FsIHRpbWVcclxuICAgICAgICAgICAgICAgIGlmIChpc01pblN0YXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IEp1bGlhbkRhdGUuZnJvbURhdGUoZGF0ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy9JZiBzdG9wIGlzIG1heCB2YWx1ZSBqdXN0IHN0b3AgYXQgbWlkbmlnaHQgdG9uaWdodCwgbG9jYWwgdGltZVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzTWF4U3RvcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGUuc2V0SG91cnMoMjQsIDAsIDAsIDApO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0b3AgPSBKdWxpYW5EYXRlLmZyb21EYXRlKGRhdGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGNsb2NrID0gbmV3IERhdGFTb3VyY2VDbG9jaygpO1xyXG4gICAgICAgICAgICAgICAgY2xvY2suc3RhcnRUaW1lID0gc3RhcnQ7XHJcbiAgICAgICAgICAgICAgICBjbG9jay5zdG9wVGltZSA9IHN0b3A7XHJcbiAgICAgICAgICAgICAgICBjbG9jay5jdXJyZW50VGltZSA9IEp1bGlhbkRhdGUuY2xvbmUoc3RhcnQpO1xyXG4gICAgICAgICAgICAgICAgY2xvY2suY2xvY2tSYW5nZSA9IENsb2NrUmFuZ2UuTE9PUF9TVE9QO1xyXG4gICAgICAgICAgICAgICAgY2xvY2suY2xvY2tTdGVwID0gQ2xvY2tTdGVwLlNZU1RFTV9DTE9DS19NVUxUSVBMSUVSO1xyXG4gICAgICAgICAgICAgICAgY2xvY2subXVsdGlwbGllciA9IE1hdGgucm91bmQoTWF0aC5taW4oTWF0aC5tYXgoSnVsaWFuRGF0ZS5zZWNvbmRzRGlmZmVyZW5jZShzdG9wLCBzdGFydCkgLyA2MCwgMSksIDMuMTU1NjllNykpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgY2hhbmdlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAoY2xvY2sgIT09IHRoYXQuX2Nsb2NrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGF0Ll9jbG9jayA9IGNsb2NrO1xyXG4gICAgICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChvbGROYW1lICE9PSB0aGF0Ll9uYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGNoYW5nZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoYXQuX2NoYW5nZWQucmFpc2VFdmVudCh0aGF0KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgRGF0YVNvdXJjZS5zZXRMb2FkaW5nKHRoYXQsIGZhbHNlKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGF0O1xyXG4gICAgICAgIH0pLm90aGVyd2lzZShmdW5jdGlvbihlcnJvcikge1xyXG4gICAgICAgICAgICBEYXRhU291cmNlLnNldExvYWRpbmcodGhhdCwgZmFsc2UpO1xyXG4gICAgICAgICAgICB0aGF0Ll9lcnJvci5yYWlzZUV2ZW50KHRoYXQsIGVycm9yKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coZXJyb3IpO1xyXG4gICAgICAgICAgICByZXR1cm4gd2hlbi5yZWplY3QoZXJyb3IpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBtZXJnZUF2YWlsYWJpbGl0eVdpdGhQYXJlbnQoY2hpbGQpIHtcclxuICAgICAgICB2YXIgcGFyZW50ID0gY2hpbGQucGFyZW50O1xyXG4gICAgICAgIGlmIChkZWZpbmVkKHBhcmVudCkpIHtcclxuICAgICAgICAgICAgdmFyIHBhcmVudEF2YWlsYWJpbGl0eSA9IHBhcmVudC5hdmFpbGFiaWxpdHk7XHJcbiAgICAgICAgICAgIGlmIChkZWZpbmVkKHBhcmVudEF2YWlsYWJpbGl0eSkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjaGlsZEF2YWlsYWJpbGl0eSA9IGNoaWxkLmF2YWlsYWJpbGl0eTtcclxuICAgICAgICAgICAgICAgIGlmIChkZWZpbmVkKGNoaWxkQXZhaWxhYmlsaXR5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkQXZhaWxhYmlsaXR5LmludGVyc2VjdChwYXJlbnRBdmFpbGFiaWxpdHkpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZC5hdmFpbGFiaWxpdHkgPSBwYXJlbnRBdmFpbGFiaWxpdHk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0TmV0d29ya0xpbmtVcGRhdGVDYWxsYmFjayhkYXRhU291cmNlLCBuZXR3b3JrTGluaywgbmV3RW50aXR5Q29sbGVjdGlvbiwgbmV0d29ya0xpbmtzLCBwcm9jZXNzZWRIcmVmKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHJvb3RFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGlmICghbmV0d29ya0xpbmtzLmNvbnRhaW5zKG5ldHdvcmtMaW5rLmlkKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gR290IGludG8gdGhlIG9kZCBjYXNlIHdoZXJlIGEgcGFyZW50IG5ldHdvcmsgbGluayB3YXMgdXBkYXRlZCB3aGlsZSBhIGNoaWxkXHJcbiAgICAgICAgICAgICAgICAvLyAgbmV0d29yayBsaW5rIHVwZGF0ZSB3YXMgaW4gZmxpZ2h0LCBzbyBqdXN0IHRocm93IGl0IGF3YXkuXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHJlbW92ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB2YXIgbmV0d29ya0xpbmtDb250cm9sID0gcXVlcnlGaXJzdE5vZGUocm9vdEVsZW1lbnQsICdOZXR3b3JrTGlua0NvbnRyb2wnLCBuYW1lc3BhY2VzLmttbCk7XHJcbiAgICAgICAgICAgIHZhciBoYXNOZXR3b3JrTGlua0NvbnRyb2wgPSBkZWZpbmVkKG5ldHdvcmtMaW5rQ29udHJvbCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgbWluUmVmcmVzaFBlcmlvZCA9IDA7XHJcbiAgICAgICAgICAgIGlmIChoYXNOZXR3b3JrTGlua0NvbnRyb2wpIHtcclxuICAgICAgICAgICAgICAgIGlmIChkZWZpbmVkKHF1ZXJ5Rmlyc3ROb2RlKG5ldHdvcmtMaW5rQ29udHJvbCwgJ1VwZGF0ZScsIG5hbWVzcGFjZXMua21sKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBvbmVUaW1lV2FybmluZygna21sLW5ldHdvcmtMaW5rQ29udHJvbC11cGRhdGUnLCAnS01MIC0gTmV0d29ya0xpbmtDb250cm9sIHVwZGF0ZXMgYXJlblxcJ3Qgc3VwcG9ydGVkLicpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5ldHdvcmtMaW5rLnVwZGF0aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV0d29ya0xpbmtzLnJlbW92ZShuZXR3b3JrTGluay5pZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbmV0d29ya0xpbmsuY29va2llID0gcXVlcnlUb09iamVjdChkZWZhdWx0VmFsdWUocXVlcnlTdHJpbmdWYWx1ZShuZXR3b3JrTGlua0NvbnRyb2wsICdjb29raWUnLCBuYW1lc3BhY2VzLmttbCksICcnKSk7XHJcbiAgICAgICAgICAgICAgICBtaW5SZWZyZXNoUGVyaW9kID0gZGVmYXVsdFZhbHVlKHF1ZXJ5TnVtZXJpY1ZhbHVlKG5ldHdvcmtMaW5rQ29udHJvbCwgJ21pblJlZnJlc2hQZXJpb2QnLCBuYW1lc3BhY2VzLmttbCksIDApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgbm93ID0gSnVsaWFuRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgdmFyIHJlZnJlc2hNb2RlID0gbmV0d29ya0xpbmsucmVmcmVzaE1vZGU7XHJcbiAgICAgICAgICAgIGlmIChyZWZyZXNoTW9kZSA9PT0gUmVmcmVzaE1vZGUuSU5URVJWQUwpIHtcclxuICAgICAgICAgICAgICAgIGlmIChkZWZpbmVkKG5ldHdvcmtMaW5rQ29udHJvbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXR3b3JrTGluay50aW1lID0gTWF0aC5tYXgobWluUmVmcmVzaFBlcmlvZCwgbmV0d29ya0xpbmsudGltZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVmcmVzaE1vZGUgPT09IFJlZnJlc2hNb2RlLkVYUElSRSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGV4cGlyZXM7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGVmaW5lZChuZXR3b3JrTGlua0NvbnRyb2wpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwaXJlcyA9IHF1ZXJ5U3RyaW5nVmFsdWUobmV0d29ya0xpbmtDb250cm9sLCAnZXhwaXJlcycsIG5hbWVzcGFjZXMua21sKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChkZWZpbmVkKGV4cGlyZXMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGUgPSBKdWxpYW5EYXRlLmZyb21Jc284NjAxKGV4cGlyZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGlmZiA9IEp1bGlhbkRhdGUuc2Vjb25kc0RpZmZlcmVuY2UoZGF0ZSwgbm93KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpZmYgPiAwICYmIGRpZmYgPCBtaW5SZWZyZXNoUGVyaW9kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBKdWxpYW5EYXRlLmFkZFNlY29uZHMobm93LCBtaW5SZWZyZXNoUGVyaW9kLCBkYXRlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXR3b3JrTGluay50aW1lID0gZGF0ZTtcclxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uZVRpbWVXYXJuaW5nKCdrbWwtbmV0d29ya0xpbmtDb250cm9sLWV4cGlyZXMnLCAnS01MIC0gTmV0d29ya0xpbmtDb250cm9sIGV4cGlyZXMgaXMgbm90IGEgdmFsaWQgZGF0ZScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb25lVGltZVdhcm5pbmcoJ2ttbC1yZWZyZXNoTW9kZS1vbkV4cGlyZScsICdLTUwgLSByZWZyZXNoTW9kZSBvZiBvbkV4cGlyZSByZXF1aXJlcyB0aGUgTmV0d29ya0xpbmtDb250cm9sIHRvIGhhdmUgYW4gZXhwaXJlcyBlbGVtZW50Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIG5ldHdvcmtMaW5rRW50aXR5ID0gbmV0d29ya0xpbmsuZW50aXR5O1xyXG4gICAgICAgICAgICB2YXIgZW50aXR5Q29sbGVjdGlvbiA9IGRhdGFTb3VyY2UuX2VudGl0eUNvbGxlY3Rpb247XHJcbiAgICAgICAgICAgIHZhciBuZXdFbnRpdGllcyA9IG5ld0VudGl0eUNvbGxlY3Rpb24udmFsdWVzO1xyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gcmVtb3ZlQ2hpbGRyZW4oZW50aXR5KSB7XHJcbiAgICAgICAgICAgICAgICBlbnRpdHlDb2xsZWN0aW9uLnJlbW92ZShlbnRpdHkpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gZW50aXR5Ll9jaGlsZHJlbjtcclxuICAgICAgICAgICAgICAgIHZhciBjb3VudCA9IGNoaWxkcmVuLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUNoaWxkcmVuKGNoaWxkcmVuW2ldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gUmVtb3ZlIG9sZCBlbnRpdGllc1xyXG4gICAgICAgICAgICBlbnRpdHlDb2xsZWN0aW9uLnN1c3BlbmRFdmVudHMoKTtcclxuICAgICAgICAgICAgdmFyIGVudGl0aWVzQ29weSA9IGVudGl0eUNvbGxlY3Rpb24udmFsdWVzLnNsaWNlKCk7XHJcbiAgICAgICAgICAgIHZhciBpO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZW50aXRpZXNDb3B5Lmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZW50aXR5VG9SZW1vdmUgPSBlbnRpdGllc0NvcHlbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAoZW50aXR5VG9SZW1vdmUucGFyZW50ID09PSBuZXR3b3JrTGlua0VudGl0eSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVudGl0eVRvUmVtb3ZlLnBhcmVudCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmVDaGlsZHJlbihlbnRpdHlUb1JlbW92ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZW50aXR5Q29sbGVjdGlvbi5yZXN1bWVFdmVudHMoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEFkZCBuZXcgZW50aXRpZXNcclxuICAgICAgICAgICAgZW50aXR5Q29sbGVjdGlvbi5zdXNwZW5kRXZlbnRzKCk7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBuZXdFbnRpdGllcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5ld0VudGl0eSA9IG5ld0VudGl0aWVzW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFkZWZpbmVkKG5ld0VudGl0eS5wYXJlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3RW50aXR5LnBhcmVudCA9IG5ldHdvcmtMaW5rRW50aXR5O1xyXG4gICAgICAgICAgICAgICAgICAgIG1lcmdlQXZhaWxhYmlsaXR5V2l0aFBhcmVudChuZXdFbnRpdHkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZW50aXR5Q29sbGVjdGlvbi5hZGQobmV3RW50aXR5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbnRpdHlDb2xsZWN0aW9uLnJlc3VtZUV2ZW50cygpO1xyXG5cclxuICAgICAgICAgICAgLy8gTm8gcmVmcmVzaCBpbmZvcm1hdGlvbiByZW1vdmUgaXQsIG90aGVyd2lzZSB1cGRhdGUgbGFzdFVwZGF0ZSB0aW1lXHJcbiAgICAgICAgICAgIGlmIChyZW1vdmUpIHtcclxuICAgICAgICAgICAgICAgIG5ldHdvcmtMaW5rcy5yZW1vdmUobmV0d29ya0xpbmsuaWQpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbmV0d29ya0xpbmsubGFzdFVwZGF0ZWQgPSBub3c7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBhdmFpbGFiaWxpdHkgPSBlbnRpdHlDb2xsZWN0aW9uLmNvbXB1dGVBdmFpbGFiaWxpdHkoKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBzdGFydCA9IGF2YWlsYWJpbGl0eS5zdGFydDtcclxuICAgICAgICAgICAgdmFyIHN0b3AgPSBhdmFpbGFiaWxpdHkuc3RvcDtcclxuICAgICAgICAgICAgdmFyIGlzTWluU3RhcnQgPSBKdWxpYW5EYXRlLmVxdWFscyhzdGFydCwgSXNvODYwMS5NSU5JTVVNX1ZBTFVFKTtcclxuICAgICAgICAgICAgdmFyIGlzTWF4U3RvcCA9IEp1bGlhbkRhdGUuZXF1YWxzKHN0b3AsIElzbzg2MDEuTUFYSU1VTV9WQUxVRSk7XHJcbiAgICAgICAgICAgIGlmICghaXNNaW5TdGFydCB8fCAhaXNNYXhTdG9wKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2xvY2sgPSBkYXRhU291cmNlLl9jbG9jaztcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoY2xvY2suc3RhcnRUaW1lICE9PSBzdGFydCB8fCBjbG9jay5zdG9wVGltZSAhPT0gc3RvcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsb2NrLnN0YXJ0VGltZSA9IHN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgICAgIGNsb2NrLnN0b3BUaW1lID0gc3RvcDtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhU291cmNlLl9jaGFuZ2VkLnJhaXNlRXZlbnQoZGF0YVNvdXJjZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIG5ldHdvcmtMaW5rLnVwZGF0aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIG5ldHdvcmtMaW5rLm5lZWRzVXBkYXRlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGRhdGFTb3VyY2UuX3JlZnJlc2gucmFpc2VFdmVudChkYXRhU291cmNlLCBwcm9jZXNzZWRIcmVmLmdldFVybENvbXBvbmVudCh0cnVlKSk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZW50aXRpZXNUb0lnbm9yZSA9IG5ldyBBc3NvY2lhdGl2ZUFycmF5KCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIGFueSBOZXR3b3JrTGluayB0aGF0IHJlcXVpcmUgdXBkYXRpbmdcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7SnVsaWFuRGF0ZX0gdGltZSBUaGUgc2ltdWxhdGlvbiB0aW1lLlxyXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhpcyBkYXRhIHNvdXJjZSBpcyByZWFkeSB0byBiZSBkaXNwbGF5ZWQgYXQgdGhlIHByb3ZpZGVkIHRpbWUsIGZhbHNlIG90aGVyd2lzZS5cclxuICAgICAqL1xyXG4gICAgS21sRGF0YVNvdXJjZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24odGltZSkge1xyXG4gICAgICAgIHZhciBuZXR3b3JrTGlua3MgPSB0aGlzLl9uZXR3b3JrTGlua3M7XHJcbiAgICAgICAgaWYgKG5ldHdvcmtMaW5rcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgbm93ID0gSnVsaWFuRGF0ZS5ub3coKTtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcblxyXG4gICAgICAgIGVudGl0aWVzVG9JZ25vcmUucmVtb3ZlQWxsKCk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlY3Vyc2VJZ25vcmVFbnRpdGllcyhlbnRpdHkpIHtcclxuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gZW50aXR5Ll9jaGlsZHJlbjtcclxuICAgICAgICAgICAgdmFyIGNvdW50ID0gY2hpbGRyZW4ubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICAgICAgZW50aXRpZXNUb0lnbm9yZS5zZXQoY2hpbGQuaWQsIGNoaWxkKTtcclxuICAgICAgICAgICAgICAgIHJlY3Vyc2VJZ25vcmVFbnRpdGllcyhjaGlsZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBjYW1lcmFWaWV3VXBkYXRlID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIGxhc3RDYW1lcmFWaWV3ID0gdGhpcy5fbGFzdENhbWVyYVZpZXc7XHJcbiAgICAgICAgdmFyIGNhbWVyYSA9IHRoaXMuX2NhbWVyYTtcclxuICAgICAgICBpZiAoZGVmaW5lZChjYW1lcmEpICYmXHJcbiAgICAgICAgICAgICEoY2FtZXJhLnBvc2l0aW9uV0MuZXF1YWxzRXBzaWxvbihsYXN0Q2FtZXJhVmlldy5wb3NpdGlvbiwgQ2VzaXVtTWF0aC5FUFNJTE9ONykgJiZcclxuICAgICAgICAgICAgY2FtZXJhLmRpcmVjdGlvbldDLmVxdWFsc0Vwc2lsb24obGFzdENhbWVyYVZpZXcuZGlyZWN0aW9uLCBDZXNpdW1NYXRoLkVQU0lMT043KSAmJlxyXG4gICAgICAgICAgICBjYW1lcmEudXBXQy5lcXVhbHNFcHNpbG9uKGxhc3RDYW1lcmFWaWV3LnVwLCBDZXNpdW1NYXRoLkVQU0lMT043KSkpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIENhbWVyYSBoYXMgY2hhbmdlZCBzbyB1cGRhdGUgdGhlIGxhc3Qgdmlld1xyXG4gICAgICAgICAgICBsYXN0Q2FtZXJhVmlldy5wb3NpdGlvbiA9IENhcnRlc2lhbjMuY2xvbmUoY2FtZXJhLnBvc2l0aW9uV0MpO1xyXG4gICAgICAgICAgICBsYXN0Q2FtZXJhVmlldy5kaXJlY3Rpb24gPSBDYXJ0ZXNpYW4zLmNsb25lKGNhbWVyYS5kaXJlY3Rpb25XQyk7XHJcbiAgICAgICAgICAgIGxhc3RDYW1lcmFWaWV3LnVwID0gQ2FydGVzaWFuMy5jbG9uZShjYW1lcmEudXBXQyk7XHJcbiAgICAgICAgICAgIGxhc3RDYW1lcmFWaWV3LmJib3ggPSBjYW1lcmEuY29tcHV0ZVZpZXdSZWN0YW5nbGUoKTtcclxuICAgICAgICAgICAgY2FtZXJhVmlld1VwZGF0ZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgbmV3TmV0d29ya0xpbmtzID0gbmV3IEFzc29jaWF0aXZlQXJyYXkoKTtcclxuICAgICAgICB2YXIgY2hhbmdlZCA9IGZhbHNlO1xyXG4gICAgICAgIG5ldHdvcmtMaW5rcy52YWx1ZXMuZm9yRWFjaChmdW5jdGlvbihuZXR3b3JrTGluaykge1xyXG4gICAgICAgICAgICB2YXIgZW50aXR5ID0gbmV0d29ya0xpbmsuZW50aXR5O1xyXG4gICAgICAgICAgICBpZiAoZW50aXRpZXNUb0lnbm9yZS5jb250YWlucyhlbnRpdHkuaWQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICghbmV0d29ya0xpbmsudXBkYXRpbmcpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkb1VwZGF0ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5ldHdvcmtMaW5rLnJlZnJlc2hNb2RlID09PSBSZWZyZXNoTW9kZS5JTlRFUlZBTCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChKdWxpYW5EYXRlLnNlY29uZHNEaWZmZXJlbmNlKG5vdywgbmV0d29ya0xpbmsubGFzdFVwZGF0ZWQpID4gbmV0d29ya0xpbmsudGltZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkb1VwZGF0ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobmV0d29ya0xpbmsucmVmcmVzaE1vZGUgPT09IFJlZnJlc2hNb2RlLkVYUElSRSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChKdWxpYW5EYXRlLmdyZWF0ZXJUaGFuKG5vdywgbmV0d29ya0xpbmsudGltZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZG9VcGRhdGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5ldHdvcmtMaW5rLnJlZnJlc2hNb2RlID09PSBSZWZyZXNoTW9kZS5TVE9QKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbWVyYVZpZXdVcGRhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV0d29ya0xpbmsubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXR3b3JrTGluay5jYW1lcmFVcGRhdGVUaW1lID0gbm93O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ldHdvcmtMaW5rLm5lZWRzVXBkYXRlICYmIEp1bGlhbkRhdGUuc2Vjb25kc0RpZmZlcmVuY2Uobm93LCBuZXR3b3JrTGluay5jYW1lcmFVcGRhdGVUaW1lKSA+PSBuZXR3b3JrTGluay50aW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvVXBkYXRlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGRvVXBkYXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVjdXJzZUlnbm9yZUVudGl0aWVzKGVudGl0eSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV0d29ya0xpbmsudXBkYXRpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdFbnRpdHlDb2xsZWN0aW9uID0gbmV3IEVudGl0eUNvbGxlY3Rpb24oKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaHJlZiA9IG5ldHdvcmtMaW5rLmhyZWYuY2xvbmUoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaHJlZi5zZXRRdWVyeVBhcmFtZXRlcnMobmV0d29ya0xpbmsuY29va2llKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZWxsaXBzb2lkID0gZGVmYXVsdFZhbHVlKHRoYXQuX2VsbGlwc29pZCwgRWxsaXBzb2lkLldHUzg0KTtcclxuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzTmV0d29ya0xpbmtRdWVyeVN0cmluZyhocmVmLCB0aGF0Ll9jYW1lcmEsIHRoYXQuX2NhbnZhcywgbmV0d29ya0xpbmsudmlld0JvdW5kU2NhbGUsIGxhc3RDYW1lcmFWaWV3LmJib3gsIGVsbGlwc29pZCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGxvYWQodGhhdCwgbmV3RW50aXR5Q29sbGVjdGlvbiwgaHJlZiwge2NvbnRleHQgOiBlbnRpdHkuaWR9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihnZXROZXR3b3JrTGlua1VwZGF0ZUNhbGxiYWNrKHRoYXQsIG5ldHdvcmtMaW5rLCBuZXdFbnRpdHlDb2xsZWN0aW9uLCBuZXdOZXR3b3JrTGlua3MsIGhyZWYpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAub3RoZXJ3aXNlKGZ1bmN0aW9uKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbXNnID0gJ05ldHdvcmtMaW5rICcgKyBuZXR3b3JrTGluay5ocmVmICsgJyByZWZyZXNoIGZhaWxlZDogJyArIGVycm9yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2cobXNnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuX2Vycm9yLnJhaXNlRXZlbnQodGhhdCwgbXNnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbmV3TmV0d29ya0xpbmtzLnNldChuZXR3b3JrTGluay5pZCwgbmV0d29ya0xpbmspO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpZiAoY2hhbmdlZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9uZXR3b3JrTGlua3MgPSBuZXdOZXR3b3JrTGlua3M7XHJcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZWQucmFpc2VFdmVudCh0aGlzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnRhaW5zIEtNTCBGZWF0dXJlIGRhdGEgbG9hZGVkIGludG8gdGhlIDxjb2RlPkVudGl0eS5rbWw8L2NvZGU+IHByb3BlcnR5IGJ5IHtAbGluayBLbWxEYXRhU291cmNlfS5cclxuICAgICAqIEBhbGlhcyBLbWxGZWF0dXJlRGF0YVxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIEttbEZlYXR1cmVEYXRhKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIGF0b20gc3luZGljYXRpb24gZm9ybWF0IGF1dGhvciBmaWVsZC5cclxuICAgICAgICAgKiBAdHlwZSBPYmplY3RcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmF1dGhvciA9IHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgdGhlIG5hbWUuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIFN0cmluZ1xyXG4gICAgICAgICAgICAgKiBAYWxpYXMgYXV0aG9yLm5hbWVcclxuICAgICAgICAgICAgICogQG1lbWJlcm9mISBLbWxGZWF0dXJlRGF0YSNcclxuICAgICAgICAgICAgICogQHByb3BlcnR5IGF1dGhvci5uYW1lXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBuYW1lIDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyB0aGUgVVJJLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSBTdHJpbmdcclxuICAgICAgICAgICAgICogQGFsaWFzIGF1dGhvci51cmlcclxuICAgICAgICAgICAgICogQG1lbWJlcm9mISBLbWxGZWF0dXJlRGF0YSNcclxuICAgICAgICAgICAgICogQHByb3BlcnR5IGF1dGhvci51cmlcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHVyaSA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgdGhlIGVtYWlsLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSBTdHJpbmdcclxuICAgICAgICAgICAgICogQGFsaWFzIGF1dGhvci5lbWFpbFxyXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2YhIEttbEZlYXR1cmVEYXRhI1xyXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgYXV0aG9yLmVtYWlsXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBlbWFpbCA6IHVuZGVmaW5lZFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIGxpbmsuXHJcbiAgICAgICAgICogQHR5cGUgT2JqZWN0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5saW5rID0ge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyB0aGUgaHJlZi5cclxuICAgICAgICAgICAgICogQHR5cGUgU3RyaW5nXHJcbiAgICAgICAgICAgICAqIEBhbGlhcyBsaW5rLmhyZWZcclxuICAgICAgICAgICAgICogQG1lbWJlcm9mISBLbWxGZWF0dXJlRGF0YSNcclxuICAgICAgICAgICAgICogQHByb3BlcnR5IGxpbmsuaHJlZlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgaHJlZiA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgdGhlIGxhbmd1YWdlIG9mIHRoZSBsaW5rZWQgcmVzb3VyY2UuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIFN0cmluZ1xyXG4gICAgICAgICAgICAgKiBAYWxpYXMgbGluay5ocmVmbGFuZ1xyXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2YhIEttbEZlYXR1cmVEYXRhI1xyXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgbGluay5ocmVmbGFuZ1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgaHJlZmxhbmcgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIHRoZSBsaW5rIHJlbGF0aW9uLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSBTdHJpbmdcclxuICAgICAgICAgICAgICogQGFsaWFzIGxpbmsucmVsXHJcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiEgS21sRmVhdHVyZURhdGEjXHJcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBsaW5rLnJlbFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgcmVsIDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyB0aGUgbGluayB0eXBlLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSBTdHJpbmdcclxuICAgICAgICAgICAgICogQGFsaWFzIGxpbmsudHlwZVxyXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2YhIEttbEZlYXR1cmVEYXRhI1xyXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgbGluay50eXBlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0eXBlIDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyB0aGUgbGluayB0aXRsZS5cclxuICAgICAgICAgICAgICogQHR5cGUgU3RyaW5nXHJcbiAgICAgICAgICAgICAqIEBhbGlhcyBsaW5rLnRpdGxlXHJcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiEgS21sRmVhdHVyZURhdGEjXHJcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBsaW5rLnRpdGxlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aXRsZSA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgdGhlIGxpbmsgbGVuZ3RoLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSBTdHJpbmdcclxuICAgICAgICAgICAgICogQGFsaWFzIGxpbmsubGVuZ3RoXHJcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiEgS21sRmVhdHVyZURhdGEjXHJcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBsaW5rLmxlbmd0aFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgbGVuZ3RoIDogdW5kZWZpbmVkXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgdW5zdHJ1Y3R1cmVkIGFkZHJlc3MgZmllbGQuXHJcbiAgICAgICAgICogQHR5cGUgU3RyaW5nXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5hZGRyZXNzID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIHBob25lIG51bWJlci5cclxuICAgICAgICAgKiBAdHlwZSBTdHJpbmdcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnBob25lTnVtYmVyID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIHNuaXBwZXQuXHJcbiAgICAgICAgICogQHR5cGUgU3RyaW5nXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5zbmlwcGV0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIGV4dGVuZGVkIGRhdGEsIHBhcnNlZCBpbnRvIGEgSlNPTiBvYmplY3QuXHJcbiAgICAgICAgICogQ3VycmVudGx5IG9ubHkgdGhlIDxjb2RlPkRhdGE8L2NvZGU+IHByb3BlcnR5IGlzIHN1cHBvcnRlZC5cclxuICAgICAgICAgKiA8Y29kZT5TY2hlbWFEYXRhPC9jb2RlPiBhbmQgY3VzdG9tIGRhdGEgYXJlIGlnbm9yZWQuXHJcbiAgICAgICAgICogQHR5cGUgU3RyaW5nXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5leHRlbmRlZERhdGEgPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIEttbERhdGFTb3VyY2U7XHJcbn0pO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy90ZXJyaWFqcy1jZXNpdW0vU291cmNlL0RhdGFTb3VyY2VzL0ttbERhdGFTb3VyY2UuanNcbi8vIG1vZHVsZSBpZCA9IDU0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7Ozs7Ozs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7Ozs7Ozs7QUM1SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBOzs7Ozs7OztBQzlPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7Ozs7Ozs7O0FDdkpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7Ozs7Ozs7O0FDMUxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7Ozs7Ozs7O0FDM1dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBOzs7Ozs7OztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBOzs7Ozs7OztBQ2xOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7Ozs7Ozs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7Ozs7Ozs7QUN0U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBOzs7Ozs7OztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7Ozs7Ozs7O0FDNUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBOzs7Ozs7OztBQ25JQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBOzs7Ozs7OztBQ2pMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7Ozs7Ozs7QUMzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBOzs7Ozs7OztBQzFKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7Ozs7Ozs7O0FDNUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7Ozs7Ozs7QUM5SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7Ozs7Ozs7O0FDeEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBOzs7Ozs7OztBQ3JKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7Ozs7Ozs7O0FDeExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7Ozs7Ozs7O0FDNUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNuc0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7Ozs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7Ozs7Ozs7QUN0TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7Ozs7Ozs7O0FDakhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7Ozs7Ozs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7Ozs7Ozs7O0FDL0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7Ozs7Ozs7O0FDcjZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7Ozs7Ozs7QUM3dUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7Ozs7QSIsInNvdXJjZVJvb3QiOiIifQ==